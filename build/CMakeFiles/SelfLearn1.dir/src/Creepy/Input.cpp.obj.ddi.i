# 0 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/src/Creepy/Input.cpp"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/src/Creepy/Input.cpp"
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/utility" 1 3
# 58 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/utility" 3
       
# 59 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/utility" 3
# 67 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/utility" 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/x86_64-w64-mingw32/bits/c++config.h" 1 3
# 33 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/x86_64-w64-mingw32/bits/c++config.h" 3
       
# 34 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/x86_64-w64-mingw32/bits/c++config.h" 3
# 308 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/x86_64-w64-mingw32/bits/c++config.h" 3

# 308 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/x86_64-w64-mingw32/bits/c++config.h" 3
namespace std
{
  typedef long long unsigned int size_t;
  typedef long long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;


#pragma GCC visibility push(default)


  extern "C++" __attribute__ ((__noreturn__, __always_inline__))
  inline void __terminate() noexcept
  {
    void terminate() noexcept __attribute__ ((__noreturn__,__cold__));
    terminate();
  }
#pragma GCC visibility pop
}
# 341 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/x86_64-w64-mingw32/bits/c++config.h" 3
namespace std
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
namespace __gnu_cxx
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
# 534 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/x86_64-w64-mingw32/bits/c++config.h" 3
namespace std
{
#pragma GCC visibility push(default)




  __attribute__((__always_inline__))
  constexpr inline bool
  __is_constant_evaluated() noexcept
  {


    if consteval { return true; } else { return false; }






  }
#pragma GCC visibility pop
}
# 573 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/x86_64-w64-mingw32/bits/c++config.h" 3
namespace std
{
#pragma GCC visibility push(default)

  extern "C++" __attribute__ ((__noreturn__))
  void
  __glibcxx_assert_fail
    (const char* __file, int __line, const char* __function,
     const char* __condition)
  noexcept;
#pragma GCC visibility pop
}
# 601 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/x86_64-w64-mingw32/bits/c++config.h" 3
namespace std
{
  __attribute__((__always_inline__,__visibility__("default")))
  inline void
  __glibcxx_assert_fail()
  { }
}
# 680 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/x86_64-w64-mingw32/bits/c++config.h" 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/x86_64-w64-mingw32/bits/os_defines.h" 1 3
# 681 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/x86_64-w64-mingw32/bits/c++config.h" 2 3


# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/x86_64-w64-mingw32/bits/cpu_defines.h" 1 3
# 684 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/x86_64-w64-mingw32/bits/c++config.h" 2 3
# 825 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/x86_64-w64-mingw32/bits/c++config.h" 3
namespace __gnu_cxx
{
  typedef __decltype(0.0bf16) __bfloat16_t;
}
# 887 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/x86_64-w64-mingw32/bits/c++config.h" 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/pstl/pstl_config.h" 1 3
# 888 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/x86_64-w64-mingw32/bits/c++config.h" 2 3
# 68 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/utility" 2 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_relops.h" 1 3
# 62 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_relops.h" 3
namespace std
{


  namespace rel_ops
  {
# 86 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
# 99 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
# 112 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
# 125 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }
  }


}
# 69 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/utility" 2 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_pair.h" 1 3
# 60 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_pair.h" 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 1 3
# 32 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
       
# 33 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
# 63 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 1 3
# 47 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 3
       
# 48 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 3
# 64 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 2 3

namespace std
{


  template<typename _Tp>
    class reference_wrapper;
# 86 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static constexpr _Tp value = __v;
      using value_type = _Tp;
      using type = integral_constant<_Tp, __v>;
      constexpr operator value_type() const noexcept { return value; }


      constexpr value_type operator()() const noexcept { return value; }

    };
# 106 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
  template<bool __v>
    using __bool_constant = integral_constant<bool, __v>;



  using true_type = __bool_constant<true>;


  using false_type = __bool_constant<false>;




  template<bool __v>
    using bool_constant = __bool_constant<__v>;






  template<bool, typename _Tp = void>
    struct enable_if
    { };


  template<typename _Tp>
    struct enable_if<true, _Tp>
    { using type = _Tp; };


  template<bool _Cond, typename _Tp = void>
    using __enable_if_t = typename enable_if<_Cond, _Tp>::type;

  template<bool>
    struct __conditional
    {
      template<typename _Tp, typename>
 using type = _Tp;
    };

  template<>
    struct __conditional<false>
    {
      template<typename, typename _Up>
 using type = _Up;
    };


  template<bool _Cond, typename _If, typename _Else>
    using __conditional_t
      = typename __conditional<_Cond>::template type<_If, _Else>;


  template <typename _Type>
    struct __type_identity
    { using type = _Type; };

  template<typename _Tp>
    using __type_identity_t = typename __type_identity<_Tp>::type;

  namespace __detail
  {

    template<typename _Tp, typename...>
      using __first_t = _Tp;


    template<typename... _Bn>
      auto __or_fn(int) -> __first_t<false_type,
         __enable_if_t<!bool(_Bn::value)>...>;

    template<typename... _Bn>
      auto __or_fn(...) -> true_type;

    template<typename... _Bn>
      auto __and_fn(int) -> __first_t<true_type,
          __enable_if_t<bool(_Bn::value)>...>;

    template<typename... _Bn>
      auto __and_fn(...) -> false_type;
  }




  template<typename... _Bn>
    struct __or_
    : decltype(__detail::__or_fn<_Bn...>(0))
    { };

  template<typename... _Bn>
    struct __and_
    : decltype(__detail::__and_fn<_Bn...>(0))
    { };

  template<typename _Pp>
    struct __not_
    : __bool_constant<!bool(_Pp::value)>
    { };





  template<typename... _Bn>
    inline constexpr bool __or_v = __or_<_Bn...>::value;
  template<typename... _Bn>
    inline constexpr bool __and_v = __and_<_Bn...>::value;

  namespace __detail
  {
    template<typename , typename _B1, typename... _Bn>
      struct __disjunction_impl
      { using type = _B1; };

    template<typename _B1, typename _B2, typename... _Bn>
      struct __disjunction_impl<__enable_if_t<!bool(_B1::value)>, _B1, _B2, _Bn...>
      { using type = typename __disjunction_impl<void, _B2, _Bn...>::type; };

    template<typename , typename _B1, typename... _Bn>
      struct __conjunction_impl
      { using type = _B1; };

    template<typename _B1, typename _B2, typename... _Bn>
      struct __conjunction_impl<__enable_if_t<bool(_B1::value)>, _B1, _B2, _Bn...>
      { using type = typename __conjunction_impl<void, _B2, _Bn...>::type; };
  }


  template<typename... _Bn>
    struct conjunction
    : __detail::__conjunction_impl<void, _Bn...>::type
    { };

  template<>
    struct conjunction<>
    : true_type
    { };

  template<typename... _Bn>
    struct disjunction
    : __detail::__disjunction_impl<void, _Bn...>::type
    { };

  template<>
    struct disjunction<>
    : false_type
    { };

  template<typename _Pp>
    struct negation
    : __not_<_Pp>::type
    { };




  template<typename... _Bn>
    inline constexpr bool conjunction_v = conjunction<_Bn...>::value;

  template<typename... _Bn>
    inline constexpr bool disjunction_v = disjunction<_Bn...>::value;

  template<typename _Pp>
    inline constexpr bool negation_v = negation<_Pp>::value;





  template<typename>
    struct is_reference;
  template<typename>
    struct is_function;
  template<typename>
    struct is_void;
  template<typename>
    struct remove_cv;
  template<typename>
    struct is_const;


  template<typename>
    struct __is_array_unknown_bounds;




  template <typename _Tp, size_t = sizeof(_Tp)>
    constexpr true_type __is_complete_or_unbounded(__type_identity<_Tp>)
    { return {}; }

  template <typename _TypeIdentity,
      typename _NestedType = typename _TypeIdentity::type>
    constexpr typename __or_<
      is_reference<_NestedType>,
      is_function<_NestedType>,
      is_void<_NestedType>,
      __is_array_unknown_bounds<_NestedType>
    >::type __is_complete_or_unbounded(_TypeIdentity)
    { return {}; }


  template<typename _Tp>
    using __remove_cv_t = typename remove_cv<_Tp>::type;





  template<typename _Tp>
    struct is_void
    : public false_type { };

  template<>
    struct is_void<void>
    : public true_type { };

  template<>
    struct is_void<const void>
    : public true_type { };

  template<>
    struct is_void<volatile void>
    : public true_type { };

  template<>
    struct is_void<const volatile void>
    : public true_type { };


  template<typename>
    struct __is_integral_helper
    : public false_type { };

  template<>
    struct __is_integral_helper<bool>
    : public true_type { };

  template<>
    struct __is_integral_helper<char>
    : public true_type { };

  template<>
    struct __is_integral_helper<signed char>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned char>
    : public true_type { };




  template<>
    struct __is_integral_helper<wchar_t>
    : public true_type { };


  template<>
    struct __is_integral_helper<char8_t>
    : public true_type { };


  template<>
    struct __is_integral_helper<char16_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<char32_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<short>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned short>
    : public true_type { };

  template<>
    struct __is_integral_helper<int>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned int>
    : public true_type { };

  template<>
    struct __is_integral_helper<long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long>
    : public true_type { };

  template<>
    struct __is_integral_helper<long long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long long>
    : public true_type { };




  __extension__
  template<>
    struct __is_integral_helper<__int128>
    : public true_type { };

  __extension__
  template<>
    struct __is_integral_helper<unsigned __int128>
    : public true_type { };
# 460 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
  template<typename _Tp>
    struct is_integral
    : public __is_integral_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename>
    struct __is_floating_point_helper
    : public false_type { };

  template<>
    struct __is_floating_point_helper<float>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<double>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<long double>
    : public true_type { };


  template<>
    struct __is_floating_point_helper<_Float16>
    : public true_type { };



  template<>
    struct __is_floating_point_helper<_Float32>
    : public true_type { };



  template<>
    struct __is_floating_point_helper<_Float64>
    : public true_type { };



  template<>
    struct __is_floating_point_helper<_Float128>
    : public true_type { };



  template<>
    struct __is_floating_point_helper<__gnu_cxx::__bfloat16_t>
    : public true_type { };



  template<>
    struct __is_floating_point_helper<__float128>
    : public true_type { };




  template<typename _Tp>
    struct is_floating_point
    : public __is_floating_point_helper<__remove_cv_t<_Tp>>::type
    { };



  template<typename _Tp>
    struct is_array
    : public __bool_constant<__is_array(_Tp)>
    { };
# 545 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
  template<typename>
    struct __is_pointer_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_pointer_helper<_Tp*>
    : public true_type { };


  template<typename _Tp>
    struct is_pointer
    : public __is_pointer_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename>
    struct is_lvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };


  template<typename>
    struct is_rvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };



  template<typename _Tp>
    struct is_member_object_pointer
    : public __bool_constant<__is_member_object_pointer(_Tp)>
    { };
# 601 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
  template<typename _Tp>
    struct is_member_function_pointer
    : public __bool_constant<__is_member_function_pointer(_Tp)>
    { };
# 622 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
  template<typename _Tp>
    struct is_enum
    : public __bool_constant<__is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public __bool_constant<__is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public __bool_constant<__is_class(_Tp)>
    { };



  template<typename _Tp>
    struct is_function
    : public __bool_constant<__is_function(_Tp)>
    { };
# 661 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
  template<typename _Tp>
    struct is_null_pointer
    : public false_type { };

  template<>
    struct is_null_pointer<std::nullptr_t>
    : public true_type { };

  template<>
    struct is_null_pointer<const std::nullptr_t>
    : public true_type { };

  template<>
    struct is_null_pointer<volatile std::nullptr_t>
    : public true_type { };

  template<>
    struct is_null_pointer<const volatile std::nullptr_t>
    : public true_type { };



  template<typename _Tp>
    struct __is_nullptr_t
    : public is_null_pointer<_Tp>
    { } __attribute__ ((__deprecated__ ("use '" "std::is_null_pointer" "' instead")));






  template<typename _Tp>
    struct is_reference
    : public __bool_constant<__is_reference(_Tp)>
    { };
# 715 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
  template<typename _Tp>
    struct is_arithmetic
    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_fundamental
    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,
     is_null_pointer<_Tp>>::type
    { };



  template<typename _Tp>
    struct is_object
    : public __bool_constant<__is_object(_Tp)>
    { };
# 741 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
  template<typename>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                   is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_compound
    : public __bool_constant<!is_fundamental<_Tp>::value> { };



  template<typename _Tp>
    struct is_member_pointer
    : public __bool_constant<__is_member_pointer(_Tp)>
    { };
# 779 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
  template<typename, typename>
    struct is_same;


  template<typename _Tp, typename... _Types>
    using __is_one_of = __or_<is_same<_Tp, _Types>...>;


  __extension__
  template<typename _Tp>
    using __is_signed_integer = __is_one_of<__remove_cv_t<_Tp>,
   signed char, signed short, signed int, signed long,
   signed long long

   , signed __int128
# 804 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
   >;


  __extension__
  template<typename _Tp>
    using __is_unsigned_integer = __is_one_of<__remove_cv_t<_Tp>,
   unsigned char, unsigned short, unsigned int, unsigned long,
   unsigned long long

   , unsigned __int128
# 824 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
   >;


  template<typename _Tp>
    using __is_standard_integer
      = __or_<__is_signed_integer<_Tp>, __is_unsigned_integer<_Tp>>;


  template<typename...> using __void_t = void;





  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_trivial
    : public __bool_constant<__is_trivial(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_copyable
    : public __bool_constant<__is_trivially_copyable(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_standard_layout
    : public __bool_constant<__is_standard_layout(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };






  template<typename _Tp>
    struct
    __attribute__ ((__deprecated__ ("use '" "is_standard_layout && is_trivial" "' instead")))
    is_pod
    : public __bool_constant<__is_pod(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };





  template<typename _Tp>
    struct
    [[__deprecated__]]
    is_literal_type
    : public __bool_constant<__is_literal_type(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_empty
    : public __bool_constant<__is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public __bool_constant<__is_polymorphic(_Tp)>
    { };




  template<typename _Tp>
    struct is_final
    : public __bool_constant<__is_final(_Tp)>
    { };



  template<typename _Tp>
    struct is_abstract
    : public __bool_constant<__is_abstract(_Tp)>
    { };


  template<typename _Tp,
    bool = is_arithmetic<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, true>
    : public __bool_constant<_Tp(-1) < _Tp(0)>
    { };



  template<typename _Tp>
    struct is_signed
    : public __is_signed_helper<_Tp>::type
    { };


  template<typename _Tp>
    struct is_unsigned
    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>::type
    { };


  template<typename _Tp, typename _Up = _Tp&&>
    _Up
    __declval(int);

  template<typename _Tp>
    _Tp
    __declval(long);


  template<typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0));

  template<typename>
    struct remove_all_extents;


  template<typename _Tp>
    struct __is_array_known_bounds
    : public false_type
    { };

  template<typename _Tp, size_t _Size>
    struct __is_array_known_bounds<_Tp[_Size]>
    : public true_type
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds
    : public false_type
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds<_Tp[]>
    : public true_type
    { };
# 1006 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
  struct __do_is_destructible_impl
  {
    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_destructible_impl
    : public __do_is_destructible_impl
    {
      using type = decltype(__test<_Tp>(0));
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_destructible_safe;

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, false>
    : public __is_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, true>
    : public true_type { };



  template<typename _Tp>
    struct is_destructible
    : public __is_destructible_safe<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };







  struct __do_is_nt_destructible_impl
  {
    template<typename _Tp>
      static __bool_constant<noexcept(declval<_Tp&>().~_Tp())>
      __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_nt_destructible_impl
    : public __do_is_nt_destructible_impl
    {
      using type = decltype(__test<_Tp>(0));
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_nt_destructible_safe;

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, false>
    : public __is_nt_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, true>
    : public true_type { };



  template<typename _Tp>
    struct is_nothrow_destructible
    : public __is_nt_destructible_safe<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename... _Args>
    using __is_constructible_impl
      = __bool_constant<__is_constructible(_Tp, _Args...)>;



  template<typename _Tp, typename... _Args>
    struct is_constructible
      : public __is_constructible_impl<_Tp, _Args...>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_default_constructible
    : public __is_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename = void>
    struct __add_lvalue_reference_helper
    { using type = _Tp; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, __void_t<_Tp&>>
    { using type = _Tp&; };

  template<typename _Tp>
    using __add_lval_ref_t = typename __add_lvalue_reference_helper<_Tp>::type;



  template<typename _Tp>
    struct is_copy_constructible
    : public __is_constructible_impl<_Tp, __add_lval_ref_t<const _Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename = void>
    struct __add_rvalue_reference_helper
    { using type = _Tp; };

  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, __void_t<_Tp&&>>
    { using type = _Tp&&; };

  template<typename _Tp>
    using __add_rval_ref_t = typename __add_rvalue_reference_helper<_Tp>::type;



  template<typename _Tp>
    struct is_move_constructible
    : public __is_constructible_impl<_Tp, __add_rval_ref_t<_Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename... _Args>
    using __is_nothrow_constructible_impl
      = __bool_constant<__is_nothrow_constructible(_Tp, _Args...)>;



  template<typename _Tp, typename... _Args>
    struct is_nothrow_constructible
    : public __is_nothrow_constructible_impl<_Tp, _Args...>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_default_constructible
    : public __is_nothrow_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_copy_constructible
    : public __is_nothrow_constructible_impl<_Tp, __add_lval_ref_t<const _Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_move_constructible
    : public __is_nothrow_constructible_impl<_Tp, __add_rval_ref_t<_Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    using __is_assignable_impl = __bool_constant<__is_assignable(_Tp, _Up)>;



  template<typename _Tp, typename _Up>
    struct is_assignable
    : public __is_assignable_impl<_Tp, _Up>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_copy_assignable
    : public __is_assignable_impl<__add_lval_ref_t<_Tp>,
      __add_lval_ref_t<const _Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_move_assignable
    : public __is_assignable_impl<__add_lval_ref_t<_Tp>, __add_rval_ref_t<_Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    using __is_nothrow_assignable_impl
      = __bool_constant<__is_nothrow_assignable(_Tp, _Up)>;



  template<typename _Tp, typename _Up>
    struct is_nothrow_assignable
    : public __is_nothrow_assignable_impl<_Tp, _Up>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_copy_assignable
    : public __is_nothrow_assignable_impl<__add_lval_ref_t<_Tp>,
       __add_lval_ref_t<const _Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_move_assignable
    : public __is_nothrow_assignable_impl<__add_lval_ref_t<_Tp>,
       __add_rval_ref_t<_Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename... _Args>
    using __is_trivially_constructible_impl
      = __bool_constant<__is_trivially_constructible(_Tp, _Args...)>;



  template<typename _Tp, typename... _Args>
    struct is_trivially_constructible
    : public __is_trivially_constructible_impl<_Tp, _Args...>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_default_constructible
    : public __is_trivially_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    constexpr bool __is_implicitly_default_constructible_v
      = requires (void(&__f)(_Tp)) { __f({}); };

  template<typename _Tp>
    struct __is_implicitly_default_constructible
    : __bool_constant<__is_implicitly_default_constructible_v<_Tp>>
    { };
# 1351 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
  template<typename _Tp>
    struct is_trivially_copy_constructible
    : public __is_trivially_constructible_impl<_Tp, __add_lval_ref_t<const _Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_move_constructible
    : public __is_trivially_constructible_impl<_Tp, __add_rval_ref_t<_Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    using __is_trivially_assignable_impl
      = __bool_constant<__is_trivially_assignable(_Tp, _Up)>;



  template<typename _Tp, typename _Up>
    struct is_trivially_assignable
    : public __is_trivially_assignable_impl<_Tp, _Up>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_copy_assignable
    : public __is_trivially_assignable_impl<__add_lval_ref_t<_Tp>,
         __add_lval_ref_t<const _Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_move_assignable
    : public __is_trivially_assignable_impl<__add_lval_ref_t<_Tp>,
         __add_rval_ref_t<_Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_destructible
    : public __and_<__is_destructible_safe<_Tp>,
      __bool_constant<__has_trivial_destructor(_Tp)>>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp>
    struct has_virtual_destructor
    : public __bool_constant<__has_virtual_destructor(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };





  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, alignof(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint = 0>
    struct extent
    : public integral_constant<size_t, 0> { };

  template<typename _Tp, size_t _Size>
    struct extent<_Tp[_Size], 0>
    : public integral_constant<size_t, _Size> { };

  template<typename _Tp, unsigned _Uint, size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public extent<_Tp, _Uint - 1>::type { };

  template<typename _Tp>
    struct extent<_Tp[], 0>
    : public integral_constant<size_t, 0> { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public extent<_Tp, _Uint - 1>::type { };






  template<typename _Tp, typename _Up>
    struct is_same
    : public __bool_constant<__is_same(_Tp, _Up)>
    { };
# 1491 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
  template<typename _Base, typename _Derived>
    struct is_base_of
    : public __bool_constant<__is_base_of(_Base, _Derived)>
    { };


  template<typename _From, typename _To>
    struct is_convertible
    : public __bool_constant<__is_convertible(_From, _To)>
    { };
# 1540 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
  template<typename _ToElementType, typename _FromElementType>
    using __is_array_convertible
      = is_convertible<_FromElementType(*)[], _ToElementType(*)[]>;





  template<typename _From, typename _To>
    inline constexpr bool is_nothrow_convertible_v
      = __is_nothrow_convertible(_From, _To);


  template<typename _From, typename _To>
    struct is_nothrow_convertible
    : public bool_constant<is_nothrow_convertible_v<_From, _To>>
    { };
# 1603 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
  template<typename _Tp>
    struct remove_const
    { using type = _Tp; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { using type = _Tp; };


  template<typename _Tp>
    struct remove_volatile
    { using type = _Tp; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { using type = _Tp; };



  template<typename _Tp>
    struct remove_cv
    { using type = __remove_cv(_Tp); };
# 1644 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
  template<typename _Tp>
    struct add_const
    { using type = _Tp const; };


  template<typename _Tp>
    struct add_volatile
    { using type = _Tp volatile; };


  template<typename _Tp>
    struct add_cv
    { using type = _Tp const volatile; };



  template<typename _Tp>
    using remove_const_t = typename remove_const<_Tp>::type;


  template<typename _Tp>
    using remove_volatile_t = typename remove_volatile<_Tp>::type;


  template<typename _Tp>
    using remove_cv_t = typename remove_cv<_Tp>::type;


  template<typename _Tp>
    using add_const_t = typename add_const<_Tp>::type;


  template<typename _Tp>
    using add_volatile_t = typename add_volatile<_Tp>::type;


  template<typename _Tp>
    using add_cv_t = typename add_cv<_Tp>::type;






  template<typename _Tp>
    struct remove_reference
    { using type = __remove_reference(_Tp); };
# 1706 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
  template<typename _Tp>
    struct add_lvalue_reference
    { using type = __add_lval_ref_t<_Tp>; };


  template<typename _Tp>
    struct add_rvalue_reference
    { using type = __add_rval_ref_t<_Tp>; };



  template<typename _Tp>
    using remove_reference_t = typename remove_reference<_Tp>::type;


  template<typename _Tp>
    using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;


  template<typename _Tp>
    using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;







  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { using __type = _Unqualified; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { using __type = volatile _Unqualified; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { using __type = const _Unqualified; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { using __type = const volatile _Unqualified; };

  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    class __match_cv_qualifiers
    {
      using __match = __cv_selector<_Unqualified, _IsConst, _IsVol>;

    public:
      using __type = typename __match::__type;
    };


  template<typename _Tp>
    struct __make_unsigned
    { using __type = _Tp; };

  template<>
    struct __make_unsigned<char>
    { using __type = unsigned char; };

  template<>
    struct __make_unsigned<signed char>
    { using __type = unsigned char; };

  template<>
    struct __make_unsigned<short>
    { using __type = unsigned short; };

  template<>
    struct __make_unsigned<int>
    { using __type = unsigned int; };

  template<>
    struct __make_unsigned<long>
    { using __type = unsigned long; };

  template<>
    struct __make_unsigned<long long>
    { using __type = unsigned long long; };


  __extension__
  template<>
    struct __make_unsigned<__int128>
    { using __type = unsigned __int128; };
# 1819 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = __is_enum(_Tp)>
    class __make_unsigned_selector;

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, true, false>
    {
      using __unsigned_type
 = typename __make_unsigned<__remove_cv_t<_Tp>>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };

  class __make_unsigned_selector_base
  {
  protected:
    template<typename...> struct _List { };

    template<typename _Tp, typename... _Up>
      struct _List<_Tp, _Up...> : _List<_Up...>
      { static constexpr size_t __size = sizeof(_Tp); };

    template<size_t _Sz, typename _Tp, bool = (_Sz <= _Tp::__size)>
      struct __select;

    template<size_t _Sz, typename _Uint, typename... _UInts>
      struct __select<_Sz, _List<_Uint, _UInts...>, true>
      { using __type = _Uint; };

    template<size_t _Sz, typename _Uint, typename... _UInts>
      struct __select<_Sz, _List<_Uint, _UInts...>, false>
      : __select<_Sz, _List<_UInts...>>
      { };
  };


  template<typename _Tp>
    class __make_unsigned_selector<_Tp, false, true>
    : __make_unsigned_selector_base
    {

      using _UInts = _List<unsigned char, unsigned short, unsigned int,
      unsigned long, unsigned long long>;

      using __unsigned_type = typename __select<sizeof(_Tp), _UInts>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };





  template<>
    struct __make_unsigned<wchar_t>
    {
      using __type
 = typename __make_unsigned_selector<wchar_t, false, true>::__type;
    };


  template<>
    struct __make_unsigned<char8_t>
    {
      using __type
 = typename __make_unsigned_selector<char8_t, false, true>::__type;
    };


  template<>
    struct __make_unsigned<char16_t>
    {
      using __type
 = typename __make_unsigned_selector<char16_t, false, true>::__type;
    };

  template<>
    struct __make_unsigned<char32_t>
    {
      using __type
 = typename __make_unsigned_selector<char32_t, false, true>::__type;
    };






  template<typename _Tp>
    struct make_unsigned
    { using type = typename __make_unsigned_selector<_Tp>::__type; };


  template<> struct make_unsigned<bool>;
  template<> struct make_unsigned<bool const>;
  template<> struct make_unsigned<bool volatile>;
  template<> struct make_unsigned<bool const volatile>;




  template<typename _Tp>
    struct __make_signed
    { using __type = _Tp; };

  template<>
    struct __make_signed<char>
    { using __type = signed char; };

  template<>
    struct __make_signed<unsigned char>
    { using __type = signed char; };

  template<>
    struct __make_signed<unsigned short>
    { using __type = signed short; };

  template<>
    struct __make_signed<unsigned int>
    { using __type = signed int; };

  template<>
    struct __make_signed<unsigned long>
    { using __type = signed long; };

  template<>
    struct __make_signed<unsigned long long>
    { using __type = signed long long; };


  __extension__
  template<>
    struct __make_signed<unsigned __int128>
    { using __type = __int128; };
# 1979 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = __is_enum(_Tp)>
    class __make_signed_selector;

  template<typename _Tp>
    class __make_signed_selector<_Tp, true, false>
    {
      using __signed_type
 = typename __make_signed<__remove_cv_t<_Tp>>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __signed_type>::__type;
    };


  template<typename _Tp>
    class __make_signed_selector<_Tp, false, true>
    {
      using __unsigned_type = typename __make_unsigned_selector<_Tp>::__type;

    public:
      using __type = typename __make_signed_selector<__unsigned_type>::__type;
    };





  template<>
    struct __make_signed<wchar_t>
    {
      using __type
 = typename __make_signed_selector<wchar_t, false, true>::__type;
    };


  template<>
    struct __make_signed<char8_t>
    {
      using __type
 = typename __make_signed_selector<char8_t, false, true>::__type;
    };


  template<>
    struct __make_signed<char16_t>
    {
      using __type
 = typename __make_signed_selector<char16_t, false, true>::__type;
    };

  template<>
    struct __make_signed<char32_t>
    {
      using __type
 = typename __make_signed_selector<char32_t, false, true>::__type;
    };






  template<typename _Tp>
    struct make_signed
    { using type = typename __make_signed_selector<_Tp>::__type; };


  template<> struct make_signed<bool>;
  template<> struct make_signed<bool const>;
  template<> struct make_signed<bool volatile>;
  template<> struct make_signed<bool const volatile>;



  template<typename _Tp>
    using make_signed_t = typename make_signed<_Tp>::type;


  template<typename _Tp>
    using make_unsigned_t = typename make_unsigned<_Tp>::type;





  template<typename _Tp>
    struct remove_extent
    { using type = _Tp; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { using type = _Tp; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { using type = _Tp; };


  template<typename _Tp>
    struct remove_all_extents
    { using type = _Tp; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { using type = typename remove_all_extents<_Tp>::type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { using type = typename remove_all_extents<_Tp>::type; };



  template<typename _Tp>
    using remove_extent_t = typename remove_extent<_Tp>::type;


  template<typename _Tp>
    using remove_all_extents_t = typename remove_all_extents<_Tp>::type;






  template<typename _Tp>
    struct remove_pointer
    { using type = __remove_pointer(_Tp); };
# 2124 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
  template<typename _Tp, typename = void>
    struct __add_pointer_helper
    { using type = _Tp; };

  template<typename _Tp>
    struct __add_pointer_helper<_Tp, __void_t<_Tp*>>
    { using type = _Tp*; };


  template<typename _Tp>
    struct add_pointer
    : public __add_pointer_helper<_Tp>
    { };

  template<typename _Tp>
    struct add_pointer<_Tp&>
    { using type = _Tp*; };

  template<typename _Tp>
    struct add_pointer<_Tp&&>
    { using type = _Tp*; };



  template<typename _Tp>
    using remove_pointer_t = typename remove_pointer<_Tp>::type;


  template<typename _Tp>
    using add_pointer_t = typename add_pointer<_Tp>::type;


  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
# 2179 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct
    [[__deprecated__]]
    aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };

  template <typename... _Types>
    struct __strictest_alignment
    {
      static const size_t _S_alignment = 0;
      static const size_t _S_size = 0;
    };

  template <typename _Tp, typename... _Types>
    struct __strictest_alignment<_Tp, _Types...>
    {
      static const size_t _S_alignment =
        alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment
 ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;
      static const size_t _S_size =
        sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size
 ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;
    };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
# 2225 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
  template <size_t _Len, typename... _Types>
    struct
    [[__deprecated__]]
    aligned_union
    {
    private:
      static_assert(sizeof...(_Types) != 0, "At least one type is required");

      using __strictest = __strictest_alignment<_Types...>;
      static const size_t _S_len = _Len > __strictest::_S_size
 ? _Len : __strictest::_S_size;
    public:

      static const size_t alignment_value = __strictest::_S_alignment;

      using type = typename aligned_storage<_S_len, alignment_value>::type;
    };

  template <size_t _Len, typename... _Types>
    const size_t aligned_union<_Len, _Types...>::alignment_value;
#pragma GCC diagnostic pop





  template<typename _Up>
    struct __decay_selector
    : __conditional_t<is_const<const _Up>::value,
        remove_cv<_Up>,
        add_pointer<_Up>>
    { };

  template<typename _Up, size_t _Nm>
    struct __decay_selector<_Up[_Nm]>
    { using type = _Up*; };

  template<typename _Up>
    struct __decay_selector<_Up[]>
    { using type = _Up*; };




  template<typename _Tp>
    struct decay
    { using type = typename __decay_selector<_Tp>::type; };

  template<typename _Tp>
    struct decay<_Tp&>
    { using type = typename __decay_selector<_Tp>::type; };

  template<typename _Tp>
    struct decay<_Tp&&>
    { using type = typename __decay_selector<_Tp>::type; };




  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      using __type = _Tp;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      using __type = _Tp&;
    };


  template<typename _Tp>
    using __decay_t = typename decay<_Tp>::type;

  template<typename _Tp>
    using __decay_and_strip = __strip_reference_wrapper<__decay_t<_Tp>>;





  template<typename... _Cond>
    using _Require = __enable_if_t<__and_<_Cond...>::value>;


  template<typename _Tp>
    using __remove_cvref_t
     = typename remove_cv<typename remove_reference<_Tp>::type>::type;




  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { using type = _Iftrue; };


  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { using type = _Iffalse; };


  template<typename... _Tp>
    struct common_type;
# 2340 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
  template<typename _Tp>
    struct __success_type
    { using type = _Tp; };

  struct __failure_type
  { };

  struct __do_common_type_impl
  {
    template<typename _Tp, typename _Up>
      using __cond_t
 = decltype(true ? std::declval<_Tp>() : std::declval<_Up>());



    template<typename _Tp, typename _Up>
      static __success_type<__decay_t<__cond_t<_Tp, _Up>>>
      _S_test(int);




    template<typename _Tp, typename _Up>
      static __success_type<__remove_cvref_t<__cond_t<const _Tp&, const _Up&>>>
      _S_test_2(int);


    template<typename, typename>
      static __failure_type
      _S_test_2(...);

    template<typename _Tp, typename _Up>
      static decltype(_S_test_2<_Tp, _Up>(0))
      _S_test(...);
  };


  template<>
    struct common_type<>
    { };


  template<typename _Tp0>
    struct common_type<_Tp0>
    : public common_type<_Tp0, _Tp0>
    { };


  template<typename _Tp1, typename _Tp2,
    typename _Dp1 = __decay_t<_Tp1>, typename _Dp2 = __decay_t<_Tp2>>
    struct __common_type_impl
    {


      using type = common_type<_Dp1, _Dp2>;
    };

  template<typename _Tp1, typename _Tp2>
    struct __common_type_impl<_Tp1, _Tp2, _Tp1, _Tp2>
    : private __do_common_type_impl
    {


      using type = decltype(_S_test<_Tp1, _Tp2>(0));
    };


  template<typename _Tp1, typename _Tp2>
    struct common_type<_Tp1, _Tp2>
    : public __common_type_impl<_Tp1, _Tp2>::type
    { };

  template<typename...>
    struct __common_type_pack
    { };

  template<typename, typename, typename = void>
    struct __common_type_fold;


  template<typename _Tp1, typename _Tp2, typename... _Rp>
    struct common_type<_Tp1, _Tp2, _Rp...>
    : public __common_type_fold<common_type<_Tp1, _Tp2>,
    __common_type_pack<_Rp...>>
    { };




  template<typename _CTp, typename... _Rp>
    struct __common_type_fold<_CTp, __common_type_pack<_Rp...>,
         __void_t<typename _CTp::type>>
    : public common_type<typename _CTp::type, _Rp...>
    { };


  template<typename _CTp, typename _Rp>
    struct __common_type_fold<_CTp, _Rp, void>
    { };

  template<typename _Tp, bool = __is_enum(_Tp)>
    struct __underlying_type_impl
    {
      using type = __underlying_type(_Tp);
    };

  template<typename _Tp>
    struct __underlying_type_impl<_Tp, false>
    { };



  template<typename _Tp>
    struct underlying_type
    : public __underlying_type_impl<_Tp>
    { };


  template<typename _Tp>
    struct __declval_protector
    {
      static const bool __stop = false;
    };






  template<typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0))
    {
      static_assert(__declval_protector<_Tp>::__stop,
      "declval() must not be used!");
      return __declval<_Tp>(0);
    }


  template<typename _Signature>
    struct result_of;




  struct __invoke_memfun_ref { };
  struct __invoke_memfun_deref { };
  struct __invoke_memobj_ref { };
  struct __invoke_memobj_deref { };
  struct __invoke_other { };


  template<typename _Tp, typename _Tag>
    struct __result_of_success : __success_type<_Tp>
    { using __invoke_type = _Tag; };


  struct __result_of_memfun_ref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_ref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_ref
    : private __result_of_memfun_ref_impl
    {
      using type = decltype(_S_test<_MemPtr, _Arg, _Args...>(0));
    };


  struct __result_of_memfun_deref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_deref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_deref
    : private __result_of_memfun_deref_impl
    {
      using type = decltype(_S_test<_MemPtr, _Arg, _Args...>(0));
    };


  struct __result_of_memobj_ref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      std::declval<_Tp1>().*std::declval<_Fp>()
      ), __invoke_memobj_ref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_ref
    : private __result_of_memobj_ref_impl
    {
      using type = decltype(_S_test<_MemPtr, _Arg>(0));
    };


  struct __result_of_memobj_deref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      (*std::declval<_Tp1>()).*std::declval<_Fp>()
      ), __invoke_memobj_deref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_deref
    : private __result_of_memobj_deref_impl
    {
      using type = decltype(_S_test<_MemPtr, _Arg>(0));
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj;

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, _Arg>
    {
      using _Argval = __remove_cvref_t<_Arg>;
      using _MemPtr = _Res _Class::*;
      using type = typename __conditional_t<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memobj_ref<_MemPtr, _Arg>,
        __result_of_memobj_deref<_MemPtr, _Arg>
      >::type;
    };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun;

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>
    {
      using _Argval = typename remove_reference<_Arg>::type;
      using _MemPtr = _Res _Class::*;
      using type = typename __conditional_t<is_base_of<_Class, _Argval>::value,
        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>
      >::type;
    };






  template<typename _Tp, typename _Up = __remove_cvref_t<_Tp>>
    struct __inv_unwrap
    {
      using type = _Tp;
    };

  template<typename _Tp, typename _Up>
    struct __inv_unwrap<_Tp, reference_wrapper<_Up>>
    {
      using type = _Up&;
    };

  template<bool, bool, typename _Functor, typename... _ArgTypes>
    struct __result_of_impl
    {
      using type = __failure_type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_impl<true, false, _MemPtr, _Arg>
    : public __result_of_memobj<__decay_t<_MemPtr>,
    typename __inv_unwrap<_Arg>::type>
    { };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
    : public __result_of_memfun<__decay_t<_MemPtr>,
    typename __inv_unwrap<_Arg>::type, _Args...>
    { };


  struct __result_of_other_impl
  {
    template<typename _Fn, typename... _Args>
      static __result_of_success<decltype(
      std::declval<_Fn>()(std::declval<_Args>()...)
      ), __invoke_other> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _Functor, typename... _ArgTypes>
    struct __result_of_impl<false, false, _Functor, _ArgTypes...>
    : private __result_of_other_impl
    {
      using type = decltype(_S_test<_Functor, _ArgTypes...>(0));
    };


  template<typename _Functor, typename... _ArgTypes>
    struct __invoke_result
    : public __result_of_impl<
        is_member_object_pointer<
          typename remove_reference<_Functor>::type
        >::value,
        is_member_function_pointer<
          typename remove_reference<_Functor>::type
        >::value,
 _Functor, _ArgTypes...
      >::type
    { };


  template<typename _Fn, typename... _Args>
    using __invoke_result_t = typename __invoke_result<_Fn, _Args...>::type;


  template<typename _Functor, typename... _ArgTypes>
    struct result_of<_Functor(_ArgTypes...)>
    : public __invoke_result<_Functor, _ArgTypes...>
    { } __attribute__ ((__deprecated__ ("use '" "std::invoke_result" "' instead")));


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

  template<size_t _Len, size_t _Align =
     __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    using aligned_storage_t [[__deprecated__]] = typename aligned_storage<_Len, _Align>::type;

  template <size_t _Len, typename... _Types>
    using aligned_union_t [[__deprecated__]] = typename aligned_union<_Len, _Types...>::type;
#pragma GCC diagnostic pop


  template<typename _Tp>
    using decay_t = typename decay<_Tp>::type;


  template<bool _Cond, typename _Tp = void>
    using enable_if_t = typename enable_if<_Cond, _Tp>::type;


  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    using conditional_t = typename conditional<_Cond, _Iftrue, _Iffalse>::type;


  template<typename... _Tp>
    using common_type_t = typename common_type<_Tp...>::type;


  template<typename _Tp>
    using underlying_type_t = typename underlying_type<_Tp>::type;


  template<typename _Tp>
    using result_of_t = typename result_of<_Tp>::type;




  template<typename...> using void_t = void;
# 2727 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
  template<typename _Def, template<typename...> class _Op, typename... _Args>
    struct __detected_or
    {
      using type = _Def;
      using __is_detected = false_type;
    };


  template<typename _Def, template<typename...> class _Op, typename... _Args>
    requires requires { typename _Op<_Args...>; }
    struct __detected_or<_Def, _Op, _Args...>
    {
      using type = _Op<_Args...>;
      using __is_detected = true_type;
    };
# 2767 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or_t
      = typename __detected_or<_Default, _Op, _Args...>::type;
# 2786 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
  template <typename _Tp>
    struct __is_swappable;

  template <typename _Tp>
    struct __is_nothrow_swappable;

  template<typename>
    struct __is_tuple_like_impl : false_type
    { };


  template<typename _Tp>
    struct __is_tuple_like
    : public __is_tuple_like_impl<__remove_cvref_t<_Tp>>::type
    { };


  template<typename _Tp>
    constexpr
    inline
    _Require<__not_<__is_tuple_like<_Tp>>,
      is_move_constructible<_Tp>,
      is_move_assignable<_Tp>>
    swap(_Tp&, _Tp&)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value);

  template<typename _Tp, size_t _Nm>
    constexpr
    inline
    __enable_if_t<__is_swappable<_Tp>::value>
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value);


  namespace __swappable_details {
    using std::swap;

    struct __do_is_swappable_impl
    {
      template<typename _Tp, typename
               = decltype(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))>
        static true_type __test(int);

      template<typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_impl
    {
      template<typename _Tp>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))
        > __test(int);

      template<typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp>
    struct __is_swappable_impl
    : public __swappable_details::__do_is_swappable_impl
    {
      using type = decltype(__test<_Tp>(0));
    };

  template<typename _Tp>
    struct __is_nothrow_swappable_impl
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      using type = decltype(__test<_Tp>(0));
    };

  template<typename _Tp>
    struct __is_swappable
    : public __is_swappable_impl<_Tp>::type
    { };

  template<typename _Tp>
    struct __is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    { };






  template<typename _Tp>
    struct is_swappable
    : public __is_swappable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp>
    inline constexpr bool is_swappable_v =
      is_swappable<_Tp>::value;


  template<typename _Tp>
    inline constexpr bool is_nothrow_swappable_v =
      is_nothrow_swappable<_Tp>::value;



  namespace __swappable_with_details {
    using std::swap;

    struct __do_is_swappable_with_impl
    {
      template<typename _Tp, typename _Up, typename
               = decltype(swap(std::declval<_Tp>(), std::declval<_Up>())),
               typename
               = decltype(swap(std::declval<_Up>(), std::declval<_Tp>()))>
        static true_type __test(int);

      template<typename, typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_with_impl
    {
      template<typename _Tp, typename _Up>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp>(), std::declval<_Up>()))
          &&
          noexcept(swap(std::declval<_Up>(), std::declval<_Tp>()))
        > __test(int);

      template<typename, typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp, typename _Up>
    struct __is_swappable_with_impl
    : public __swappable_with_details::__do_is_swappable_with_impl
    {
      using type = decltype(__test<_Tp, _Up>(0));
    };


  template<typename _Tp>
    struct __is_swappable_with_impl<_Tp&, _Tp&>
    : public __swappable_details::__do_is_swappable_impl
    {
      using type = decltype(__test<_Tp&>(0));
    };

  template<typename _Tp, typename _Up>
    struct __is_nothrow_swappable_with_impl
    : public __swappable_with_details::__do_is_nothrow_swappable_with_impl
    {
      using type = decltype(__test<_Tp, _Up>(0));
    };


  template<typename _Tp>
    struct __is_nothrow_swappable_with_impl<_Tp&, _Tp&>
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      using type = decltype(__test<_Tp&>(0));
    };



  template<typename _Tp, typename _Up>
    struct is_swappable_with
    : public __is_swappable_with_impl<_Tp, _Up>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "first template argument must be a complete class or an unbounded array");
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Up>{}),
 "second template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    struct is_nothrow_swappable_with
    : public __is_nothrow_swappable_with_impl<_Tp, _Up>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "first template argument must be a complete class or an unbounded array");
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Up>{}),
 "second template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp, typename _Up>
    inline constexpr bool is_swappable_with_v =
      is_swappable_with<_Tp, _Up>::value;


  template<typename _Tp, typename _Up>
    inline constexpr bool is_nothrow_swappable_with_v =
      is_nothrow_swappable_with<_Tp, _Up>::value;
# 3008 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
  template<typename _Result, typename _Ret,
    bool = is_void<_Ret>::value, typename = void>
    struct __is_invocable_impl
    : false_type
    {
      using __nothrow_conv = false_type;
    };


  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret,
                                true,
          __void_t<typename _Result::type>>
    : true_type
    {
      using __nothrow_conv = true_type;
    };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"

  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret,
                                false,
          __void_t<typename _Result::type>>
    {
    private:

      using _Res_t = typename _Result::type;



      static _Res_t _S_get() noexcept;


      template<typename _Tp>
 static void _S_conv(__type_identity_t<_Tp>) noexcept;


      template<typename _Tp,
        bool _Nothrow = noexcept(_S_conv<_Tp>(_S_get())),
        typename = decltype(_S_conv<_Tp>(_S_get())),

        bool _Dangle = __reference_converts_from_temporary(_Tp, _Res_t)



       >
 static __bool_constant<_Nothrow && !_Dangle>
 _S_test(int);

      template<typename _Tp, bool = false>
 static false_type
 _S_test(...);

    public:

      using type = decltype(_S_test<_Ret, true>(1));


      using __nothrow_conv = decltype(_S_test<_Ret>(1));
    };
#pragma GCC diagnostic pop

  template<typename _Fn, typename... _ArgTypes>
    struct __is_invocable
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type
    { };

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept((std::declval<_Up>().*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_deref)
    {
      return noexcept(((*std::declval<_Tp>()).*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept(std::declval<_Up>().*std::declval<_Fn>());
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_deref)
    {
      return noexcept((*std::declval<_Tp>()).*std::declval<_Fn>());
    }

  template<typename _Fn, typename... _Args>
    constexpr bool __call_is_nt(__invoke_other)
    {
      return noexcept(std::declval<_Fn>()(std::declval<_Args>()...));
    }

  template<typename _Result, typename _Fn, typename... _Args>
    struct __call_is_nothrow
    : __bool_constant<
 std::__call_is_nt<_Fn, _Args...>(typename _Result::__invoke_type{})
      >
    { };

  template<typename _Fn, typename... _Args>
    using __call_is_nothrow_
      = __call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;


  template<typename _Fn, typename... _Args>
    struct __is_nothrow_invocable
    : __and_<__is_invocable<_Fn, _Args...>,
             __call_is_nothrow_<_Fn, _Args...>>::type
    { };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
  struct __nonesuchbase {};
  struct __nonesuch : private __nonesuchbase {
    ~__nonesuch() = delete;
    __nonesuch(__nonesuch const&) = delete;
    void operator=(__nonesuch const&) = delete;
  };
#pragma GCC diagnostic pop




  template<typename _Functor, typename... _ArgTypes>
    struct invoke_result
    : public __invoke_result<_Functor, _ArgTypes...>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Functor>{}),
 "_Functor must be a complete class or an unbounded array");
      static_assert((std::__is_complete_or_unbounded(
 __type_identity<_ArgTypes>{}) && ...),
 "each argument type must be a complete class or an unbounded array");
    };


  template<typename _Fn, typename... _Args>
    using invoke_result_t = typename invoke_result<_Fn, _Args...>::type;


  template<typename _Fn, typename... _ArgTypes>
    struct is_invocable
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
 "_Fn must be a complete class or an unbounded array");
      static_assert((std::__is_complete_or_unbounded(
 __type_identity<_ArgTypes>{}) && ...),
 "each argument type must be a complete class or an unbounded array");
    };


  template<typename _Ret, typename _Fn, typename... _ArgTypes>
    struct is_invocable_r
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
 "_Fn must be a complete class or an unbounded array");
      static_assert((std::__is_complete_or_unbounded(
 __type_identity<_ArgTypes>{}) && ...),
 "each argument type must be a complete class or an unbounded array");
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Ret>{}),
 "_Ret must be a complete class or an unbounded array");
    };


  template<typename _Fn, typename... _ArgTypes>
    struct is_nothrow_invocable
    : __and_<__is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>,
      __call_is_nothrow_<_Fn, _ArgTypes...>>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
 "_Fn must be a complete class or an unbounded array");
      static_assert((std::__is_complete_or_unbounded(
 __type_identity<_ArgTypes>{}) && ...),
 "each argument type must be a complete class or an unbounded array");
    };





  template<typename _Result, typename _Ret>
    using __is_nt_invocable_impl
      = typename __is_invocable_impl<_Result, _Ret>::__nothrow_conv;



  template<typename _Ret, typename _Fn, typename... _ArgTypes>
    struct is_nothrow_invocable_r
    : __and_<__is_nt_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>,
             __call_is_nothrow_<_Fn, _ArgTypes...>>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
 "_Fn must be a complete class or an unbounded array");
      static_assert((std::__is_complete_or_unbounded(
 __type_identity<_ArgTypes>{}) && ...),
 "each argument type must be a complete class or an unbounded array");
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Ret>{}),
 "_Ret must be a complete class or an unbounded array");
    };
# 3236 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
template <typename _Tp>
  inline constexpr bool is_void_v = is_void<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_null_pointer_v = is_null_pointer<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_integral_v = is_integral<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_floating_point_v = is_floating_point<_Tp>::value;


template <typename _Tp>
  inline constexpr bool is_array_v = __is_array(_Tp);
# 3257 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
template <typename _Tp>
  inline constexpr bool is_pointer_v = is_pointer<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_lvalue_reference_v = false;
template <typename _Tp>
  inline constexpr bool is_lvalue_reference_v<_Tp&> = true;
template <typename _Tp>
  inline constexpr bool is_rvalue_reference_v = false;
template <typename _Tp>
  inline constexpr bool is_rvalue_reference_v<_Tp&&> = true;


template <typename _Tp>
  inline constexpr bool is_member_object_pointer_v =
    __is_member_object_pointer(_Tp);







template <typename _Tp>
  inline constexpr bool is_member_function_pointer_v =
    __is_member_function_pointer(_Tp);






template <typename _Tp>
  inline constexpr bool is_enum_v = __is_enum(_Tp);
template <typename _Tp>
  inline constexpr bool is_union_v = __is_union(_Tp);
template <typename _Tp>
  inline constexpr bool is_class_v = __is_class(_Tp);



template <typename _Tp>
  inline constexpr bool is_reference_v = __is_reference(_Tp);
# 3308 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
template <typename _Tp>
  inline constexpr bool is_arithmetic_v = is_arithmetic<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_fundamental_v = is_fundamental<_Tp>::value;


template <typename _Tp>
  inline constexpr bool is_object_v = __is_object(_Tp);





template <typename _Tp>
  inline constexpr bool is_scalar_v = is_scalar<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_compound_v = !is_fundamental_v<_Tp>;


template <typename _Tp>
  inline constexpr bool is_member_pointer_v = __is_member_pointer(_Tp);





template <typename _Tp>
  inline constexpr bool is_const_v = false;
template <typename _Tp>
  inline constexpr bool is_const_v<const _Tp> = true;


template <typename _Tp>
  inline constexpr bool is_function_v = __is_function(_Tp);
# 3351 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
template <typename _Tp>
  inline constexpr bool is_volatile_v = false;
template <typename _Tp>
  inline constexpr bool is_volatile_v<volatile _Tp> = true;

template <typename _Tp>
  inline constexpr bool is_trivial_v = __is_trivial(_Tp);
template <typename _Tp>
  inline constexpr bool is_trivially_copyable_v = __is_trivially_copyable(_Tp);
template <typename _Tp>
  inline constexpr bool is_standard_layout_v = __is_standard_layout(_Tp);
template <typename _Tp>
  __attribute__ ((__deprecated__ ("use '" "is_standard_layout_v && is_trivial_v" "' instead")))
  inline constexpr bool is_pod_v = __is_pod(_Tp);
template <typename _Tp>
  [[__deprecated__]]
  inline constexpr bool is_literal_type_v = __is_literal_type(_Tp);
template <typename _Tp>
  inline constexpr bool is_empty_v = __is_empty(_Tp);
template <typename _Tp>
  inline constexpr bool is_polymorphic_v = __is_polymorphic(_Tp);
template <typename _Tp>
  inline constexpr bool is_abstract_v = __is_abstract(_Tp);
template <typename _Tp>
  inline constexpr bool is_final_v = __is_final(_Tp);

template <typename _Tp>
  inline constexpr bool is_signed_v = is_signed<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_unsigned_v = is_unsigned<_Tp>::value;

template <typename _Tp, typename... _Args>
  inline constexpr bool is_constructible_v = __is_constructible(_Tp, _Args...);
template <typename _Tp>
  inline constexpr bool is_default_constructible_v = __is_constructible(_Tp);
template <typename _Tp>
  inline constexpr bool is_copy_constructible_v
    = __is_constructible(_Tp, __add_lval_ref_t<const _Tp>);
template <typename _Tp>
  inline constexpr bool is_move_constructible_v
    = __is_constructible(_Tp, __add_rval_ref_t<_Tp>);

template <typename _Tp, typename _Up>
  inline constexpr bool is_assignable_v = __is_assignable(_Tp, _Up);
template <typename _Tp>
  inline constexpr bool is_copy_assignable_v
    = __is_assignable(__add_lval_ref_t<_Tp>, __add_lval_ref_t<const _Tp>);
template <typename _Tp>
  inline constexpr bool is_move_assignable_v
    = __is_assignable(__add_lval_ref_t<_Tp>, __add_rval_ref_t<_Tp>);

template <typename _Tp>
  inline constexpr bool is_destructible_v = is_destructible<_Tp>::value;

template <typename _Tp, typename... _Args>
  inline constexpr bool is_trivially_constructible_v
    = __is_trivially_constructible(_Tp, _Args...);
template <typename _Tp>
  inline constexpr bool is_trivially_default_constructible_v
    = __is_trivially_constructible(_Tp);
template <typename _Tp>
  inline constexpr bool is_trivially_copy_constructible_v
    = __is_trivially_constructible(_Tp, __add_lval_ref_t<const _Tp>);
template <typename _Tp>
  inline constexpr bool is_trivially_move_constructible_v
    = __is_trivially_constructible(_Tp, __add_rval_ref_t<_Tp>);

template <typename _Tp, typename _Up>
  inline constexpr bool is_trivially_assignable_v
    = __is_trivially_assignable(_Tp, _Up);
template <typename _Tp>
  inline constexpr bool is_trivially_copy_assignable_v
    = __is_trivially_assignable(__add_lval_ref_t<_Tp>,
    __add_lval_ref_t<const _Tp>);
template <typename _Tp>
  inline constexpr bool is_trivially_move_assignable_v
    = __is_trivially_assignable(__add_lval_ref_t<_Tp>,
    __add_rval_ref_t<_Tp>);


template <typename _Tp>
  inline constexpr bool is_trivially_destructible_v = false;

template <typename _Tp>
  requires (!is_reference_v<_Tp>) && requires (_Tp& __t) { __t.~_Tp(); }
  inline constexpr bool is_trivially_destructible_v<_Tp>
    = __has_trivial_destructor(_Tp);
template <typename _Tp>
  inline constexpr bool is_trivially_destructible_v<_Tp&> = true;
template <typename _Tp>
  inline constexpr bool is_trivially_destructible_v<_Tp&&> = true;
template <typename _Tp, size_t _Nm>
  inline constexpr bool is_trivially_destructible_v<_Tp[_Nm]>
    = is_trivially_destructible_v<_Tp>;






template <typename _Tp, typename... _Args>
  inline constexpr bool is_nothrow_constructible_v
    = __is_nothrow_constructible(_Tp, _Args...);
template <typename _Tp>
  inline constexpr bool is_nothrow_default_constructible_v
    = __is_nothrow_constructible(_Tp);
template <typename _Tp>
  inline constexpr bool is_nothrow_copy_constructible_v
    = __is_nothrow_constructible(_Tp, __add_lval_ref_t<const _Tp>);
template <typename _Tp>
  inline constexpr bool is_nothrow_move_constructible_v
    = __is_nothrow_constructible(_Tp, __add_rval_ref_t<_Tp>);

template <typename _Tp, typename _Up>
  inline constexpr bool is_nothrow_assignable_v
    = __is_nothrow_assignable(_Tp, _Up);
template <typename _Tp>
  inline constexpr bool is_nothrow_copy_assignable_v
    = __is_nothrow_assignable(__add_lval_ref_t<_Tp>,
         __add_lval_ref_t<const _Tp>);
template <typename _Tp>
  inline constexpr bool is_nothrow_move_assignable_v
    = __is_nothrow_assignable(__add_lval_ref_t<_Tp>, __add_rval_ref_t<_Tp>);

template <typename _Tp>
  inline constexpr bool is_nothrow_destructible_v =
    is_nothrow_destructible<_Tp>::value;

template <typename _Tp>
  inline constexpr bool has_virtual_destructor_v
    = __has_virtual_destructor(_Tp);

template <typename _Tp>
  inline constexpr size_t alignment_of_v = alignment_of<_Tp>::value;

template <typename _Tp>
  inline constexpr size_t rank_v = 0;
template <typename _Tp, size_t _Size>
  inline constexpr size_t rank_v<_Tp[_Size]> = 1 + rank_v<_Tp>;
template <typename _Tp>
  inline constexpr size_t rank_v<_Tp[]> = 1 + rank_v<_Tp>;

template <typename _Tp, unsigned _Idx = 0>
  inline constexpr size_t extent_v = 0;
template <typename _Tp, size_t _Size>
  inline constexpr size_t extent_v<_Tp[_Size], 0> = _Size;
template <typename _Tp, unsigned _Idx, size_t _Size>
  inline constexpr size_t extent_v<_Tp[_Size], _Idx> = extent_v<_Tp, _Idx - 1>;
template <typename _Tp>
  inline constexpr size_t extent_v<_Tp[], 0> = 0;
template <typename _Tp, unsigned _Idx>
  inline constexpr size_t extent_v<_Tp[], _Idx> = extent_v<_Tp, _Idx - 1>;


template <typename _Tp, typename _Up>
  inline constexpr bool is_same_v = __is_same(_Tp, _Up);






template <typename _Base, typename _Derived>
  inline constexpr bool is_base_of_v = __is_base_of(_Base, _Derived);

template <typename _From, typename _To>
  inline constexpr bool is_convertible_v = __is_convertible(_From, _To);




template<typename _Fn, typename... _Args>
  inline constexpr bool is_invocable_v = is_invocable<_Fn, _Args...>::value;
template<typename _Fn, typename... _Args>
  inline constexpr bool is_nothrow_invocable_v
    = is_nothrow_invocable<_Fn, _Args...>::value;
template<typename _Ret, typename _Fn, typename... _Args>
  inline constexpr bool is_invocable_r_v
    = is_invocable_r<_Ret, _Fn, _Args...>::value;
template<typename _Ret, typename _Fn, typename... _Args>
  inline constexpr bool is_nothrow_invocable_r_v
    = is_nothrow_invocable_r<_Ret, _Fn, _Args...>::value;






  template<typename _Tp>
    struct has_unique_object_representations
    : bool_constant<__has_unique_object_representations(
      remove_cv_t<remove_all_extents_t<_Tp>>
      )>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp>
    inline constexpr bool has_unique_object_representations_v
      = has_unique_object_representations<_Tp>::value;






  template<typename _Tp>
    struct is_aggregate
    : bool_constant<__is_aggregate(remove_cv_t<_Tp>)>
    { };






  template<typename _Tp>
    inline constexpr bool is_aggregate_v = __is_aggregate(remove_cv_t<_Tp>);
# 3581 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
  template<typename _Tp>
    struct remove_cvref
    { using type = __remove_cvref(_Tp); };
# 3598 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
  template<typename _Tp>
    using remove_cvref_t = typename remove_cvref<_Tp>::type;
# 3608 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
  template<typename _Tp>
    struct type_identity { using type = _Tp; };

  template<typename _Tp>
    using type_identity_t = typename type_identity<_Tp>::type;
# 3621 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
  template<typename _Tp>
    struct unwrap_reference { using type = _Tp; };

  template<typename _Tp>
    struct unwrap_reference<reference_wrapper<_Tp>> { using type = _Tp&; };

  template<typename _Tp>
    using unwrap_reference_t = typename unwrap_reference<_Tp>::type;






  template<typename _Tp>
    struct unwrap_ref_decay { using type = unwrap_reference_t<decay_t<_Tp>>; };

  template<typename _Tp>
    using unwrap_ref_decay_t = typename unwrap_ref_decay<_Tp>::type;
# 3648 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
  template<typename _Tp>
    inline constexpr bool is_bounded_array_v = __is_bounded_array(_Tp);
# 3661 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
  template<typename _Tp>
    inline constexpr bool is_unbounded_array_v = false;

  template<typename _Tp>
    inline constexpr bool is_unbounded_array_v<_Tp[]> = true;



  template<typename _Tp>
    struct is_bounded_array
    : public bool_constant<is_bounded_array_v<_Tp>>
    { };



  template<typename _Tp>
    struct is_unbounded_array
    : public bool_constant<is_unbounded_array_v<_Tp>>
    { };





  template<typename _Tp, typename _Up>
    struct is_layout_compatible
    : bool_constant<__is_layout_compatible(_Tp, _Up)>
    { };



  template<typename _Tp, typename _Up>
    constexpr bool is_layout_compatible_v
      = __is_layout_compatible(_Tp, _Up);







  template<typename _S1, typename _S2, typename _M1, typename _M2>
    constexpr bool
    is_corresponding_member(_M1 _S1::*__m1, _M2 _S2::*__m2) noexcept
    { return __builtin_is_corresponding_member(__m1, __m2); }







  template<typename _Base, typename _Derived>
    struct is_pointer_interconvertible_base_of
    : bool_constant<__is_pointer_interconvertible_base_of(_Base, _Derived)>
    { };



  template<typename _Base, typename _Derived>
    constexpr bool is_pointer_interconvertible_base_of_v
      = __is_pointer_interconvertible_base_of(_Base, _Derived);
# 3732 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
  template<typename _Tp, typename _Mem>
    constexpr bool
    is_pointer_interconvertible_with_class(_Mem _Tp::*__mp) noexcept
    { return __builtin_is_pointer_interconvertible_with_class(__mp); }
# 3744 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
  template<typename _Tp>
    struct is_scoped_enum
    : bool_constant<__is_scoped_enum(_Tp)>
    { };
# 3765 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
  template<typename _Tp>
    inline constexpr bool is_scoped_enum_v = __is_scoped_enum(_Tp);
# 3778 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/type_traits" 3
  template<typename _Tp, typename _Up>
    struct reference_constructs_from_temporary
    : public bool_constant<__reference_constructs_from_temporary(_Tp, _Up)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{})
      && std::__is_complete_or_unbounded(__type_identity<_Up>{}),
 "template argument must be a complete class or an unbounded array");
    };





  template<typename _Tp, typename _Up>
    struct reference_converts_from_temporary
    : public bool_constant<__reference_converts_from_temporary(_Tp, _Up)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{})
      && std::__is_complete_or_unbounded(__type_identity<_Up>{}),
 "template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp, typename _Up>
    inline constexpr bool reference_constructs_from_temporary_v
      = reference_constructs_from_temporary<_Tp, _Up>::value;



  template<typename _Tp, typename _Up>
    inline constexpr bool reference_converts_from_temporary_v
      = reference_converts_from_temporary<_Tp, _Up>::value;





  constexpr inline bool
  is_constant_evaluated() noexcept
  {

    if consteval { return true; } else { return false; }



  }




  template<typename _From, typename _To>
    using __copy_cv = typename __match_cv_qualifiers<_From, _To>::__type;

  template<typename _Xp, typename _Yp>
    using __cond_res
      = decltype(false ? declval<_Xp(&)()>()() : declval<_Yp(&)()>()());

  template<typename _Ap, typename _Bp, typename = void>
    struct __common_ref_impl
    { };


  template<typename _Ap, typename _Bp>
    using __common_ref = typename __common_ref_impl<_Ap, _Bp>::type;


  template<typename _Xp, typename _Yp>
    using __condres_cvref
      = __cond_res<__copy_cv<_Xp, _Yp>&, __copy_cv<_Yp, _Xp>&>;


  template<typename _Xp, typename _Yp>
    struct __common_ref_impl<_Xp&, _Yp&, __void_t<__condres_cvref<_Xp, _Yp>>>
    : enable_if<is_reference_v<__condres_cvref<_Xp, _Yp>>,
  __condres_cvref<_Xp, _Yp>>
    { };


  template<typename _Xp, typename _Yp>
    using __common_ref_C = remove_reference_t<__common_ref<_Xp&, _Yp&>>&&;


  template<typename _Xp, typename _Yp>
    struct __common_ref_impl<_Xp&&, _Yp&&,
      _Require<is_convertible<_Xp&&, __common_ref_C<_Xp, _Yp>>,
        is_convertible<_Yp&&, __common_ref_C<_Xp, _Yp>>>>
    { using type = __common_ref_C<_Xp, _Yp>; };


  template<typename _Xp, typename _Yp>
    using __common_ref_D = __common_ref<const _Xp&, _Yp&>;


  template<typename _Xp, typename _Yp>
    struct __common_ref_impl<_Xp&&, _Yp&,
      _Require<is_convertible<_Xp&&, __common_ref_D<_Xp, _Yp>>>>
    { using type = __common_ref_D<_Xp, _Yp>; };


  template<typename _Xp, typename _Yp>
    struct __common_ref_impl<_Xp&, _Yp&&>
    : __common_ref_impl<_Yp&&, _Xp&>
    { };


  template<typename _Tp, typename _Up,
    template<typename> class _TQual, template<typename> class _UQual>
    struct basic_common_reference
    { };


  template<typename _Tp>
    struct __xref
    { template<typename _Up> using __type = __copy_cv<_Tp, _Up>; };

  template<typename _Tp>
    struct __xref<_Tp&>
    { template<typename _Up> using __type = __copy_cv<_Tp, _Up>&; };

  template<typename _Tp>
    struct __xref<_Tp&&>
    { template<typename _Up> using __type = __copy_cv<_Tp, _Up>&&; };

  template<typename _Tp1, typename _Tp2>
    using __basic_common_ref
      = typename basic_common_reference<remove_cvref_t<_Tp1>,
     remove_cvref_t<_Tp2>,
     __xref<_Tp1>::template __type,
     __xref<_Tp2>::template __type>::type;


  template<typename... _Tp>
    struct common_reference;

  template<typename... _Tp>
    using common_reference_t = typename common_reference<_Tp...>::type;


  template<>
    struct common_reference<>
    { };


  template<typename _Tp0>
    struct common_reference<_Tp0>
    { using type = _Tp0; };


  template<typename _Tp1, typename _Tp2, int _Bullet = 1, typename = void>
    struct __common_reference_impl
    : __common_reference_impl<_Tp1, _Tp2, _Bullet + 1>
    { };


  template<typename _Tp1, typename _Tp2>
    struct common_reference<_Tp1, _Tp2>
    : __common_reference_impl<_Tp1, _Tp2>
    { };


  template<typename _Tp1, typename _Tp2>
    struct __common_reference_impl<_Tp1&, _Tp2&, 1,
       void_t<__common_ref<_Tp1&, _Tp2&>>>
    { using type = __common_ref<_Tp1&, _Tp2&>; };

  template<typename _Tp1, typename _Tp2>
    struct __common_reference_impl<_Tp1&&, _Tp2&&, 1,
       void_t<__common_ref<_Tp1&&, _Tp2&&>>>
    { using type = __common_ref<_Tp1&&, _Tp2&&>; };

  template<typename _Tp1, typename _Tp2>
    struct __common_reference_impl<_Tp1&, _Tp2&&, 1,
       void_t<__common_ref<_Tp1&, _Tp2&&>>>
    { using type = __common_ref<_Tp1&, _Tp2&&>; };

  template<typename _Tp1, typename _Tp2>
    struct __common_reference_impl<_Tp1&&, _Tp2&, 1,
       void_t<__common_ref<_Tp1&&, _Tp2&>>>
    { using type = __common_ref<_Tp1&&, _Tp2&>; };


  template<typename _Tp1, typename _Tp2>
    struct __common_reference_impl<_Tp1, _Tp2, 2,
       void_t<__basic_common_ref<_Tp1, _Tp2>>>
    { using type = __basic_common_ref<_Tp1, _Tp2>; };


  template<typename _Tp1, typename _Tp2>
    struct __common_reference_impl<_Tp1, _Tp2, 3,
       void_t<__cond_res<_Tp1, _Tp2>>>
    { using type = __cond_res<_Tp1, _Tp2>; };


  template<typename _Tp1, typename _Tp2>
    struct __common_reference_impl<_Tp1, _Tp2, 4,
       void_t<common_type_t<_Tp1, _Tp2>>>
    { using type = common_type_t<_Tp1, _Tp2>; };


  template<typename _Tp1, typename _Tp2>
    struct __common_reference_impl<_Tp1, _Tp2, 5, void>
    { };


  template<typename _Tp1, typename _Tp2, typename... _Rest>
    struct common_reference<_Tp1, _Tp2, _Rest...>
    : __common_type_fold<common_reference<_Tp1, _Tp2>,
    __common_type_pack<_Rest...>>
    { };


  template<typename _Tp1, typename _Tp2, typename... _Rest>
    struct __common_type_fold<common_reference<_Tp1, _Tp2>,
         __common_type_pack<_Rest...>,
         void_t<common_reference_t<_Tp1, _Tp2>>>
    : public common_reference<common_reference_t<_Tp1, _Tp2>, _Rest...>
    { };







}
# 61 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_pair.h" 2 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/move.h" 1 3
# 40 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/move.h" 3
namespace std
{







  template<typename _Tp>
    inline constexpr _Tp*
    __addressof(_Tp& __r) noexcept
    { return __builtin_addressof(__r); }
# 67 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/move.h" 3
  template<typename _Tp>
    [[__nodiscard__]]
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Tp&&>(__t); }







  template<typename _Tp>
    [[__nodiscard__]]
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
    {
      static_assert(!std::is_lvalue_reference<_Tp>::value,
   "std::forward must not be used to convert an rvalue to an lvalue");
      return static_cast<_Tp&&>(__t);
    }


  template<typename _Tp, typename _Up>
  [[nodiscard]]
  constexpr decltype(auto)
  forward_like(_Up&& __x) noexcept
  {
    constexpr bool __as_rval = is_rvalue_reference_v<_Tp&&>;

    if constexpr (is_const_v<remove_reference_t<_Tp>>)
      {
 using _Up2 = remove_reference_t<_Up>;
 if constexpr (__as_rval)
   return static_cast<const _Up2&&>(__x);
 else
   return static_cast<const _Up2&>(__x);
      }
    else
      {
 if constexpr (__as_rval)
   return static_cast<remove_reference_t<_Up>&&>(__x);
 else
   return static_cast<_Up&>(__x);
      }
  }

  template<typename _Tp, typename _Up>
    using __like_t = decltype(std::forward_like<_Tp>(std::declval<_Up>()));







  template<typename _Tp>
    [[__nodiscard__]]
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }


  template<typename _Tp>
    struct __move_if_noexcept_cond
    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                    is_copy_constructible<_Tp>>::type { };
# 143 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/move.h" 3
  template<typename _Tp>
    [[__nodiscard__]]
    constexpr
    __conditional_t<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>
    move_if_noexcept(_Tp& __x) noexcept
    { return std::move(__x); }
# 159 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/move.h" 3
  template<typename _Tp>
    [[__nodiscard__]]
    inline constexpr _Tp*
    addressof(_Tp& __r) noexcept
    { return std::__addressof(__r); }



  template<typename _Tp>
    const _Tp* addressof(const _Tp&&) = delete;


  template <typename _Tp, typename _Up = _Tp>
    constexpr
    inline _Tp
    __exchange(_Tp& __obj, _Up&& __new_val)
    {
      _Tp __old_val = std::move(__obj);
      __obj = std::forward<_Up>(__new_val);
      return __old_val;
    }
# 203 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/move.h" 3
  template<typename _Tp>
    constexpr
    inline

    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
         is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type



    swap(_Tp& __a, _Tp& __b)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp>>::value)

    {




      _Tp __tmp = std::move(__a);
      __a = std::move(__b);
      __b = std::move(__tmp);
    }




  template<typename _Tp, size_t _Nm>
    constexpr
    inline

    typename enable_if<__is_swappable<_Tp>::value>::type



    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value)
    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }



}
# 62 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_pair.h" 2 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/utility.h" 1 3
# 36 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/utility.h" 3
       
# 37 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/utility.h" 3






namespace std
{



  template<typename _Tp>
    struct tuple_size;





  template<typename _Tp,
    typename _Up = typename remove_cv<_Tp>::type,
    typename = typename enable_if<is_same<_Tp, _Up>::value>::type,
    size_t = tuple_size<_Tp>::value>
    using __enable_if_has_tuple_size = _Tp;

  template<typename _Tp>
    struct tuple_size<const __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };

  template<typename _Tp>
    struct tuple_size<volatile __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };

  template<typename _Tp>
    struct tuple_size<const volatile __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };


  template<typename _Tp>
    inline constexpr size_t tuple_size_v = tuple_size<_Tp>::value;



  template<size_t __i, typename _Tp>
    struct tuple_element;


  template<size_t __i, typename _Tp>
    using __tuple_element_t = typename tuple_element<__i, _Tp>::type;

  template<size_t __i, typename _Tp>
    struct tuple_element<__i, const _Tp>
    {
      using type = const __tuple_element_t<__i, _Tp>;
    };

  template<size_t __i, typename _Tp>
    struct tuple_element<__i, volatile _Tp>
    {
      using type = volatile __tuple_element_t<__i, _Tp>;
    };

  template<size_t __i, typename _Tp>
    struct tuple_element<__i, const volatile _Tp>
    {
      using type = const volatile __tuple_element_t<__i, _Tp>;
    };





  template<typename _Tp, typename... _Types>
    constexpr size_t
    __find_uniq_type_in_pack()
    {
      constexpr size_t __sz = sizeof...(_Types);
      constexpr bool __found[__sz] = { __is_same(_Tp, _Types) ... };
      size_t __n = __sz;
      for (size_t __i = 0; __i < __sz; ++__i)
 {
   if (__found[__i])
     {
       if (__n < __sz)
  return __sz;
       __n = __i;
     }
 }
      return __n;
    }
# 134 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/utility.h" 3
  template<size_t __i, typename _Tp>
    using tuple_element_t = typename tuple_element<__i, _Tp>::type;




  template<size_t... _Indexes> struct _Index_tuple { };


  template<size_t _Num>
    struct _Build_index_tuple
    {
# 154 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/utility.h" 3
      using __type = _Index_tuple<__integer_pack(_Num)...>;

    };




  template<typename _Tp, _Tp... _Idx>
    struct integer_sequence
    {

      static_assert(is_integral_v<_Tp>);

      typedef _Tp value_type;
      static constexpr size_t size() noexcept { return sizeof...(_Idx); }
    };


  template<typename _Tp, _Tp _Num>
    using make_integer_sequence



      = integer_sequence<_Tp, __integer_pack(_Num)...>;



  template<size_t... _Idx>
    using index_sequence = integer_sequence<size_t, _Idx...>;


  template<size_t _Num>
    using make_index_sequence = make_integer_sequence<size_t, _Num>;


  template<typename... _Types>
    using index_sequence_for = make_index_sequence<sizeof...(_Types)>;




  struct in_place_t {
    explicit in_place_t() = default;
  };

  inline constexpr in_place_t in_place{};

  template<typename _Tp> struct in_place_type_t
  {
    explicit in_place_type_t() = default;
  };

  template<typename _Tp>
    inline constexpr in_place_type_t<_Tp> in_place_type{};

  template<size_t _Idx> struct in_place_index_t
  {
    explicit in_place_index_t() = default;
  };

  template<size_t _Idx>
    inline constexpr in_place_index_t<_Idx> in_place_index{};

  template<typename>
    inline constexpr bool __is_in_place_type_v = false;

  template<typename _Tp>
    inline constexpr bool __is_in_place_type_v<in_place_type_t<_Tp>> = true;

  template<typename _Tp>
    using __is_in_place_type = bool_constant<__is_in_place_type_v<_Tp>>;

  template<typename>
    inline constexpr bool __is_in_place_index_v = false;

  template<size_t _Nm>
    inline constexpr bool __is_in_place_index_v<in_place_index_t<_Nm>> = true;




  template<size_t _Np, typename... _Types>
    struct _Nth_type
    { using type = __type_pack_element<_Np, _Types...>; };
# 276 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/utility.h" 3
  namespace ranges::__detail
  {
    template<typename _Range>
      inline constexpr bool __is_subrange = false;
  }



}
# 63 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_pair.h" 2 3


# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/compare" 1 3
# 33 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/compare" 3
       
# 34 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/compare" 3


# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 1 3
# 47 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 3
       
# 48 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 3
# 37 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/compare" 2 3



# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/concepts" 1 3
# 33 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/concepts" 3
       
# 34 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/concepts" 3


# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 1 3
# 47 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 3
       
# 48 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 3
# 37 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/concepts" 2 3
# 48 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/concepts" 3
namespace std
{




  namespace __detail
  {
    template<typename _Tp, typename _Up>
      concept __same_as = std::is_same_v<_Tp, _Up>;
  }


  template<typename _Tp, typename _Up>
    concept same_as
      = __detail::__same_as<_Tp, _Up> && __detail::__same_as<_Up, _Tp>;

  namespace __detail
  {
    template<typename _Tp, typename _Up>
      concept __different_from
 = !same_as<remove_cvref_t<_Tp>, remove_cvref_t<_Up>>;
  }


  template<typename _Derived, typename _Base>
    concept derived_from = __is_base_of(_Base, _Derived)
      && is_convertible_v<const volatile _Derived*, const volatile _Base*>;


  template<typename _From, typename _To>
    concept convertible_to = is_convertible_v<_From, _To>
      && requires { static_cast<_To>(std::declval<_From>()); };


  template<typename _Tp, typename _Up>
    concept common_reference_with
      = same_as<common_reference_t<_Tp, _Up>, common_reference_t<_Up, _Tp>>
      && convertible_to<_Tp, common_reference_t<_Tp, _Up>>
      && convertible_to<_Up, common_reference_t<_Tp, _Up>>;


  template<typename _Tp, typename _Up>
    concept common_with
      = same_as<common_type_t<_Tp, _Up>, common_type_t<_Up, _Tp>>
      && requires {
 static_cast<common_type_t<_Tp, _Up>>(std::declval<_Tp>());
 static_cast<common_type_t<_Tp, _Up>>(std::declval<_Up>());
      }
      && common_reference_with<add_lvalue_reference_t<const _Tp>,
          add_lvalue_reference_t<const _Up>>
      && common_reference_with<add_lvalue_reference_t<common_type_t<_Tp, _Up>>,
          common_reference_t<
     add_lvalue_reference_t<const _Tp>,
     add_lvalue_reference_t<const _Up>>>;



  template<typename _Tp>
    concept integral = is_integral_v<_Tp>;

  template<typename _Tp>
    concept signed_integral = integral<_Tp> && is_signed_v<_Tp>;

  template<typename _Tp>
    concept unsigned_integral = integral<_Tp> && !signed_integral<_Tp>;

  template<typename _Tp>
    concept floating_point = is_floating_point_v<_Tp>;

  namespace __detail
  {
    template<typename _Tp>
      using __cref = const remove_reference_t<_Tp>&;

    template<typename _Tp>
      concept __class_or_enum
 = is_class_v<_Tp> || is_union_v<_Tp> || is_enum_v<_Tp>;

    template<typename _Tp>
      constexpr bool __destructible_impl = false;
    template<typename _Tp>
      requires requires(_Tp& __t) { { __t.~_Tp() } noexcept; }
      constexpr bool __destructible_impl<_Tp> = true;

    template<typename _Tp>
      constexpr bool __destructible = __destructible_impl<_Tp>;
    template<typename _Tp>
      constexpr bool __destructible<_Tp&> = true;
    template<typename _Tp>
      constexpr bool __destructible<_Tp&&> = true;
    template<typename _Tp, size_t _Nm>
      constexpr bool __destructible<_Tp[_Nm]> = __destructible<_Tp>;

  }


  template<typename _Lhs, typename _Rhs>
    concept assignable_from
      = is_lvalue_reference_v<_Lhs>
      && common_reference_with<__detail::__cref<_Lhs>, __detail::__cref<_Rhs>>
      && requires(_Lhs __lhs, _Rhs&& __rhs) {
 { __lhs = static_cast<_Rhs&&>(__rhs) } -> same_as<_Lhs>;
      };


  template<typename _Tp>
    concept destructible = __detail::__destructible<_Tp>;


  template<typename _Tp, typename... _Args>
    concept constructible_from
      = destructible<_Tp> && is_constructible_v<_Tp, _Args...>;


  template<typename _Tp>
    concept default_initializable = constructible_from<_Tp>
      && requires
      {
 _Tp{};
 (void) ::new _Tp;
      };


  template<typename _Tp>
    concept move_constructible
    = constructible_from<_Tp, _Tp> && convertible_to<_Tp, _Tp>;


  template<typename _Tp>
    concept copy_constructible
      = move_constructible<_Tp>
      && constructible_from<_Tp, _Tp&> && convertible_to<_Tp&, _Tp>
      && constructible_from<_Tp, const _Tp&> && convertible_to<const _Tp&, _Tp>
      && constructible_from<_Tp, const _Tp> && convertible_to<const _Tp, _Tp>;



  namespace ranges
  {

    namespace __swap
    {
      template<typename _Tp> void swap(_Tp&, _Tp&) = delete;

      template<typename _Tp, typename _Up>
 concept __adl_swap
   = (std::__detail::__class_or_enum<remove_reference_t<_Tp>>
     || std::__detail::__class_or_enum<remove_reference_t<_Up>>)
   && requires(_Tp&& __t, _Up&& __u) {
     swap(static_cast<_Tp&&>(__t), static_cast<_Up&&>(__u));
   };

      struct _Swap
      {
      private:
 template<typename _Tp, typename _Up>
   static constexpr bool
   _S_noexcept()
   {
     if constexpr (__adl_swap<_Tp, _Up>)
       return noexcept(swap(std::declval<_Tp>(), std::declval<_Up>()));
     else
       return is_nothrow_move_constructible_v<remove_reference_t<_Tp>>
     && is_nothrow_move_assignable_v<remove_reference_t<_Tp>>;
   }

      public:
 template<typename _Tp, typename _Up>
   requires __adl_swap<_Tp, _Up>
   || (same_as<_Tp, _Up> && is_lvalue_reference_v<_Tp>
       && move_constructible<remove_reference_t<_Tp>>
       && assignable_from<_Tp, remove_reference_t<_Tp>>)
   constexpr void
   operator()(_Tp&& __t, _Up&& __u) const
   noexcept(_S_noexcept<_Tp, _Up>())
   {
     if constexpr (__adl_swap<_Tp, _Up>)
       swap(static_cast<_Tp&&>(__t), static_cast<_Up&&>(__u));
     else
       {
  auto __tmp = static_cast<remove_reference_t<_Tp>&&>(__t);
  __t = static_cast<remove_reference_t<_Tp>&&>(__u);
  __u = static_cast<remove_reference_t<_Tp>&&>(__tmp);
       }
   }

 template<typename _Tp, typename _Up, size_t _Num>
   requires requires(const _Swap& __swap, _Tp& __e1, _Up& __e2) {
     __swap(__e1, __e2);
   }
   constexpr void
   operator()(_Tp (&__e1)[_Num], _Up (&__e2)[_Num]) const
   noexcept(noexcept(std::declval<const _Swap&>()(*__e1, *__e2)))
   {
     for (size_t __n = 0; __n < _Num; ++__n)
       (*this)(__e1[__n], __e2[__n]);
   }
      };
    }


    inline namespace _Cpo {
      inline constexpr __swap::_Swap swap{};
    }
  }

  template<typename _Tp>
    concept swappable
      = requires(_Tp& __a, _Tp& __b) { ranges::swap(__a, __b); };

  template<typename _Tp, typename _Up>
    concept swappable_with = common_reference_with<_Tp, _Up>
      && requires(_Tp&& __t, _Up&& __u) {
 ranges::swap(static_cast<_Tp&&>(__t), static_cast<_Tp&&>(__t));
 ranges::swap(static_cast<_Up&&>(__u), static_cast<_Up&&>(__u));
 ranges::swap(static_cast<_Tp&&>(__t), static_cast<_Up&&>(__u));
 ranges::swap(static_cast<_Up&&>(__u), static_cast<_Tp&&>(__t));
      };



  template<typename _Tp>
    concept movable = is_object_v<_Tp> && move_constructible<_Tp>
      && assignable_from<_Tp&, _Tp> && swappable<_Tp>;

  template<typename _Tp>
    concept copyable = copy_constructible<_Tp> && movable<_Tp>
      && assignable_from<_Tp&, _Tp&> && assignable_from<_Tp&, const _Tp&>
      && assignable_from<_Tp&, const _Tp>;

  template<typename _Tp>
    concept semiregular = copyable<_Tp> && default_initializable<_Tp>;




  namespace __detail
  {
    template<typename _Tp>
      concept __boolean_testable_impl = convertible_to<_Tp, bool>;

    template<typename _Tp>
      concept __boolean_testable
 = __boolean_testable_impl<_Tp>
   && requires(_Tp&& __t)
   { { !static_cast<_Tp&&>(__t) } -> __boolean_testable_impl; };
  }



  namespace __detail
  {
    template<typename _Tp, typename _Up>
      concept __weakly_eq_cmp_with
 = requires(__detail::__cref<_Tp> __t, __detail::__cref<_Up> __u) {
   { __t == __u } -> __boolean_testable;
   { __t != __u } -> __boolean_testable;
   { __u == __t } -> __boolean_testable;
   { __u != __t } -> __boolean_testable;
 };
  }

  template<typename _Tp>
    concept equality_comparable = __detail::__weakly_eq_cmp_with<_Tp, _Tp>;

  template<typename _Tp, typename _Up>
    concept equality_comparable_with
      = equality_comparable<_Tp> && equality_comparable<_Up>
      && common_reference_with<__detail::__cref<_Tp>, __detail::__cref<_Up>>
      && equality_comparable<common_reference_t<__detail::__cref<_Tp>,
      __detail::__cref<_Up>>>
      && __detail::__weakly_eq_cmp_with<_Tp, _Up>;

  namespace __detail
  {
    template<typename _Tp, typename _Up>
      concept __partially_ordered_with
 = requires(const remove_reference_t<_Tp>& __t,
     const remove_reference_t<_Up>& __u) {
   { __t < __u } -> __boolean_testable;
   { __t > __u } -> __boolean_testable;
   { __t <= __u } -> __boolean_testable;
   { __t >= __u } -> __boolean_testable;
   { __u < __t } -> __boolean_testable;
   { __u > __t } -> __boolean_testable;
   { __u <= __t } -> __boolean_testable;
   { __u >= __t } -> __boolean_testable;
 };
  }


  template<typename _Tp>
    concept totally_ordered
      = equality_comparable<_Tp>
      && __detail::__partially_ordered_with<_Tp, _Tp>;

  template<typename _Tp, typename _Up>
    concept totally_ordered_with
      = totally_ordered<_Tp> && totally_ordered<_Up>
      && equality_comparable_with<_Tp, _Up>
      && totally_ordered<common_reference_t<__detail::__cref<_Tp>,
         __detail::__cref<_Up>>>
      && __detail::__partially_ordered_with<_Tp, _Up>;

  template<typename _Tp>
    concept regular = semiregular<_Tp> && equality_comparable<_Tp>;




  template<typename _Fn, typename... _Args>
    concept invocable = is_invocable_v<_Fn, _Args...>;


  template<typename _Fn, typename... _Args>
    concept regular_invocable = invocable<_Fn, _Args...>;


  template<typename _Fn, typename... _Args>
    concept predicate = regular_invocable<_Fn, _Args...>
      && __detail::__boolean_testable<invoke_result_t<_Fn, _Args...>>;


  template<typename _Rel, typename _Tp, typename _Up>
    concept relation
      = predicate<_Rel, _Tp, _Tp> && predicate<_Rel, _Up, _Up>
      && predicate<_Rel, _Tp, _Up> && predicate<_Rel, _Up, _Tp>;


  template<typename _Rel, typename _Tp, typename _Up>
    concept equivalence_relation = relation<_Rel, _Tp, _Up>;


  template<typename _Rel, typename _Tp, typename _Up>
    concept strict_weak_order = relation<_Rel, _Tp, _Up>;


}
# 41 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/compare" 2 3

namespace std
{


  namespace __cmp_cat
  {
    using type = signed char;

    enum class _Ord : type { equivalent = 0, less = -1, greater = 1 };

    enum class _Ncmp : type { _Unordered = 2 };

    struct __unspec
    {
      consteval __unspec(__unspec*) noexcept { }
    };
  }

  class partial_ordering
  {

    __cmp_cat::type _M_value;

    constexpr explicit
    partial_ordering(__cmp_cat::_Ord __v) noexcept
    : _M_value(__cmp_cat::type(__v))
    { }

    constexpr explicit
    partial_ordering(__cmp_cat::_Ncmp __v) noexcept
    : _M_value(__cmp_cat::type(__v))
    { }

    friend class weak_ordering;
    friend class strong_ordering;

  public:

    static const partial_ordering less;
    static const partial_ordering equivalent;
    static const partial_ordering greater;
    static const partial_ordering unordered;


    [[nodiscard]]
    friend constexpr bool
    operator==(partial_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value == 0; }

    [[nodiscard]]
    friend constexpr bool
    operator==(partial_ordering, partial_ordering) noexcept = default;

    [[nodiscard]]
    friend constexpr bool
    operator< (partial_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value == -1; }

    [[nodiscard]]
    friend constexpr bool
    operator> (partial_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value == 1; }

    [[nodiscard]]
    friend constexpr bool
    operator<=(partial_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value <= 0; }

    [[nodiscard]]
    friend constexpr bool
    operator>=(partial_ordering __v, __cmp_cat::__unspec) noexcept
    { return __cmp_cat::type(__v._M_value & 1) == __v._M_value; }

    [[nodiscard]]
    friend constexpr bool
    operator< (__cmp_cat::__unspec, partial_ordering __v) noexcept
    { return __v._M_value == 1; }

    [[nodiscard]]
    friend constexpr bool
    operator> (__cmp_cat::__unspec, partial_ordering __v) noexcept
    { return __v._M_value == -1; }

    [[nodiscard]]
    friend constexpr bool
    operator<=(__cmp_cat::__unspec, partial_ordering __v) noexcept
    { return __cmp_cat::type(__v._M_value & 1) == __v._M_value; }

    [[nodiscard]]
    friend constexpr bool
    operator>=(__cmp_cat::__unspec, partial_ordering __v) noexcept
    { return 0 >= __v._M_value; }

    [[nodiscard]]
    friend constexpr partial_ordering
    operator<=>(partial_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v; }

    [[nodiscard]]
    friend constexpr partial_ordering
    operator<=>(__cmp_cat::__unspec, partial_ordering __v) noexcept
    {
      if (__v._M_value & 1)
 return partial_ordering(__cmp_cat::_Ord(-__v._M_value));
      else
 return __v;
    }
  };


  inline constexpr partial_ordering
  partial_ordering::less(__cmp_cat::_Ord::less);

  inline constexpr partial_ordering
  partial_ordering::equivalent(__cmp_cat::_Ord::equivalent);

  inline constexpr partial_ordering
  partial_ordering::greater(__cmp_cat::_Ord::greater);

  inline constexpr partial_ordering
  partial_ordering::unordered(__cmp_cat::_Ncmp::_Unordered);

  class weak_ordering
  {
    __cmp_cat::type _M_value;

    constexpr explicit
    weak_ordering(__cmp_cat::_Ord __v) noexcept : _M_value(__cmp_cat::type(__v))
    { }

    friend class strong_ordering;

  public:

    static const weak_ordering less;
    static const weak_ordering equivalent;
    static const weak_ordering greater;

    [[nodiscard]]
    constexpr operator partial_ordering() const noexcept
    { return partial_ordering(__cmp_cat::_Ord(_M_value)); }


    [[nodiscard]]
    friend constexpr bool
    operator==(weak_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value == 0; }

    [[nodiscard]]
    friend constexpr bool
    operator==(weak_ordering, weak_ordering) noexcept = default;

    [[nodiscard]]
    friend constexpr bool
    operator< (weak_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value < 0; }

    [[nodiscard]]
    friend constexpr bool
    operator> (weak_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value > 0; }

    [[nodiscard]]
    friend constexpr bool
    operator<=(weak_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value <= 0; }

    [[nodiscard]]
    friend constexpr bool
    operator>=(weak_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value >= 0; }

    [[nodiscard]]
    friend constexpr bool
    operator< (__cmp_cat::__unspec, weak_ordering __v) noexcept
    { return 0 < __v._M_value; }

    [[nodiscard]]
    friend constexpr bool
    operator> (__cmp_cat::__unspec, weak_ordering __v) noexcept
    { return 0 > __v._M_value; }

    [[nodiscard]]
    friend constexpr bool
    operator<=(__cmp_cat::__unspec, weak_ordering __v) noexcept
    { return 0 <= __v._M_value; }

    [[nodiscard]]
    friend constexpr bool
    operator>=(__cmp_cat::__unspec, weak_ordering __v) noexcept
    { return 0 >= __v._M_value; }

    [[nodiscard]]
    friend constexpr weak_ordering
    operator<=>(weak_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v; }

    [[nodiscard]]
    friend constexpr weak_ordering
    operator<=>(__cmp_cat::__unspec, weak_ordering __v) noexcept
    { return weak_ordering(__cmp_cat::_Ord(-__v._M_value)); }
  };


  inline constexpr weak_ordering
  weak_ordering::less(__cmp_cat::_Ord::less);

  inline constexpr weak_ordering
  weak_ordering::equivalent(__cmp_cat::_Ord::equivalent);

  inline constexpr weak_ordering
  weak_ordering::greater(__cmp_cat::_Ord::greater);

  class strong_ordering
  {
    __cmp_cat::type _M_value;

    constexpr explicit
    strong_ordering(__cmp_cat::_Ord __v) noexcept
    : _M_value(__cmp_cat::type(__v))
    { }

  public:

    static const strong_ordering less;
    static const strong_ordering equal;
    static const strong_ordering equivalent;
    static const strong_ordering greater;

    [[nodiscard]]
    constexpr operator partial_ordering() const noexcept
    { return partial_ordering(__cmp_cat::_Ord(_M_value)); }

    [[nodiscard]]
    constexpr operator weak_ordering() const noexcept
    { return weak_ordering(__cmp_cat::_Ord(_M_value)); }


    [[nodiscard]]
    friend constexpr bool
    operator==(strong_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value == 0; }

    [[nodiscard]]
    friend constexpr bool
    operator==(strong_ordering, strong_ordering) noexcept = default;

    [[nodiscard]]
    friend constexpr bool
    operator< (strong_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value < 0; }

    [[nodiscard]]
    friend constexpr bool
    operator> (strong_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value > 0; }

    [[nodiscard]]
    friend constexpr bool
    operator<=(strong_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value <= 0; }

    [[nodiscard]]
    friend constexpr bool
    operator>=(strong_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value >= 0; }

    [[nodiscard]]
    friend constexpr bool
    operator< (__cmp_cat::__unspec, strong_ordering __v) noexcept
    { return 0 < __v._M_value; }

    [[nodiscard]]
    friend constexpr bool
    operator> (__cmp_cat::__unspec, strong_ordering __v) noexcept
    { return 0 > __v._M_value; }

    [[nodiscard]]
    friend constexpr bool
    operator<=(__cmp_cat::__unspec, strong_ordering __v) noexcept
    { return 0 <= __v._M_value; }

    [[nodiscard]]
    friend constexpr bool
    operator>=(__cmp_cat::__unspec, strong_ordering __v) noexcept
    { return 0 >= __v._M_value; }

    [[nodiscard]]
    friend constexpr strong_ordering
    operator<=>(strong_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v; }

    [[nodiscard]]
    friend constexpr strong_ordering
    operator<=>(__cmp_cat::__unspec, strong_ordering __v) noexcept
    { return strong_ordering(__cmp_cat::_Ord(-__v._M_value)); }
  };


  inline constexpr strong_ordering
  strong_ordering::less(__cmp_cat::_Ord::less);

  inline constexpr strong_ordering
  strong_ordering::equal(__cmp_cat::_Ord::equivalent);

  inline constexpr strong_ordering
  strong_ordering::equivalent(__cmp_cat::_Ord::equivalent);

  inline constexpr strong_ordering
  strong_ordering::greater(__cmp_cat::_Ord::greater);



  [[nodiscard]]
  constexpr bool
  is_eq(partial_ordering __cmp) noexcept
  { return __cmp == 0; }

  [[nodiscard]]
  constexpr bool
  is_neq(partial_ordering __cmp) noexcept
  { return __cmp != 0; }

  [[nodiscard]]
  constexpr bool
  is_lt (partial_ordering __cmp) noexcept
  { return __cmp < 0; }

  [[nodiscard]]
  constexpr bool
  is_lteq(partial_ordering __cmp) noexcept
  { return __cmp <= 0; }

  [[nodiscard]]
  constexpr bool
  is_gt (partial_ordering __cmp) noexcept
  { return __cmp > 0; }

  [[nodiscard]]
  constexpr bool
  is_gteq(partial_ordering __cmp) noexcept
  { return __cmp >= 0; }

  namespace __detail
  {
    template<typename _Tp>
      inline constexpr unsigned __cmp_cat_id = 1;
    template<>
      inline constexpr unsigned __cmp_cat_id<partial_ordering> = 2;
    template<>
      inline constexpr unsigned __cmp_cat_id<weak_ordering> = 4;
    template<>
      inline constexpr unsigned __cmp_cat_id<strong_ordering> = 8;

    template<typename... _Ts>
      constexpr auto __common_cmp_cat()
      {
 constexpr unsigned __cats = (__cmp_cat_id<_Ts> | ...);

 if constexpr (__cats & 1)
   return;


 else if constexpr (bool(__cats & __cmp_cat_id<partial_ordering>))
   return partial_ordering::equivalent;


 else if constexpr (bool(__cats & __cmp_cat_id<weak_ordering>))
   return weak_ordering::equivalent;

 else
   return strong_ordering::equivalent;
      }
  }


  template<typename... _Ts>
    struct common_comparison_category
    {
      using type = decltype(__detail::__common_cmp_cat<_Ts...>());
    };



  template<typename _Tp>
    struct common_comparison_category<_Tp>
    { using type = void; };

  template<>
    struct common_comparison_category<partial_ordering>
    { using type = partial_ordering; };

  template<>
    struct common_comparison_category<weak_ordering>
    { using type = weak_ordering; };

  template<>
    struct common_comparison_category<strong_ordering>
    { using type = strong_ordering; };

  template<>
    struct common_comparison_category<>
    { using type = strong_ordering; };

  template<typename... _Ts>
    using common_comparison_category_t
      = typename common_comparison_category<_Ts...>::type;



  namespace __detail
  {
    template<typename _Tp, typename _Cat>
      concept __compares_as
 = same_as<common_comparison_category_t<_Tp, _Cat>, _Cat>;
  }


  template<typename _Tp, typename _Cat = partial_ordering>
    concept three_way_comparable
      = __detail::__weakly_eq_cmp_with<_Tp, _Tp>
      && __detail::__partially_ordered_with<_Tp, _Tp>
      && requires(const remove_reference_t<_Tp>& __a,
    const remove_reference_t<_Tp>& __b)
      {
 { __a <=> __b } -> __detail::__compares_as<_Cat>;
      };

  template<typename _Tp, typename _Up, typename _Cat = partial_ordering>
    concept three_way_comparable_with
      = three_way_comparable<_Tp, _Cat>
      && three_way_comparable<_Up, _Cat>
      && common_reference_with<const remove_reference_t<_Tp>&,
          const remove_reference_t<_Up>&>
      && three_way_comparable<
   common_reference_t<const remove_reference_t<_Tp>&,
        const remove_reference_t<_Up>&>, _Cat>
      && __detail::__weakly_eq_cmp_with<_Tp, _Up>
      && __detail::__partially_ordered_with<_Tp, _Up>
      && requires(const remove_reference_t<_Tp>& __t,
    const remove_reference_t<_Up>& __u)
      {
 { __t <=> __u } -> __detail::__compares_as<_Cat>;
 { __u <=> __t } -> __detail::__compares_as<_Cat>;
      };

  namespace __detail
  {
    template<typename _Tp, typename _Up>
      using __cmp3way_res_t
 = decltype(std::declval<_Tp>() <=> std::declval<_Up>());






    template<typename _Tp, typename _Up>
      struct __cmp3way_res_impl
      { };

    template<typename _Tp, typename _Up>
      requires requires { typename __cmp3way_res_t<__cref<_Tp>, __cref<_Up>>; }
      struct __cmp3way_res_impl<_Tp, _Up>
      {
 using type = __cmp3way_res_t<__cref<_Tp>, __cref<_Up>>;
      };
  }


  template<typename _Tp, typename _Up = _Tp>
    struct compare_three_way_result
    : __detail::__cmp3way_res_impl<_Tp, _Up>
    { };


  template<typename _Tp, typename _Up = _Tp>
    using compare_three_way_result_t
      = typename __detail::__cmp3way_res_impl<_Tp, _Up>::type;

  namespace __detail
  {




    template<typename _Tp, typename _Up>
      concept __3way_builtin_ptr_cmp
 = requires(_Tp&& __t, _Up&& __u)
   { static_cast<_Tp&&>(__t) <=> static_cast<_Up&&>(__u); }
   && convertible_to<_Tp, const volatile void*>
   && convertible_to<_Up, const volatile void*>
   && ! requires(_Tp&& __t, _Up&& __u)
   { operator<=>(static_cast<_Tp&&>(__t), static_cast<_Up&&>(__u)); }
   && ! requires(_Tp&& __t, _Up&& __u)
   { static_cast<_Tp&&>(__t).operator<=>(static_cast<_Up&&>(__u)); };
  }





  struct compare_three_way
  {
    template<typename _Tp, typename _Up>
      requires three_way_comparable_with<_Tp, _Up>
      constexpr auto
      operator() [[nodiscard]] (_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(std::declval<_Tp>() <=> std::declval<_Up>()))
      {
 if constexpr (__detail::__3way_builtin_ptr_cmp<_Tp, _Up>)
   {
     auto __pt = static_cast<const volatile void*>(__t);
     auto __pu = static_cast<const volatile void*>(__u);
     if (std::__is_constant_evaluated())
       return __pt <=> __pu;
     auto __it = reinterpret_cast<long long unsigned int>(__pt);
     auto __iu = reinterpret_cast<long long unsigned int>(__pu);
     return __it <=> __iu;
   }
 else
   return static_cast<_Tp&&>(__t) <=> static_cast<_Up&&>(__u);
      }

    using is_transparent = void;
  };



  namespace __compare
  {
    template<floating_point _Tp>
      constexpr weak_ordering
      __fp_weak_ordering(_Tp __e, _Tp __f)
      {


 auto __cat = [](_Tp __fp) -> int {
   const int __sign = __builtin_signbit(__fp) ? -1 : 1;
   if (__builtin_isnormal(__fp))
     return (__fp == 0 ? 1 : 3) * __sign;
   if (__builtin_isnan(__fp))
     return 5 * __sign;
   if (int __inf = __builtin_isinf_sign(__fp))
     return 4 * __inf;
   return 2 * __sign;
 };

 auto __po = __e <=> __f;
 if (is_lt(__po))
   return weak_ordering::less;
 else if (is_gt(__po))
   return weak_ordering::greater;
 else if (__po == partial_ordering::equivalent)
   return weak_ordering::equivalent;
 else
   {

     auto __isnan_sign = [](_Tp __fp) -> int {
       return __builtin_isnan(__fp)
  ? __builtin_signbit(__fp) ? -1 : 1
  : 0;
     };
     auto __ord = __isnan_sign(__e) <=> __isnan_sign(__f);
     if (is_eq(__ord))
       return weak_ordering::equivalent;
     else if (is_lt(__ord))
       return weak_ordering::less;
     else
       return weak_ordering::greater;
   }
      }

    void strong_order() = delete;

    template<typename _Tp, typename _Up>
      concept __adl_strong = requires(_Tp&& __t, _Up&& __u)
 {
   strong_ordering(strong_order(static_cast<_Tp&&>(__t),
           static_cast<_Up&&>(__u)));
 };

    void weak_order() = delete;

    template<typename _Tp, typename _Up>
      concept __adl_weak = requires(_Tp&& __t, _Up&& __u)
 {
   weak_ordering(weak_order(static_cast<_Tp&&>(__t),
       static_cast<_Up&&>(__u)));
 };

    void partial_order() = delete;

    template<typename _Tp, typename _Up>
      concept __adl_partial = requires(_Tp&& __t, _Up&& __u)
 {
   partial_ordering(partial_order(static_cast<_Tp&&>(__t),
      static_cast<_Up&&>(__u)));
 };

    template<typename _Ord, typename _Tp, typename _Up>
      concept __cmp3way = requires(_Tp&& __t, _Up&& __u, compare_three_way __c)
 {
   _Ord(__c(static_cast<_Tp&&>(__t), static_cast<_Up&&>(__u)));
 };

    template<typename _Tp, typename _Up>
      concept __strongly_ordered
 = __adl_strong<_Tp, _Up>
   || floating_point<remove_reference_t<_Tp>>
   || __cmp3way<strong_ordering, _Tp, _Up>;

    template<typename _Tp, typename _Up>
      concept __decayed_same_as = same_as<decay_t<_Tp>, decay_t<_Up>>;

    class _Strong_order
    {
      template<typename _Tp, typename _Up>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (floating_point<decay_t<_Tp>>)
     return true;
   else if constexpr (__adl_strong<_Tp, _Up>)
     return noexcept(strong_ordering(strong_order(std::declval<_Tp>(),
        std::declval<_Up>())));
   else if constexpr (__cmp3way<strong_ordering, _Tp, _Up>)
     return noexcept(compare_three_way()(std::declval<_Tp>(),
      std::declval<_Up>()));
 }

      friend class _Weak_order;
      friend class _Strong_fallback;


      enum class _Fp_fmt
      {
 _Binary16, _Binary32, _Binary64, _Binary128,
 _X86_80bit,
 _M68k_80bit,
 _Dbldbl,
 _Bfloat16,
      };
# 699 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/compare" 3
      template<typename _Tp>
 static consteval _Fp_fmt
 _S_fp_fmt() noexcept
 {

   using enum _Fp_fmt;
# 719 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/compare" 3
   if constexpr (__is_same(_Tp, long double))
     return (-16381) == -16381 ? _X86_80bit : _M68k_80bit;


   if constexpr (__is_same(_Tp, __float80))
     return _X86_80bit;


   if constexpr (__is_same(_Tp, decltype(0.0bf16)))
     return _Bfloat16;


   constexpr int __width = sizeof(_Tp) * 8;

   if constexpr (__width == 16)
     return _Binary16;
   else if constexpr (__width == 32)
     return _Binary32;
   else if constexpr (__width == 64)
     return _Binary64;
   else if constexpr (__width == 128)
     return _Binary128;
 }


      using int64_t = long long int;
      using int32_t = int;
      using int16_t = short int;
      using uint64_t = long long unsigned int;
      using uint16_t = short unsigned int;


      template<typename _Tp>
 struct _Int
 {

   uint64_t _M_lo;
   _Tp _M_hi;





   constexpr explicit
   _Int(_Tp __hi, uint64_t __lo) noexcept : _M_hi(__hi)
   { _M_lo = __lo; }

   constexpr explicit
   _Int(uint64_t __lo) noexcept : _M_hi(0)
   { _M_lo = __lo; }

   constexpr bool operator==(const _Int&) const = default;
# 781 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/compare" 3
   constexpr _Int&
   operator^=(const _Int& __rhs) noexcept
   {
     _M_hi ^= __rhs._M_hi;
     _M_lo ^= __rhs._M_lo;
     return *this;
   }

   constexpr strong_ordering
   operator<=>(const _Int& __rhs) const noexcept
   {
     strong_ordering __cmp = _M_hi <=> __rhs._M_hi;
     if (__cmp != strong_ordering::equal)
       return __cmp;
     return _M_lo <=> __rhs._M_lo;
   }
 };

      template<typename _Tp>
 static constexpr _Tp
 _S_compl(_Tp __t) noexcept
 {
   constexpr int __width = sizeof(_Tp) * 8;

   make_unsigned_t<_Tp> __sign = __t >> (__width - 1);


   return __t ^ (__sign >> 1);
 }


      template<typename _Tp>
 static constexpr _Int<_Tp>
 _S_compl(_Int<_Tp> __t) noexcept
 {
   constexpr int __width = sizeof(_Tp) * 8;
   make_unsigned_t<_Tp> __sign = __t._M_hi >> (__width - 1);
   __t._M_hi ^= (__sign >> 1 );
   uint64_t __sign64 = (_Tp)__sign;
   __t._M_lo ^= __sign64;
   return __t;
 }


      template<typename _Tp>
 constexpr static auto
 _S_fp_bits(_Tp __val) noexcept
 {
   if constexpr (sizeof(_Tp) == sizeof(int64_t))
     return __builtin_bit_cast(int64_t, __val);
   else if constexpr (sizeof(_Tp) == sizeof(int32_t))
     return __builtin_bit_cast(int32_t, __val);
   else if constexpr (sizeof(_Tp) == sizeof(int16_t))
     return __builtin_bit_cast(int16_t, __val);
   else
     {

       using enum _Fp_fmt;

       constexpr auto __fmt = _S_fp_fmt<_Tp>();
       if constexpr (__fmt == _X86_80bit || __fmt == _M68k_80bit)
  {
    if constexpr (sizeof(_Tp) == 3 * sizeof(int32_t))
      {
        auto __ival = __builtin_bit_cast(_Int<int32_t>, __val);
        return _Int<int16_t>(__ival._M_hi, __ival._M_lo);
      }
    else
      {
        auto __ival = __builtin_bit_cast(_Int<int64_t>, __val);
        return _Int<int16_t>(__ival._M_hi, __ival._M_lo);
      }
  }
       else if constexpr (sizeof(_Tp) == 2 * sizeof(int64_t))
  {

    return __builtin_bit_cast(__int128, __val);



  }
       else
  static_assert(sizeof(_Tp) == sizeof(int64_t),
         "unsupported floating-point type");
     }
 }

      template<typename _Tp>
 static constexpr strong_ordering
 _S_fp_cmp(_Tp __x, _Tp __y) noexcept
 {
# 885 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/compare" 3
   auto __ix = _S_fp_bits(__x);
   auto __iy = _S_fp_bits(__y);

   if (__ix == __iy)
     return strong_ordering::equal;


   using enum _Fp_fmt;

   constexpr auto __fmt = _S_fp_fmt<_Tp>();

   if constexpr (__fmt == _Dbldbl)
     {


       struct _Unpacked { double _M_hi; int64_t _M_lo; };
       auto __x2 = __builtin_bit_cast(_Unpacked, __x);
       auto __y2 = __builtin_bit_cast(_Unpacked, __y);


       auto __cmp = _S_fp_cmp(__x2._M_hi, __y2._M_hi);
       if (__cmp != strong_ordering::equal)
  return __cmp;



       if (__builtin_isnan(__x2._M_hi))
  return strong_ordering::equal;


       if (((__x2._M_lo | __y2._M_lo) & 0x7fffffffffffffffULL) == 0)
  return strong_ordering::equal;


       return _S_compl(__x2._M_lo) <=> _S_compl(__y2._M_lo);
     }
   else
     {
       if constexpr (__fmt == _M68k_80bit)
  {



    constexpr uint16_t __maxexp = 0x7fff;
    if ((__ix._M_hi & __maxexp) == __maxexp)
      __ix._M_lo |= 1ull << 63;
    if ((__iy._M_hi & __maxexp) == __maxexp)
      __iy._M_lo |= 1ull << 63;
  }
       else
  {
# 952 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/compare" 3
  }
       return _S_compl(__ix) <=> _S_compl(__iy);
     }
 }

    public:
      template<typename _Tp, __decayed_same_as<_Tp> _Up>
 requires __strongly_ordered<_Tp, _Up>
 constexpr strong_ordering
 operator() [[nodiscard]] (_Tp&& __e, _Up&& __f) const
 noexcept(_S_noexcept<_Tp, _Up>())
 {
   if constexpr (floating_point<decay_t<_Tp>>)
     return _S_fp_cmp(__e, __f);
   else if constexpr (__adl_strong<_Tp, _Up>)
     return strong_ordering(strong_order(static_cast<_Tp&&>(__e),
      static_cast<_Up&&>(__f)));
   else if constexpr (__cmp3way<strong_ordering, _Tp, _Up>)
     return compare_three_way()(static_cast<_Tp&&>(__e),
           static_cast<_Up&&>(__f));
 }
    };

    template<typename _Tp, typename _Up>
      concept __weakly_ordered
 = floating_point<remove_reference_t<_Tp>>
   || __adl_weak<_Tp, _Up>
   || __cmp3way<weak_ordering, _Tp, _Up>
   || __strongly_ordered<_Tp, _Up>;

    class _Weak_order
    {
      template<typename _Tp, typename _Up>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (floating_point<decay_t<_Tp>>)
     return true;
   else if constexpr (__adl_weak<_Tp, _Up>)
     return noexcept(weak_ordering(weak_order(std::declval<_Tp>(),
           std::declval<_Up>())));
   else if constexpr (__cmp3way<weak_ordering, _Tp, _Up>)
     return noexcept(compare_three_way()(std::declval<_Tp>(),
      std::declval<_Up>()));
   else if constexpr (__strongly_ordered<_Tp, _Up>)
     return _Strong_order::_S_noexcept<_Tp, _Up>();
 }

      friend class _Partial_order;
      friend class _Weak_fallback;

    public:
      template<typename _Tp, __decayed_same_as<_Tp> _Up>
 requires __weakly_ordered<_Tp, _Up>
 constexpr weak_ordering
 operator() [[nodiscard]] (_Tp&& __e, _Up&& __f) const
 noexcept(_S_noexcept<_Tp, _Up>())
 {
   if constexpr (floating_point<decay_t<_Tp>>)
     return __compare::__fp_weak_ordering(__e, __f);
   else if constexpr (__adl_weak<_Tp, _Up>)
     return weak_ordering(weak_order(static_cast<_Tp&&>(__e),
         static_cast<_Up&&>(__f)));
   else if constexpr (__cmp3way<weak_ordering, _Tp, _Up>)
     return compare_three_way()(static_cast<_Tp&&>(__e),
           static_cast<_Up&&>(__f));
   else if constexpr (__strongly_ordered<_Tp, _Up>)
     return _Strong_order{}(static_cast<_Tp&&>(__e),
       static_cast<_Up&&>(__f));
 }
    };

    template<typename _Tp, typename _Up>
      concept __partially_ordered
 = __adl_partial<_Tp, _Up>
 || __cmp3way<partial_ordering, _Tp, _Up>
 || __weakly_ordered<_Tp, _Up>;

    class _Partial_order
    {
      template<typename _Tp, typename _Up>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__adl_partial<_Tp, _Up>)
     return noexcept(partial_ordering(partial_order(std::declval<_Tp>(),
        std::declval<_Up>())));
   else if constexpr (__cmp3way<partial_ordering, _Tp, _Up>)
     return noexcept(compare_three_way()(std::declval<_Tp>(),
      std::declval<_Up>()));
   else if constexpr (__weakly_ordered<_Tp, _Up>)
     return _Weak_order::_S_noexcept<_Tp, _Up>();
 }

      friend class _Partial_fallback;

    public:
      template<typename _Tp, __decayed_same_as<_Tp> _Up>
 requires __partially_ordered<_Tp, _Up>
 constexpr partial_ordering
 operator() [[nodiscard]] (_Tp&& __e, _Up&& __f) const
 noexcept(_S_noexcept<_Tp, _Up>())
 {
   if constexpr (__adl_partial<_Tp, _Up>)
     return partial_ordering(partial_order(static_cast<_Tp&&>(__e),
        static_cast<_Up&&>(__f)));
   else if constexpr (__cmp3way<partial_ordering, _Tp, _Up>)
     return compare_three_way()(static_cast<_Tp&&>(__e),
           static_cast<_Up&&>(__f));
   else if constexpr (__weakly_ordered<_Tp, _Up>)
     return _Weak_order{}(static_cast<_Tp&&>(__e),
     static_cast<_Up&&>(__f));
 }
    };

    template<typename _Tp, typename _Up>
      concept __op_eq_lt = requires(_Tp&& __t, _Up&& __u)
 {
   { static_cast<_Tp&&>(__t) == static_cast<_Up&&>(__u) }
     -> convertible_to<bool>;
   { static_cast<_Tp&&>(__t) < static_cast<_Up&&>(__u) }
     -> convertible_to<bool>;
 };

    class _Strong_fallback
    {
      template<typename _Tp, typename _Up>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__strongly_ordered<_Tp, _Up>)
     return _Strong_order::_S_noexcept<_Tp, _Up>();
   else
     return noexcept(bool(std::declval<_Tp>() == std::declval<_Up>()))
       && noexcept(bool(std::declval<_Tp>() < std::declval<_Up>()));
 }

    public:
      template<typename _Tp, __decayed_same_as<_Tp> _Up>
 requires __strongly_ordered<_Tp, _Up> || __op_eq_lt<_Tp, _Up>
 constexpr strong_ordering
 operator() [[nodiscard]] (_Tp&& __e, _Up&& __f) const
 noexcept(_S_noexcept<_Tp, _Up>())
 {
   if constexpr (__strongly_ordered<_Tp, _Up>)
     return _Strong_order{}(static_cast<_Tp&&>(__e),
       static_cast<_Up&&>(__f));
   else
     return static_cast<_Tp&&>(__e) == static_cast<_Up&&>(__f)
       ? strong_ordering::equal
       : static_cast<_Tp&&>(__e) < static_cast<_Up&&>(__f)
       ? strong_ordering::less
       : strong_ordering::greater;
 }
    };

    class _Weak_fallback
    {
      template<typename _Tp, typename _Up>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__weakly_ordered<_Tp, _Up>)
     return _Weak_order::_S_noexcept<_Tp, _Up>();
   else
     return noexcept(bool(std::declval<_Tp>() == std::declval<_Up>()))
       && noexcept(bool(std::declval<_Tp>() < std::declval<_Up>()));
 }

    public:
      template<typename _Tp, __decayed_same_as<_Tp> _Up>
 requires __weakly_ordered<_Tp, _Up> || __op_eq_lt<_Tp, _Up>
 constexpr weak_ordering
 operator() [[nodiscard]] (_Tp&& __e, _Up&& __f) const
 noexcept(_S_noexcept<_Tp, _Up>())
 {
   if constexpr (__weakly_ordered<_Tp, _Up>)
     return _Weak_order{}(static_cast<_Tp&&>(__e),
     static_cast<_Up&&>(__f));
   else
     return static_cast<_Tp&&>(__e) == static_cast<_Up&&>(__f)
       ? weak_ordering::equivalent
       : static_cast<_Tp&&>(__e) < static_cast<_Up&&>(__f)
       ? weak_ordering::less
       : weak_ordering::greater;
 }
    };



    template<typename _Tp, typename _Up>
      concept __op_eq_lt_lt = __op_eq_lt<_Tp, _Up>
 && requires(_Tp&& __t, _Up&& __u)
 {
   { static_cast<_Up&&>(__u) < static_cast<_Tp&&>(__t) }
     -> convertible_to<bool>;
 };

    class _Partial_fallback
    {
      template<typename _Tp, typename _Up>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__partially_ordered<_Tp, _Up>)
     return _Partial_order::_S_noexcept<_Tp, _Up>();
   else
     return noexcept(bool(std::declval<_Tp>() == std::declval<_Up>()))
       && noexcept(bool(std::declval<_Tp>() < std::declval<_Up>()));
 }

    public:
      template<typename _Tp, __decayed_same_as<_Tp> _Up>
 requires __partially_ordered<_Tp, _Up> || __op_eq_lt_lt<_Tp, _Up>
 constexpr partial_ordering
 operator() [[nodiscard]] (_Tp&& __e, _Up&& __f) const
 noexcept(_S_noexcept<_Tp, _Up>())
 {
   if constexpr (__partially_ordered<_Tp, _Up>)
     return _Partial_order{}(static_cast<_Tp&&>(__e),
        static_cast<_Up&&>(__f));
   else
     return static_cast<_Tp&&>(__e) == static_cast<_Up&&>(__f)
       ? partial_ordering::equivalent
       : static_cast<_Tp&&>(__e) < static_cast<_Up&&>(__f)
       ? partial_ordering::less
       : static_cast<_Up&&>(__f) < static_cast<_Tp&&>(__e)
       ? partial_ordering::greater
       : partial_ordering::unordered;
 }
    };
  }



  inline namespace _Cpo
  {
    inline constexpr __compare::_Strong_order strong_order{};

    inline constexpr __compare::_Weak_order weak_order{};

    inline constexpr __compare::_Partial_order partial_order{};

    inline constexpr __compare::_Strong_fallback
      compare_strong_order_fallback{};

    inline constexpr __compare::_Weak_fallback
      compare_weak_order_fallback{};

    inline constexpr __compare::_Partial_fallback
      compare_partial_order_fallback{};
  }


  namespace __detail
  {

    inline constexpr struct _Synth3way
    {
      template<typename _Tp, typename _Up>
 static constexpr bool
 _S_noexcept(const _Tp* __t = nullptr, const _Up* __u = nullptr)
 {
   if constexpr (three_way_comparable_with<_Tp, _Up>)
     return noexcept(*__t <=> *__u);
   else
     return noexcept(*__t < *__u) && noexcept(*__u < *__t);
 }

      template<typename _Tp, typename _Up>
 [[nodiscard]]
 constexpr auto
 operator()(const _Tp& __t, const _Up& __u) const
 noexcept(_S_noexcept<_Tp, _Up>())
 requires requires
 {
   { __t < __u } -> __boolean_testable;
   { __u < __t } -> __boolean_testable;
 }
 {
   if constexpr (three_way_comparable_with<_Tp, _Up>)
     return __t <=> __u;
   else
     {
       if (__t < __u)
  return weak_ordering::less;
       else if (__u < __t)
  return weak_ordering::greater;
       else
  return weak_ordering::equivalent;
     }
 }
    } __synth3way = {};


    template<typename _Tp, typename _Up = _Tp>
      using __synth3way_t
 = decltype(__detail::__synth3way(std::declval<_Tp&>(),
      std::declval<_Up&>()));
  }


}
# 66 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_pair.h" 2 3


namespace std
{

# 79 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_pair.h" 3
  struct piecewise_construct_t { explicit piecewise_construct_t() = default; };


  inline constexpr piecewise_construct_t piecewise_construct =
    piecewise_construct_t();




  template<typename _T1, typename _T2>
    struct pair;

  template<typename...>
    class tuple;





  template<typename _Tp, size_t _Nm>
    struct array;

  template<size_t...>
    struct _Index_tuple;

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&
    get(pair<_Tp1, _Tp2>& __in) noexcept;

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&&
    get(pair<_Tp1, _Tp2>&& __in) noexcept;

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&
    get(const pair<_Tp1, _Tp2>& __in) noexcept;

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&&
    get(const pair<_Tp1, _Tp2>&& __in) noexcept;

  template<size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&
    get(tuple<_Elements...>& __t) noexcept;

  template<size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&
    get(const tuple<_Elements...>& __t) noexcept;

  template<size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&&
    get(tuple<_Elements...>&& __t) noexcept;

  template<size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&&
    get(const tuple<_Elements...>&& __t) noexcept;

  template<size_t _Int, typename _Tp, size_t _Nm>
    constexpr _Tp&
    get(array<_Tp, _Nm>&) noexcept;

  template<size_t _Int, typename _Tp, size_t _Nm>
    constexpr _Tp&&
    get(array<_Tp, _Nm>&&) noexcept;

  template<size_t _Int, typename _Tp, size_t _Nm>
    constexpr const _Tp&
    get(const array<_Tp, _Nm>&) noexcept;

  template<size_t _Int, typename _Tp, size_t _Nm>
    constexpr const _Tp&&
    get(const array<_Tp, _Nm>&&) noexcept;
# 221 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_pair.h" 3
  template<typename _Tp>
    inline constexpr bool __is_tuple_v = false;

  template<typename... _Ts>
    inline constexpr bool __is_tuple_v<tuple<_Ts...>> = true;


  template<typename _Tp>
    inline constexpr bool __is_tuple_like_v = false;

  template<typename... _Elements>
    inline constexpr bool __is_tuple_like_v<tuple<_Elements...>> = true;

  template<typename _T1, typename _T2>
    inline constexpr bool __is_tuple_like_v<pair<_T1, _T2>> = true;

  template<typename _Tp, size_t _Nm>
    inline constexpr bool __is_tuple_like_v<array<_Tp, _Nm>> = true;



  template<typename _Tp>
    concept __tuple_like = __is_tuple_like_v<remove_cvref_t<_Tp>>;

  template<typename _Tp>
    concept __pair_like = __tuple_like<_Tp> && tuple_size_v<remove_cvref_t<_Tp>> == 2;

  template<typename _Tp, typename _Tuple>
    concept __eligible_tuple_like
      = __detail::__different_from<_Tp, _Tuple> && __tuple_like<_Tp>
 && (tuple_size_v<remove_cvref_t<_Tp>> == tuple_size_v<_Tuple>)
 && !ranges::__detail::__is_subrange<remove_cvref_t<_Tp>>;

  template<typename _Tp, typename _Pair>
    concept __eligible_pair_like
      = __detail::__different_from<_Tp, _Pair> && __pair_like<_Tp>
 && !ranges::__detail::__is_subrange<remove_cvref_t<_Tp>>;


  template<typename _U1, typename _U2> class __pair_base
  {







  };
# 283 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    struct pair
    : public __pair_base<_T1, _T2>
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;


      constexpr pair(const pair&) = default;
      constexpr pair(pair&&) = default;

      template<typename... _Args1, typename... _Args2>
 constexpr
 pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);


      constexpr void
      swap(pair& __p)
      noexcept(__and_<__is_nothrow_swappable<_T1>,
        __is_nothrow_swappable<_T2>>::value)
      {
 using std::swap;
 swap(first, __p.first);
 swap(second, __p.second);
      }
# 319 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_pair.h" 3
      constexpr void
      swap(const pair& __p) const
      noexcept(__and_v<__is_nothrow_swappable<const _T1>,
         __is_nothrow_swappable<const _T2>>)
      requires is_swappable_v<const _T1> && is_swappable_v<const _T2>
      {
 using std::swap;
 swap(first, __p.first);
 swap(second, __p.second);
      }


    private:
      template<typename... _Args1, size_t... _Indexes1,
        typename... _Args2, size_t... _Indexes2>
 constexpr
 pair(tuple<_Args1...>&, tuple<_Args2...>&,
      _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);
    public:





      constexpr
      explicit(__not_<__and_<__is_implicitly_default_constructible<_T1>,
        __is_implicitly_default_constructible<_T2>>>())
      pair()
      requires is_default_constructible_v<_T1>
        && is_default_constructible_v<_T2>
      : first(), second()
      { }

    private:


      template<typename _U1, typename _U2>
 static constexpr bool
 _S_constructible()
 {
   if constexpr (is_constructible_v<_T1, _U1>)
     return is_constructible_v<_T2, _U2>;
   return false;
 }

      template<typename _U1, typename _U2>
 static constexpr bool
 _S_nothrow_constructible()
 {
   if constexpr (is_nothrow_constructible_v<_T1, _U1>)
     return is_nothrow_constructible_v<_T2, _U2>;
   return false;
 }

      template<typename _U1, typename _U2>
 static constexpr bool
 _S_convertible()
 {
   if constexpr (is_convertible_v<_U1, _T1>)
     return is_convertible_v<_U2, _T2>;
   return false;
 }


      template<typename _U1, typename _U2>
 static constexpr bool
 _S_dangles()
 {

   if constexpr (__reference_constructs_from_temporary(_T1, _U1&&))
     return true;
   else
     return __reference_constructs_from_temporary(_T2, _U2&&);



 }


      template<typename _UPair>
 static constexpr bool
 _S_constructible_from_pair_like()
 {
   return _S_constructible<decltype(std::get<0>(std::declval<_UPair>())),
      decltype(std::get<1>(std::declval<_UPair>()))>();
 }

      template<typename _UPair>
 static constexpr bool
 _S_convertible_from_pair_like()
 {
   return _S_convertible<decltype(std::get<0>(std::declval<_UPair>())),
    decltype(std::get<1>(std::declval<_UPair>()))>();
 }

      template<typename _UPair>
 static constexpr bool
 _S_dangles_from_pair_like()
 {
   return _S_dangles<decltype(std::get<0>(std::declval<_UPair>())),
       decltype(std::get<1>(std::declval<_UPair>()))>();
 }



    public:


      constexpr explicit(!_S_convertible<const _T1&, const _T2&>())
      pair(const _T1& __x, const _T2& __y)
      noexcept(_S_nothrow_constructible<const _T1&, const _T2&>())
      requires (_S_constructible<const _T1&, const _T2&>())
      : first(__x), second(__y)
      { }



      template<typename _U1 = _T1, typename _U2 = _T2>



 requires (_S_constructible<_U1, _U2>()) && (!_S_dangles<_U1, _U2>())
 constexpr explicit(!_S_convertible<_U1, _U2>())
 pair(_U1&& __x, _U2&& __y)
 noexcept(_S_nothrow_constructible<_U1, _U2>())
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y))
 { }


      template<typename _U1 = _T1, typename _U2 = _T2>



 requires (_S_constructible<_U1, _U2>()) && (_S_dangles<_U1, _U2>())
 constexpr explicit(!_S_convertible<_U1, _U2>())
 pair(_U1&&, _U2&&) = delete;


      template<typename _U1, typename _U2>
 requires (_S_constructible<const _U1&, const _U2&>())
   && (!_S_dangles<_U1, _U2>())
 constexpr explicit(!_S_convertible<const _U1&, const _U2&>())
 pair(const pair<_U1, _U2>& __p)
 noexcept(_S_nothrow_constructible<const _U1&, const _U2&>())
 : first(__p.first), second(__p.second)
 { }

      template<typename _U1, typename _U2>
 requires (_S_constructible<const _U1&, const _U2&>())
       && (_S_dangles<const _U1&, const _U2&>())
 constexpr explicit(!_S_convertible<const _U1&, const _U2&>())
 pair(const pair<_U1, _U2>&) = delete;


      template<typename _U1, typename _U2>
 requires (_S_constructible<_U1, _U2>()) && (!_S_dangles<_U1, _U2>())
 constexpr explicit(!_S_convertible<_U1, _U2>())
 pair(pair<_U1, _U2>&& __p)
 noexcept(_S_nothrow_constructible<_U1, _U2>())
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second))
 { }

      template<typename _U1, typename _U2>
 requires (_S_constructible<_U1, _U2>()) && (_S_dangles<_U1, _U2>())
 constexpr explicit(!_S_convertible<_U1, _U2>())
 pair(pair<_U1, _U2>&&) = delete;



      template<typename _U1, typename _U2>
 requires (_S_constructible<_U1&, _U2&>()) && (!_S_dangles<_U1&, _U2&>())
 constexpr explicit(!_S_convertible<_U1&, _U2&>())
 pair(pair<_U1, _U2>& __p)
 noexcept(_S_nothrow_constructible<_U1&, _U2&>())
 : first(__p.first), second(__p.second)
 { }

      template<typename _U1, typename _U2>
 requires (_S_constructible<_U1&, _U2&>()) && (_S_dangles<_U1&, _U2&>())
 constexpr explicit(!_S_convertible<_U1&, _U2&>())
 pair(pair<_U1, _U2>&) = delete;


      template<typename _U1, typename _U2>
 requires (_S_constructible<const _U1, const _U2>())
   && (!_S_dangles<const _U1, const _U2>())
 constexpr explicit(!_S_convertible<const _U1, const _U2>())
 pair(const pair<_U1, _U2>&& __p)
 noexcept(_S_nothrow_constructible<const _U1, const _U2>())
 : first(std::forward<const _U1>(__p.first)),
   second(std::forward<const _U2>(__p.second))
 { }

      template<typename _U1, typename _U2>
 requires (_S_constructible<const _U1, const _U2>())
   && (_S_dangles<const _U1, const _U2>())
 constexpr explicit(!_S_convertible<const _U1, const _U2>())
 pair(const pair<_U1, _U2>&&) = delete;



      template<__eligible_pair_like<pair> _UPair>
 requires (_S_constructible_from_pair_like<_UPair>())
   && (!_S_dangles_from_pair_like<_UPair>())
 constexpr explicit(!_S_convertible_from_pair_like<_UPair>())
 pair(_UPair&& __p)
 : first(std::get<0>(std::forward<_UPair>(__p))),
   second(std::get<1>(std::forward<_UPair>(__p)))
 { }

      template<__eligible_pair_like<pair> _UPair>
 requires (_S_constructible_from_pair_like<_UPair>())
   && (_S_dangles_from_pair_like<_UPair>())
 constexpr explicit(!_S_convertible_from_pair_like<_UPair>())
 pair(_UPair&&) = delete;


  private:

      template<typename _U1, typename _U2>
 static constexpr bool
 _S_assignable()
 {
   if constexpr (is_assignable_v<_T1&, _U1>)
     return is_assignable_v<_T2&, _U2>;
   return false;
 }

      template<typename _U1, typename _U2>
 static constexpr bool
 _S_const_assignable()
 {
   if constexpr (is_assignable_v<const _T1&, _U1>)
     return is_assignable_v<const _T2&, _U2>;
   return false;
 }

      template<typename _U1, typename _U2>
 static constexpr bool
 _S_nothrow_assignable()
 {
   if constexpr (is_nothrow_assignable_v<_T1&, _U1>)
     return is_nothrow_assignable_v<_T2&, _U2>;
   return false;
 }


      template<typename _UPair>
 static constexpr bool
 _S_assignable_from_tuple_like()
 {
   return _S_assignable<decltype(std::get<0>(std::declval<_UPair>())),
          decltype(std::get<1>(std::declval<_UPair>()))>();
 }

      template<typename _UPair>
 static constexpr bool
 _S_const_assignable_from_tuple_like()
 {
   return _S_const_assignable<decltype(std::get<0>(std::declval<_UPair>())),
         decltype(std::get<1>(std::declval<_UPair>()))>();
 }



  public:

      pair& operator=(const pair&) = delete;


      constexpr pair&
      operator=(const pair& __p)
      noexcept(_S_nothrow_assignable<const _T1&, const _T2&>())
      requires (_S_assignable<const _T1&, const _T2&>())
      {
 first = __p.first;
 second = __p.second;
 return *this;
      }


      constexpr pair&
      operator=(pair&& __p)
      noexcept(_S_nothrow_assignable<_T1, _T2>())
      requires (_S_assignable<_T1, _T2>())
      {
 first = std::forward<first_type>(__p.first);
 second = std::forward<second_type>(__p.second);
 return *this;
      }


      template<typename _U1, typename _U2>
 constexpr pair&
 operator=(const pair<_U1, _U2>& __p)
 noexcept(_S_nothrow_assignable<const _U1&, const _U2&>())
 requires (_S_assignable<const _U1&, const _U2&>())
 {
   first = __p.first;
   second = __p.second;
   return *this;
 }


      template<typename _U1, typename _U2>
 constexpr pair&
 operator=(pair<_U1, _U2>&& __p)
 noexcept(_S_nothrow_assignable<_U1, _U2>())
 requires (_S_assignable<_U1, _U2>())
 {
   first = std::forward<_U1>(__p.first);
   second = std::forward<_U2>(__p.second);
   return *this;
 }



      constexpr const pair&
      operator=(const pair& __p) const
      requires (_S_const_assignable<const first_type&, const second_type&>())
      {
 first = __p.first;
 second = __p.second;
 return *this;
      }


      constexpr const pair&
      operator=(pair&& __p) const
      requires (_S_const_assignable<first_type, second_type>())
      {
 first = std::forward<first_type>(__p.first);
 second = std::forward<second_type>(__p.second);
 return *this;
      }


      template<typename _U1, typename _U2>
 constexpr const pair&
 operator=(const pair<_U1, _U2>& __p) const
 requires (_S_const_assignable<const _U1&, const _U2&>())
 {
   first = __p.first;
   second = __p.second;
   return *this;
 }


      template<typename _U1, typename _U2>
 constexpr const pair&
 operator=(pair<_U1, _U2>&& __p) const
 requires (_S_const_assignable<_U1, _U2>())
 {
   first = std::forward<_U1>(__p.first);
   second = std::forward<_U2>(__p.second);
   return *this;
 }



      template<__eligible_pair_like<pair> _UPair>
 requires (_S_assignable_from_tuple_like<_UPair>())
 constexpr pair&
 operator=(_UPair&& __p)
 {
   first = std::get<0>(std::forward<_UPair>(__p));
   second = std::get<1>(std::forward<_UPair>(__p));
   return *this;
 }

      template<__eligible_pair_like<pair> _UPair>
 requires (_S_const_assignable_from_tuple_like<_UPair>())
 constexpr const pair&
 operator=(_UPair&& __p) const
 {
   first = std::get<0>(std::forward<_UPair>(__p));
   second = std::get<1>(std::forward<_UPair>(__p));
   return *this;
 }
# 995 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_pair.h" 3
    };




  template<typename _T1, typename _T2> pair(_T1, _T2) -> pair<_T1, _T2>;







  template<typename _T1, typename _T2, typename _U1, typename _U2>
    inline constexpr bool
    operator==(const pair<_T1, _T2>& __x, const pair<_U1, _U2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }
# 1020 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_pair.h" 3
  template<typename _T1, typename _T2, typename _U1, typename _U2>
    constexpr common_comparison_category_t<__detail::__synth3way_t<_T1, _U1>,
        __detail::__synth3way_t<_T2, _U2>>
    operator<=>(const pair<_T1, _T2>& __x, const pair<_U1, _U2>& __y)
    {
      if (auto __c = __detail::__synth3way(__x.first, __y.first); __c != 0)
 return __c;
      return __detail::__synth3way(__x.second, __y.second);
    }
# 1080 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    constexpr inline


    typename enable_if<__and_<__is_swappable<_T1>,
                              __is_swappable<_T2>>::value>::type



    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }


  template<typename _T1, typename _T2>
    requires is_swappable_v<const _T1> && is_swappable_v<const _T2>
    constexpr void
    swap(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }



  template<typename _T1, typename _T2>
    typename enable_if<!__and_<__is_swappable<_T1>,
          __is_swappable<_T2>>::value>::type
    swap(pair<_T1, _T2>&, pair<_T1, _T2>&) = delete;
# 1129 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    constexpr pair<typename __decay_and_strip<_T1>::__type,
                   typename __decay_and_strip<_T2>::__type>
    make_pair(_T1&& __x, _T2&& __y)
    {
      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
      typedef pair<__ds_type1, __ds_type2> __pair_type;
      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
# 1152 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    struct __is_tuple_like_impl<pair<_T1, _T2>> : true_type
    { };



  template<class _Tp1, class _Tp2>
    struct tuple_size<pair<_Tp1, _Tp2>>
    : public integral_constant<size_t, 2> { };


  template<class _Tp1, class _Tp2>
    struct tuple_element<0, pair<_Tp1, _Tp2>>
    { typedef _Tp1 type; };


  template<class _Tp1, class _Tp2>
    struct tuple_element<1, pair<_Tp1, _Tp2>>
    { typedef _Tp2 type; };



  template<size_t __i, typename... _Types>
    struct tuple_element<__i, tuple<_Types...>>;


  template<typename _Tp1, typename _Tp2>
    inline constexpr size_t tuple_size_v<pair<_Tp1, _Tp2>> = 2;

  template<typename _Tp1, typename _Tp2>
    inline constexpr size_t tuple_size_v<const pair<_Tp1, _Tp2>> = 2;

  template<typename _Tp>
    inline constexpr bool __is_pair = false;

  template<typename _Tp, typename _Up>
    inline constexpr bool __is_pair<pair<_Tp, _Up>> = true;



  template<size_t _Int>
    struct __pair_get;

  template<>
    struct __pair_get<0>
    {
      template<typename _Tp1, typename _Tp2>
 static constexpr _Tp1&
 __get(pair<_Tp1, _Tp2>& __pair) noexcept
 { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
 static constexpr _Tp1&&
 __move_get(pair<_Tp1, _Tp2>&& __pair) noexcept
 { return std::forward<_Tp1>(__pair.first); }

      template<typename _Tp1, typename _Tp2>
 static constexpr const _Tp1&
 __const_get(const pair<_Tp1, _Tp2>& __pair) noexcept
 { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
 static constexpr const _Tp1&&
 __const_move_get(const pair<_Tp1, _Tp2>&& __pair) noexcept
 { return std::forward<const _Tp1>(__pair.first); }
    };

  template<>
    struct __pair_get<1>
    {
      template<typename _Tp1, typename _Tp2>
 static constexpr _Tp2&
 __get(pair<_Tp1, _Tp2>& __pair) noexcept
 { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
 static constexpr _Tp2&&
 __move_get(pair<_Tp1, _Tp2>&& __pair) noexcept
 { return std::forward<_Tp2>(__pair.second); }

      template<typename _Tp1, typename _Tp2>
 static constexpr const _Tp2&
 __const_get(const pair<_Tp1, _Tp2>& __pair) noexcept
 { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
 static constexpr const _Tp2&&
 __const_move_get(const pair<_Tp1, _Tp2>&& __pair) noexcept
 { return std::forward<const _Tp2>(__pair.second); }
    };






  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&
    get(pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__get(__in); }

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&&
    get(pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__move_get(std::move(__in)); }

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&
    get(const pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__const_get(__in); }

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&&
    get(const pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__const_move_get(std::move(__in)); }



  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Tp, _Up>&& __p) noexcept
    { return std::move(__p.first); }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&&
    get(const pair<_Tp, _Up>&& __p) noexcept
    { return std::move(__p.first); }

  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Up, _Tp>&& __p) noexcept
    { return std::move(__p.second); }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&&
    get(const pair<_Up, _Tp>&& __p) noexcept
    { return std::move(__p.second); }




  template<typename _T1, typename _T2, typename _U1, typename _U2,
    template<typename> class _TQual, template<typename> class _UQual>
    requires requires { typename pair<common_reference_t<_TQual<_T1>, _UQual<_U1>>,
          common_reference_t<_TQual<_T2>, _UQual<_U2>>>; }
  struct basic_common_reference<pair<_T1, _T2>, pair<_U1, _U2>, _TQual, _UQual>
  {
    using type = pair<common_reference_t<_TQual<_T1>, _UQual<_U1>>,
        common_reference_t<_TQual<_T2>, _UQual<_U2>>>;
  };

  template<typename _T1, typename _T2, typename _U1, typename _U2>
    requires requires { typename pair<common_type_t<_T1, _U1>, common_type_t<_T2, _U2>>; }
  struct common_type<pair<_T1, _T2>, pair<_U1, _U2>>
  { using type = pair<common_type_t<_T1, _U1>, common_type_t<_T2, _U2>>; };






}
# 70 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/utility" 2 3



# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/initializer_list" 1 3
# 33 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/initializer_list" 3
       
# 34 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/initializer_list" 3







namespace std
{

  template<class _E>
    class initializer_list
    {
    public:
      typedef _E value_type;
      typedef const _E& reference;
      typedef const _E& const_reference;
      typedef size_t size_type;
      typedef const _E* iterator;
      typedef const _E* const_iterator;

    private:
      iterator _M_array;
      size_type _M_len;


      constexpr initializer_list(const_iterator __a, size_type __l)
      : _M_array(__a), _M_len(__l) { }

    public:
      constexpr initializer_list() noexcept
      : _M_array(0), _M_len(0) { }


      constexpr size_type
      size() const noexcept { return _M_len; }


      constexpr const_iterator
      begin() const noexcept { return _M_array; }


      constexpr const_iterator
      end() const noexcept { return begin() + size(); }
    };







  template<class _Tp>
    constexpr const _Tp*
    begin(initializer_list<_Tp> __ils) noexcept
    { return __ils.begin(); }







  template<class _Tp>
    constexpr const _Tp*
    end(initializer_list<_Tp> __ils) noexcept
    { return __ils.end(); }
}
# 74 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/utility" 2 3





# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/ext/numeric_traits.h" 1 3
# 32 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/ext/numeric_traits.h" 3
       
# 33 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/ext/numeric_traits.h" 3

# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/cpp_type_traits.h" 1 3
# 35 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/cpp_type_traits.h" 3
       
# 36 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/cpp_type_traits.h" 3
# 67 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/cpp_type_traits.h" 3
extern "C++" {

namespace std
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };





  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_integer<char8_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_integer<char16_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char32_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 272 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/cpp_type_traits.h" 3
__extension__ template<> struct __is_integer<__int128> { enum { __value = 1 }; typedef __true_type __type; }; __extension__ template<> struct __is_integer<unsigned __int128> { enum { __value = 1 }; typedef __true_type __type; };
# 289 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/cpp_type_traits.h" 3
  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_floating<_Float16>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_floating<_Float32>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_floating<_Float64>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_floating<_Float128>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_floating<__gnu_cxx::__bfloat16_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };





  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  enum class byte : unsigned char;

  template<>
    struct __is_byte<byte>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_byte<char8_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename> struct iterator_traits;


  template<typename _Tp>
    struct __is_nonvolatile_trivially_copyable
    {
      enum { __value = __is_trivially_copyable(_Tp) };
    };




  template<typename _Tp>
    struct __is_nonvolatile_trivially_copyable<volatile _Tp>
    {
      enum { __value = 0 };
    };


  template<typename _OutputIter, typename _InputIter>
    struct __memcpyable
    {
      enum { __value = 0 };
    };

  template<typename _Tp>
    struct __memcpyable<_Tp*, _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };

  template<typename _Tp>
    struct __memcpyable<_Tp*, const _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };






  template<typename _Iter1, typename _Iter2>
    struct __memcmpable
    {
      enum { __value = 0 };
    };


  template<typename _Tp>
    struct __memcmpable<_Tp*, _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };

  template<typename _Tp>
    struct __memcmpable<const _Tp*, _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };

  template<typename _Tp>
    struct __memcmpable<_Tp*, const _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };







  template<typename _Tp, bool _TreatAsBytes =



 __is_byte<_Tp>::__value

    >
    struct __is_memcmp_ordered
    {
      static const bool __value = _Tp(-1) > _Tp(1);
    };

  template<typename _Tp>
    struct __is_memcmp_ordered<_Tp, false>
    {
      static const bool __value = false;
    };


  template<typename _Tp, typename _Up, bool = sizeof(_Tp) == sizeof(_Up)>
    struct __is_memcmp_ordered_with
    {
      static const bool __value = __is_memcmp_ordered<_Tp>::__value
 && __is_memcmp_ordered<_Up>::__value;
    };

  template<typename _Tp, typename _Up>
    struct __is_memcmp_ordered_with<_Tp, _Up, false>
    {
      static const bool __value = false;
    };
# 579 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/cpp_type_traits.h" 3
  template<>
    struct __is_memcmp_ordered_with<std::byte, std::byte, true>
    { static constexpr bool __value = true; };

  template<typename _Tp, bool _SameSize>
    struct __is_memcmp_ordered_with<_Tp, std::byte, _SameSize>
    { static constexpr bool __value = false; };

  template<typename _Up, bool _SameSize>
    struct __is_memcmp_ordered_with<std::byte, _Up, _SameSize>
    { static constexpr bool __value = false; };





  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };



  template<typename _Iterator>
    constexpr
    inline _Iterator
    __miter_base(_Iterator __it)
    { return __it; }


}
}
# 35 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/ext/numeric_traits.h" 2 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/ext/type_traits.h" 1 3
# 32 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/ext/type_traits.h" 3
       
# 33 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/ext/type_traits.h" 3




extern "C++" {

namespace __gnu_cxx
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    constexpr
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    constexpr
    inline bool
    __is_null_pointer(_Type)
    { return false; }


  constexpr bool
  __is_null_pointer(std::nullptr_t)
  { return true; }




  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };


  template<>
    struct __promote<_Float16>
    { typedef _Float16 __type; };



  template<>
    struct __promote<_Float32>
    { typedef _Float32 __type; };



  template<>
    struct __promote<_Float64>
    { typedef _Float64 __type; };



  template<>
    struct __promote<_Float128>
    { typedef _Float128 __type; };



  template<>
    struct __promote<__gnu_cxx::__bfloat16_t>
    { typedef __gnu_cxx::__bfloat16_t __type; };




  template<typename... _Tp>
    using __promoted_t = decltype((typename __promote<_Tp>::__type(0) + ...));



  template<typename _Tp, typename _Up>
    using __promote_2 = __promote<__promoted_t<_Tp, _Up>>;

  template<typename _Tp, typename _Up, typename _Vp>
    using __promote_3 = __promote<__promoted_t<_Tp, _Up, _Vp>>;

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp>
    using __promote_4 = __promote<__promoted_t<_Tp, _Up, _Vp, _Wp>>;
# 269 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/ext/type_traits.h" 3

}
}
# 36 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/ext/numeric_traits.h" 2 3

namespace __gnu_cxx
{

# 50 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/ext/numeric_traits.h" 3
  template<typename _Tp>
    struct __is_integer_nonstrict
    : public std::__is_integer<_Tp>
    {
      using std::__is_integer<_Tp>::__value;


      enum { __width = __value ? sizeof(_Tp) * 8 : 0 };
    };

  template<typename _Value>
    struct __numeric_traits_integer
    {

      static_assert(__is_integer_nonstrict<_Value>::__value,
      "invalid specialization");




      static const bool __is_signed = (_Value)(-1) < 0;
      static const int __digits
 = __is_integer_nonstrict<_Value>::__width - __is_signed;


      static const _Value __max = __is_signed
 ? (((((_Value)1 << (__digits - 1)) - 1) << 1) + 1)
 : ~(_Value)0;
      static const _Value __min = __is_signed ? -__max - 1 : (_Value)0;
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
# 137 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/ext/numeric_traits.h" 3
  template<typename _Tp>
    using __int_traits = __numeric_traits_integer<_Tp>;
# 157 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;






  template<typename _Value>
    struct __numeric_traits
    : public __numeric_traits_integer<_Value>
    { };

  template<>
    struct __numeric_traits<float>
    : public __numeric_traits_floating<float>
    { };

  template<>
    struct __numeric_traits<double>
    : public __numeric_traits_floating<double>
    { };

  template<>
    struct __numeric_traits<long double>
    : public __numeric_traits_floating<long double>
    { };
# 238 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/ext/numeric_traits.h" 3

}
# 80 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/utility" 2 3
# 96 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/utility" 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 1 3
# 47 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 3
       
# 48 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 3
# 97 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/utility" 2 3

namespace std
{




  template <typename _Tp, typename _Up = _Tp>
    constexpr
    inline _Tp
    exchange(_Tp& __obj, _Up&& __new_val)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
      is_nothrow_assignable<_Tp&, _Up>>::value)
    { return std::__exchange(__obj, std::forward<_Up>(__new_val)); }



  template<typename _Tp>
    [[nodiscard]]
    constexpr add_const_t<_Tp>&
    as_const(_Tp& __t) noexcept
    { return __t; }

  template<typename _Tp>
    void as_const(const _Tp&&) = delete;



  template<typename _Tp, typename _Up>
    constexpr bool
    cmp_equal(_Tp __t, _Up __u) noexcept
    {
      static_assert(__is_standard_integer<_Tp>::value);
      static_assert(__is_standard_integer<_Up>::value);

      if constexpr (is_signed_v<_Tp> == is_signed_v<_Up>)
 return __t == __u;
      else if constexpr (is_signed_v<_Tp>)
 return __t >= 0 && make_unsigned_t<_Tp>(__t) == __u;
      else
 return __u >= 0 && __t == make_unsigned_t<_Up>(__u);
    }

  template<typename _Tp, typename _Up>
    constexpr bool
    cmp_not_equal(_Tp __t, _Up __u) noexcept
    { return !std::cmp_equal(__t, __u); }

  template<typename _Tp, typename _Up>
    constexpr bool
    cmp_less(_Tp __t, _Up __u) noexcept
    {
      static_assert(__is_standard_integer<_Tp>::value);
      static_assert(__is_standard_integer<_Up>::value);

      if constexpr (is_signed_v<_Tp> == is_signed_v<_Up>)
 return __t < __u;
      else if constexpr (is_signed_v<_Tp>)
 return __t < 0 || make_unsigned_t<_Tp>(__t) < __u;
      else
 return __u >= 0 && __t < make_unsigned_t<_Up>(__u);
    }

  template<typename _Tp, typename _Up>
    constexpr bool
    cmp_greater(_Tp __t, _Up __u) noexcept
    { return std::cmp_less(__u, __t); }

  template<typename _Tp, typename _Up>
    constexpr bool
    cmp_less_equal(_Tp __t, _Up __u) noexcept
    { return !std::cmp_less(__u, __t); }

  template<typename _Tp, typename _Up>
    constexpr bool
    cmp_greater_equal(_Tp __t, _Up __u) noexcept
    { return !std::cmp_less(__t, __u); }

  template<typename _Res, typename _Tp>
    constexpr bool
    in_range(_Tp __t) noexcept
    {
      static_assert(__is_standard_integer<_Res>::value);
      static_assert(__is_standard_integer<_Tp>::value);
      using __gnu_cxx::__int_traits;

      if constexpr (is_signed_v<_Tp> == is_signed_v<_Res>)
 return __int_traits<_Res>::__min <= __t
   && __t <= __int_traits<_Res>::__max;
      else if constexpr (is_signed_v<_Tp>)
 return __t >= 0
   && make_unsigned_t<_Tp>(__t) <= __int_traits<_Res>::__max;
      else
 return __t <= make_unsigned_t<_Res>(__int_traits<_Res>::__max);
    }




  template<typename _Tp>
    [[nodiscard]]
    constexpr underlying_type_t<_Tp>
    to_underlying(_Tp __value) noexcept
    { return static_cast<underlying_type_t<_Tp>>(__value); }
# 216 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/utility" 3
  [[noreturn,__gnu__::__always_inline__]]
  inline void
  unreachable()
  {





    __builtin_unreachable();

  }



}
# 2 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/src/Creepy/Input.cpp" 2
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/unordered_set" 1 3
# 32 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/unordered_set" 3
       
# 33 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/unordered_set" 3

# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/requires_hosted.h" 1 3
# 35 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/unordered_set" 2 3






# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 1 3
# 33 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/hashtable.h" 1 3
# 33 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/hashtable.h" 3
       
# 34 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/hashtable.h" 3

# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/hashtable_policy.h" 1 3
# 34 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/hashtable_policy.h" 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tuple" 1 3
# 32 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tuple" 3
       
# 33 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tuple" 3






# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/uses_allocator.h" 1 3
# 40 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/uses_allocator.h" 3
namespace std
{




  struct __erased_type { };




  template<typename _Alloc, typename _Tp>
    using __is_erased_or_convertible
      = __or_<is_convertible<_Alloc, _Tp>, is_same<_Tp, __erased_type>>;


  struct allocator_arg_t { explicit allocator_arg_t() = default; };

  inline constexpr allocator_arg_t allocator_arg =
    allocator_arg_t();

  template<typename _Tp, typename _Alloc, typename = __void_t<>>
    struct __uses_allocator_helper
    : false_type { };

  template<typename _Tp, typename _Alloc>
    struct __uses_allocator_helper<_Tp, _Alloc,
       __void_t<typename _Tp::allocator_type>>
    : __is_erased_or_convertible<_Alloc, typename _Tp::allocator_type>::type
    { };


  template<typename _Tp, typename _Alloc>
    struct uses_allocator
    : __uses_allocator_helper<_Tp, _Alloc>::type
    { };

  struct __uses_alloc_base { };

  struct __uses_alloc0 : __uses_alloc_base
  {
    struct _Sink { void constexpr operator=(const void*) { } } _M_a;
  };

  template<typename _Alloc>
    struct __uses_alloc1 : __uses_alloc_base { const _Alloc* _M_a; };

  template<typename _Alloc>
    struct __uses_alloc2 : __uses_alloc_base { const _Alloc* _M_a; };

  template<bool, typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc;

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<true, _Tp, _Alloc, _Args...>
    : __conditional_t<
        is_constructible<_Tp, allocator_arg_t, const _Alloc&, _Args...>::value,
        __uses_alloc1<_Alloc>,
        __uses_alloc2<_Alloc>>
    {


      static_assert(__or_<
   is_constructible<_Tp, allocator_arg_t, const _Alloc&, _Args...>,
   is_constructible<_Tp, _Args..., const _Alloc&>>::value,
   "construction with an allocator must be possible"
   " if uses_allocator is true");
    };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<false, _Tp, _Alloc, _Args...>
    : __uses_alloc0 { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    using __uses_alloc_t =
      __uses_alloc<uses_allocator<_Tp, _Alloc>::value, _Tp, _Alloc, _Args...>;

  template<typename _Tp, typename _Alloc, typename... _Args>
    constexpr
    inline __uses_alloc_t<_Tp, _Alloc, _Args...>
    __use_alloc(const _Alloc& __a)
    {
      __uses_alloc_t<_Tp, _Alloc, _Args...> __ret;
      __ret._M_a = std::__addressof(__a);
      return __ret;
    }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void
    __use_alloc(const _Alloc&&) = delete;


  template <typename _Tp, typename _Alloc>
    inline constexpr bool uses_allocator_v =
      uses_allocator<_Tp, _Alloc>::value;


  template<template<typename...> class _Predicate,
    typename _Tp, typename _Alloc, typename... _Args>
    struct __is_uses_allocator_predicate
    : __conditional_t<uses_allocator<_Tp, _Alloc>::value,
      __or_<_Predicate<_Tp, allocator_arg_t, _Alloc, _Args...>,
     _Predicate<_Tp, _Args..., _Alloc>>,
      _Predicate<_Tp, _Args...>> { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __is_uses_allocator_constructible
    : __is_uses_allocator_predicate<is_constructible, _Tp, _Alloc, _Args...>
    { };


  template<typename _Tp, typename _Alloc, typename... _Args>
    inline constexpr bool __is_uses_allocator_constructible_v =
      __is_uses_allocator_constructible<_Tp, _Alloc, _Args...>::value;


  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __is_nothrow_uses_allocator_constructible
    : __is_uses_allocator_predicate<is_nothrow_constructible,
        _Tp, _Alloc, _Args...>
    { };



  template<typename _Tp, typename _Alloc, typename... _Args>
    inline constexpr bool
    __is_nothrow_uses_allocator_constructible_v =
      __is_nothrow_uses_allocator_constructible<_Tp, _Alloc, _Args...>::value;


  template<typename _Tp, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc0, _Tp* __ptr,
      _Args&&... __args)
    { ::new ((void*)__ptr) _Tp(std::forward<_Args>(__args)...); }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc1<_Alloc> __a, _Tp* __ptr,
      _Args&&... __args)
    {
      ::new ((void*)__ptr) _Tp(allocator_arg, *__a._M_a,
          std::forward<_Args>(__args)...);
    }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc2<_Alloc> __a, _Tp* __ptr,
      _Args&&... __args)
    { ::new ((void*)__ptr) _Tp(std::forward<_Args>(__args)..., *__a._M_a); }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct(const _Alloc& __a, _Tp* __ptr,
        _Args&&... __args)
    {
      std::__uses_allocator_construct_impl(
   std::__use_alloc<_Tp, _Alloc, _Args...>(__a), __ptr,
   std::forward<_Args>(__args)...);
    }



}
# 40 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tuple" 2 3

# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/invoke.h" 1 3
# 33 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/invoke.h" 3
       
# 34 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/invoke.h" 3
# 42 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/invoke.h" 3
namespace std
{

# 53 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/invoke.h" 3
  template<typename _Tp, typename _Up = typename __inv_unwrap<_Tp>::type>
    constexpr _Up&&
    __invfwd(typename remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Up&&>(__t); }

  template<typename _Res, typename _Fn, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_other, _Fn&& __f, _Args&&... __args)
    { return std::forward<_Fn>(__f)(std::forward<_Args>(__args)...); }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_memfun_ref, _MemFun&& __f, _Tp&& __t,
    _Args&&... __args)
    { return (__invfwd<_Tp>(__t).*__f)(std::forward<_Args>(__args)...); }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_memfun_deref, _MemFun&& __f, _Tp&& __t,
    _Args&&... __args)
    {
      return ((*std::forward<_Tp>(__t)).*__f)(std::forward<_Args>(__args)...);
    }

  template<typename _Res, typename _MemPtr, typename _Tp>
    constexpr _Res
    __invoke_impl(__invoke_memobj_ref, _MemPtr&& __f, _Tp&& __t)
    { return __invfwd<_Tp>(__t).*__f; }

  template<typename _Res, typename _MemPtr, typename _Tp>
    constexpr _Res
    __invoke_impl(__invoke_memobj_deref, _MemPtr&& __f, _Tp&& __t)
    { return (*std::forward<_Tp>(__t)).*__f; }


  template<typename _Callable, typename... _Args>
    constexpr typename __invoke_result<_Callable, _Args...>::type
    __invoke(_Callable&& __fn, _Args&&... __args)
    noexcept(__is_nothrow_invocable<_Callable, _Args...>::value)
    {
      using __result = __invoke_result<_Callable, _Args...>;
      using __type = typename __result::type;
      using __tag = typename __result::__invoke_type;
      return std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),
     std::forward<_Args>(__args)...);
    }



  template<typename _Res, typename _Callable, typename... _Args>
    constexpr enable_if_t<is_invocable_r_v<_Res, _Callable, _Args...>, _Res>
    __invoke_r(_Callable&& __fn, _Args&&... __args)
    noexcept(is_nothrow_invocable_r_v<_Res, _Callable, _Args...>)
    {
      using __result = __invoke_result<_Callable, _Args...>;
      using __type = typename __result::type;
      using __tag = typename __result::__invoke_type;
      if constexpr (is_void_v<_Res>)
 std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),
     std::forward<_Args>(__args)...);
      else
 return std::__invoke_impl<__type>(__tag{},
       std::forward<_Callable>(__fn),
       std::forward<_Args>(__args)...);
    }
# 155 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/invoke.h" 3

}
# 42 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tuple" 2 3


# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/ranges_util.h" 1 3
# 34 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/ranges_util.h" 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/ranges_base.h" 1 3
# 33 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/ranges_base.h" 3
       
# 34 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/ranges_base.h" 3



# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator.h" 1 3
# 64 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator.h" 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator_base_types.h" 1 3
# 62 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator_base_types.h" 3
       
# 63 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator_base_types.h" 3
# 71 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator_base_types.h" 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/iterator_concepts.h" 1 3
# 33 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/iterator_concepts.h" 3
       
# 34 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/iterator_concepts.h" 3



# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/ptr_traits.h" 1 3
# 39 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/ptr_traits.h" 3
namespace __gnu_debug { struct _Safe_iterator_base; }


namespace std
{




  class __undefined;



  template<typename _Tp>
    struct __get_first_arg
    { using type = __undefined; };

  template<template<typename, typename...> class _SomeTemplate, typename _Tp,
           typename... _Types>
    struct __get_first_arg<_SomeTemplate<_Tp, _Types...>>
    { using type = _Tp; };



  template<typename _Tp, typename _Up>
    struct __replace_first_arg
    { };

  template<template<typename, typename...> class _SomeTemplate, typename _Up,
           typename _Tp, typename... _Types>
    struct __replace_first_arg<_SomeTemplate<_Tp, _Types...>, _Up>
    { using type = _SomeTemplate<_Up, _Types...>; };


  template<typename _Ptr, typename = void>
    struct __ptr_traits_elem : __get_first_arg<_Ptr>
    { };



  template<typename _Ptr> requires requires { typename _Ptr::element_type; }
    struct __ptr_traits_elem<_Ptr, void>
    { using type = typename _Ptr::element_type; };






  template<typename _Ptr>
    using __ptr_traits_elem_t = typename __ptr_traits_elem<_Ptr>::type;




  template<typename _Ptr, typename _Elt, bool = is_void<_Elt>::value>
    struct __ptr_traits_ptr_to
    {
      using pointer = _Ptr;
      using element_type = _Elt;







      static pointer
      pointer_to(element_type& __r)

      requires requires {
 { pointer::pointer_to(__r) } -> convertible_to<pointer>;
      }

      { return pointer::pointer_to(__r); }
    };


  template<typename _Ptr, typename _Elt>
    struct __ptr_traits_ptr_to<_Ptr, _Elt, true>
    { };


  template<typename _Tp>
    struct __ptr_traits_ptr_to<_Tp*, _Tp, false>
    {
      using pointer = _Tp*;
      using element_type = _Tp;






      static constexpr pointer
      pointer_to(element_type& __r) noexcept
      { return std::addressof(__r); }
    };

  template<typename _Ptr, typename _Elt>
    struct __ptr_traits_impl : __ptr_traits_ptr_to<_Ptr, _Elt>
    {
    private:
      template<typename _Tp>
 using __diff_t = typename _Tp::difference_type;

      template<typename _Tp, typename _Up>
 using __rebind = __type_identity<typename _Tp::template rebind<_Up>>;

    public:

      using pointer = _Ptr;


      using element_type = _Elt;


      using difference_type = __detected_or_t<ptrdiff_t, __diff_t, _Ptr>;


      template<typename _Up>
 using rebind = typename __detected_or_t<__replace_first_arg<_Ptr, _Up>,
      __rebind, _Ptr, _Up>::type;
    };



  template<typename _Ptr>
    struct __ptr_traits_impl<_Ptr, __undefined>
    { };







  template<typename _Ptr>
    struct pointer_traits : __ptr_traits_impl<_Ptr, __ptr_traits_elem_t<_Ptr>>
    { };







  template<typename _Tp>
    struct pointer_traits<_Tp*> : __ptr_traits_ptr_to<_Tp*, _Tp>
    {

      typedef _Tp* pointer;

      typedef _Tp element_type;

      typedef ptrdiff_t difference_type;

      template<typename _Up> using rebind = _Up*;
    };


  template<typename _Ptr, typename _Tp>
    using __ptr_rebind = typename pointer_traits<_Ptr>::template rebind<_Tp>;

  template<typename _Tp>
    constexpr _Tp*
    __to_address(_Tp* __ptr) noexcept
    {
      static_assert(!std::is_function<_Tp>::value, "not a function pointer");
      return __ptr;
    }







  template<typename _Ptr>
    constexpr auto
    __to_address(const _Ptr& __ptr) noexcept
    -> decltype(std::pointer_traits<_Ptr>::to_address(__ptr))
    { return std::pointer_traits<_Ptr>::to_address(__ptr); }

  template<typename _Ptr, typename... _None>
    constexpr auto
    __to_address(const _Ptr& __ptr, _None...) noexcept
    {
      if constexpr (is_base_of_v<__gnu_debug::_Safe_iterator_base, _Ptr>)
 return std::__to_address(__ptr.base().operator->());
      else
 return std::__to_address(__ptr.operator->());
    }







  template<typename _Tp>
    constexpr _Tp*
    to_address(_Tp* __ptr) noexcept
    { return std::__to_address(__ptr); }
# 251 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/ptr_traits.h" 3
  template<typename _Ptr>
    constexpr auto
    to_address(const _Ptr& __ptr) noexcept
    { return std::__to_address(__ptr); }



}
# 38 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/iterator_concepts.h" 2 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/ranges_cmp.h" 1 3
# 37 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/ranges_cmp.h" 3
namespace std
{


  struct __is_transparent;





  struct identity
  {
    template<typename _Tp>
      [[nodiscard]]
      constexpr _Tp&&
      operator()(_Tp&& __t) const noexcept
      { return std::forward<_Tp>(__t); }

    using is_transparent = __is_transparent;
  };


namespace ranges
{
  namespace __detail
  {



    template<typename _Tp, typename _Up>
      concept __less_builtin_ptr_cmp
 = requires (_Tp&& __t, _Up&& __u) { { __t < __u } -> same_as<bool>; }
   && convertible_to<_Tp, const volatile void*>
   && convertible_to<_Up, const volatile void*>
   && (! requires(_Tp&& __t, _Up&& __u)
       { operator<(std::forward<_Tp>(__t), std::forward<_Up>(__u)); }
       && ! requires(_Tp&& __t, _Up&& __u)
       { std::forward<_Tp>(__t).operator<(std::forward<_Up>(__u)); });
  }







  struct equal_to
  {
    template<typename _Tp, typename _Up>
      requires equality_comparable_with<_Tp, _Up>
      constexpr bool
      operator()(_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(std::declval<_Tp>() == std::declval<_Up>()))
      { return std::forward<_Tp>(__t) == std::forward<_Up>(__u); }

    using is_transparent = __is_transparent;
  };


  struct not_equal_to
  {
    template<typename _Tp, typename _Up>
      requires equality_comparable_with<_Tp, _Up>
      constexpr bool
      operator()(_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(std::declval<_Up>() == std::declval<_Tp>()))
      { return !equal_to{}(std::forward<_Tp>(__t), std::forward<_Up>(__u)); }

    using is_transparent = __is_transparent;
  };


  struct less
  {
    template<typename _Tp, typename _Up>
      requires totally_ordered_with<_Tp, _Up>
      constexpr bool
      operator()(_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(std::declval<_Tp>() < std::declval<_Up>()))
      {
 if constexpr (__detail::__less_builtin_ptr_cmp<_Tp, _Up>)
   {
     if (std::__is_constant_evaluated())
       return __t < __u;

     auto __x = reinterpret_cast<long long unsigned int>(
       static_cast<const volatile void*>(std::forward<_Tp>(__t)));
     auto __y = reinterpret_cast<long long unsigned int>(
       static_cast<const volatile void*>(std::forward<_Up>(__u)));
     return __x < __y;
   }
 else
   return std::forward<_Tp>(__t) < std::forward<_Up>(__u);
      }

    using is_transparent = __is_transparent;
  };


  struct greater
  {
    template<typename _Tp, typename _Up>
      requires totally_ordered_with<_Tp, _Up>
      constexpr bool
      operator()(_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(std::declval<_Up>() < std::declval<_Tp>()))
      { return less{}(std::forward<_Up>(__u), std::forward<_Tp>(__t)); }

    using is_transparent = __is_transparent;
  };


  struct greater_equal
  {
    template<typename _Tp, typename _Up>
      requires totally_ordered_with<_Tp, _Up>
      constexpr bool
      operator()(_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(std::declval<_Tp>() < std::declval<_Up>()))
      { return !less{}(std::forward<_Tp>(__t), std::forward<_Up>(__u)); }

    using is_transparent = __is_transparent;
  };


  struct less_equal
  {
    template<typename _Tp, typename _Up>
      requires totally_ordered_with<_Tp, _Up>
      constexpr bool
      operator()(_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(std::declval<_Up>() < std::declval<_Tp>()))
      { return !less{}(std::forward<_Up>(__u), std::forward<_Tp>(__t)); }

    using is_transparent = __is_transparent;
  };

}


}
# 39 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/iterator_concepts.h" 2 3

namespace std
{

# 58 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/iterator_concepts.h" 3
  struct default_sentinel_t { };


  inline constexpr default_sentinel_t default_sentinel{};


  struct input_iterator_tag;
  struct output_iterator_tag;
  struct forward_iterator_tag;
  struct bidirectional_iterator_tag;
  struct random_access_iterator_tag;
  struct contiguous_iterator_tag;

  template<typename _Iterator>
    struct iterator_traits;

  template<typename _Tp> requires is_object_v<_Tp>
    struct iterator_traits<_Tp*>;

  template<typename _Iterator, typename>
    struct __iterator_traits;

  namespace __detail
  {
    template<typename _Tp>
      using __with_ref = _Tp&;

    template<typename _Tp>
      concept __can_reference = requires { typename __with_ref<_Tp>; };

    template<typename _Tp>
      concept __dereferenceable = requires(_Tp& __t)
 {
   { *__t } -> __can_reference;
 };
  }

  template<__detail::__dereferenceable _Tp>
    using iter_reference_t = decltype(*std::declval<_Tp&>());

  namespace ranges
  {

    namespace __imove
    {
      void iter_move() = delete;

      template<typename _Tp>
 concept __adl_imove
   = (std::__detail::__class_or_enum<remove_reference_t<_Tp>>)
   && requires(_Tp&& __t) { iter_move(static_cast<_Tp&&>(__t)); };

      struct _IterMove
      {
      private:
 template<typename _Tp>
   struct __result
   { using type = iter_reference_t<_Tp>; };

 template<typename _Tp>
   requires __adl_imove<_Tp>
   struct __result<_Tp>
   { using type = decltype(iter_move(std::declval<_Tp>())); };

 template<typename _Tp>
   requires (!__adl_imove<_Tp>)
   && is_lvalue_reference_v<iter_reference_t<_Tp>>
   struct __result<_Tp>
   { using type = remove_reference_t<iter_reference_t<_Tp>>&&; };

 template<typename _Tp>
   static constexpr bool
   _S_noexcept()
   {
     if constexpr (__adl_imove<_Tp>)
       return noexcept(iter_move(std::declval<_Tp>()));
     else
       return noexcept(*std::declval<_Tp>());
   }

      public:

 template<std::__detail::__dereferenceable _Tp>
   using __type = typename __result<_Tp>::type;

 template<std::__detail::__dereferenceable _Tp>
   [[nodiscard]]
   constexpr __type<_Tp>
   operator()(_Tp&& __e) const
   noexcept(_S_noexcept<_Tp>())
   {
     if constexpr (__adl_imove<_Tp>)
       return iter_move(static_cast<_Tp&&>(__e));
     else if constexpr (is_lvalue_reference_v<iter_reference_t<_Tp>>)
       return static_cast<__type<_Tp>>(*__e);
     else
       return *__e;
   }
      };
    }


    inline namespace _Cpo {
      inline constexpr __imove::_IterMove iter_move{};
    }
  }

  template<__detail::__dereferenceable _Tp>
    requires __detail::__can_reference<ranges::__imove::_IterMove::__type<_Tp&>>
    using iter_rvalue_reference_t = ranges::__imove::_IterMove::__type<_Tp&>;

  template<typename> struct incrementable_traits { };

  template<typename _Tp> requires is_object_v<_Tp>
    struct incrementable_traits<_Tp*>
    { using difference_type = ptrdiff_t; };

  template<typename _Iter>
    struct incrementable_traits<const _Iter>
    : incrementable_traits<_Iter> { };

  template<typename _Tp> requires requires { typename _Tp::difference_type; }
    struct incrementable_traits<_Tp>
    { using difference_type = typename _Tp::difference_type; };

  template<typename _Tp>
    requires (!requires { typename _Tp::difference_type; }
       && requires(const _Tp& __a, const _Tp& __b)
       { { __a - __b } -> integral; })
    struct incrementable_traits<_Tp>
    {
      using difference_type
 = make_signed_t<decltype(std::declval<_Tp>() - std::declval<_Tp>())>;
    };
# 204 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/iterator_concepts.h" 3
  namespace __detail
  {


    template<typename _Iter>
      concept __primary_traits_iter
 = __is_base_of(__iterator_traits<_Iter, void>, iterator_traits<_Iter>);

    template<typename _Iter, typename _Tp>
      struct __iter_traits_impl
      { using type = iterator_traits<_Iter>; };

    template<typename _Iter, typename _Tp>
      requires __primary_traits_iter<_Iter>
      struct __iter_traits_impl<_Iter, _Tp>
      { using type = _Tp; };


    template<typename _Iter, typename _Tp = _Iter>
      using __iter_traits = typename __iter_traits_impl<_Iter, _Tp>::type;

    template<typename _Tp>
      using __iter_diff_t = typename
 __iter_traits<_Tp, incrementable_traits<_Tp>>::difference_type;
  }

  template<typename _Tp>
    using iter_difference_t = __detail::__iter_diff_t<remove_cvref_t<_Tp>>;

  namespace __detail
  {
    template<typename> struct __cond_value_type { };

    template<typename _Tp> requires is_object_v<_Tp>
      struct __cond_value_type<_Tp>
      { using value_type = remove_cv_t<_Tp>; };

    template<typename _Tp>
      concept __has_member_value_type
 = requires { typename _Tp::value_type; };

    template<typename _Tp>
      concept __has_member_element_type
 = requires { typename _Tp::element_type; };

  }

  template<typename> struct indirectly_readable_traits { };

  template<typename _Tp>
    struct indirectly_readable_traits<_Tp*>
    : __detail::__cond_value_type<_Tp>
    { };

  template<typename _Iter> requires is_array_v<_Iter>
    struct indirectly_readable_traits<_Iter>
    { using value_type = remove_cv_t<remove_extent_t<_Iter>>; };

  template<typename _Iter>
    struct indirectly_readable_traits<const _Iter>
    : indirectly_readable_traits<_Iter>
    { };

  template<__detail::__has_member_value_type _Tp>
    struct indirectly_readable_traits<_Tp>
    : __detail::__cond_value_type<typename _Tp::value_type>
    { };

  template<__detail::__has_member_element_type _Tp>
    struct indirectly_readable_traits<_Tp>
    : __detail::__cond_value_type<typename _Tp::element_type>
    { };



  template<__detail::__has_member_value_type _Tp>
    requires __detail::__has_member_element_type<_Tp>
    && same_as<remove_cv_t<typename _Tp::element_type>,
        remove_cv_t<typename _Tp::value_type>>
    struct indirectly_readable_traits<_Tp>
    : __detail::__cond_value_type<typename _Tp::value_type>
    { };



  template<__detail::__has_member_value_type _Tp>
    requires __detail::__has_member_element_type<_Tp>
    struct indirectly_readable_traits<_Tp>
    { };

  namespace __detail
  {
    template<typename _Tp>
      using __iter_value_t = typename
 __iter_traits<_Tp, indirectly_readable_traits<_Tp>>::value_type;
  }

  template<typename _Tp>
    using iter_value_t = __detail::__iter_value_t<remove_cvref_t<_Tp>>;

  namespace __detail
  {


    template<typename _Iter>
      concept __cpp17_iterator = requires(_Iter __it)
 {
   { *__it } -> __can_reference;
   { ++__it } -> same_as<_Iter&>;
   { *__it++ } -> __can_reference;
 } && copyable<_Iter>;

    template<typename _Iter>
      concept __cpp17_input_iterator = __cpp17_iterator<_Iter>
 && equality_comparable<_Iter>
 && requires(_Iter __it)
 {
   typename incrementable_traits<_Iter>::difference_type;
   typename indirectly_readable_traits<_Iter>::value_type;
   typename common_reference_t<iter_reference_t<_Iter>&&,
     typename indirectly_readable_traits<_Iter>::value_type&>;
   typename common_reference_t<decltype(*__it++)&&,
     typename indirectly_readable_traits<_Iter>::value_type&>;
   requires signed_integral<
     typename incrementable_traits<_Iter>::difference_type>;
 };

    template<typename _Iter>
      concept __cpp17_fwd_iterator = __cpp17_input_iterator<_Iter>
 && constructible_from<_Iter>
 && is_lvalue_reference_v<iter_reference_t<_Iter>>
 && same_as<remove_cvref_t<iter_reference_t<_Iter>>,
     typename indirectly_readable_traits<_Iter>::value_type>
 && requires(_Iter __it)
 {
   { __it++ } -> convertible_to<const _Iter&>;
   { *__it++ } -> same_as<iter_reference_t<_Iter>>;
 };

    template<typename _Iter>
      concept __cpp17_bidi_iterator = __cpp17_fwd_iterator<_Iter>
 && requires(_Iter __it)
 {
   { --__it } -> same_as<_Iter&>;
   { __it-- } -> convertible_to<const _Iter&>;
   { *__it-- } -> same_as<iter_reference_t<_Iter>>;
 };

    template<typename _Iter>
      concept __cpp17_randacc_iterator = __cpp17_bidi_iterator<_Iter>
 && totally_ordered<_Iter>
 && requires(_Iter __it,
      typename incrementable_traits<_Iter>::difference_type __n)
 {
   { __it += __n } -> same_as<_Iter&>;
   { __it -= __n } -> same_as<_Iter&>;
   { __it + __n } -> same_as<_Iter>;
   { __n + __it } -> same_as<_Iter>;
   { __it - __n } -> same_as<_Iter>;
   { __it - __it } -> same_as<decltype(__n)>;
   { __it[__n] } -> convertible_to<iter_reference_t<_Iter>>;
 };

    template<typename _Iter>
      concept __iter_with_nested_types = requires {
 typename _Iter::iterator_category;
 typename _Iter::value_type;
 typename _Iter::difference_type;
 typename _Iter::reference;
      };

    template<typename _Iter>
      concept __iter_without_nested_types = !__iter_with_nested_types<_Iter>;

    template<typename _Iter>
      concept __iter_without_category
 = !requires { typename _Iter::iterator_category; };

  }

  template<typename _Iterator>
    requires __detail::__iter_with_nested_types<_Iterator>
    struct __iterator_traits<_Iterator, void>
    {
    private:
      template<typename _Iter>
 struct __ptr
 { using type = void; };

      template<typename _Iter> requires requires { typename _Iter::pointer; }
 struct __ptr<_Iter>
 { using type = typename _Iter::pointer; };

    public:
      using iterator_category = typename _Iterator::iterator_category;
      using value_type = typename _Iterator::value_type;
      using difference_type = typename _Iterator::difference_type;
      using pointer = typename __ptr<_Iterator>::type;
      using reference = typename _Iterator::reference;
    };

  template<typename _Iterator>
    requires __detail::__iter_without_nested_types<_Iterator>
       && __detail::__cpp17_input_iterator<_Iterator>
    struct __iterator_traits<_Iterator, void>
    {
    private:
      template<typename _Iter>
 struct __cat
 { using type = input_iterator_tag; };

      template<typename _Iter>
 requires requires { typename _Iter::iterator_category; }
 struct __cat<_Iter>
 { using type = typename _Iter::iterator_category; };

      template<typename _Iter>
 requires __detail::__iter_without_category<_Iter>
    && __detail::__cpp17_randacc_iterator<_Iter>
 struct __cat<_Iter>
 { using type = random_access_iterator_tag; };

      template<typename _Iter>
 requires __detail::__iter_without_category<_Iter>
    && __detail::__cpp17_bidi_iterator<_Iter>
 struct __cat<_Iter>
 { using type = bidirectional_iterator_tag; };

      template<typename _Iter>
 requires __detail::__iter_without_category<_Iter>
    && __detail::__cpp17_fwd_iterator<_Iter>
 struct __cat<_Iter>
 { using type = forward_iterator_tag; };

      template<typename _Iter>
 struct __ptr
 { using type = void; };

      template<typename _Iter> requires requires { typename _Iter::pointer; }
 struct __ptr<_Iter>
 { using type = typename _Iter::pointer; };

      template<typename _Iter>
 requires (!requires { typename _Iter::pointer; }
     && requires(_Iter& __it) { __it.operator->(); })
 struct __ptr<_Iter>
 { using type = decltype(std::declval<_Iter&>().operator->()); };

      template<typename _Iter>
 struct __ref
 { using type = iter_reference_t<_Iter>; };

      template<typename _Iter> requires requires { typename _Iter::reference; }
 struct __ref<_Iter>
 { using type = typename _Iter::reference; };

    public:
      using iterator_category = typename __cat<_Iterator>::type;
      using value_type
 = typename indirectly_readable_traits<_Iterator>::value_type;
      using difference_type
 = typename incrementable_traits<_Iterator>::difference_type;
      using pointer = typename __ptr<_Iterator>::type;
      using reference = typename __ref<_Iterator>::type;
    };

  template<typename _Iterator>
    requires __detail::__iter_without_nested_types<_Iterator>
       && __detail::__cpp17_iterator<_Iterator>
    struct __iterator_traits<_Iterator, void>
    {
    private:
      template<typename _Iter>
 struct __diff
 { using type = void; };

      template<typename _Iter>
 requires requires
 { typename incrementable_traits<_Iter>::difference_type; }
 struct __diff<_Iter>
 {
   using type = typename incrementable_traits<_Iter>::difference_type;
 };

    public:
      using iterator_category = output_iterator_tag;
      using value_type = void;
      using difference_type = typename __diff<_Iterator>::type;
      using pointer = void;
      using reference = void;
    };

  namespace __detail
  {
    template<typename _Iter>
      struct __iter_concept_impl;


    template<typename _Iter>
      requires requires { typename __iter_traits<_Iter>::iterator_concept; }
      struct __iter_concept_impl<_Iter>
      { using type = typename __iter_traits<_Iter>::iterator_concept; };


    template<typename _Iter>
      requires (!requires { typename __iter_traits<_Iter>::iterator_concept; }
   && requires { typename __iter_traits<_Iter>::iterator_category; })
      struct __iter_concept_impl<_Iter>
      { using type = typename __iter_traits<_Iter>::iterator_category; };


    template<typename _Iter>
      requires (!requires { typename __iter_traits<_Iter>::iterator_concept; }
   && !requires { typename __iter_traits<_Iter>::iterator_category; }
   && __primary_traits_iter<_Iter>)
      struct __iter_concept_impl<_Iter>
      { using type = random_access_iterator_tag; };


    template<typename _Iter>
      struct __iter_concept_impl
      { };


    template<typename _Iter>
      using __iter_concept = typename __iter_concept_impl<_Iter>::type;

  template<typename _In>
    concept __indirectly_readable_impl = requires
      {
 typename iter_value_t<_In>;
 typename iter_reference_t<_In>;
 typename iter_rvalue_reference_t<_In>;
 requires same_as<iter_reference_t<const _In>,
    iter_reference_t<_In>>;
 requires same_as<iter_rvalue_reference_t<const _In>,
    iter_rvalue_reference_t<_In>>;
      }
      && common_reference_with<iter_reference_t<_In>&&, iter_value_t<_In>&>
      && common_reference_with<iter_reference_t<_In>&&,
         iter_rvalue_reference_t<_In>&&>
      && common_reference_with<iter_rvalue_reference_t<_In>&&,
          const iter_value_t<_In>&>;

  }


  template<typename _In>
    concept indirectly_readable
      = __detail::__indirectly_readable_impl<remove_cvref_t<_In>>;

  template<indirectly_readable _Tp>
    using iter_common_reference_t
      = common_reference_t<iter_reference_t<_Tp>, iter_value_t<_Tp>&>;


  template<typename _Out, typename _Tp>
    concept indirectly_writable = requires(_Out&& __o, _Tp&& __t)
      {
 *__o = std::forward<_Tp>(__t);
 *std::forward<_Out>(__o) = std::forward<_Tp>(__t);
 const_cast<const iter_reference_t<_Out>&&>(*__o)
   = std::forward<_Tp>(__t);
 const_cast<const iter_reference_t<_Out>&&>(*std::forward<_Out>(__o))
   = std::forward<_Tp>(__t);
      };

  namespace ranges::__detail
  {
    class __max_diff_type;
    class __max_size_type;

    __extension__
    template<typename _Tp>
      concept __is_signed_int128

 = same_as<_Tp, __int128>;




    __extension__
    template<typename _Tp>
      concept __is_unsigned_int128

 = same_as<_Tp, unsigned __int128>;




    template<typename _Tp>
      concept __cv_bool = same_as<const volatile _Tp, const volatile bool>;

    template<typename _Tp>
      concept __integral_nonbool = integral<_Tp> && !__cv_bool<_Tp>;

    template<typename _Tp>
      concept __is_int128 = __is_signed_int128<_Tp> || __is_unsigned_int128<_Tp>;

    template<typename _Tp>
      concept __is_integer_like = __integral_nonbool<_Tp>
 || __is_int128<_Tp>
 || same_as<_Tp, __max_diff_type> || same_as<_Tp, __max_size_type>;

    template<typename _Tp>
      concept __is_signed_integer_like = signed_integral<_Tp>
 || __is_signed_int128<_Tp>
 || same_as<_Tp, __max_diff_type>;

  }

  namespace __detail { using ranges::__detail::__is_signed_integer_like; }


  template<typename _Iter>
    concept weakly_incrementable = movable<_Iter>
      && requires(_Iter __i)
      {
 typename iter_difference_t<_Iter>;
 requires __detail::__is_signed_integer_like<iter_difference_t<_Iter>>;
 { ++__i } -> same_as<_Iter&>;
 __i++;
      };

  template<typename _Iter>
    concept incrementable = regular<_Iter> && weakly_incrementable<_Iter>
      && requires(_Iter __i) { { __i++ } -> same_as<_Iter>; };

  template<typename _Iter>
    concept input_or_output_iterator
      = requires(_Iter __i) { { *__i } -> __detail::__can_reference; }
 && weakly_incrementable<_Iter>;

  template<typename _Sent, typename _Iter>
    concept sentinel_for = semiregular<_Sent>
      && input_or_output_iterator<_Iter>
      && __detail::__weakly_eq_cmp_with<_Sent, _Iter>;

  template<typename _Sent, typename _Iter>
    inline constexpr bool disable_sized_sentinel_for = false;

  template<typename _Sent, typename _Iter>
    concept sized_sentinel_for = sentinel_for<_Sent, _Iter>
    && !disable_sized_sentinel_for<remove_cv_t<_Sent>, remove_cv_t<_Iter>>
    && requires(const _Iter& __i, const _Sent& __s)
    {
      { __s - __i } -> same_as<iter_difference_t<_Iter>>;
      { __i - __s } -> same_as<iter_difference_t<_Iter>>;
    };

  template<typename _Iter>
    concept input_iterator = input_or_output_iterator<_Iter>
      && indirectly_readable<_Iter>
      && requires { typename __detail::__iter_concept<_Iter>; }
      && derived_from<__detail::__iter_concept<_Iter>, input_iterator_tag>;

  template<typename _Iter, typename _Tp>
    concept output_iterator = input_or_output_iterator<_Iter>
      && indirectly_writable<_Iter, _Tp>
      && requires(_Iter __i, _Tp&& __t) { *__i++ = std::forward<_Tp>(__t); };

  template<typename _Iter>
    concept forward_iterator = input_iterator<_Iter>
      && derived_from<__detail::__iter_concept<_Iter>, forward_iterator_tag>
      && incrementable<_Iter> && sentinel_for<_Iter, _Iter>;

  template<typename _Iter>
    concept bidirectional_iterator = forward_iterator<_Iter>
      && derived_from<__detail::__iter_concept<_Iter>,
        bidirectional_iterator_tag>
      && requires(_Iter __i)
      {
 { --__i } -> same_as<_Iter&>;
 { __i-- } -> same_as<_Iter>;
      };

  template<typename _Iter>
    concept random_access_iterator = bidirectional_iterator<_Iter>
      && derived_from<__detail::__iter_concept<_Iter>,
        random_access_iterator_tag>
      && totally_ordered<_Iter> && sized_sentinel_for<_Iter, _Iter>
      && requires(_Iter __i, const _Iter __j,
    const iter_difference_t<_Iter> __n)
      {
 { __i += __n } -> same_as<_Iter&>;
 { __j + __n } -> same_as<_Iter>;
 { __n + __j } -> same_as<_Iter>;
 { __i -= __n } -> same_as<_Iter&>;
 { __j - __n } -> same_as<_Iter>;
 { __j[__n] } -> same_as<iter_reference_t<_Iter>>;
      };

  template<typename _Iter>
    concept contiguous_iterator = random_access_iterator<_Iter>
      && derived_from<__detail::__iter_concept<_Iter>, contiguous_iterator_tag>
      && is_lvalue_reference_v<iter_reference_t<_Iter>>
      && same_as<iter_value_t<_Iter>, remove_cvref_t<iter_reference_t<_Iter>>>
      && requires(const _Iter& __i)
      {
 { std::to_address(__i) }
   -> same_as<add_pointer_t<iter_reference_t<_Iter>>>;
      };





  template<typename _Fn, typename _Iter>
    concept indirectly_unary_invocable = indirectly_readable<_Iter>
      && copy_constructible<_Fn> && invocable<_Fn&, iter_value_t<_Iter>&>
      && invocable<_Fn&, iter_reference_t<_Iter>>
      && invocable<_Fn&, iter_common_reference_t<_Iter>>
      && common_reference_with<invoke_result_t<_Fn&, iter_value_t<_Iter>&>,
          invoke_result_t<_Fn&, iter_reference_t<_Iter>>>;

  template<typename _Fn, typename _Iter>
    concept indirectly_regular_unary_invocable = indirectly_readable<_Iter>
      && copy_constructible<_Fn>
      && regular_invocable<_Fn&, iter_value_t<_Iter>&>
      && regular_invocable<_Fn&, iter_reference_t<_Iter>>
      && regular_invocable<_Fn&, iter_common_reference_t<_Iter>>
      && common_reference_with<invoke_result_t<_Fn&, iter_value_t<_Iter>&>,
          invoke_result_t<_Fn&, iter_reference_t<_Iter>>>;

  template<typename _Fn, typename _Iter>
    concept indirect_unary_predicate = indirectly_readable<_Iter>
      && copy_constructible<_Fn> && predicate<_Fn&, iter_value_t<_Iter>&>
      && predicate<_Fn&, iter_reference_t<_Iter>>
      && predicate<_Fn&, iter_common_reference_t<_Iter>>;

  template<typename _Fn, typename _I1, typename _I2>
    concept indirect_binary_predicate
      = indirectly_readable<_I1> && indirectly_readable<_I2>
      && copy_constructible<_Fn>
      && predicate<_Fn&, iter_value_t<_I1>&, iter_value_t<_I2>&>
      && predicate<_Fn&, iter_value_t<_I1>&, iter_reference_t<_I2>>
      && predicate<_Fn&, iter_reference_t<_I1>, iter_value_t<_I2>&>
      && predicate<_Fn&, iter_reference_t<_I1>, iter_reference_t<_I2>>
      && predicate<_Fn&, iter_common_reference_t<_I1>,
     iter_common_reference_t<_I2>>;

  template<typename _Fn, typename _I1, typename _I2 = _I1>
    concept indirect_equivalence_relation
      = indirectly_readable<_I1> && indirectly_readable<_I2>
      && copy_constructible<_Fn>
      && equivalence_relation<_Fn&, iter_value_t<_I1>&, iter_value_t<_I2>&>
      && equivalence_relation<_Fn&, iter_value_t<_I1>&, iter_reference_t<_I2>>
      && equivalence_relation<_Fn&, iter_reference_t<_I1>, iter_value_t<_I2>&>
      && equivalence_relation<_Fn&, iter_reference_t<_I1>,
         iter_reference_t<_I2>>
      && equivalence_relation<_Fn&, iter_common_reference_t<_I1>,
         iter_common_reference_t<_I2>>;

  template<typename _Fn, typename _I1, typename _I2 = _I1>
    concept indirect_strict_weak_order
      = indirectly_readable<_I1> && indirectly_readable<_I2>
      && copy_constructible<_Fn>
      && strict_weak_order<_Fn&, iter_value_t<_I1>&, iter_value_t<_I2>&>
      && strict_weak_order<_Fn&, iter_value_t<_I1>&, iter_reference_t<_I2>>
      && strict_weak_order<_Fn&, iter_reference_t<_I1>, iter_value_t<_I2>&>
      && strict_weak_order<_Fn&, iter_reference_t<_I1>, iter_reference_t<_I2>>
      && strict_weak_order<_Fn&, iter_common_reference_t<_I1>,
      iter_common_reference_t<_I2>>;

  template<typename _Fn, typename... _Is>
    requires (indirectly_readable<_Is> && ...)
      && invocable<_Fn, iter_reference_t<_Is>...>
    using indirect_result_t = invoke_result_t<_Fn, iter_reference_t<_Is>...>;

  namespace __detail
  {
    template<typename _Iter, typename _Proj>
      struct __projected
      {
 struct __type
 {
   using value_type = remove_cvref_t<indirect_result_t<_Proj&, _Iter>>;
   indirect_result_t<_Proj&, _Iter> operator*() const;
 };
      };

    template<weakly_incrementable _Iter, typename _Proj>
      struct __projected<_Iter, _Proj>
      {
 struct __type
 {
   using value_type = remove_cvref_t<indirect_result_t<_Proj&, _Iter>>;
   using difference_type = iter_difference_t<_Iter>;
   indirect_result_t<_Proj&, _Iter> operator*() const;
 };
      };
  }


  template<indirectly_readable _Iter,
    indirectly_regular_unary_invocable<_Iter> _Proj>
    using projected = typename __detail::__projected<_Iter, _Proj>::__type;





  template<typename _In, typename _Out>
    concept indirectly_movable = indirectly_readable<_In>
      && indirectly_writable<_Out, iter_rvalue_reference_t<_In>>;

  template<typename _In, typename _Out>
    concept indirectly_movable_storable = indirectly_movable<_In, _Out>
      && indirectly_writable<_Out, iter_value_t<_In>>
      && movable<iter_value_t<_In>>
      && constructible_from<iter_value_t<_In>, iter_rvalue_reference_t<_In>>
      && assignable_from<iter_value_t<_In>&, iter_rvalue_reference_t<_In>>;


  template<typename _In, typename _Out>
    concept indirectly_copyable = indirectly_readable<_In>
      && indirectly_writable<_Out, iter_reference_t<_In>>;

  template<typename _In, typename _Out>
    concept indirectly_copyable_storable = indirectly_copyable<_In, _Out>
      && indirectly_writable<_Out, iter_value_t<_In>&>
      && indirectly_writable<_Out, const iter_value_t<_In>&>
      && indirectly_writable<_Out, iter_value_t<_In>&&>
      && indirectly_writable<_Out, const iter_value_t<_In>&&>
      && copyable<iter_value_t<_In>>
      && constructible_from<iter_value_t<_In>, iter_reference_t<_In>>
      && assignable_from<iter_value_t<_In>&, iter_reference_t<_In>>;

namespace ranges
{

  namespace __iswap
  {
    template<typename _It1, typename _It2>
      void iter_swap(_It1, _It2) = delete;

    template<typename _Tp, typename _Up>
      concept __adl_iswap
 = (std::__detail::__class_or_enum<remove_reference_t<_Tp>>
   || std::__detail::__class_or_enum<remove_reference_t<_Up>>)
 && requires(_Tp&& __t, _Up&& __u) {
   iter_swap(static_cast<_Tp&&>(__t), static_cast<_Up&&>(__u));
 };

    template<typename _Xp, typename _Yp>
      constexpr iter_value_t<_Xp>
      __iter_exchange_move(_Xp&& __x, _Yp&& __y)
      noexcept(noexcept(iter_value_t<_Xp>(iter_move(__x)))
        && noexcept(*__x = iter_move(__y)))
      {
 iter_value_t<_Xp> __old_value(iter_move(__x));
 *__x = iter_move(__y);
 return __old_value;
      }

    struct _IterSwap
    {
    private:
      template<typename _Tp, typename _Up>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__adl_iswap<_Tp, _Up>)
     return noexcept(iter_swap(std::declval<_Tp>(),
          std::declval<_Up>()));
   else if constexpr (indirectly_readable<_Tp>
       && indirectly_readable<_Up>
       && swappable_with<iter_reference_t<_Tp>, iter_reference_t<_Up>>)
     return noexcept(ranges::swap(*std::declval<_Tp>(),
      *std::declval<_Up>()));
   else
     return noexcept(*std::declval<_Tp>()
  = __iswap::__iter_exchange_move(std::declval<_Up>(),
          std::declval<_Tp>()));
 }

    public:
      template<typename _Tp, typename _Up>
 requires __adl_iswap<_Tp, _Up>
 || (indirectly_readable<remove_reference_t<_Tp>>
     && indirectly_readable<remove_reference_t<_Up>>
     && swappable_with<iter_reference_t<_Tp>, iter_reference_t<_Up>>)
 || (indirectly_movable_storable<_Tp, _Up>
     && indirectly_movable_storable<_Up, _Tp>)
 constexpr void
 operator()(_Tp&& __e1, _Up&& __e2) const
 noexcept(_S_noexcept<_Tp, _Up>())
 {
   if constexpr (__adl_iswap<_Tp, _Up>)
     iter_swap(static_cast<_Tp&&>(__e1), static_cast<_Up&&>(__e2));
   else if constexpr (indirectly_readable<_Tp>
       && indirectly_readable<_Up>
       && swappable_with<iter_reference_t<_Tp>, iter_reference_t<_Up>>)
     ranges::swap(*__e1, *__e2);
   else
     *__e1 = __iswap::__iter_exchange_move(__e2, __e1);
 }
    };
  }


  inline namespace _Cpo {
    inline constexpr __iswap::_IterSwap iter_swap{};
  }

}


  template<typename _I1, typename _I2 = _I1>
    concept indirectly_swappable
      = indirectly_readable<_I1> && indirectly_readable<_I2>
      && requires(const _I1 __i1, const _I2 __i2)
      {
 ranges::iter_swap(__i1, __i1);
 ranges::iter_swap(__i2, __i2);
 ranges::iter_swap(__i1, __i2);
 ranges::iter_swap(__i2, __i1);
      };


  template<typename _I1, typename _I2, typename _Rel, typename _P1 = identity,
    typename _P2 = identity>
    concept indirectly_comparable
      = indirect_binary_predicate<_Rel, projected<_I1, _P1>,
      projected<_I2, _P2>>;


  template<typename _Iter>
    concept permutable = forward_iterator<_Iter>
      && indirectly_movable_storable<_Iter, _Iter>
      && indirectly_swappable<_Iter, _Iter>;


  template<typename _I1, typename _I2, typename _Out,
    typename _Rel = ranges::less, typename _P1 = identity,
    typename _P2 = identity>
    concept mergeable = input_iterator<_I1> && input_iterator<_I2>
      && weakly_incrementable<_Out> && indirectly_copyable<_I1, _Out>
      && indirectly_copyable<_I2, _Out>
      && indirect_strict_weak_order<_Rel, projected<_I1, _P1>,
        projected<_I2, _P2>>;


  template<typename _Iter, typename _Rel = ranges::less,
    typename _Proj = identity>
    concept sortable = permutable<_Iter>
      && indirect_strict_weak_order<_Rel, projected<_Iter, _Proj>>;

  struct unreachable_sentinel_t
  {
    template<weakly_incrementable _It>
      friend constexpr bool
      operator==(unreachable_sentinel_t, const _It&) noexcept
      { return false; }
  };

  inline constexpr unreachable_sentinel_t unreachable_sentinel{};


  namespace ranges::__access
  {
    using std::__detail::__class_or_enum;

    struct _Decay_copy final
    {
      template<typename _Tp>
 constexpr decay_t<_Tp>
 operator()(_Tp&& __t) const
 noexcept(is_nothrow_convertible_v<_Tp, decay_t<_Tp>>)
 { return std::forward<_Tp>(__t); }
    } inline constexpr __decay_copy{};

    template<typename _Tp>
      concept __member_begin = requires(_Tp& __t)
 {
   { __decay_copy(__t.begin()) } -> input_or_output_iterator;
 };


    void begin() = delete;

    template<typename _Tp>
      concept __adl_begin = __class_or_enum<remove_reference_t<_Tp>>
 && requires(_Tp& __t)
 {
   { __decay_copy(begin(__t)) } -> input_or_output_iterator;
 };



    template<typename _Tp>
      requires is_array_v<_Tp> || __member_begin<_Tp&> || __adl_begin<_Tp&>
      auto
      __begin(_Tp& __t)
      {
 if constexpr (is_array_v<_Tp>)
   return __t + 0;
 else if constexpr (__member_begin<_Tp&>)
   return __t.begin();
 else
   return begin(__t);
      }
  }

  namespace __detail
  {

    template<typename _Tp>
      using __range_iter_t
 = decltype(ranges::__access::__begin(std::declval<_Tp&>()));

  }



}
# 72 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator_base_types.h" 2 3


namespace std
{

# 93 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };



  struct contiguous_iterator_tag : public random_access_iterator_tag { };
# 125 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct [[__deprecated__]] iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
# 149 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator_base_types.h" 3
  template<typename _Iterator>
    struct iterator_traits;




  template<typename _Iterator, typename = __void_t<>>
    struct __iterator_traits { };
# 176 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator_base_types.h" 3
  template<typename _Iterator>
    struct iterator_traits
    : public __iterator_traits<_Iterator> { };
# 194 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator_base_types.h" 3
  template<typename _Tp>

    requires is_object_v<_Tp>

    struct iterator_traits<_Tp*>
    {
      using iterator_concept = contiguous_iterator_tag;
      using iterator_category = random_access_iterator_tag;
      using value_type = remove_cv_t<_Tp>;
      using difference_type = ptrdiff_t;
      using pointer = _Tp*;
      using reference = _Tp&;
    };
# 235 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator_base_types.h" 3
  template<typename _Iter>
    __attribute__((__always_inline__))
    inline constexpr
    typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }




  template<typename _Iter>
    using __iter_category_t
      = typename iterator_traits<_Iter>::iterator_category;

  template<typename _InIter>
    using _RequireInputIter =
      __enable_if_t<is_convertible<__iter_category_t<_InIter>,
       input_iterator_tag>::value>;

  template<typename _It,
    typename _Cat = __iter_category_t<_It>>
    struct __is_random_access_iter
      : is_base_of<random_access_iterator_tag, _Cat>
    {
      typedef is_base_of<random_access_iterator_tag, _Cat> _Base;
      enum { __value = _Base::value };
    };








}
# 65 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator.h" 2 3
# 75 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator.h" 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/new" 1 3
# 38 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/new" 3
       
# 39 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/new" 3


# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/exception.h" 1 3
# 34 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/exception.h" 3
       
# 35 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/exception.h" 3



extern "C++" {

namespace std
{
# 59 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/exception.h" 3
  class exception
  {
  public:
    exception() noexcept { }
    virtual ~exception() noexcept;

    exception(const exception&) = default;
    exception& operator=(const exception&) = default;
    exception(exception&&) = default;
    exception& operator=(exception&&) = default;




    virtual const char*
    what() const noexcept;
  };



}

}
# 42 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/new" 2 3




# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 1 3
# 47 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 3
       
# 48 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 3
# 47 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/new" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }


    bad_alloc(const bad_alloc&) = default;
    bad_alloc& operator=(const bad_alloc&) = default;




    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };


  class bad_array_new_length : public bad_alloc
  {
  public:
    bad_array_new_length() throw() { }



    virtual ~bad_array_new_length() throw();


    virtual const char* what() const throw();
  };



  enum class align_val_t: size_t {};


  struct nothrow_t
  {

    explicit nothrow_t() = default;

  };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();



  new_handler get_new_handler() noexcept;

}
# 131 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/new" 3
[[__nodiscard__]] void* operator new(std::size_t)
  __attribute__((__externally_visible__));
[[__nodiscard__]] void* operator new[](std::size_t)
  __attribute__((__externally_visible__));
void operator delete(void*) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*) noexcept
  __attribute__((__externally_visible__));

void operator delete(void*, std::size_t) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, std::size_t) noexcept
  __attribute__((__externally_visible__));

[[__nodiscard__]] void* operator new(std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
[[__nodiscard__]] void* operator new[](std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
void operator delete(void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));

[[__nodiscard__]] void* operator new(std::size_t, std::align_val_t)
  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
[[__nodiscard__]] void* operator new(std::size_t, std::align_val_t, const std::nothrow_t&)
  noexcept __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
void operator delete(void*, std::align_val_t)
  noexcept __attribute__((__externally_visible__));
void operator delete(void*, std::align_val_t, const std::nothrow_t&)
  noexcept __attribute__((__externally_visible__));
[[__nodiscard__]] void* operator new[](std::size_t, std::align_val_t)
  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
[[__nodiscard__]] void* operator new[](std::size_t, std::align_val_t, const std::nothrow_t&)
  noexcept __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
void operator delete[](void*, std::align_val_t)
  noexcept __attribute__((__externally_visible__));
void operator delete[](void*, std::align_val_t, const std::nothrow_t&)
  noexcept __attribute__((__externally_visible__));

void operator delete(void*, std::size_t, std::align_val_t)
  noexcept __attribute__((__externally_visible__));
void operator delete[](void*, std::size_t, std::align_val_t)
  noexcept __attribute__((__externally_visible__));




[[__nodiscard__]] inline void* operator new(std::size_t, void* __p) noexcept
{ return __p; }
[[__nodiscard__]] inline void* operator new[](std::size_t, void* __p) noexcept
{ return __p; }


inline void operator delete (void*, void*) noexcept { }
inline void operator delete[](void*, void*) noexcept { }

}


namespace std
{


  template<typename _Tp>
    [[nodiscard]] constexpr _Tp*
    launder(_Tp* __p) noexcept
    { return __builtin_launder(__p); }




  template<typename _Ret, typename... _Args , bool _NE>
    void launder(_Ret (*)(_Args...) noexcept (_NE)) = delete;
  template<typename _Ret, typename... _Args , bool _NE>
    void launder(_Ret (*)(_Args......) noexcept (_NE)) = delete;

  void launder(void*) = delete;
  void launder(const void*) = delete;
  void launder(volatile void*) = delete;
  void launder(const volatile void*) = delete;



  inline constexpr size_t hardware_destructive_interference_size = 64;
  inline constexpr size_t hardware_constructive_interference_size = 64;

}




namespace std
{


  struct destroying_delete_t
  {
    explicit destroying_delete_t() = default;
  };

  inline constexpr destroying_delete_t destroying_delete{};
}


#pragma GCC visibility pop
# 76 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator.h" 2 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/exception_defines.h" 1 3
# 77 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator.h" 2 3

# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_construct.h" 1 3
# 62 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_construct.h" 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator_base_funcs.h" 1 3
# 62 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator_base_funcs.h" 3
       
# 63 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator_base_funcs.h" 3

# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/concept_check.h" 1 3
# 33 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/concept_check.h" 3
       
# 34 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/concept_check.h" 3
# 65 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator_base_funcs.h" 2 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/debug/assertions.h" 1 3
# 66 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator_base_funcs.h" 2 3


namespace std
{




  template <typename> struct _List_iterator;
  template <typename> struct _List_const_iterator;


  template<typename _InputIterator>
    inline constexpr
    typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {

     

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    __attribute__((__always_inline__))
    inline constexpr
    typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {

     

      return __last - __first;
    }



  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_iterator<_Tp>,
        std::_List_iterator<_Tp>,
        input_iterator_tag);

  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_const_iterator<_Tp>,
        std::_List_const_iterator<_Tp>,
        input_iterator_tag);




  template<typename _OutputIterator>
    void
    __distance(_OutputIterator, _OutputIterator, output_iterator_tag) = delete;
# 144 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    [[__nodiscard__]] __attribute__((__always_inline__))
    inline constexpr
    typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline constexpr void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {

     
      do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__n >= 0), false)) std::__glibcxx_assert_fail(); } while (false);
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline constexpr void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {

     

      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline constexpr void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {

     

      if (__builtin_constant_p(__n) && __n == 1)
 ++__i;
      else if (__builtin_constant_p(__n) && __n == -1)
 --__i;
      else
 __i += __n;
    }



  template<typename _OutputIterator, typename _Distance>
    void
    __advance(_OutputIterator&, _Distance, output_iterator_tag) = delete;
# 217 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    __attribute__((__always_inline__))
    inline constexpr void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }



  template<typename _InputIterator>
    [[__nodiscard__]] [[__gnu__::__always_inline__]]
    inline constexpr _InputIterator
    next(_InputIterator __x, typename
  iterator_traits<_InputIterator>::difference_type __n = 1)
    {

     
      std::advance(__x, __n);
      return __x;
    }

  template<typename _BidirectionalIterator>
    [[__nodiscard__]] [[__gnu__::__always_inline__]]
    inline constexpr _BidirectionalIterator
    prev(_BidirectionalIterator __x, typename
  iterator_traits<_BidirectionalIterator>::difference_type __n = 1)
    {

     

      std::advance(__x, -__n);
      return __x;
    }




}
# 63 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_construct.h" 2 3
# 73 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_construct.h" 3
namespace std
{



  template <typename _Tp>
    constexpr inline void
    destroy_at(_Tp* __location)
    {
      if constexpr (202400L > 201703L && is_array_v<_Tp>)
 {
   for (auto& __x : *__location)
     std::destroy_at(std::__addressof(__x));
 }
      else
 __location->~_Tp();
    }


  template<typename _Tp, typename... _Args>
    constexpr auto
    construct_at(_Tp* __location, _Args&&... __args)
    noexcept(noexcept(::new((void*)0) _Tp(std::declval<_Args>()...)))
    -> decltype(::new((void*)0) _Tp(std::declval<_Args>()...))
    { return ::new((void*)__location) _Tp(std::forward<_Args>(__args)...); }
# 106 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_construct.h" 3
  template<typename _Tp, typename... _Args>
    constexpr
    inline void
    _Construct(_Tp* __p, _Args&&... __args)
    {

      if (std::__is_constant_evaluated())
 {

   std::construct_at(__p, std::forward<_Args>(__args)...);
   return;
 }

      ::new((void*)__p) _Tp(std::forward<_Args>(__args)...);
    }
# 132 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_construct.h" 3
  template<typename _T1>
    inline void
    _Construct_novalue(_T1* __p)
    { ::new((void*)__p) _T1; }

  template<typename _ForwardIterator>
    constexpr void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last);




  template<typename _Tp>
    constexpr inline void
    _Destroy(_Tp* __pointer)
    {

      std::destroy_at(__pointer);



    }

  template<bool>
    struct _Destroy_aux
    {
      template<typename _ForwardIterator>
 static constexpr void
 __destroy(_ForwardIterator __first, _ForwardIterator __last)
 {
   for (; __first != __last; ++__first)
     std::_Destroy(std::__addressof(*__first));
 }
    };

  template<>
    struct _Destroy_aux<true>
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator, _ForwardIterator) { }
    };






  template<typename _ForwardIterator>
    constexpr inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;


      static_assert(is_destructible<_Value_type>::value,
      "value type is destructible");


      if (std::__is_constant_evaluated())
 return std::_Destroy_aux<false>::__destroy(__first, __last);

      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
 __destroy(__first, __last);
    }

  template<bool>
    struct _Destroy_n_aux
    {
      template<typename _ForwardIterator, typename _Size>
 static constexpr _ForwardIterator
 __destroy_n(_ForwardIterator __first, _Size __count)
 {
   for (; __count > 0; (void)++__first, --__count)
     std::_Destroy(std::__addressof(*__first));
   return __first;
 }
    };

  template<>
    struct _Destroy_n_aux<true>
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __destroy_n(_ForwardIterator __first, _Size __count)
 {
   std::advance(__first, __count);
   return __first;
 }
    };






  template<typename _ForwardIterator, typename _Size>
    constexpr inline _ForwardIterator
    _Destroy_n(_ForwardIterator __first, _Size __count)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;


      static_assert(is_destructible<_Value_type>::value,
      "value type is destructible");


      if (std::__is_constant_evaluated())
 return std::_Destroy_n_aux<false>::__destroy_n(__first, __count);

      return std::_Destroy_n_aux<__has_trivial_destructor(_Value_type)>::
 __destroy_n(__first, __count);
    }


  template <typename _ForwardIterator>
    constexpr inline void
    destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      std::_Destroy(__first, __last);
    }

  template <typename _ForwardIterator, typename _Size>
    constexpr inline _ForwardIterator
    destroy_n(_ForwardIterator __first, _Size __count)
    {
      return std::_Destroy_n(__first, __count);
    }



}
# 79 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator.h" 2 3






namespace std
{








  namespace __detail
  {


    template<typename _Cat, typename _Limit, typename _Otherwise = _Cat>
      using __clamp_iter_cat
 = __conditional_t<derived_from<_Cat, _Limit>, _Limit, _Otherwise>;
  }



#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
# 128 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
      template<typename _Iter>
 friend class reverse_iterator;




      template<typename _Iter>
 static constexpr bool __convertible = !is_same_v<_Iter, _Iterator>
     && convertible_to<const _Iter&, _Iterator>;


    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::pointer pointer;




      using iterator_concept
 = __conditional_t<random_access_iterator<_Iterator>,
     random_access_iterator_tag,
     bidirectional_iterator_tag>;
      using iterator_category
 = __detail::__clamp_iter_cat<typename __traits_type::iterator_category,
         random_access_iterator_tag>;
      using value_type = iter_value_t<_Iterator>;
      using difference_type = iter_difference_t<_Iterator>;
      using reference = iter_reference_t<_Iterator>;
# 178 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator.h" 3
      constexpr
      reverse_iterator()
      noexcept(noexcept(_Iterator()))
      : current()
      { }




      explicit constexpr
      reverse_iterator(iterator_type __x)
      noexcept(noexcept(_Iterator(__x)))
      : current(__x)
      { }




      constexpr
      reverse_iterator(const reverse_iterator& __x)
      noexcept(noexcept(_Iterator(__x.current)))
      : current(__x.current)
      { }


      reverse_iterator& operator=(const reverse_iterator&) = default;






      template<typename _Iter>

 requires __convertible<_Iter>

 constexpr
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 noexcept(noexcept(_Iterator(__x.current)))
 : current(__x.current)
 { }


      template<typename _Iter>

 requires __convertible<_Iter>
   && assignable_from<_Iterator&, const _Iter&>

 constexpr
 reverse_iterator&
 operator=(const reverse_iterator<_Iter>& __x)
 noexcept(noexcept(current = __x.current))
 {
   current = __x.current;
   return *this;
 }





      [[__nodiscard__]]
      constexpr iterator_type
      base() const
      noexcept(noexcept(_Iterator(current)))
      { return current; }
# 255 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator.h" 3
      [[__nodiscard__]]
      constexpr reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      [[__nodiscard__]]
      constexpr pointer
      operator->() const

      requires is_pointer_v<_Iterator>
 || requires(const _Iterator __i) { __i.operator->(); }

      {


 _Iterator __tmp = current;
 --__tmp;
 return _S_to_pointer(__tmp);
      }






      constexpr reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      constexpr reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      constexpr reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      constexpr reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      [[__nodiscard__]]
      constexpr reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }







      constexpr reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      [[__nodiscard__]]
      constexpr reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }







      constexpr reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      [[__nodiscard__]]
      constexpr reference
      operator[](difference_type __n) const
      { return *(*this + __n); }


      [[nodiscard]]
      friend constexpr iter_rvalue_reference_t<_Iterator>
      iter_move(const reverse_iterator& __i)
      noexcept(is_nothrow_copy_constructible_v<_Iterator>
        && noexcept(ranges::iter_move(--std::declval<_Iterator&>())))
      {
 auto __tmp = __i.base();
 return ranges::iter_move(--__tmp);
      }

      template<indirectly_swappable<_Iterator> _Iter2>
 friend constexpr void
 iter_swap(const reverse_iterator& __x,
    const reverse_iterator<_Iter2>& __y)
 noexcept(is_nothrow_copy_constructible_v<_Iterator>
   && is_nothrow_copy_constructible_v<_Iter2>
   && noexcept(ranges::iter_swap(--std::declval<_Iterator&>(),
            --std::declval<_Iter2&>())))
 {
   auto __xtmp = __x.base();
   auto __ytmp = __y.base();
   ranges::iter_swap(--__xtmp, --__ytmp);
 }


    private:
      template<typename _Tp>
 static constexpr _Tp*
 _S_to_pointer(_Tp* __p)
        { return __p; }

      template<typename _Tp>
 static constexpr pointer
 _S_to_pointer(_Tp __t)
        { return __t.operator->(); }
    };
# 524 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR>
    [[nodiscard]]
    constexpr bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    requires requires { { __x.base() == __y.base() } -> convertible_to<bool>; }
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    [[nodiscard]]
    constexpr bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    requires requires { { __x.base() != __y.base() } -> convertible_to<bool>; }
    { return __x.base() != __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    [[nodiscard]]
    constexpr bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    requires requires { { __x.base() > __y.base() } -> convertible_to<bool>; }
    { return __x.base() > __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    [[nodiscard]]
    constexpr bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    requires requires { { __x.base() < __y.base() } -> convertible_to<bool>; }
    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    [[nodiscard]]
    constexpr bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    requires requires { { __x.base() >= __y.base() } -> convertible_to<bool>; }
    { return __x.base() >= __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    [[nodiscard]]
    constexpr bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    requires requires { { __x.base() <= __y.base() } -> convertible_to<bool>; }
    { return __x.base() <= __y.base(); }

  template<typename _IteratorL,
    three_way_comparable_with<_IteratorL> _IteratorR>
    [[nodiscard]]
    constexpr compare_three_way_result_t<_IteratorL, _IteratorR>
    operator<=>(const reverse_iterator<_IteratorL>& __x,
  const reverse_iterator<_IteratorR>& __y)
    { return __y.base() <=> __x.base(); }




  template<typename _Iterator>
    [[nodiscard]]
    constexpr bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    requires requires { { __x.base() == __y.base() } -> convertible_to<bool>; }
    { return __x.base() == __y.base(); }

  template<three_way_comparable _Iterator>
    [[nodiscard]]
    constexpr compare_three_way_result_t<_Iterator, _Iterator>
    operator<=>(const reverse_iterator<_Iterator>& __x,
  const reverse_iterator<_Iterator>& __y)
    { return __y.base() <=> __x.base(); }
# 615 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr auto
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    -> decltype(__y.base() - __x.base())
    { return __y.base() - __x.base(); }


  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _Iterator>
    inline constexpr reverse_iterator<_Iterator>
    __make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }





  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr reverse_iterator<_Iterator>
    make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }


  template<typename _Iterator1, typename _Iterator2>
    requires (!sized_sentinel_for<_Iterator1, _Iterator2>)
    inline constexpr bool
    disable_sized_sentinel_for<reverse_iterator<_Iterator1>,
          reverse_iterator<_Iterator2>> = true;



  template<typename _Iterator>
    constexpr
    auto
    __niter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__niter_base(__it.base())))
    { return __make_reverse_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<reverse_iterator<_Iterator> >
      : __is_move_iterator<_Iterator>
    { };

  template<typename _Iterator>
    constexpr
    auto
    __miter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__miter_base(__it.base())))
    { return __make_reverse_iterator(__miter_base(__it.base())); }
# 688 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;

      using difference_type = ptrdiff_t;



      explicit constexpr
      back_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 726 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator.h" 3
      constexpr
      back_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_back(__value);
 return *this;
      }

      constexpr
      back_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_back(std::move(__value));
 return *this;
      }



      [[__nodiscard__]] constexpr
      back_insert_iterator&
      operator*()
      { return *this; }


      constexpr
      back_insert_iterator&
      operator++()
      { return *this; }


      constexpr
      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 773 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
    [[__nodiscard__]] constexpr
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 789 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;

      using difference_type = ptrdiff_t;



      explicit constexpr
      front_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 827 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator.h" 3
      constexpr
      front_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_front(__value);
 return *this;
      }

      constexpr
      front_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_front(std::move(__value));
 return *this;
      }



      [[__nodiscard__]] constexpr
      front_insert_iterator&
      operator*()
      { return *this; }


      constexpr
      front_insert_iterator&
      operator++()
      { return *this; }


      constexpr
      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 874 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
    [[__nodiscard__]] constexpr
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 894 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {

      using _Iter = std::__detail::__range_iter_t<_Container>;



    protected:
      _Container* container;
      _Iter iter;

    public:

      typedef _Container container_type;


      using difference_type = ptrdiff_t;






      constexpr
      insert_iterator(_Container& __x, _Iter __i)
      : container(std::__addressof(__x)), iter(__i) {}
# 955 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator.h" 3
      constexpr
      insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }

      constexpr
      insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 iter = container->insert(iter, std::move(__value));
 ++iter;
 return *this;
      }



      [[__nodiscard__]] constexpr
      insert_iterator&
      operator*()
      { return *this; }


      constexpr
      insert_iterator&
      operator++()
      { return *this; }


      constexpr
      insert_iterator&
      operator++(int)
      { return *this; }
    };

#pragma GCC diagnostic pop
# 1008 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
    [[nodiscard]]
    constexpr insert_iterator<_Container>
    inserter(_Container& __x, std::__detail::__range_iter_t<_Container> __i)
    { return insert_iterator<_Container>(__x, __i); }
# 1023 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator.h" 3

}

namespace __gnu_cxx
{

# 1037 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator.h" 3
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef std::iterator_traits<_Iterator> __traits_type;


      template<typename _Iter>
 using __convertible_from
   = std::__enable_if_t<std::is_convertible<_Iter, _Iterator>::value>;


    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;


      using iterator_concept = std::__detail::__iter_concept<_Iterator>;


      constexpr __normal_iterator() noexcept
      : _M_current(_Iterator()) { }

      explicit constexpr
      __normal_iterator(const _Iterator& __i) noexcept
      : _M_current(__i) { }



      template<typename _Iter, typename = __convertible_from<_Iter>>
 constexpr
 __normal_iterator(const __normal_iterator<_Iter, _Container>& __i)
 noexcept
# 1085 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator.h" 3
        : _M_current(__i.base()) { }


      constexpr
      reference
      operator*() const noexcept
      { return *_M_current; }

      constexpr
      pointer
      operator->() const noexcept
      { return _M_current; }

      constexpr
      __normal_iterator&
      operator++() noexcept
      {
 ++_M_current;
 return *this;
      }

      constexpr
      __normal_iterator
      operator++(int) noexcept
      { return __normal_iterator(_M_current++); }


      constexpr
      __normal_iterator&
      operator--() noexcept
      {
 --_M_current;
 return *this;
      }

      constexpr
      __normal_iterator
      operator--(int) noexcept
      { return __normal_iterator(_M_current--); }


      constexpr
      reference
      operator[](difference_type __n) const noexcept
      { return _M_current[__n]; }

      constexpr
      __normal_iterator&
      operator+=(difference_type __n) noexcept
      { _M_current += __n; return *this; }

      constexpr
      __normal_iterator
      operator+(difference_type __n) const noexcept
      { return __normal_iterator(_M_current + __n); }

      constexpr
      __normal_iterator&
      operator-=(difference_type __n) noexcept
      { _M_current -= __n; return *this; }

      constexpr
      __normal_iterator
      operator-(difference_type __n) const noexcept
      { return __normal_iterator(_M_current - __n); }

      constexpr
      const _Iterator&
      base() const noexcept
      { return _M_current; }
    };
# 1166 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    [[nodiscard]]
    constexpr bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept(noexcept(__lhs.base() == __rhs.base()))
    requires requires {
      { __lhs.base() == __rhs.base() } -> std::convertible_to<bool>;
    }
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    [[nodiscard]]
    constexpr std::__detail::__synth3way_t<_IteratorR, _IteratorL>
    operator<=>(const __normal_iterator<_IteratorL, _Container>& __lhs,
  const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept(noexcept(std::__detail::__synth3way(__lhs.base(), __rhs.base())))
    { return std::__detail::__synth3way(__lhs.base(), __rhs.base()); }

  template<typename _Iterator, typename _Container>
    [[nodiscard]]
    constexpr bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept(noexcept(__lhs.base() == __rhs.base()))
    requires requires {
      { __lhs.base() == __rhs.base() } -> std::convertible_to<bool>;
    }
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    [[nodiscard]]
    constexpr std::__detail::__synth3way_t<_Iterator>
    operator<=>(const __normal_iterator<_Iterator, _Container>& __lhs,
  const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept(noexcept(std::__detail::__synth3way(__lhs.base(), __rhs.base())))
    { return std::__detail::__synth3way(__lhs.base(), __rhs.base()); }
# 1307 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>


    [[__nodiscard__]] constexpr
    inline auto
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs) noexcept
    -> decltype(__lhs.base() - __rhs.base())





    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    [[__nodiscard__]] constexpr
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    [[__nodiscard__]] constexpr
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    noexcept
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }


}

namespace std
{


  template<typename _Iterator, typename _Container>
    constexpr
    _Iterator
    __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it)
    noexcept(std::is_nothrow_copy_constructible<_Iterator>::value)
    { return __it.base(); }
# 1371 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator.h" 3
  template<semiregular _Sent>
    class move_sentinel
    {
    public:
      constexpr
      move_sentinel()
      noexcept(is_nothrow_default_constructible_v<_Sent>)
      : _M_last() { }

      constexpr explicit
      move_sentinel(_Sent __s)
      noexcept(is_nothrow_move_constructible_v<_Sent>)
      : _M_last(std::move(__s)) { }

      template<typename _S2> requires convertible_to<const _S2&, _Sent>
 constexpr
 move_sentinel(const move_sentinel<_S2>& __s)
 noexcept(is_nothrow_constructible_v<_Sent, const _S2&>)
 : _M_last(__s.base())
 { }

      template<typename _S2> requires assignable_from<_Sent&, const _S2&>
 constexpr move_sentinel&
 operator=(const move_sentinel<_S2>& __s)
 noexcept(is_nothrow_assignable_v<_Sent, const _S2&>)
 {
   _M_last = __s.base();
   return *this;
 }

      [[nodiscard]]
      constexpr _Sent
      base() const
      noexcept(is_nothrow_copy_constructible_v<_Sent>)
      { return _M_last; }

    private:
      _Sent _M_last;
    };


  namespace __detail
  {

    template<typename _Iterator>
      struct __move_iter_cat
      { };

    template<typename _Iterator>
      requires requires { typename __iter_category_t<_Iterator>; }
      struct __move_iter_cat<_Iterator>
      {
 using iterator_category
   = __clamp_iter_cat<__iter_category_t<_Iterator>,
        random_access_iterator_tag>;
      };

  }
# 1439 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class move_iterator

      : public __detail::__move_iter_cat<_Iterator>

    {
      _Iterator _M_current;

      using __traits_type = iterator_traits<_Iterator>;




      template<typename _Iter2>
 friend class move_iterator;




      template<typename _Iter2>
 static constexpr bool __convertible = !is_same_v<_Iter2, _Iterator>
     && convertible_to<const _Iter2&, _Iterator>;



      static auto
      _S_iter_concept()
      {
 if constexpr (random_access_iterator<_Iterator>)
   return random_access_iterator_tag{};
 else if constexpr (bidirectional_iterator<_Iterator>)
   return bidirectional_iterator_tag{};
 else if constexpr (forward_iterator<_Iterator>)
   return forward_iterator_tag{};
 else
   return input_iterator_tag{};
      }


    public:
      using iterator_type = _Iterator;


      using iterator_concept = decltype(_S_iter_concept());


      using value_type = iter_value_t<_Iterator>;
      using difference_type = iter_difference_t<_Iterator>;
      using pointer = _Iterator;
      using reference = iter_rvalue_reference_t<_Iterator>;
# 1503 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator.h" 3
      constexpr
      move_iterator()
      : _M_current() { }

      explicit constexpr
      move_iterator(iterator_type __i)
      : _M_current(std::move(__i)) { }

      template<typename _Iter>

 requires __convertible<_Iter>

 constexpr
 move_iterator(const move_iterator<_Iter>& __i)
 : _M_current(__i._M_current) { }

      template<typename _Iter>

 requires __convertible<_Iter>
   && assignable_from<_Iterator&, const _Iter&>

 constexpr
 move_iterator& operator=(const move_iterator<_Iter>& __i)
 {
   _M_current = __i._M_current;
   return *this;
 }







      [[nodiscard]]
      constexpr const iterator_type&
      base() const & noexcept
      { return _M_current; }

      [[nodiscard]]
      constexpr iterator_type
      base() &&
      { return std::move(_M_current); }


      [[__nodiscard__]]
      constexpr reference
      operator*() const

      { return ranges::iter_move(_M_current); }




      [[__nodiscard__]]
      constexpr pointer
      operator->() const
      { return _M_current; }

      constexpr move_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      constexpr move_iterator
      operator++(int)
      {
 move_iterator __tmp = *this;
 ++_M_current;
 return __tmp;
      }


      constexpr void
      operator++(int) requires (!forward_iterator<_Iterator>)
      { ++_M_current; }


      constexpr move_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      constexpr move_iterator
      operator--(int)
      {
 move_iterator __tmp = *this;
 --_M_current;
 return __tmp;
      }

      [[__nodiscard__]]
      constexpr move_iterator
      operator+(difference_type __n) const
      { return move_iterator(_M_current + __n); }

      constexpr move_iterator&
      operator+=(difference_type __n)
      {
 _M_current += __n;
 return *this;
      }

      [[__nodiscard__]]
      constexpr move_iterator
      operator-(difference_type __n) const
      { return move_iterator(_M_current - __n); }

      constexpr move_iterator&
      operator-=(difference_type __n)
      {
 _M_current -= __n;
 return *this;
      }

      [[__nodiscard__]]
      constexpr reference
      operator[](difference_type __n) const

      { return ranges::iter_move(_M_current + __n); }





      template<sentinel_for<_Iterator> _Sent>
 [[nodiscard]]
 friend constexpr bool
 operator==(const move_iterator& __x, const move_sentinel<_Sent>& __y)
 { return __x.base() == __y.base(); }

      template<sized_sentinel_for<_Iterator> _Sent>
 [[nodiscard]]
 friend constexpr iter_difference_t<_Iterator>
 operator-(const move_sentinel<_Sent>& __x, const move_iterator& __y)
 { return __x.base() - __y.base(); }

      template<sized_sentinel_for<_Iterator> _Sent>
 [[nodiscard]]
 friend constexpr iter_difference_t<_Iterator>
 operator-(const move_iterator& __x, const move_sentinel<_Sent>& __y)
 { return __x.base() - __y.base(); }

      [[nodiscard]]
      friend constexpr iter_rvalue_reference_t<_Iterator>
      iter_move(const move_iterator& __i)
      noexcept(noexcept(ranges::iter_move(__i._M_current)))
      { return ranges::iter_move(__i._M_current); }

      template<indirectly_swappable<_Iterator> _Iter2>
 friend constexpr void
 iter_swap(const move_iterator& __x, const move_iterator<_Iter2>& __y)
 noexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current)))
 { return ranges::iter_swap(__x._M_current, __y._M_current); }

    };

  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator==(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)

    requires requires { { __x.base() == __y.base() } -> convertible_to<bool>; }

    { return __x.base() == __y.base(); }


  template<typename _IteratorL,
    three_way_comparable_with<_IteratorL> _IteratorR>
    [[__nodiscard__]]
    constexpr compare_three_way_result_t<_IteratorL, _IteratorR>
    operator<=>(const move_iterator<_IteratorL>& __x,
  const move_iterator<_IteratorR>& __y)
    { return __x.base() <=> __y.base(); }
# 1691 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator<(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)

    requires requires { { __x.base() < __y.base() } -> convertible_to<bool>; }

    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator<=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)

    requires requires { { __y.base() < __x.base() } -> convertible_to<bool>; }

    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator>(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)

    requires requires { { __y.base() < __x.base() } -> convertible_to<bool>; }

    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator>=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)

    requires requires { { __x.base() < __y.base() } -> convertible_to<bool>; }

    { return !(__x < __y); }




  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr bool
    operator==(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }


  template<three_way_comparable _Iterator>
    [[__nodiscard__]]
    constexpr compare_three_way_result_t<_Iterator>
    operator<=>(const move_iterator<_Iterator>& __x,
  const move_iterator<_Iterator>& __y)
    { return __x.base() <=> __y.base(); }
# 1786 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr auto
    operator-(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr move_iterator<_Iterator>
    operator+(typename move_iterator<_Iterator>::difference_type __n,
       const move_iterator<_Iterator>& __x)
    { return __x + __n; }

  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr move_iterator<_Iterator>
    make_move_iterator(_Iterator __i)
    { return move_iterator<_Iterator>(std::move(__i)); }

  template<typename _Iterator, typename _ReturnType
    = __conditional_t<__move_if_noexcept_cond
      <typename iterator_traits<_Iterator>::value_type>::value,
  _Iterator, move_iterator<_Iterator>>>
    inline constexpr _ReturnType
    __make_move_if_noexcept_iterator(_Iterator __i)
    { return _ReturnType(__i); }



  template<typename _Tp, typename _ReturnType
    = __conditional_t<__move_if_noexcept_cond<_Tp>::value,
        const _Tp*, move_iterator<_Tp*>>>
    inline constexpr _ReturnType
    __make_move_if_noexcept_iterator(_Tp* __i)
    { return _ReturnType(__i); }




  namespace __detail
  {
    template<typename _It>
      concept __common_iter_has_arrow = indirectly_readable<const _It>
 && (requires(const _It& __it) { __it.operator->(); }
     || is_reference_v<iter_reference_t<_It>>
     || constructible_from<iter_value_t<_It>, iter_reference_t<_It>>);

    template<typename _It>
      concept __common_iter_use_postfix_proxy
 = (!requires (_It& __i) { { *__i++ } -> __can_reference; })
   && constructible_from<iter_value_t<_It>, iter_reference_t<_It>>
   && move_constructible<iter_value_t<_It>>;
  }


  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
    requires (!same_as<_It, _Sent>) && copyable<_It>
  class common_iterator
  {
    template<typename _Tp, typename _Up>
      static constexpr bool
      _S_noexcept1()
      {
 if constexpr (is_trivially_default_constructible_v<_Tp>)
   return is_nothrow_assignable_v<_Tp&, _Up>;
 else
   return is_nothrow_constructible_v<_Tp, _Up>;
      }

    template<typename _It2, typename _Sent2>
      static constexpr bool
      _S_noexcept()
      { return _S_noexcept1<_It, _It2>() && _S_noexcept1<_Sent, _Sent2>(); }

    class __arrow_proxy
    {
      iter_value_t<_It> _M_keep;

      constexpr
      __arrow_proxy(iter_reference_t<_It>&& __x)
      : _M_keep(std::move(__x)) { }

      friend class common_iterator;

    public:
      constexpr const iter_value_t<_It>*
      operator->() const noexcept
      { return std::__addressof(_M_keep); }
    };

    class __postfix_proxy
    {
      iter_value_t<_It> _M_keep;

      constexpr
      __postfix_proxy(iter_reference_t<_It>&& __x)
      : _M_keep(std::forward<iter_reference_t<_It>>(__x)) { }

      friend class common_iterator;

    public:
      constexpr const iter_value_t<_It>&
      operator*() const noexcept
      { return _M_keep; }
    };

  public:
    constexpr
    common_iterator()
    noexcept(is_nothrow_default_constructible_v<_It>)
    requires default_initializable<_It>
    : _M_it(), _M_index(0)
    { }

    constexpr
    common_iterator(_It __i)
    noexcept(is_nothrow_move_constructible_v<_It>)
    : _M_it(std::move(__i)), _M_index(0)
    { }

    constexpr
    common_iterator(_Sent __s)
    noexcept(is_nothrow_move_constructible_v<_Sent>)
    : _M_sent(std::move(__s)), _M_index(1)
    { }

    template<typename _It2, typename _Sent2>
      requires convertible_to<const _It2&, _It>
 && convertible_to<const _Sent2&, _Sent>
      constexpr
      common_iterator(const common_iterator<_It2, _Sent2>& __x)
      noexcept(_S_noexcept<const _It2&, const _Sent2&>())
      : _M_valueless(), _M_index(__x._M_index)
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__x._M_has_value()), false)) std::__glibcxx_assert_fail(); } while (false);
 if (_M_index == 0)
   {
     if constexpr (is_trivially_default_constructible_v<_It>)
       _M_it = std::move(__x._M_it);
     else
       std::construct_at(std::__addressof(_M_it), __x._M_it);
   }
 else if (_M_index == 1)
   {
     if constexpr (is_trivially_default_constructible_v<_Sent>)
       _M_sent = std::move(__x._M_sent);
     else
       std::construct_at(std::__addressof(_M_sent), __x._M_sent);
   }
      }

    common_iterator(const common_iterator&) = default;

    constexpr
    common_iterator(const common_iterator& __x)
    noexcept(_S_noexcept<const _It&, const _Sent&>())
    requires (!is_trivially_copyable_v<_It> || !is_trivially_copyable_v<_Sent>)
    : _M_valueless(), _M_index(__x._M_index)
    {
      if (_M_index == 0)
 {
   if constexpr (is_trivially_default_constructible_v<_It>)
     _M_it = __x._M_it;
   else
     std::construct_at(std::__addressof(_M_it), __x._M_it);
 }
      else if (_M_index == 1)
 {
   if constexpr (is_trivially_default_constructible_v<_Sent>)
     _M_sent = __x._M_sent;
   else
     std::construct_at(std::__addressof(_M_sent), __x._M_sent);
 }
    }

    common_iterator(common_iterator&&) = default;

    constexpr
    common_iterator(common_iterator&& __x)
    noexcept(_S_noexcept<_It, _Sent>())
    requires (!is_trivially_copyable_v<_It> || !is_trivially_copyable_v<_Sent>)
    : _M_valueless(), _M_index(__x._M_index)
    {
      if (_M_index == 0)
 {
   if constexpr (is_trivially_default_constructible_v<_It>)
     _M_it = std::move(__x._M_it);
   else
     std::construct_at(std::__addressof(_M_it), std::move(__x._M_it));
 }
      else if (_M_index == 1)
 {
   if constexpr (is_trivially_default_constructible_v<_Sent>)
     _M_sent = std::move(__x._M_sent);
   else
     std::construct_at(std::__addressof(_M_sent),
         std::move(__x._M_sent));
 }
    }

    constexpr common_iterator&
    operator=(const common_iterator&) = default;

    constexpr common_iterator&
    operator=(const common_iterator& __x)
    noexcept(is_nothrow_copy_assignable_v<_It>
      && is_nothrow_copy_assignable_v<_Sent>
      && is_nothrow_copy_constructible_v<_It>
      && is_nothrow_copy_constructible_v<_Sent>)
    requires (!is_trivially_copy_assignable_v<_It>
  || !is_trivially_copy_assignable_v<_Sent>)
    {
      _M_assign(__x);
      return *this;
    }

    constexpr common_iterator&
    operator=(common_iterator&&) = default;

    constexpr common_iterator&
    operator=(common_iterator&& __x)
    noexcept(is_nothrow_move_assignable_v<_It>
      && is_nothrow_move_assignable_v<_Sent>
      && is_nothrow_move_constructible_v<_It>
      && is_nothrow_move_constructible_v<_Sent>)
    requires (!is_trivially_move_assignable_v<_It>
  || !is_trivially_move_assignable_v<_Sent>)
    {
      _M_assign(std::move(__x));
      return *this;
    }

    template<typename _It2, typename _Sent2>
      requires convertible_to<const _It2&, _It>
 && convertible_to<const _Sent2&, _Sent>
 && assignable_from<_It&, const _It2&>
 && assignable_from<_Sent&, const _Sent2&>
      constexpr common_iterator&
      operator=(const common_iterator<_It2, _Sent2>& __x)
      noexcept(is_nothrow_constructible_v<_It, const _It2&>
        && is_nothrow_constructible_v<_Sent, const _Sent2&>
        && is_nothrow_assignable_v<_It&, const _It2&>
        && is_nothrow_assignable_v<_Sent&, const _Sent2&>)
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__x._M_has_value()), false)) std::__glibcxx_assert_fail(); } while (false);
 _M_assign(__x);
 return *this;
      }


    ~common_iterator() = default;

    constexpr
    ~common_iterator()
      requires (!is_trivially_destructible_v<_It>
    || !is_trivially_destructible_v<_Sent>)




    {
      if (_M_index == 0)
 _M_it.~_It();
      else if (_M_index == 1)
 _M_sent.~_Sent();
    }

    [[nodiscard]]
    constexpr decltype(auto)
    operator*()
    {
      do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(_M_index == 0), false)) std::__glibcxx_assert_fail(); } while (false);
      return *_M_it;
    }

    [[nodiscard]]
    constexpr decltype(auto)
    operator*() const requires __detail::__dereferenceable<const _It>
    {
      do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(_M_index == 0), false)) std::__glibcxx_assert_fail(); } while (false);
      return *_M_it;
    }

    [[nodiscard]]
    constexpr auto
    operator->() const requires __detail::__common_iter_has_arrow<_It>
    {
      do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(_M_index == 0), false)) std::__glibcxx_assert_fail(); } while (false);
      if constexpr (is_pointer_v<_It> || requires { _M_it.operator->(); })
 return _M_it;
      else if constexpr (is_reference_v<iter_reference_t<_It>>)
 {
   auto&& __tmp = *_M_it;
   return std::__addressof(__tmp);
 }
      else
 return __arrow_proxy{*_M_it};
    }

    constexpr common_iterator&
    operator++()
    {
      do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(_M_index == 0), false)) std::__glibcxx_assert_fail(); } while (false);
      ++_M_it;
      return *this;
    }

    constexpr decltype(auto)
    operator++(int)
    {
      do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(_M_index == 0), false)) std::__glibcxx_assert_fail(); } while (false);
      if constexpr (forward_iterator<_It>)
 {
   common_iterator __tmp = *this;
   ++*this;
   return __tmp;
 }
      else if constexpr (!__detail::__common_iter_use_postfix_proxy<_It>)
 return _M_it++;
      else
 {
   __postfix_proxy __p(**this);
   ++*this;
   return __p;
 }
    }

    template<typename _It2, sentinel_for<_It> _Sent2>
      requires sentinel_for<_Sent, _It2>
      friend constexpr bool
      operator== [[nodiscard]] (const common_iterator& __x,
    const common_iterator<_It2, _Sent2>& __y)
      {
 switch(__x._M_index << 2 | __y._M_index)
   {
   case 0b0000:
   case 0b0101:
     return true;
   case 0b0001:
     return __x._M_it == __y._M_sent;
   case 0b0100:
     return __x._M_sent == __y._M_it;
   default:
     do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__x._M_has_value()), false)) std::__glibcxx_assert_fail(); } while (false);
     do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__y._M_has_value()), false)) std::__glibcxx_assert_fail(); } while (false);
     __builtin_unreachable();
   }
      }

    template<typename _It2, sentinel_for<_It> _Sent2>
      requires sentinel_for<_Sent, _It2> && equality_comparable_with<_It, _It2>
      friend constexpr bool
      operator== [[nodiscard]] (const common_iterator& __x,
    const common_iterator<_It2, _Sent2>& __y)
      {
 switch(__x._M_index << 2 | __y._M_index)
   {
   case 0b0101:
     return true;
   case 0b0000:
     return __x._M_it == __y._M_it;
   case 0b0001:
     return __x._M_it == __y._M_sent;
   case 0b0100:
     return __x._M_sent == __y._M_it;
   default:
     do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__x._M_has_value()), false)) std::__glibcxx_assert_fail(); } while (false);
     do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__y._M_has_value()), false)) std::__glibcxx_assert_fail(); } while (false);
     __builtin_unreachable();
   }
      }

    template<sized_sentinel_for<_It> _It2, sized_sentinel_for<_It> _Sent2>
      requires sized_sentinel_for<_Sent, _It2>
      friend constexpr iter_difference_t<_It2>
      operator- [[nodiscard]] (const common_iterator& __x,
          const common_iterator<_It2, _Sent2>& __y)
      {
 switch(__x._M_index << 2 | __y._M_index)
   {
   case 0b0101:
     return 0;
   case 0b0000:
     return __x._M_it - __y._M_it;
   case 0b0001:
     return __x._M_it - __y._M_sent;
   case 0b0100:
     return __x._M_sent - __y._M_it;
   default:
     do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__x._M_has_value()), false)) std::__glibcxx_assert_fail(); } while (false);
     do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__y._M_has_value()), false)) std::__glibcxx_assert_fail(); } while (false);
     __builtin_unreachable();
   }
      }

    [[nodiscard]]
    friend constexpr iter_rvalue_reference_t<_It>
    iter_move(const common_iterator& __i)
    noexcept(noexcept(ranges::iter_move(std::declval<const _It&>())))
    requires input_iterator<_It>
    {
      do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__i._M_index == 0), false)) std::__glibcxx_assert_fail(); } while (false);
      return ranges::iter_move(__i._M_it);
    }

    template<indirectly_swappable<_It> _It2, typename _Sent2>
      friend constexpr void
      iter_swap(const common_iterator& __x,
  const common_iterator<_It2, _Sent2>& __y)
      noexcept(noexcept(ranges::iter_swap(std::declval<const _It&>(),
       std::declval<const _It2&>())))
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__x._M_index == 0), false)) std::__glibcxx_assert_fail(); } while (false);
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__y._M_index == 0), false)) std::__glibcxx_assert_fail(); } while (false);
 return ranges::iter_swap(__x._M_it, __y._M_it);
      }

  private:
    template<input_or_output_iterator _It2, sentinel_for<_It2> _Sent2>
      requires (!same_as<_It2, _Sent2>) && copyable<_It2>
      friend class common_iterator;

    constexpr bool
    _M_has_value() const noexcept { return _M_index != _S_valueless; }

    template<typename _CIt>
      constexpr void
      _M_assign(_CIt&& __x)
      {
 if (_M_index == __x._M_index)
   {
     if (_M_index == 0)
       _M_it = std::forward<_CIt>(__x)._M_it;
     else if (_M_index == 1)
       _M_sent = std::forward<_CIt>(__x)._M_sent;
   }
 else
   {
     if (_M_index == 0)
       _M_it.~_It();
     else if (_M_index == 1)
       _M_sent.~_Sent();
     _M_index = _S_valueless;

     if (__x._M_index == 0)
       std::construct_at(std::__addressof(_M_it),
    std::forward<_CIt>(__x)._M_it);
     else if (__x._M_index == 1)
       std::construct_at(std::__addressof(_M_sent),
    std::forward<_CIt>(__x)._M_sent);
     _M_index = __x._M_index;
   }
      }

    union
    {
      _It _M_it;
      _Sent _M_sent;
      unsigned char _M_valueless;
    };
    unsigned char _M_index;

    static constexpr unsigned char _S_valueless{2};
  };

  template<typename _It, typename _Sent>
    struct incrementable_traits<common_iterator<_It, _Sent>>
    {
      using difference_type = iter_difference_t<_It>;
    };

  template<input_iterator _It, typename _Sent>
    struct iterator_traits<common_iterator<_It, _Sent>>
    {
    private:
      template<typename _Iter>
 struct __ptr
 {
   using type = void;
 };

      template<typename _Iter>
 requires __detail::__common_iter_has_arrow<_Iter>
 struct __ptr<_Iter>
 {
   using _CIter = common_iterator<_Iter, _Sent>;
   using type = decltype(std::declval<const _CIter&>().operator->());
 };

      static auto
      _S_iter_cat()
      {
 if constexpr (requires { requires derived_from<__iter_category_t<_It>,
             forward_iterator_tag>; })
   return forward_iterator_tag{};
 else
   return input_iterator_tag{};
      }

    public:
      using iterator_concept = __conditional_t<forward_iterator<_It>,
            forward_iterator_tag,
            input_iterator_tag>;
      using iterator_category = decltype(_S_iter_cat());
      using value_type = iter_value_t<_It>;
      using difference_type = iter_difference_t<_It>;
      using pointer = typename __ptr<_It>::type;
      using reference = iter_reference_t<_It>;
    };



  namespace __detail
  {
    template<typename _It>
      struct __counted_iter_value_type
      { };

    template<indirectly_readable _It>
      struct __counted_iter_value_type<_It>
      { using value_type = iter_value_t<_It>; };

    template<typename _It>
      struct __counted_iter_concept
      { };

    template<typename _It>
      requires requires { typename _It::iterator_concept; }
      struct __counted_iter_concept<_It>
      { using iterator_concept = typename _It::iterator_concept; };

    template<typename _It>
      struct __counted_iter_cat
      { };

    template<typename _It>
      requires requires { typename _It::iterator_category; }
      struct __counted_iter_cat<_It>
      { using iterator_category = typename _It::iterator_category; };
  }


  template<input_or_output_iterator _It>
    class counted_iterator
      : public __detail::__counted_iter_value_type<_It>,
 public __detail::__counted_iter_concept<_It>,
 public __detail::__counted_iter_cat<_It>
    {
    public:
      using iterator_type = _It;

      using difference_type = iter_difference_t<_It>;



      constexpr counted_iterator() requires default_initializable<_It> = default;

      constexpr
      counted_iterator(_It __i, iter_difference_t<_It> __n)
      : _M_current(std::move(__i)), _M_length(__n)
      { do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__n >= 0), false)) std::__glibcxx_assert_fail(); } while (false); }

      template<typename _It2>
 requires convertible_to<const _It2&, _It>
 constexpr
 counted_iterator(const counted_iterator<_It2>& __x)
 : _M_current(__x._M_current), _M_length(__x._M_length)
 { }

      template<typename _It2>
 requires assignable_from<_It&, const _It2&>
 constexpr counted_iterator&
 operator=(const counted_iterator<_It2>& __x)
 {
   _M_current = __x._M_current;
   _M_length = __x._M_length;
   return *this;
 }

      [[nodiscard]]
      constexpr const _It&
      base() const & noexcept
      { return _M_current; }

      [[nodiscard]]
      constexpr _It
      base() &&
      noexcept(is_nothrow_move_constructible_v<_It>)
      { return std::move(_M_current); }

      [[nodiscard]]
      constexpr iter_difference_t<_It>
      count() const noexcept { return _M_length; }

      [[nodiscard]]
      constexpr decltype(auto)
      operator*()
      noexcept(noexcept(*_M_current))
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(_M_length > 0), false)) std::__glibcxx_assert_fail(); } while (false);
 return *_M_current;
      }

      [[nodiscard]]
      constexpr decltype(auto)
      operator*() const
      noexcept(noexcept(*_M_current))
      requires __detail::__dereferenceable<const _It>
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(_M_length > 0), false)) std::__glibcxx_assert_fail(); } while (false);
 return *_M_current;
      }

      [[nodiscard]]
      constexpr auto
      operator->() const noexcept
      requires contiguous_iterator<_It>
      { return std::to_address(_M_current); }

      constexpr counted_iterator&
      operator++()
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(_M_length > 0), false)) std::__glibcxx_assert_fail(); } while (false);
 ++_M_current;
 --_M_length;
 return *this;
      }

      constexpr decltype(auto)
      operator++(int)
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(_M_length > 0), false)) std::__glibcxx_assert_fail(); } while (false);
 --_M_length;
 try
   {
     return _M_current++;
   } catch(...) {
     ++_M_length;
     throw;
   }
      }

      constexpr counted_iterator
      operator++(int) requires forward_iterator<_It>
      {
 auto __tmp = *this;
 ++*this;
 return __tmp;
      }

      constexpr counted_iterator&
      operator--() requires bidirectional_iterator<_It>
      {
 --_M_current;
 ++_M_length;
 return *this;
      }

      constexpr counted_iterator
      operator--(int) requires bidirectional_iterator<_It>
      {
 auto __tmp = *this;
 --*this;
 return __tmp;
      }

      [[nodiscard]]
      constexpr counted_iterator
      operator+(iter_difference_t<_It> __n) const
 requires random_access_iterator<_It>
      { return counted_iterator(_M_current + __n, _M_length - __n); }

      [[nodiscard]]
      friend constexpr counted_iterator
      operator+(iter_difference_t<_It> __n, const counted_iterator& __x)
      requires random_access_iterator<_It>
      { return __x + __n; }

      constexpr counted_iterator&
      operator+=(iter_difference_t<_It> __n)
      requires random_access_iterator<_It>
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__n <= _M_length), false)) std::__glibcxx_assert_fail(); } while (false);
 _M_current += __n;
 _M_length -= __n;
 return *this;
      }

      [[nodiscard]]
      constexpr counted_iterator
      operator-(iter_difference_t<_It> __n) const
      requires random_access_iterator<_It>
      { return counted_iterator(_M_current - __n, _M_length + __n); }

      template<common_with<_It> _It2>
 [[nodiscard]]
 friend constexpr iter_difference_t<_It2>
 operator-(const counted_iterator& __x,
    const counted_iterator<_It2>& __y)
 { return __y._M_length - __x._M_length; }

      [[nodiscard]]
      friend constexpr iter_difference_t<_It>
      operator-(const counted_iterator& __x, default_sentinel_t)
      { return -__x._M_length; }

      [[nodiscard]]
      friend constexpr iter_difference_t<_It>
      operator-(default_sentinel_t, const counted_iterator& __y)
      { return __y._M_length; }

      constexpr counted_iterator&
      operator-=(iter_difference_t<_It> __n)
      requires random_access_iterator<_It>
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(-__n <= _M_length), false)) std::__glibcxx_assert_fail(); } while (false);
 _M_current -= __n;
 _M_length += __n;
 return *this;
      }

      [[nodiscard]]
      constexpr decltype(auto)
      operator[](iter_difference_t<_It> __n) const
      noexcept(noexcept(_M_current[__n]))
      requires random_access_iterator<_It>
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__n < _M_length), false)) std::__glibcxx_assert_fail(); } while (false);
 return _M_current[__n];
      }

      template<common_with<_It> _It2>
 [[nodiscard]]
 friend constexpr bool
 operator==(const counted_iterator& __x,
     const counted_iterator<_It2>& __y)
 { return __x._M_length == __y._M_length; }

      [[nodiscard]]
      friend constexpr bool
      operator==(const counted_iterator& __x, default_sentinel_t)
      { return __x._M_length == 0; }

      template<common_with<_It> _It2>
 [[nodiscard]]
 friend constexpr strong_ordering
 operator<=>(const counted_iterator& __x,
      const counted_iterator<_It2>& __y)
 { return __y._M_length <=> __x._M_length; }

      [[nodiscard]]
      friend constexpr iter_rvalue_reference_t<_It>
      iter_move(const counted_iterator& __i)
      noexcept(noexcept(ranges::iter_move(__i._M_current)))
      requires input_iterator<_It>
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__i._M_length > 0), false)) std::__glibcxx_assert_fail(); } while (false);
 return ranges::iter_move(__i._M_current);
      }

      template<indirectly_swappable<_It> _It2>
 friend constexpr void
 iter_swap(const counted_iterator& __x,
    const counted_iterator<_It2>& __y)
 noexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current)))
 {
   do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__x._M_length > 0 && __y._M_length > 0), false)) std::__glibcxx_assert_fail(); } while (false);
   ranges::iter_swap(__x._M_current, __y._M_current);
 }

    private:
      template<input_or_output_iterator _It2> friend class counted_iterator;

      _It _M_current = _It();
      iter_difference_t<_It> _M_length = 0;
    };

  template<input_iterator _It>
    requires same_as<__detail::__iter_traits<_It>, iterator_traits<_It>>
    struct iterator_traits<counted_iterator<_It>> : iterator_traits<_It>
    {
      using pointer = __conditional_t<contiguous_iterator<_It>,
          add_pointer_t<iter_reference_t<_It>>,
          void>;
    };


  template<indirectly_readable _It>
    using iter_const_reference_t
      = common_reference_t<const iter_value_t<_It>&&, iter_reference_t<_It>>;

  template<input_iterator _It> class basic_const_iterator;

  namespace __detail
  {
    template<typename _It>
      concept __constant_iterator = input_iterator<_It>
 && same_as<iter_const_reference_t<_It>, iter_reference_t<_It>>;

    template<typename _Tp>
      inline constexpr bool __is_const_iterator = false;

    template<typename _It>
      inline constexpr bool __is_const_iterator<basic_const_iterator<_It>> = true;

    template<typename _Tp>
      concept __not_a_const_iterator = !__is_const_iterator<_Tp>;

    template<indirectly_readable _It>
      using __iter_const_rvalue_reference_t
 = common_reference_t<const iter_value_t<_It>&&, iter_rvalue_reference_t<_It>>;

    template<typename _It>
      struct __basic_const_iterator_iter_cat
      { };

    template<forward_iterator _It>
      struct __basic_const_iterator_iter_cat<_It>
      { using iterator_category = __iter_category_t<_It>; };
  }

  template<input_iterator _It>
    using const_iterator
      = __conditional_t<__detail::__constant_iterator<_It>, _It, basic_const_iterator<_It>>;

  namespace __detail
  {
    template<typename _Sent>
      struct __const_sentinel
      { using type = _Sent; };

    template<input_iterator _Sent>
      struct __const_sentinel<_Sent>
      { using type = const_iterator<_Sent>; };
  }

  template<semiregular _Sent>
    using const_sentinel = typename __detail::__const_sentinel<_Sent>::type;

  template<input_iterator _It>
  class basic_const_iterator
  : public __detail::__basic_const_iterator_iter_cat<_It>
  {
    _It _M_current = _It();
    using __reference = iter_const_reference_t<_It>;
    using __rvalue_reference = __detail::__iter_const_rvalue_reference_t<_It>;

    static auto
    _S_iter_concept()
    {
      if constexpr (contiguous_iterator<_It>)
 return contiguous_iterator_tag{};
      else if constexpr (random_access_iterator<_It>)
 return random_access_iterator_tag{};
      else if constexpr (bidirectional_iterator<_It>)
 return bidirectional_iterator_tag{};
      else if constexpr (forward_iterator<_It>)
 return forward_iterator_tag{};
      else
 return input_iterator_tag{};
    }

    template<input_iterator _It2> friend class basic_const_iterator;

  public:
    using iterator_concept = decltype(_S_iter_concept());
    using value_type = iter_value_t<_It>;
    using difference_type = iter_difference_t<_It>;

    basic_const_iterator() requires default_initializable<_It> = default;

    constexpr
    basic_const_iterator(_It __current)
    noexcept(is_nothrow_move_constructible_v<_It>)
    : _M_current(std::move(__current))
    { }

    template<convertible_to<_It> _It2>
      constexpr
      basic_const_iterator(basic_const_iterator<_It2> __current)
      noexcept(is_nothrow_constructible_v<_It, _It2>)
      : _M_current(std::move(__current._M_current))
      { }

    template<__detail::__different_from<basic_const_iterator> _Tp>
      requires convertible_to<_Tp, _It>
      constexpr
      basic_const_iterator(_Tp&& __current)
      noexcept(is_nothrow_constructible_v<_It, _Tp>)
      : _M_current(std::forward<_Tp>(__current))
      { }

    constexpr const _It&
    base() const & noexcept
    { return _M_current; }

    constexpr _It
    base() &&
    noexcept(is_nothrow_move_constructible_v<_It>)
    { return std::move(_M_current); }

    constexpr __reference
    operator*() const
    noexcept(noexcept(static_cast<__reference>(*_M_current)))
    { return static_cast<__reference>(*_M_current); }

    constexpr const auto*
    operator->() const
    noexcept(contiguous_iterator<_It> || noexcept(*_M_current))
    requires is_lvalue_reference_v<iter_reference_t<_It>>
      && same_as<remove_cvref_t<iter_reference_t<_It>>, value_type>
    {
      if constexpr (contiguous_iterator<_It>)
 return std::to_address(_M_current);
      else
 return std::__addressof(*_M_current);
    }

    constexpr basic_const_iterator&
    operator++()
    noexcept(noexcept(++_M_current))
    {
      ++_M_current;
      return *this;
    }

    constexpr void
    operator++(int)
    noexcept(noexcept(++_M_current))
    { ++_M_current; }

    constexpr basic_const_iterator
    operator++(int)
    noexcept(noexcept(++*this) && is_nothrow_copy_constructible_v<basic_const_iterator>)
    requires forward_iterator<_It>
    {
      auto __tmp = *this;
      ++*this;
      return __tmp;
    }

    constexpr basic_const_iterator&
    operator--()
    noexcept(noexcept(--_M_current))
    requires bidirectional_iterator<_It>
    {
      --_M_current;
      return *this;
    }

    constexpr basic_const_iterator
    operator--(int)
    noexcept(noexcept(--*this) && is_nothrow_copy_constructible_v<basic_const_iterator>)
    requires bidirectional_iterator<_It>
    {
      auto __tmp = *this;
      --*this;
      return __tmp;
    }

    constexpr basic_const_iterator&
    operator+=(difference_type __n)
    noexcept(noexcept(_M_current += __n))
    requires random_access_iterator<_It>
    {
      _M_current += __n;
      return *this;
    }

    constexpr basic_const_iterator&
    operator-=(difference_type __n)
    noexcept(noexcept(_M_current -= __n))
    requires random_access_iterator<_It>
    {
      _M_current -= __n;
      return *this;
    }

    constexpr __reference
    operator[](difference_type __n) const
    noexcept(noexcept(static_cast<__reference>(_M_current[__n])))
    requires random_access_iterator<_It>
    { return static_cast<__reference>(_M_current[__n]); }

    template<sentinel_for<_It> _Sent>
      constexpr bool
      operator==(const _Sent& __s) const
      noexcept(noexcept(_M_current == __s))
      { return _M_current == __s; }

    template<__detail::__not_a_const_iterator _CIt>
      requires __detail::__constant_iterator<_CIt> && convertible_to<_It, _CIt>
    constexpr
    operator _CIt() const&
    { return _M_current; }

    template<__detail::__not_a_const_iterator _CIt>
      requires __detail::__constant_iterator<_CIt> && convertible_to<_It, _CIt>
    constexpr
    operator _CIt() &&
    { return std::move(_M_current); }

    constexpr bool
    operator<(const basic_const_iterator& __y) const
    noexcept(noexcept(_M_current < __y._M_current))
    requires random_access_iterator<_It>
    { return _M_current < __y._M_current; }

    constexpr bool
    operator>(const basic_const_iterator& __y) const
    noexcept(noexcept(_M_current > __y._M_current))
    requires random_access_iterator<_It>
    { return _M_current > __y._M_current; }

    constexpr bool
    operator<=(const basic_const_iterator& __y) const
    noexcept(noexcept(_M_current <= __y._M_current))
    requires random_access_iterator<_It>
    { return _M_current <= __y._M_current; }

    constexpr bool
    operator>=(const basic_const_iterator& __y) const
    noexcept(noexcept(_M_current >= __y._M_current))
    requires random_access_iterator<_It>
    { return _M_current >= __y._M_current; }

    constexpr auto
    operator<=>(const basic_const_iterator& __y) const
    noexcept(noexcept(_M_current <=> __y._M_current))
    requires random_access_iterator<_It> && three_way_comparable<_It>
    { return _M_current <=> __y._M_current; }

    template<__detail::__different_from<basic_const_iterator> _It2>
      constexpr bool
      operator<(const _It2& __y) const
      noexcept(noexcept(_M_current < __y))
      requires random_access_iterator<_It> && totally_ordered_with<_It, _It2>
      { return _M_current < __y; }

    template<__detail::__different_from<basic_const_iterator> _It2>
      constexpr bool
      operator>(const _It2& __y) const
      noexcept(noexcept(_M_current > __y))
      requires random_access_iterator<_It> && totally_ordered_with<_It, _It2>
      { return _M_current > __y; }

    template<__detail::__different_from<basic_const_iterator> _It2>
      constexpr bool
      operator<=(const _It2& __y) const
      noexcept(noexcept(_M_current <= __y))
      requires random_access_iterator<_It> && totally_ordered_with<_It, _It2>
      { return _M_current <= __y; }

    template<__detail::__different_from<basic_const_iterator> _It2>
      constexpr bool
      operator>=(const _It2& __y) const
      noexcept(noexcept(_M_current >= __y))
      requires random_access_iterator<_It> && totally_ordered_with<_It, _It2>
      { return _M_current >= __y; }

    template<__detail::__different_from<basic_const_iterator> _It2>
      constexpr auto
      operator<=>(const _It2& __y) const
      noexcept(noexcept(_M_current <=> __y))
      requires random_access_iterator<_It> && totally_ordered_with<_It, _It2>
 && three_way_comparable_with<_It, _It2>
      { return _M_current <=> __y; }

    template<__detail::__not_a_const_iterator _It2>
      friend constexpr bool
      operator<(const _It2& __x, const basic_const_iterator& __y)
      noexcept(noexcept(__x < __y._M_current))
      requires random_access_iterator<_It> && totally_ordered_with<_It, _It2>
      { return __x < __y._M_current; }

    template<__detail::__not_a_const_iterator _It2>
      friend constexpr bool
      operator>(const _It2& __x, const basic_const_iterator& __y)
      noexcept(noexcept(__x > __y._M_current))
      requires random_access_iterator<_It> && totally_ordered_with<_It, _It2>
      { return __x > __y._M_current; }

    template<__detail::__not_a_const_iterator _It2>
      friend constexpr bool
      operator<=(const _It2& __x, const basic_const_iterator& __y)
      noexcept(noexcept(__x <= __y._M_current))
      requires random_access_iterator<_It> && totally_ordered_with<_It, _It2>
      { return __x <= __y._M_current; }

    template<__detail::__not_a_const_iterator _It2>
      friend constexpr bool
      operator>=(const _It2& __x, const basic_const_iterator& __y)
      noexcept(noexcept(__x >= __y._M_current))
      requires random_access_iterator<_It> && totally_ordered_with<_It, _It2>
      { return __x >= __y._M_current; }

    friend constexpr basic_const_iterator
    operator+(const basic_const_iterator& __i, difference_type __n)
    noexcept(noexcept(basic_const_iterator(__i._M_current + __n)))
    requires random_access_iterator<_It>
    { return basic_const_iterator(__i._M_current + __n); }

    friend constexpr basic_const_iterator
    operator+(difference_type __n, const basic_const_iterator& __i)
    noexcept(noexcept(basic_const_iterator(__i._M_current + __n)))
    requires random_access_iterator<_It>
    { return basic_const_iterator(__i._M_current + __n); }

    friend constexpr basic_const_iterator
    operator-(const basic_const_iterator& __i, difference_type __n)
    noexcept(noexcept(basic_const_iterator(__i._M_current - __n)))
    requires random_access_iterator<_It>
    { return basic_const_iterator(__i._M_current - __n); }

    template<sized_sentinel_for<_It> _Sent>
      constexpr difference_type
      operator-(const _Sent& __y) const
      noexcept(noexcept(_M_current - __y))
      { return _M_current - __y; }

    template<__detail::__not_a_const_iterator _Sent>
      requires sized_sentinel_for<_Sent, _It>
      friend constexpr difference_type
      operator-(const _Sent& __x, const basic_const_iterator& __y)
      noexcept(noexcept(__x - __y._M_current))
      { return __x - __y._M_current; }

    friend constexpr __rvalue_reference
    iter_move(const basic_const_iterator& __i)
    noexcept(noexcept(static_cast<__rvalue_reference>(ranges::iter_move(__i._M_current))))
    { return static_cast<__rvalue_reference>(ranges::iter_move(__i._M_current)); }
  };

  template<typename _Tp, common_with<_Tp> _Up>
    requires input_iterator<common_type_t<_Tp, _Up>>
    struct common_type<basic_const_iterator<_Tp>, _Up>
    { using type = basic_const_iterator<common_type_t<_Tp, _Up>>; };

  template<typename _Tp, common_with<_Tp> _Up>
    requires input_iterator<common_type_t<_Tp, _Up>>
    struct common_type<_Up, basic_const_iterator<_Tp>>
    { using type = basic_const_iterator<common_type_t<_Tp, _Up>>; };

  template<typename _Tp, common_with<_Tp> _Up>
    requires input_iterator<common_type_t<_Tp, _Up>>
    struct common_type<basic_const_iterator<_Tp>, basic_const_iterator<_Up>>
    { using type = basic_const_iterator<common_type_t<_Tp, _Up>>; };

  template<input_iterator _It>
    constexpr const_iterator<_It>
    make_const_iterator(_It __it)
    noexcept(is_nothrow_convertible_v<_It, const_iterator<_It>>)
    { return __it; }

  template<semiregular _Sent>
    constexpr const_sentinel<_Sent>
    make_const_sentinel(_Sent __s)
    noexcept(is_nothrow_convertible_v<_Sent, const_sentinel<_Sent>>)
    { return __s; }





  template<typename _Iterator>
    constexpr
    auto
    __niter_base(move_iterator<_Iterator> __it)
    -> decltype(make_move_iterator(__niter_base(__it.base())))
    { return make_move_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<move_iterator<_Iterator> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<typename _Iterator>
    constexpr
    auto
    __miter_base(move_iterator<_Iterator> __it)
    -> decltype(__miter_base(__it.base()))
    { return __miter_base(__it.base()); }
# 2984 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_iterator.h" 3
  template<typename _InputIterator>
    using __iter_key_t = remove_const_t<

      tuple_element_t<0, typename iterator_traits<_InputIterator>::value_type>>;




  template<typename _InputIterator>
    using __iter_val_t

      = tuple_element_t<1, typename iterator_traits<_InputIterator>::value_type>;




  template<typename _T1, typename _T2>
    struct pair;

  template<typename _InputIterator>
    using __iter_to_alloc_t
      = pair<const __iter_key_t<_InputIterator>, __iter_val_t<_InputIterator>>;



}
# 38 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/ranges_base.h" 2 3

# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/max_size_type.h" 1 3
# 33 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/max_size_type.h" 3
       
# 34 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/max_size_type.h" 3



# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/numbers" 1 3
# 32 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/numbers" 3
       
# 33 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/numbers" 3


# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 1 3
# 47 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 3
       
# 48 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 3
# 36 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/numbers" 2 3





namespace std
{








namespace numbers
{


  template<typename _Tp>
    using _Enable_if_floating = enable_if_t<is_floating_point_v<_Tp>, _Tp>;



  template<typename _Tp>
    inline constexpr _Tp e_v
      = _Enable_if_floating<_Tp>(2.718281828459045235360287471352662498L);


  template<typename _Tp>
    inline constexpr _Tp log2e_v
      = _Enable_if_floating<_Tp>(1.442695040888963407359924681001892137L);


  template<typename _Tp>
    inline constexpr _Tp log10e_v
      = _Enable_if_floating<_Tp>(0.434294481903251827651128918916605082L);


  template<typename _Tp>
    inline constexpr _Tp pi_v
      = _Enable_if_floating<_Tp>(3.141592653589793238462643383279502884L);


  template<typename _Tp>
    inline constexpr _Tp inv_pi_v
      = _Enable_if_floating<_Tp>(0.318309886183790671537767526745028724L);


  template<typename _Tp>
    inline constexpr _Tp inv_sqrtpi_v
      = _Enable_if_floating<_Tp>(0.564189583547756286948079451560772586L);


  template<typename _Tp>
    inline constexpr _Tp ln2_v
      = _Enable_if_floating<_Tp>(0.693147180559945309417232121458176568L);


  template<typename _Tp>
    inline constexpr _Tp ln10_v
      = _Enable_if_floating<_Tp>(2.302585092994045684017991454684364208L);


  template<typename _Tp>
    inline constexpr _Tp sqrt2_v
      = _Enable_if_floating<_Tp>(1.414213562373095048801688724209698079L);


  template<typename _Tp>
    inline constexpr _Tp sqrt3_v
      = _Enable_if_floating<_Tp>(1.732050807568877293527446341505872367L);


  template<typename _Tp>
    inline constexpr _Tp inv_sqrt3_v
      = _Enable_if_floating<_Tp>(0.577350269189625764509148780501957456L);


  template<typename _Tp>
    inline constexpr _Tp egamma_v
      = _Enable_if_floating<_Tp>(0.577215664901532860606512090082402431L);


  template<typename _Tp>
    inline constexpr _Tp phi_v
      = _Enable_if_floating<_Tp>(1.618033988749894848204586834365638118L);

  inline constexpr double e = e_v<double>;
  inline constexpr double log2e = log2e_v<double>;
  inline constexpr double log10e = log10e_v<double>;
  inline constexpr double pi = pi_v<double>;
  inline constexpr double inv_pi = inv_pi_v<double>;
  inline constexpr double inv_sqrtpi = inv_sqrtpi_v<double>;
  inline constexpr double ln2 = ln2_v<double>;
  inline constexpr double ln10 = ln10_v<double>;
  inline constexpr double sqrt2 = sqrt2_v<double>;
  inline constexpr double sqrt3 = sqrt3_v<double>;
  inline constexpr double inv_sqrt3 = inv_sqrt3_v<double>;
  inline constexpr double egamma = egamma_v<double>;
  inline constexpr double phi = phi_v<double>;
# 205 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/numbers" 3
template<> inline constexpr _Float16 e_v<_Float16> = 2.718281828459045235360287471352662498F16; template<> inline constexpr _Float16 log2e_v<_Float16> = 1.442695040888963407359924681001892137F16; template<> inline constexpr _Float16 log10e_v<_Float16> = 0.434294481903251827651128918916605082F16; template<> inline constexpr _Float16 pi_v<_Float16> = 3.141592653589793238462643383279502884F16; template<> inline constexpr _Float16 inv_pi_v<_Float16> = 0.318309886183790671537767526745028724F16; template<> inline constexpr _Float16 inv_sqrtpi_v<_Float16> = 0.564189583547756286948079451560772586F16; template<> inline constexpr _Float16 ln2_v<_Float16> = 0.693147180559945309417232121458176568F16; template<> inline constexpr _Float16 ln10_v<_Float16> = 2.302585092994045684017991454684364208F16; template<> inline constexpr _Float16 sqrt2_v<_Float16> = 1.414213562373095048801688724209698079F16; template<> inline constexpr _Float16 sqrt3_v<_Float16> = 1.732050807568877293527446341505872367F16; template<> inline constexpr _Float16 inv_sqrt3_v<_Float16> = 0.577350269189625764509148780501957456F16; template<> inline constexpr _Float16 egamma_v<_Float16> = 0.577215664901532860606512090082402431F16; template<> inline constexpr _Float16 phi_v<_Float16> = 1.618033988749894848204586834365638118F16;



template<> inline constexpr _Float32 e_v<_Float32> = 2.718281828459045235360287471352662498F32; template<> inline constexpr _Float32 log2e_v<_Float32> = 1.442695040888963407359924681001892137F32; template<> inline constexpr _Float32 log10e_v<_Float32> = 0.434294481903251827651128918916605082F32; template<> inline constexpr _Float32 pi_v<_Float32> = 3.141592653589793238462643383279502884F32; template<> inline constexpr _Float32 inv_pi_v<_Float32> = 0.318309886183790671537767526745028724F32; template<> inline constexpr _Float32 inv_sqrtpi_v<_Float32> = 0.564189583547756286948079451560772586F32; template<> inline constexpr _Float32 ln2_v<_Float32> = 0.693147180559945309417232121458176568F32; template<> inline constexpr _Float32 ln10_v<_Float32> = 2.302585092994045684017991454684364208F32; template<> inline constexpr _Float32 sqrt2_v<_Float32> = 1.414213562373095048801688724209698079F32; template<> inline constexpr _Float32 sqrt3_v<_Float32> = 1.732050807568877293527446341505872367F32; template<> inline constexpr _Float32 inv_sqrt3_v<_Float32> = 0.577350269189625764509148780501957456F32; template<> inline constexpr _Float32 egamma_v<_Float32> = 0.577215664901532860606512090082402431F32; template<> inline constexpr _Float32 phi_v<_Float32> = 1.618033988749894848204586834365638118F32;



template<> inline constexpr _Float64 e_v<_Float64> = 2.718281828459045235360287471352662498F64; template<> inline constexpr _Float64 log2e_v<_Float64> = 1.442695040888963407359924681001892137F64; template<> inline constexpr _Float64 log10e_v<_Float64> = 0.434294481903251827651128918916605082F64; template<> inline constexpr _Float64 pi_v<_Float64> = 3.141592653589793238462643383279502884F64; template<> inline constexpr _Float64 inv_pi_v<_Float64> = 0.318309886183790671537767526745028724F64; template<> inline constexpr _Float64 inv_sqrtpi_v<_Float64> = 0.564189583547756286948079451560772586F64; template<> inline constexpr _Float64 ln2_v<_Float64> = 0.693147180559945309417232121458176568F64; template<> inline constexpr _Float64 ln10_v<_Float64> = 2.302585092994045684017991454684364208F64; template<> inline constexpr _Float64 sqrt2_v<_Float64> = 1.414213562373095048801688724209698079F64; template<> inline constexpr _Float64 sqrt3_v<_Float64> = 1.732050807568877293527446341505872367F64; template<> inline constexpr _Float64 inv_sqrt3_v<_Float64> = 0.577350269189625764509148780501957456F64; template<> inline constexpr _Float64 egamma_v<_Float64> = 0.577215664901532860606512090082402431F64; template<> inline constexpr _Float64 phi_v<_Float64> = 1.618033988749894848204586834365638118F64;



template<> inline constexpr _Float128 e_v<_Float128> = 2.718281828459045235360287471352662498F128; template<> inline constexpr _Float128 log2e_v<_Float128> = 1.442695040888963407359924681001892137F128; template<> inline constexpr _Float128 log10e_v<_Float128> = 0.434294481903251827651128918916605082F128; template<> inline constexpr _Float128 pi_v<_Float128> = 3.141592653589793238462643383279502884F128; template<> inline constexpr _Float128 inv_pi_v<_Float128> = 0.318309886183790671537767526745028724F128; template<> inline constexpr _Float128 inv_sqrtpi_v<_Float128> = 0.564189583547756286948079451560772586F128; template<> inline constexpr _Float128 ln2_v<_Float128> = 0.693147180559945309417232121458176568F128; template<> inline constexpr _Float128 ln10_v<_Float128> = 2.302585092994045684017991454684364208F128; template<> inline constexpr _Float128 sqrt2_v<_Float128> = 1.414213562373095048801688724209698079F128; template<> inline constexpr _Float128 sqrt3_v<_Float128> = 1.732050807568877293527446341505872367F128; template<> inline constexpr _Float128 inv_sqrt3_v<_Float128> = 0.577350269189625764509148780501957456F128; template<> inline constexpr _Float128 egamma_v<_Float128> = 0.577215664901532860606512090082402431F128; template<> inline constexpr _Float128 phi_v<_Float128> = 1.618033988749894848204586834365638118F128;







template<> inline constexpr __float128 e_v<__float128> = 2.718281828459045235360287471352662498Q; template<> inline constexpr __float128 log2e_v<__float128> = 1.442695040888963407359924681001892137Q; template<> inline constexpr __float128 log10e_v<__float128> = 0.434294481903251827651128918916605082Q; template<> inline constexpr __float128 pi_v<__float128> = 3.141592653589793238462643383279502884Q; template<> inline constexpr __float128 inv_pi_v<__float128> = 0.318309886183790671537767526745028724Q; template<> inline constexpr __float128 inv_sqrtpi_v<__float128> = 0.564189583547756286948079451560772586Q; template<> inline constexpr __float128 ln2_v<__float128> = 0.693147180559945309417232121458176568Q; template<> inline constexpr __float128 ln10_v<__float128> = 2.302585092994045684017991454684364208Q; template<> inline constexpr __float128 sqrt2_v<__float128> = 1.414213562373095048801688724209698079Q; template<> inline constexpr __float128 sqrt3_v<__float128> = 1.732050807568877293527446341505872367Q; template<> inline constexpr __float128 inv_sqrt3_v<__float128> = 0.577350269189625764509148780501957456Q; template<> inline constexpr __float128 egamma_v<__float128> = 0.577215664901532860606512090082402431Q; template<> inline constexpr __float128 phi_v<__float128> = 1.618033988749894848204586834365638118Q;




}


}
# 38 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/max_size_type.h" 2 3
# 48 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/max_size_type.h" 3
namespace std
{


template<typename _Tp>
  struct numeric_limits;

namespace ranges
{
  namespace __detail
  {
    class __max_size_type
    {
    public:
      __max_size_type() = default;

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 constexpr
 __max_size_type(_Tp __i) noexcept
   : _M_val(__i), _M_msb(__i < 0)
 { }

      constexpr explicit
      __max_size_type(const __max_diff_type& __d) noexcept;

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 constexpr explicit
 operator _Tp() const noexcept
 { return _M_val; }

      constexpr explicit
      operator bool() const noexcept
      { return _M_val != 0 || _M_msb != 0; }

      constexpr __max_size_type
      operator+() const noexcept
      { return *this; }

      constexpr __max_size_type
      operator~() const noexcept
      { return __max_size_type{~_M_val, !_M_msb}; }

      constexpr __max_size_type
      operator-() const noexcept
      { return operator~() + 1; }

      constexpr __max_size_type&
      operator++() noexcept
      { return *this += 1; }

      constexpr __max_size_type
      operator++(int) noexcept
      {
 auto __tmp = *this;
 ++*this;
 return __tmp;
      }

      constexpr __max_size_type&
      operator--() noexcept
      { return *this -= 1; }

      constexpr __max_size_type
      operator--(int) noexcept
      {
 auto __tmp = *this;
 --*this;
 return __tmp;
      }

      constexpr __max_size_type&
      operator+=(const __max_size_type& __r) noexcept
      {
 const auto __sum = _M_val + __r._M_val;
 const bool __overflow = (__sum < _M_val);
 _M_msb = _M_msb ^ __r._M_msb ^ __overflow;
 _M_val = __sum;
 return *this;
      }

      constexpr __max_size_type&
      operator-=(const __max_size_type& __r) noexcept
      { return *this += -__r; }

      constexpr __max_size_type&
      operator*=(__max_size_type __r) noexcept
      {
 constexpr __max_size_type __threshold
   = __rep(1) << (_S_rep_bits / 2 - 1);
 if (_M_val < __threshold && __r < __threshold)


   _M_val = _M_val * __r._M_val;
 else
   {



     const bool __lsb = _M_val & 1;
     const bool __rlsb = __r._M_val & 1;
     *this >>= 1;
     __r >>= 1;
     _M_val = (2 * _M_val * __r._M_val
        + _M_val * __rlsb + __r._M_val * __lsb);
     *this <<= 1;
     *this += __rlsb * __lsb;
   }

 return *this;
      }

      constexpr __max_size_type&
      operator/=(const __max_size_type& __r) noexcept
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__r != 0), false)) std::__glibcxx_assert_fail(); } while (false);

 if (!_M_msb && !__r._M_msb) [[likely]]
   _M_val /= __r._M_val;
 else if (_M_msb && __r._M_msb)
   {
     _M_val = (_M_val >= __r._M_val);
     _M_msb = 0;
   }
 else if (!_M_msb && __r._M_msb)
   _M_val = 0;
 else if (_M_msb && !__r._M_msb)
   {




     const auto __orig = *this;
     *this >>= 1;
     _M_val /= __r._M_val;
     *this <<= 1;
     if (__orig - *this * __r >= __r)
       ++_M_val;
   }
 return *this;
      }

      constexpr __max_size_type&
      operator%=(const __max_size_type& __r) noexcept
      {
 if (!_M_msb && !__r._M_msb) [[likely]]
   _M_val %= __r._M_val;
 else
   *this -= (*this / __r) * __r;
 return *this;
      }

      constexpr __max_size_type&
      operator<<=(const __max_size_type& __r) noexcept
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__r <= _S_rep_bits), false)) std::__glibcxx_assert_fail(); } while (false);
 if (__r != 0)
   {
     _M_msb = (_M_val >> (_S_rep_bits - __r._M_val)) & 1;

     if (__r._M_val == _S_rep_bits) [[unlikely]]
       _M_val = 0;
     else
       _M_val <<= __r._M_val;
   }
 return *this;
      }

      constexpr __max_size_type&
      operator>>=(const __max_size_type& __r) noexcept
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__r <= _S_rep_bits), false)) std::__glibcxx_assert_fail(); } while (false);
 if (__r != 0)
   {
     if (__r._M_val == _S_rep_bits) [[unlikely]]
       _M_val = 0;
     else
       _M_val >>= __r._M_val;

     if (_M_msb) [[unlikely]]
       {
  _M_val |= __rep(1) << (_S_rep_bits - __r._M_val);
  _M_msb = 0;
       }
   }
 return *this;
      }

      constexpr __max_size_type&
      operator&=(const __max_size_type& __r) noexcept
      {
 _M_val &= __r._M_val;
 _M_msb &= __r._M_msb;
 return *this;
      }

      constexpr __max_size_type&
      operator|=(const __max_size_type& __r) noexcept
      {
 _M_val |= __r._M_val;
 _M_msb |= __r._M_msb;
 return *this;
      }

      constexpr __max_size_type&
      operator^=(const __max_size_type& __r) noexcept
      {
 _M_val ^= __r._M_val;
 _M_msb ^= __r._M_msb;
 return *this;
      }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator+=(_Tp& __a, const __max_size_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a + __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator-=(_Tp& __a, const __max_size_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a - __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator*=(_Tp& __a, const __max_size_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a * __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator/=(_Tp& __a, const __max_size_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a / __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator%=(_Tp& __a, const __max_size_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a % __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator&=(_Tp& __a, const __max_size_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a & __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator|=(_Tp& __a, const __max_size_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a | __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator^=(_Tp& __a, const __max_size_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a ^ __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator<<=(_Tp& __a, const __max_size_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a << __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator>>=(_Tp& __a, const __max_size_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a >> __b)); }

      friend constexpr __max_size_type
      operator+(__max_size_type __l, const __max_size_type& __r) noexcept
      {
 __l += __r;
 return __l;
      }

      friend constexpr __max_size_type
      operator-(__max_size_type __l, const __max_size_type& __r) noexcept
      {
 __l -= __r;
 return __l;
      }

      friend constexpr __max_size_type
      operator*(__max_size_type __l, const __max_size_type& __r) noexcept
      {
 __l *= __r;
 return __l;
      }

      friend constexpr __max_size_type
      operator/(__max_size_type __l, const __max_size_type& __r) noexcept
      {
 __l /= __r;
 return __l;
      }

      friend constexpr __max_size_type
      operator%(__max_size_type __l, const __max_size_type& __r) noexcept
      {
 __l %= __r;
 return __l;
      }

      friend constexpr __max_size_type
      operator<<(__max_size_type __l, const __max_size_type& __r) noexcept
      {
 __l <<= __r;
 return __l;
      }

      friend constexpr __max_size_type
      operator>>(__max_size_type __l, const __max_size_type& __r) noexcept
      {
 __l >>= __r;
 return __l;
      }

      friend constexpr __max_size_type
      operator&(__max_size_type __l, const __max_size_type& __r) noexcept
      {
 __l &= __r;
 return __l;
      }

      friend constexpr __max_size_type
      operator|(__max_size_type __l, const __max_size_type& __r) noexcept
      {
 __l |= __r;
 return __l;
      }

      friend constexpr __max_size_type
      operator^(__max_size_type __l, const __max_size_type& __r) noexcept
      {
 __l ^= __r;
 return __l;
      }

      friend constexpr bool
      operator==(const __max_size_type& __l, const __max_size_type& __r) noexcept
      { return __l._M_val == __r._M_val && __l._M_msb == __r._M_msb; }


      friend constexpr strong_ordering
      operator<=>(const __max_size_type& __l, const __max_size_type& __r) noexcept
      {
 if (__l._M_msb ^ __r._M_msb)
   return __l._M_msb ? strong_ordering::greater : strong_ordering::less;
 else
   return __l._M_val <=> __r._M_val;
      }
# 420 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/max_size_type.h" 3
      __extension__
      using __rep = unsigned __int128;



      static constexpr size_t _S_rep_bits = sizeof(__rep) * 8;
    private:
      __rep _M_val = 0;
      unsigned _M_msb:1 = 0;

      constexpr explicit
      __max_size_type(__rep __val, int __msb) noexcept
 : _M_val(__val), _M_msb(__msb)
      { }

      friend __max_diff_type;
      friend std::numeric_limits<__max_size_type>;
      friend std::numeric_limits<__max_diff_type>;
    };

    class __max_diff_type
    {
    public:
      __max_diff_type() = default;

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 constexpr
 __max_diff_type(_Tp __i) noexcept
   : _M_rep(__i)
 { }

      constexpr explicit
      __max_diff_type(const __max_size_type& __d) noexcept
 : _M_rep(__d)
      { }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 constexpr explicit
 operator _Tp() const noexcept
 { return static_cast<_Tp>(_M_rep); }

      constexpr explicit
      operator bool() const noexcept
      { return _M_rep != 0; }

      constexpr __max_diff_type
      operator+() const noexcept
      { return *this; }

      constexpr __max_diff_type
      operator-() const noexcept
      { return __max_diff_type(-_M_rep); }

      constexpr __max_diff_type
      operator~() const noexcept
      { return __max_diff_type(~_M_rep); }

      constexpr __max_diff_type&
      operator++() noexcept
      { return *this += 1; }

      constexpr __max_diff_type
      operator++(int) noexcept
      {
 auto __tmp = *this;
 ++*this;
 return __tmp;
      }

      constexpr __max_diff_type&
      operator--() noexcept
      { return *this -= 1; }

      constexpr __max_diff_type
      operator--(int) noexcept
      {
 auto __tmp = *this;
 --*this;
 return __tmp;
      }

      constexpr __max_diff_type&
      operator+=(const __max_diff_type& __r) noexcept
      {
 _M_rep += __r._M_rep;
 return *this;
      }

      constexpr __max_diff_type&
      operator-=(const __max_diff_type& __r) noexcept
      {
 _M_rep -= __r._M_rep;
 return *this;
      }

      constexpr __max_diff_type&
      operator*=(const __max_diff_type& __r) noexcept
      {
 _M_rep *= __r._M_rep;
 return *this;
      }

      constexpr __max_diff_type&
      operator/=(const __max_diff_type& __r) noexcept
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__r != 0), false)) std::__glibcxx_assert_fail(); } while (false);
 const bool __neg = *this < 0;
 const bool __rneg = __r < 0;
 if (!__neg && !__rneg)
   _M_rep = _M_rep / __r._M_rep;
 else if (__neg && __rneg)
   _M_rep = -_M_rep / -__r._M_rep;
 else if (__neg && !__rneg)
   _M_rep = -(-_M_rep / __r._M_rep);
 else
   _M_rep = -(_M_rep / -__r._M_rep);
 return *this ;
      }

      constexpr __max_diff_type&
      operator%=(const __max_diff_type& __r) noexcept
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__r != 0), false)) std::__glibcxx_assert_fail(); } while (false);
 if (*this >= 0 && __r > 0)
   _M_rep %= __r._M_rep;
 else
   *this -= (*this / __r) * __r;
 return *this;
      }

      constexpr __max_diff_type&
      operator<<=(const __max_diff_type& __r) noexcept
      {
 _M_rep.operator<<=(__r._M_rep);
 return *this;
      }

      constexpr __max_diff_type&
      operator>>=(const __max_diff_type& __r) noexcept
      {

 const auto __msb = _M_rep._M_msb;
 _M_rep >>= __r._M_rep;
 if (__msb)
   _M_rep |= ~(__max_size_type(-1) >> __r._M_rep);
 return *this;
      }

      constexpr __max_diff_type&
      operator&=(const __max_diff_type& __r) noexcept
      {
 _M_rep &= __r._M_rep;
 return *this;
      }

      constexpr __max_diff_type&
      operator|=(const __max_diff_type& __r) noexcept
      {
 _M_rep |= __r._M_rep;
 return *this;
      }

      constexpr __max_diff_type&
      operator^=(const __max_diff_type& __r) noexcept
      {
 _M_rep ^= __r._M_rep;
 return *this;
      }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator+=(_Tp& __a, const __max_diff_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a + __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator-=(_Tp& __a, const __max_diff_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a - __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator*=(_Tp& __a, const __max_diff_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a * __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator/=(_Tp& __a, const __max_diff_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a / __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator%=(_Tp& __a, const __max_diff_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a % __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator&=(_Tp& __a, const __max_diff_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a & __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator|=(_Tp& __a, const __max_diff_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a | __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator^=(_Tp& __a, const __max_diff_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a ^ __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator<<=(_Tp& __a, const __max_diff_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a << __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator>>=(_Tp& __a, const __max_diff_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a >> __b)); }

      friend constexpr __max_diff_type
      operator+(__max_diff_type __l, const __max_diff_type& __r) noexcept
      {
 __l += __r;
 return __l;
      }

      friend constexpr __max_diff_type
      operator-(__max_diff_type __l, const __max_diff_type& __r) noexcept
      {
 __l -= __r;
 return __l;
      }

      friend constexpr __max_diff_type
      operator*(__max_diff_type __l, const __max_diff_type& __r) noexcept
      {
 __l *= __r;
 return __l;
      }

      friend constexpr __max_diff_type
      operator/(__max_diff_type __l, const __max_diff_type& __r) noexcept
      {
 __l /= __r;
 return __l;
      }

      friend constexpr __max_diff_type
      operator%(__max_diff_type __l, const __max_diff_type& __r) noexcept
      {
 __l %= __r;
 return __l;
      }

      friend constexpr __max_diff_type
      operator<<(__max_diff_type __l, const __max_diff_type& __r) noexcept
      {
 __l <<= __r;
 return __l;
      }

      friend constexpr __max_diff_type
      operator>>(__max_diff_type __l, const __max_diff_type& __r) noexcept
      {
 __l >>= __r;
 return __l;
      }

      friend constexpr __max_diff_type
      operator&(__max_diff_type __l, const __max_diff_type& __r) noexcept
      {
 __l &= __r;
 return __l;
      }

      friend constexpr __max_diff_type
      operator|(__max_diff_type __l, const __max_diff_type& __r) noexcept
      {
 __l |= __r;
 return __l;
      }

      friend constexpr __max_diff_type
      operator^(__max_diff_type __l, const __max_diff_type& __r) noexcept
      {
 __l ^= __r;
 return __l;
      }

      friend constexpr bool
      operator==(const __max_diff_type& __l, const __max_diff_type& __r) noexcept
      { return __l._M_rep == __r._M_rep; }


      constexpr strong_ordering
      operator<=>(const __max_diff_type& __r) const noexcept
      {
 const auto __lsign = _M_rep._M_msb;
 const auto __rsign = __r._M_rep._M_msb;
 if (__lsign ^ __rsign)
   return __lsign ? strong_ordering::less : strong_ordering::greater;
 else
   return _M_rep <=> __r._M_rep;
      }
# 753 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/max_size_type.h" 3
    private:
      __max_size_type _M_rep = 0;

      friend class __max_size_type;
    };

    constexpr
    __max_size_type::__max_size_type(const __max_diff_type& __d) noexcept
      : __max_size_type(__d._M_rep)
    { }

  }
}

  template<>
    struct numeric_limits<ranges::__detail::__max_size_type>
    {
      using _Sp = ranges::__detail::__max_size_type;
      static constexpr bool is_specialized = true;
      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int digits
 = __gnu_cxx::__int_traits<_Sp::__rep>::__digits + 1;
      static constexpr int digits10
 = static_cast<int>(digits * numbers::ln2 / numbers::ln10);

      static constexpr _Sp
      min() noexcept
      { return 0; }

      static constexpr _Sp
      max() noexcept
      { return _Sp(static_cast<_Sp::__rep>(-1), 1); }

      static constexpr _Sp
      lowest() noexcept
      { return min(); }
    };

  template<>
    struct numeric_limits<ranges::__detail::__max_diff_type>
    {
      using _Dp = ranges::__detail::__max_diff_type;
      using _Sp = ranges::__detail::__max_size_type;
      static constexpr bool is_specialized = true;
      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int digits = numeric_limits<_Sp>::digits - 1;
      static constexpr int digits10
 = static_cast<int>(digits * numbers::ln2 / numbers::ln10);

      static constexpr _Dp
      min() noexcept
      { return _Dp(_Sp(0, 1)); }

      static constexpr _Dp
      max() noexcept
      { return _Dp(_Sp(static_cast<_Sp::__rep>(-1), 0)); }

      static constexpr _Dp
      lowest() noexcept
      { return min(); }
    };


}
# 40 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/ranges_base.h" 2 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 1 3
# 47 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 3
       
# 48 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 3
# 41 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/ranges_base.h" 2 3


namespace std
{

namespace ranges
{
  template<typename>
    inline constexpr bool disable_sized_range = false;

  template<typename _Tp>
    inline constexpr bool enable_borrowed_range = false;

  namespace __detail
  {
    constexpr __max_size_type
    __to_unsigned_like(__max_size_type __t) noexcept
    { return __t; }

    constexpr __max_size_type
    __to_unsigned_like(__max_diff_type __t) noexcept
    { return __max_size_type(__t); }

    template<integral _Tp>
      constexpr auto
      __to_unsigned_like(_Tp __t) noexcept
      { return static_cast<make_unsigned_t<_Tp>>(__t); }
# 79 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/ranges_base.h" 3
    template<typename _Tp>
      using __make_unsigned_like_t
 = decltype(__detail::__to_unsigned_like(std::declval<_Tp>()));


    template<typename _Tp>
      concept __maybe_borrowed_range
 = is_lvalue_reference_v<_Tp>
   || enable_borrowed_range<remove_cvref_t<_Tp>>;

  }


  namespace __access
  {
    using std::ranges::__detail::__maybe_borrowed_range;
    using std::__detail::__range_iter_t;

    struct _Begin
    {
    private:
      template<typename _Tp>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (is_array_v<remove_reference_t<_Tp>>)
     return true;
   else if constexpr (__member_begin<_Tp>)
     return noexcept(__decay_copy(std::declval<_Tp&>().begin()));
   else
     return noexcept(__decay_copy(begin(std::declval<_Tp&>())));
 }

    public:
      template<__maybe_borrowed_range _Tp>
 requires is_array_v<remove_reference_t<_Tp>> || __member_begin<_Tp>
   || __adl_begin<_Tp>
 constexpr auto
 operator()[[nodiscard]](_Tp&& __t) const noexcept(_S_noexcept<_Tp&>())
 {
   if constexpr (is_array_v<remove_reference_t<_Tp>>)
     {
       static_assert(is_lvalue_reference_v<_Tp>);
       return __t + 0;
     }
   else if constexpr (__member_begin<_Tp>)
     return __t.begin();
   else
     return begin(__t);
 }
    };

    template<typename _Tp>
      concept __member_end = requires(_Tp& __t)
 {
   { __decay_copy(__t.end()) } -> sentinel_for<__range_iter_t<_Tp>>;
 };


    void end() = delete;

    template<typename _Tp>
      concept __adl_end = __class_or_enum<remove_reference_t<_Tp>>
 && requires(_Tp& __t)
 {
   { __decay_copy(end(__t)) } -> sentinel_for<__range_iter_t<_Tp>>;
 };

    struct _End
    {
    private:
      template<typename _Tp>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (is_bounded_array_v<remove_reference_t<_Tp>>)
     return true;
   else if constexpr (__member_end<_Tp>)
     return noexcept(__decay_copy(std::declval<_Tp&>().end()));
   else
     return noexcept(__decay_copy(end(std::declval<_Tp&>())));
 }

    public:
      template<__maybe_borrowed_range _Tp>
 requires is_bounded_array_v<remove_reference_t<_Tp>>
   || __member_end<_Tp> || __adl_end<_Tp>
 constexpr auto
 operator()[[nodiscard]](_Tp&& __t) const noexcept(_S_noexcept<_Tp&>())
 {
   if constexpr (is_bounded_array_v<remove_reference_t<_Tp>>)
     {
       static_assert(is_lvalue_reference_v<_Tp>);
       return __t + extent_v<remove_reference_t<_Tp>>;
     }
   else if constexpr (__member_end<_Tp>)
     return __t.end();
   else
     return end(__t);
 }
    };

    template<typename _Tp>
      concept __member_rbegin = requires(_Tp& __t)
 {
   { __decay_copy(__t.rbegin()) } -> input_or_output_iterator;
 };

    void rbegin() = delete;

    template<typename _Tp>
      concept __adl_rbegin = __class_or_enum<remove_reference_t<_Tp>>
 && requires(_Tp& __t)
 {
   { __decay_copy(rbegin(__t)) } -> input_or_output_iterator;
 };

    template<typename _Tp>
      concept __reversable = requires(_Tp& __t)
 {
   { _Begin{}(__t) } -> bidirectional_iterator;
   { _End{}(__t) } -> same_as<decltype(_Begin{}(__t))>;
 };

    struct _RBegin
    {
    private:
      template<typename _Tp>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__member_rbegin<_Tp>)
     return noexcept(__decay_copy(std::declval<_Tp&>().rbegin()));
   else if constexpr (__adl_rbegin<_Tp>)
     return noexcept(__decay_copy(rbegin(std::declval<_Tp&>())));
   else
     {
       if constexpr (noexcept(_End{}(std::declval<_Tp&>())))
  {
    using _It = decltype(_End{}(std::declval<_Tp&>()));

    return is_nothrow_copy_constructible_v<_It>;
  }
       else
  return false;
     }
 }

    public:
      template<__maybe_borrowed_range _Tp>
 requires __member_rbegin<_Tp> || __adl_rbegin<_Tp> || __reversable<_Tp>
 constexpr auto
 operator()[[nodiscard]](_Tp&& __t) const
 noexcept(_S_noexcept<_Tp&>())
 {
   if constexpr (__member_rbegin<_Tp>)
     return __t.rbegin();
   else if constexpr (__adl_rbegin<_Tp>)
     return rbegin(__t);
   else
     return std::make_reverse_iterator(_End{}(__t));
 }
    };

    template<typename _Tp>
      concept __member_rend = requires(_Tp& __t)
 {
   { __decay_copy(__t.rend()) }
     -> sentinel_for<decltype(_RBegin{}(std::forward<_Tp>(__t)))>;
 };

    void rend() = delete;

    template<typename _Tp>
      concept __adl_rend = __class_or_enum<remove_reference_t<_Tp>>
 && requires(_Tp& __t)
 {
   { __decay_copy(rend(__t)) }
     -> sentinel_for<decltype(_RBegin{}(std::forward<_Tp>(__t)))>;
 };

    struct _REnd
    {
    private:
      template<typename _Tp>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__member_rend<_Tp>)
     return noexcept(__decay_copy(std::declval<_Tp&>().rend()));
   else if constexpr (__adl_rend<_Tp>)
     return noexcept(__decay_copy(rend(std::declval<_Tp&>())));
   else
     {
       if constexpr (noexcept(_Begin{}(std::declval<_Tp&>())))
  {
    using _It = decltype(_Begin{}(std::declval<_Tp&>()));

    return is_nothrow_copy_constructible_v<_It>;
  }
       else
  return false;
     }
 }

    public:
      template<__maybe_borrowed_range _Tp>
 requires __member_rend<_Tp> || __adl_rend<_Tp> || __reversable<_Tp>
 constexpr auto
 operator()[[nodiscard]](_Tp&& __t) const
 noexcept(_S_noexcept<_Tp&>())
 {
   if constexpr (__member_rend<_Tp>)
     return __t.rend();
   else if constexpr (__adl_rend<_Tp>)
     return rend(__t);
   else
     return std::make_reverse_iterator(_Begin{}(__t));
 }
    };

    template<typename _Tp>
      concept __member_size = !disable_sized_range<remove_cvref_t<_Tp>>
 && requires(_Tp& __t)
 {
   { __decay_copy(__t.size()) } -> __detail::__is_integer_like;
 };

    void size() = delete;

    template<typename _Tp>
      concept __adl_size = __class_or_enum<remove_reference_t<_Tp>>
 && !disable_sized_range<remove_cvref_t<_Tp>>
 && requires(_Tp& __t)
 {
   { __decay_copy(size(__t)) } -> __detail::__is_integer_like;
 };

    template<typename _Tp>
      concept __sentinel_size = requires(_Tp& __t)
 {
   requires (!is_unbounded_array_v<remove_reference_t<_Tp>>);

   { _Begin{}(__t) } -> forward_iterator;

   { _End{}(__t) } -> sized_sentinel_for<decltype(_Begin{}(__t))>;

   __detail::__to_unsigned_like(_End{}(__t) - _Begin{}(__t));
 };

    struct _Size
    {
    private:
      template<typename _Tp>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (is_bounded_array_v<remove_reference_t<_Tp>>)
     return true;
   else if constexpr (__member_size<_Tp>)
     return noexcept(__decay_copy(std::declval<_Tp&>().size()));
   else if constexpr (__adl_size<_Tp>)
     return noexcept(__decay_copy(size(std::declval<_Tp&>())));
   else if constexpr (__sentinel_size<_Tp>)
     return noexcept(_End{}(std::declval<_Tp&>())
       - _Begin{}(std::declval<_Tp&>()));
 }

    public:
      template<typename _Tp>
 requires is_bounded_array_v<remove_reference_t<_Tp>>
   || __member_size<_Tp> || __adl_size<_Tp> || __sentinel_size<_Tp>
 constexpr auto
 operator()[[nodiscard]](_Tp&& __t) const noexcept(_S_noexcept<_Tp&>())
 {
   if constexpr (is_bounded_array_v<remove_reference_t<_Tp>>)
     return extent_v<remove_reference_t<_Tp>>;
   else if constexpr (__member_size<_Tp>)
     return __t.size();
   else if constexpr (__adl_size<_Tp>)
     return size(__t);
   else if constexpr (__sentinel_size<_Tp>)
     return __detail::__to_unsigned_like(_End{}(__t) - _Begin{}(__t));
 }
    };

    struct _SSize
    {


      template<typename _Tp>
 requires requires (_Tp& __t) { _Size{}(__t); }
 constexpr auto
 operator()[[nodiscard]](_Tp&& __t) const noexcept(noexcept(_Size{}(__t)))
 {
   auto __size = _Size{}(__t);
   using __size_type = decltype(__size);

   if constexpr (integral<__size_type>)
     {
       using __gnu_cxx::__int_traits;
       if constexpr (__int_traits<__size_type>::__digits
       < __int_traits<ptrdiff_t>::__digits)
  return static_cast<ptrdiff_t>(__size);
       else
  return static_cast<make_signed_t<__size_type>>(__size);
     }





   else
     return __detail::__max_diff_type(__size);
 }
    };

    template<typename _Tp>
      concept __member_empty = requires(_Tp& __t) { bool(__t.empty()); };

    template<typename _Tp>
      concept __size0_empty = requires(_Tp& __t) { _Size{}(__t) == 0; };

    template<typename _Tp>
      concept __eq_iter_empty = requires(_Tp& __t)
 {
   requires (!is_unbounded_array_v<remove_reference_t<_Tp>>);

   { _Begin{}(__t) } -> forward_iterator;

   bool(_Begin{}(__t) == _End{}(__t));
 };

    struct _Empty
    {
    private:
      template<typename _Tp>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__member_empty<_Tp>)
     return noexcept(bool(std::declval<_Tp&>().empty()));
   else if constexpr (__size0_empty<_Tp>)
     return noexcept(_Size{}(std::declval<_Tp&>()) == 0);
   else
     return noexcept(bool(_Begin{}(std::declval<_Tp&>())
  == _End{}(std::declval<_Tp&>())));
 }

    public:
      template<typename _Tp>
 requires __member_empty<_Tp> || __size0_empty<_Tp>
   || __eq_iter_empty<_Tp>
 constexpr bool
 operator()[[nodiscard]](_Tp&& __t) const noexcept(_S_noexcept<_Tp&>())
 {
   if constexpr (__member_empty<_Tp>)
     return bool(__t.empty());
   else if constexpr (__size0_empty<_Tp>)
     return _Size{}(__t) == 0;
   else
     return bool(_Begin{}(__t) == _End{}(__t));
 }
    };

    template<typename _Tp>
      concept __pointer_to_object = is_pointer_v<_Tp>
        && is_object_v<remove_pointer_t<_Tp>>;

    template<typename _Tp>
      concept __member_data = requires(_Tp& __t)
 {
   { __decay_copy(__t.data()) } -> __pointer_to_object;
 };

    template<typename _Tp>
      concept __begin_data = contiguous_iterator<__range_iter_t<_Tp>>;

    struct _Data
    {
    private:
      template<typename _Tp>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__member_data<_Tp>)
     return noexcept(__decay_copy(std::declval<_Tp&>().data()));
   else
     return noexcept(_Begin{}(std::declval<_Tp&>()));
 }

    public:
      template<__maybe_borrowed_range _Tp>
 requires __member_data<_Tp> || __begin_data<_Tp>
 constexpr auto
 operator()[[nodiscard]](_Tp&& __t) const noexcept(_S_noexcept<_Tp>())
 {
   if constexpr (__member_data<_Tp>)
     return __t.data();
   else
     return std::to_address(_Begin{}(__t));
 }
    };

  }

  inline namespace _Cpo
  {
    inline constexpr ranges::__access::_Begin begin{};
    inline constexpr ranges::__access::_End end{};
    inline constexpr ranges::__access::_RBegin rbegin{};
    inline constexpr ranges::__access::_REnd rend{};
    inline constexpr ranges::__access::_Size size{};
    inline constexpr ranges::__access::_SSize ssize{};
    inline constexpr ranges::__access::_Empty empty{};
    inline constexpr ranges::__access::_Data data{};
  }


  template<typename _Tp>
    concept range = requires(_Tp& __t)
      {
 ranges::begin(__t);
 ranges::end(__t);
      };


  template<typename _Tp>
    concept borrowed_range
      = range<_Tp> && __detail::__maybe_borrowed_range<_Tp>;

  template<typename _Tp>
    using iterator_t = std::__detail::__range_iter_t<_Tp>;

  template<range _Range>
    using sentinel_t = decltype(ranges::end(std::declval<_Range&>()));


  template<range _Range>
    using const_iterator_t = const_iterator<iterator_t<_Range>>;

  template<range _Range>
    using const_sentinel_t = const_sentinel<sentinel_t<_Range>>;

  template<range _Range>
    using range_const_reference_t = iter_const_reference_t<iterator_t<_Range>>;


  template<range _Range>
    using range_difference_t = iter_difference_t<iterator_t<_Range>>;

  template<range _Range>
    using range_value_t = iter_value_t<iterator_t<_Range>>;

  template<range _Range>
    using range_reference_t = iter_reference_t<iterator_t<_Range>>;

  template<range _Range>
    using range_rvalue_reference_t
      = iter_rvalue_reference_t<iterator_t<_Range>>;


  template<typename _Tp>
    concept sized_range = range<_Tp>
      && requires(_Tp& __t) { ranges::size(__t); };

  template<sized_range _Range>
    using range_size_t = decltype(ranges::size(std::declval<_Range&>()));

  template<typename _Derived>
    requires is_class_v<_Derived> && same_as<_Derived, remove_cv_t<_Derived>>
    class view_interface;

  namespace __detail
  {
    template<typename _Tp, typename _Up>
      requires (!same_as<_Tp, view_interface<_Up>>)
      void __is_derived_from_view_interface_fn(const _Tp&,
            const view_interface<_Up>&);



    template<typename _Tp>
      concept __is_derived_from_view_interface
 = requires (_Tp __t) { __is_derived_from_view_interface_fn(__t, __t); };
  }


  struct view_base { };


  template<typename _Tp>
    inline constexpr bool enable_view = derived_from<_Tp, view_base>
      || __detail::__is_derived_from_view_interface<_Tp>;


  template<typename _Tp>
    concept view
      = range<_Tp> && movable<_Tp> && enable_view<_Tp>;




  template<typename _Range, typename _Tp>
    concept output_range
      = range<_Range> && output_iterator<iterator_t<_Range>, _Tp>;


  template<typename _Tp>
    concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;


  template<typename _Tp>
    concept forward_range
      = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;


  template<typename _Tp>
    concept bidirectional_range
      = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;


  template<typename _Tp>
    concept random_access_range
      = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;


  template<typename _Tp>
    concept contiguous_range
      = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>>
      && requires(_Tp& __t)
      {
 { ranges::data(__t) } -> same_as<add_pointer_t<range_reference_t<_Tp>>>;
      };


  template<typename _Tp>
    concept common_range
      = range<_Tp> && same_as<iterator_t<_Tp>, sentinel_t<_Tp>>;


  template<typename _Tp>
    concept constant_range
      = input_range<_Tp> && std::__detail::__constant_iterator<iterator_t<_Tp>>;


  namespace __access
  {

    template<typename _Range>
      constexpr auto&
      __possibly_const_range(_Range& __r) noexcept
      {
 if constexpr (constant_range<const _Range> && !constant_range<_Range>)
   return const_cast<const _Range&>(__r);
 else
   return __r;
      }
# 652 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/ranges_base.h" 3
    struct _CBegin
    {

      template<__maybe_borrowed_range _Tp>
 [[nodiscard]]
 constexpr auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(std::make_const_iterator
     (ranges::begin(__access::__possibly_const_range(__t)))))
 requires requires { std::make_const_iterator
       (ranges::begin(__access::__possibly_const_range(__t))); }
 {
   auto& __r = __access::__possibly_const_range(__t);
   return const_iterator_t<decltype(__r)>(ranges::begin(__r));
 }
# 678 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/ranges_base.h" 3
    };

    struct _CEnd final
    {

      template<__maybe_borrowed_range _Tp>
 [[nodiscard]]
 constexpr auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(std::make_const_sentinel
     (ranges::end(__access::__possibly_const_range(__t)))))
 requires requires { std::make_const_sentinel
       (ranges::end(__access::__possibly_const_range(__t))); }
 {
   auto& __r = __access::__possibly_const_range(__t);
   return const_sentinel_t<decltype(__r)>(ranges::end(__r));
 }
# 706 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/ranges_base.h" 3
    };

    struct _CRBegin
    {

      template<__maybe_borrowed_range _Tp>
 [[nodiscard]]
 constexpr auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(std::make_const_iterator
     (ranges::rbegin(__access::__possibly_const_range(__t)))))
 requires requires { std::make_const_iterator
       (ranges::rbegin(__access::__possibly_const_range(__t))); }
 {
   auto& __r = __access::__possibly_const_range(__t);
   return const_iterator<decltype(ranges::rbegin(__r))>(ranges::rbegin(__r));
 }
# 734 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/ranges_base.h" 3
    };

    struct _CREnd
    {

      template<__maybe_borrowed_range _Tp>
 [[nodiscard]]
 constexpr auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(std::make_const_sentinel
     (ranges::rend(__access::__possibly_const_range(__t)))))
 requires requires { std::make_const_sentinel
       (ranges::rend(__access::__possibly_const_range(__t))); }
 {
   auto& __r = __access::__possibly_const_range(__t);
   return const_sentinel<decltype(ranges::rend(__r))>(ranges::rend(__r));
 }
# 762 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/ranges_base.h" 3
    };

    struct _CData
    {

      template<__maybe_borrowed_range _Tp>
 [[nodiscard]]
 constexpr const auto*
 operator()(_Tp&& __t) const
 noexcept(noexcept(ranges::data(__access::__possibly_const_range(__t))))
 requires requires { ranges::data(__access::__possibly_const_range(__t)); }
 { return ranges::data(__access::__possibly_const_range(__t)); }
# 785 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/ranges_base.h" 3
    };
  }

  inline namespace _Cpo
  {
    inline constexpr ranges::__access::_CBegin cbegin{};
    inline constexpr ranges::__access::_CEnd cend{};
    inline constexpr ranges::__access::_CRBegin crbegin{};
    inline constexpr ranges::__access::_CREnd crend{};
    inline constexpr ranges::__access::_CData cdata{};
  }

  namespace __detail
  {
    template<typename _Tp>
      inline constexpr bool __is_initializer_list = false;

    template<typename _Tp>
      inline constexpr bool __is_initializer_list<initializer_list<_Tp>> = true;
  }


  template<typename _Tp>
    concept viewable_range = range<_Tp>
      && ((view<remove_cvref_t<_Tp>> && constructible_from<remove_cvref_t<_Tp>, _Tp>)
   || (!view<remove_cvref_t<_Tp>>
       && (is_lvalue_reference_v<_Tp>
    || (movable<remove_reference_t<_Tp>>
        && !__detail::__is_initializer_list<remove_cvref_t<_Tp>>))));



  struct __advance_fn final
  {
    template<input_or_output_iterator _It>
      constexpr void
      operator()(_It& __it, iter_difference_t<_It> __n) const
      {
 if constexpr (random_access_iterator<_It>)
   __it += __n;
 else if constexpr (bidirectional_iterator<_It>)
   {
     if (__n > 0)
       {
  do
    {
      ++__it;
    }
  while (--__n);
       }
     else if (__n < 0)
       {
  do
    {
      --__it;
    }
  while (++__n);
       }
   }
 else
   {

     do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__n >= 0), false)) std::__glibcxx_assert_fail(); } while (false);
     while (__n-- > 0)
       ++__it;
   }
      }

    template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
      constexpr void
      operator()(_It& __it, _Sent __bound) const
      {
 if constexpr (assignable_from<_It&, _Sent>)
   __it = std::move(__bound);
 else if constexpr (sized_sentinel_for<_Sent, _It>)
   (*this)(__it, __bound - __it);
 else
   {
     while (__it != __bound)
       ++__it;
   }
      }

    template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
      constexpr iter_difference_t<_It>
      operator()(_It& __it, iter_difference_t<_It> __n, _Sent __bound) const
      {
 if constexpr (sized_sentinel_for<_Sent, _It>)
   {
     const auto __diff = __bound - __it;

     if (__diff == 0)
       return __n;
     else if (__diff > 0 ? __n >= __diff : __n <= __diff)
       {
  (*this)(__it, __bound);
  return __n - __diff;
       }
     else if (__n != 0) [[likely]]
       {

  do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool((__n < 0) == (__diff < 0)), false)) std::__glibcxx_assert_fail(); } while (false);

  (*this)(__it, __n);
  return 0;
       }
     else
       return 0;
   }
 else if (__it == __bound || __n == 0)
   return __n;
 else if (__n > 0)
   {
     iter_difference_t<_It> __m = 0;
     do
       {
  ++__it;
  ++__m;
       }
     while (__m != __n && __it != __bound);
     return __n - __m;
   }
 else if constexpr (bidirectional_iterator<_It> && same_as<_It, _Sent>)
   {
     iter_difference_t<_It> __m = 0;
     do
       {
  --__it;
  --__m;
       }
     while (__m != __n && __it != __bound);
     return __n - __m;
   }
 else
   {

     do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__n >= 0), false)) std::__glibcxx_assert_fail(); } while (false);
     return __n;
   }
      }

    void operator&() const = delete;
  };

  inline constexpr __advance_fn advance{};

  struct __distance_fn final
  {
    template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
      requires (!sized_sentinel_for<_Sent, _It>)
      constexpr iter_difference_t<_It>
      operator()[[nodiscard]](_It __first, _Sent __last) const
      {
 iter_difference_t<_It> __n = 0;
 while (__first != __last)
   {
     ++__first;
     ++__n;
   }
 return __n;
      }

    template<input_or_output_iterator _It, sized_sentinel_for<_It> _Sent>
      [[nodiscard]]
      constexpr iter_difference_t<_It>
      operator()(const _It& __first, const _Sent& __last) const
      {
 return __last - __first;
      }

    template<range _Range>
      [[nodiscard]]
      constexpr range_difference_t<_Range>
      operator()(_Range&& __r) const
      {
 if constexpr (sized_range<_Range>)
   return static_cast<range_difference_t<_Range>>(ranges::size(__r));
 else
   return (*this)(ranges::begin(__r), ranges::end(__r));
      }

    void operator&() const = delete;
  };

  inline constexpr __distance_fn distance{};

  struct __next_fn final
  {
    template<input_or_output_iterator _It>
      [[nodiscard]]
      constexpr _It
      operator()(_It __x) const
      {
 ++__x;
 return __x;
      }

    template<input_or_output_iterator _It>
      [[nodiscard]]
      constexpr _It
      operator()(_It __x, iter_difference_t<_It> __n) const
      {
 ranges::advance(__x, __n);
 return __x;
      }

    template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
      [[nodiscard]]
      constexpr _It
      operator()(_It __x, _Sent __bound) const
      {
 ranges::advance(__x, __bound);
 return __x;
      }

    template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
      [[nodiscard]]
      constexpr _It
      operator()(_It __x, iter_difference_t<_It> __n, _Sent __bound) const
      {
 ranges::advance(__x, __n, __bound);
 return __x;
      }

    void operator&() const = delete;
  };

  inline constexpr __next_fn next{};

  struct __prev_fn final
  {
    template<bidirectional_iterator _It>
      [[nodiscard]]
      constexpr _It
      operator()(_It __x) const
      {
 --__x;
 return __x;
      }

    template<bidirectional_iterator _It>
      [[nodiscard]]
      constexpr _It
      operator()(_It __x, iter_difference_t<_It> __n) const
      {
 ranges::advance(__x, -__n);
 return __x;
      }

    template<bidirectional_iterator _It>
      [[nodiscard]]
      constexpr _It
      operator()(_It __x, iter_difference_t<_It> __n, _It __bound) const
      {
 ranges::advance(__x, -__n, __bound);
 return __x;
      }

    void operator&() const = delete;
  };

  inline constexpr __prev_fn prev{};


  struct dangling
  {
    constexpr dangling() noexcept = default;
    template<typename... _Args>
      constexpr dangling(_Args&&...) noexcept { }
  };

  template<range _Range>
    using borrowed_iterator_t = __conditional_t<borrowed_range<_Range>,
      iterator_t<_Range>,
      dangling>;
}


  struct from_range_t { explicit from_range_t() = default; };
  inline constexpr from_range_t from_range{};



}
# 35 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/ranges_util.h" 2 3




namespace std
{

namespace ranges
{


  namespace __detail
  {
    template<typename _Range>
      concept __simple_view = view<_Range> && range<const _Range>
 && same_as<iterator_t<_Range>, iterator_t<const _Range>>
 && same_as<sentinel_t<_Range>, sentinel_t<const _Range>>;

    template<typename _It>
      concept __has_arrow = input_iterator<_It>
 && (is_pointer_v<_It> || requires(_It __it) { __it.operator->(); });

    using std::__detail::__different_from;
  }


  template<typename _Derived>
    requires is_class_v<_Derived> && same_as<_Derived, remove_cv_t<_Derived>>
    class view_interface
    {
    private:
      constexpr _Derived& _M_derived() noexcept
      {
 static_assert(derived_from<_Derived, view_interface<_Derived>>);
 static_assert(view<_Derived>);
 return static_cast<_Derived&>(*this);
      }

      constexpr const _Derived& _M_derived() const noexcept
      {
 static_assert(derived_from<_Derived, view_interface<_Derived>>);
 static_assert(view<_Derived>);
 return static_cast<const _Derived&>(*this);
      }

      static constexpr bool
      _S_bool(bool) noexcept;

      template<typename _Tp>
 static constexpr bool
 _S_empty(_Tp& __t)
 noexcept(noexcept(_S_bool(ranges::begin(__t) == ranges::end(__t))))
 { return ranges::begin(__t) == ranges::end(__t); }

      template<typename _Tp>
 static constexpr auto
 _S_size(_Tp& __t)
 noexcept(noexcept(ranges::end(__t) - ranges::begin(__t)))
 { return ranges::end(__t) - ranges::begin(__t); }

    public:
      constexpr bool
      empty()
      noexcept(noexcept(_S_empty(_M_derived())))
      requires forward_range<_Derived> && (!sized_range<_Derived>)
      { return _S_empty(_M_derived()); }

      constexpr bool
      empty()
      noexcept(noexcept(ranges::size(_M_derived()) == 0))
      requires sized_range<_Derived>
      { return ranges::size(_M_derived()) == 0; }

      constexpr bool
      empty() const
      noexcept(noexcept(_S_empty(_M_derived())))
      requires forward_range<const _Derived> && (!sized_range<const _Derived>)
      { return _S_empty(_M_derived()); }

      constexpr bool
      empty() const
      noexcept(noexcept(ranges::size(_M_derived()) == 0))
      requires sized_range<const _Derived>
      { return ranges::size(_M_derived()) == 0; }

      constexpr explicit
      operator bool() noexcept(noexcept(ranges::empty(_M_derived())))
      requires requires { ranges::empty(_M_derived()); }
      { return !ranges::empty(_M_derived()); }

      constexpr explicit
      operator bool() const noexcept(noexcept(ranges::empty(_M_derived())))
      requires requires { ranges::empty(_M_derived()); }
      { return !ranges::empty(_M_derived()); }

      constexpr auto
      data() noexcept(noexcept(ranges::begin(_M_derived())))
      requires contiguous_iterator<iterator_t<_Derived>>
      { return std::to_address(ranges::begin(_M_derived())); }

      constexpr auto
      data() const noexcept(noexcept(ranges::begin(_M_derived())))
      requires range<const _Derived>
 && contiguous_iterator<iterator_t<const _Derived>>
      { return std::to_address(ranges::begin(_M_derived())); }

      constexpr auto
      size() noexcept(noexcept(_S_size(_M_derived())))
      requires forward_range<_Derived>
 && sized_sentinel_for<sentinel_t<_Derived>, iterator_t<_Derived>>
      { return _S_size(_M_derived()); }

      constexpr auto
      size() const noexcept(noexcept(_S_size(_M_derived())))
      requires forward_range<const _Derived>
 && sized_sentinel_for<sentinel_t<const _Derived>,
         iterator_t<const _Derived>>
      { return _S_size(_M_derived()); }

      constexpr decltype(auto)
      front() requires forward_range<_Derived>
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(!empty()), false)) std::__glibcxx_assert_fail(); } while (false);
 return *ranges::begin(_M_derived());
      }

      constexpr decltype(auto)
      front() const requires forward_range<const _Derived>
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(!empty()), false)) std::__glibcxx_assert_fail(); } while (false);
 return *ranges::begin(_M_derived());
      }

      constexpr decltype(auto)
      back()
      requires bidirectional_range<_Derived> && common_range<_Derived>
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(!empty()), false)) std::__glibcxx_assert_fail(); } while (false);
 return *ranges::prev(ranges::end(_M_derived()));
      }

      constexpr decltype(auto)
      back() const
      requires bidirectional_range<const _Derived>
 && common_range<const _Derived>
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(!empty()), false)) std::__glibcxx_assert_fail(); } while (false);
 return *ranges::prev(ranges::end(_M_derived()));
      }

      template<random_access_range _Range = _Derived>
 constexpr decltype(auto)
 operator[](range_difference_t<_Range> __n)
 { return ranges::begin(_M_derived())[__n]; }

      template<random_access_range _Range = const _Derived>
 constexpr decltype(auto)
 operator[](range_difference_t<_Range> __n) const
 { return ranges::begin(_M_derived())[__n]; }


      constexpr auto
      cbegin() requires input_range<_Derived>
      { return ranges::cbegin(_M_derived()); }

      constexpr auto
      cbegin() const requires input_range<const _Derived>
      { return ranges::cbegin(_M_derived()); }

      constexpr auto
      cend() requires input_range<_Derived>
      { return ranges::cend(_M_derived()); }

      constexpr auto
      cend() const requires input_range<const _Derived>
      { return ranges::cend(_M_derived()); }

    };

  namespace __detail
  {
    template<typename _From, typename _To>
      concept __uses_nonqualification_pointer_conversion
 = is_pointer_v<_From> && is_pointer_v<_To>
   && !convertible_to<remove_pointer_t<_From>(*)[],
        remove_pointer_t<_To>(*)[]>;

    template<typename _From, typename _To>
      concept __convertible_to_non_slicing = convertible_to<_From, _To>
 && !__uses_nonqualification_pointer_conversion<decay_t<_From>,
             decay_t<_To>>;
# 244 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/ranges_util.h" 3
    template<typename _Tp, typename _Up, typename _Vp>
      concept __pair_like_convertible_from
 = !range<_Tp> && !is_reference_v<_Vp> && __pair_like<_Tp>
 && constructible_from<_Tp, _Up, _Vp>
 && __convertible_to_non_slicing<_Up, tuple_element_t<0, _Tp>>
 && convertible_to<_Vp, tuple_element_t<1, _Tp>>;

  }

  namespace views { struct _Drop; }

  enum class subrange_kind : bool { unsized, sized };


  template<input_or_output_iterator _It, sentinel_for<_It> _Sent = _It,
    subrange_kind _Kind = sized_sentinel_for<_Sent, _It>
      ? subrange_kind::sized : subrange_kind::unsized>
    requires (_Kind == subrange_kind::sized || !sized_sentinel_for<_Sent, _It>)
    class subrange : public view_interface<subrange<_It, _Sent, _Kind>>
    {
    private:
      static constexpr bool _S_store_size
 = _Kind == subrange_kind::sized && !sized_sentinel_for<_Sent, _It>;

      friend struct views::_Drop;

      _It _M_begin = _It();
      [[no_unique_address]] _Sent _M_end = _Sent();

      using __size_type
 = __detail::__make_unsigned_like_t<iter_difference_t<_It>>;

      template<typename _Tp, bool = _S_store_size>
 struct _Size
 {
   [[__gnu__::__always_inline__]]
   constexpr _Size(_Tp = {}) { }
 };

      template<typename _Tp>
 struct _Size<_Tp, true>
 {
   [[__gnu__::__always_inline__]]
   constexpr _Size(_Tp __s = {}) : _M_size(__s) { }

   _Tp _M_size;
 };

      [[no_unique_address]] _Size<__size_type> _M_size = {};

    public:
      subrange() requires default_initializable<_It> = default;

      constexpr
      subrange(__detail::__convertible_to_non_slicing<_It> auto __i, _Sent __s)
      noexcept(is_nothrow_constructible_v<_It, decltype(__i)>
        && is_nothrow_constructible_v<_Sent, _Sent&>)
 requires (!_S_store_size)
      : _M_begin(std::move(__i)), _M_end(__s)
      { }

      constexpr
      subrange(__detail::__convertible_to_non_slicing<_It> auto __i, _Sent __s,
        __size_type __n)
      noexcept(is_nothrow_constructible_v<_It, decltype(__i)>
        && is_nothrow_constructible_v<_Sent, _Sent&>)
 requires (_Kind == subrange_kind::sized)
      : _M_begin(std::move(__i)), _M_end(__s), _M_size(__n)
      { }

      template<__detail::__different_from<subrange> _Rng>
 requires borrowed_range<_Rng>
   && __detail::__convertible_to_non_slicing<iterator_t<_Rng>, _It>
   && convertible_to<sentinel_t<_Rng>, _Sent>
 constexpr
 subrange(_Rng&& __r)
 noexcept(noexcept(subrange(__r, ranges::size(__r))))
 requires _S_store_size && sized_range<_Rng>
 : subrange(__r, ranges::size(__r))
 { }

      template<__detail::__different_from<subrange> _Rng>
 requires borrowed_range<_Rng>
   && __detail::__convertible_to_non_slicing<iterator_t<_Rng>, _It>
   && convertible_to<sentinel_t<_Rng>, _Sent>
 constexpr
 subrange(_Rng&& __r)
 noexcept(noexcept(subrange(ranges::begin(__r), ranges::end(__r))))
 requires (!_S_store_size)
 : subrange(ranges::begin(__r), ranges::end(__r))
 { }

      template<borrowed_range _Rng>
 requires __detail::__convertible_to_non_slicing<iterator_t<_Rng>, _It>
   && convertible_to<sentinel_t<_Rng>, _Sent>
 constexpr
 subrange(_Rng&& __r, __size_type __n)
 noexcept(noexcept(subrange(ranges::begin(__r), ranges::end(__r), __n)))
 requires (_Kind == subrange_kind::sized)
 : subrange{ranges::begin(__r), ranges::end(__r), __n}
 { }

      template<__detail::__different_from<subrange> _PairLike>
 requires __detail::__pair_like_convertible_from<_PairLike, const _It&,
       const _Sent&>
 constexpr
 operator _PairLike() const
 { return _PairLike(_M_begin, _M_end); }

      constexpr _It
      begin() const requires copyable<_It>
      { return _M_begin; }

      [[nodiscard]] constexpr _It
      begin() requires (!copyable<_It>)
      { return std::move(_M_begin); }

      constexpr _Sent end() const { return _M_end; }

      constexpr bool empty() const { return _M_begin == _M_end; }

      constexpr __size_type
      size() const requires (_Kind == subrange_kind::sized)
      {
 if constexpr (_S_store_size)
   return _M_size._M_size;
 else
   return __detail::__to_unsigned_like(_M_end - _M_begin);
      }

      [[nodiscard]] constexpr subrange
      next(iter_difference_t<_It> __n = 1) const &
 requires forward_iterator<_It>
      {
 auto __tmp = *this;
 __tmp.advance(__n);
 return __tmp;
      }

      [[nodiscard]] constexpr subrange
      next(iter_difference_t<_It> __n = 1) &&
      {
 advance(__n);
 return std::move(*this);
      }

      [[nodiscard]] constexpr subrange
      prev(iter_difference_t<_It> __n = 1) const
 requires bidirectional_iterator<_It>
      {
 auto __tmp = *this;
 __tmp.advance(-__n);
 return __tmp;
      }

      constexpr subrange&
      advance(iter_difference_t<_It> __n)
      {


 if constexpr (bidirectional_iterator<_It>)
   if (__n < 0)
     {
       ranges::advance(_M_begin, __n);
       if constexpr (_S_store_size)
  _M_size._M_size += __detail::__to_unsigned_like(-__n);
       return *this;
     }

 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__n >= 0), false)) std::__glibcxx_assert_fail(); } while (false);
 auto __d = __n - ranges::advance(_M_begin, __n, _M_end);
 if constexpr (_S_store_size)
   _M_size._M_size -= __detail::__to_unsigned_like(__d);
 return *this;
      }
    };

  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
    subrange(_It, _Sent) -> subrange<_It, _Sent>;

  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
    subrange(_It, _Sent,
      __detail::__make_unsigned_like_t<iter_difference_t<_It>>)
      -> subrange<_It, _Sent, subrange_kind::sized>;

  template<borrowed_range _Rng>
    subrange(_Rng&&)
      -> subrange<iterator_t<_Rng>, sentinel_t<_Rng>,
   (sized_range<_Rng>
    || sized_sentinel_for<sentinel_t<_Rng>, iterator_t<_Rng>>)
   ? subrange_kind::sized : subrange_kind::unsized>;

  template<borrowed_range _Rng>
    subrange(_Rng&&,
      __detail::__make_unsigned_like_t<range_difference_t<_Rng>>)
      -> subrange<iterator_t<_Rng>, sentinel_t<_Rng>, subrange_kind::sized>;

  template<size_t _Num, class _It, class _Sent, subrange_kind _Kind>
    requires (_Num < 2)
    constexpr auto
    get(const subrange<_It, _Sent, _Kind>& __r)
    {
      if constexpr (_Num == 0)
 return __r.begin();
      else
 return __r.end();
    }

  template<size_t _Num, class _It, class _Sent, subrange_kind _Kind>
    requires (_Num < 2)
    constexpr auto
    get(subrange<_It, _Sent, _Kind>&& __r)
    {
      if constexpr (_Num == 0)
 return __r.begin();
      else
 return __r.end();
    }

  template<typename _It, typename _Sent, subrange_kind _Kind>
    inline constexpr bool
      enable_borrowed_range<subrange<_It, _Sent, _Kind>> = true;

  template<range _Range>
    using borrowed_subrange_t = __conditional_t<borrowed_range<_Range>,
      subrange<iterator_t<_Range>>,
      dangling>;


  template<typename _Iter, typename _Sent, subrange_kind _Kind>
    inline constexpr bool __detail::__is_subrange<subrange<_Iter, _Sent, _Kind>> = true;
}



  template<typename _It, typename _Sent, ranges::subrange_kind _Kind>
    inline constexpr bool __is_tuple_like_v<ranges::subrange<_It, _Sent, _Kind>> = true;




namespace ranges
{
  struct __find_fn
  {
    template<input_iterator _Iter, sentinel_for<_Iter> _Sent, typename _Tp,
      typename _Proj = identity>
      requires indirect_binary_predicate<ranges::equal_to,
      projected<_Iter, _Proj>, const _Tp*>
      constexpr _Iter
      operator()(_Iter __first, _Sent __last,
   const _Tp& __value, _Proj __proj = {}) const
      {
 while (__first != __last
     && !(std::__invoke(__proj, *__first) == __value))
   ++__first;
 return __first;
      }

    template<input_range _Range, typename _Tp, typename _Proj = identity>
      requires indirect_binary_predicate<ranges::equal_to,
      projected<iterator_t<_Range>, _Proj>,
      const _Tp*>
      constexpr borrowed_iterator_t<_Range>
      operator()(_Range&& __r, const _Tp& __value, _Proj __proj = {}) const
      {
 return (*this)(ranges::begin(__r), ranges::end(__r),
         __value, std::move(__proj));
      }
  };

  inline constexpr __find_fn find{};

  struct __find_if_fn
  {
    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,
      typename _Proj = identity,
      indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
      constexpr _Iter
      operator()(_Iter __first, _Sent __last,
   _Pred __pred, _Proj __proj = {}) const
      {
 while (__first != __last
     && !(bool)std::__invoke(__pred, std::__invoke(__proj, *__first)))
   ++__first;
 return __first;
      }

    template<input_range _Range, typename _Proj = identity,
      indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>>
        _Pred>
      constexpr borrowed_iterator_t<_Range>
      operator()(_Range&& __r, _Pred __pred, _Proj __proj = {}) const
      {
 return (*this)(ranges::begin(__r), ranges::end(__r),
         std::move(__pred), std::move(__proj));
      }
  };

  inline constexpr __find_if_fn find_if{};

  struct __find_if_not_fn
  {
    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,
      typename _Proj = identity,
      indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
      constexpr _Iter
      operator()(_Iter __first, _Sent __last,
   _Pred __pred, _Proj __proj = {}) const
      {
 while (__first != __last
     && (bool)std::__invoke(__pred, std::__invoke(__proj, *__first)))
   ++__first;
 return __first;
      }

    template<input_range _Range, typename _Proj = identity,
      indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>>
        _Pred>
      constexpr borrowed_iterator_t<_Range>
      operator()(_Range&& __r, _Pred __pred, _Proj __proj = {}) const
      {
 return (*this)(ranges::begin(__r), ranges::end(__r),
         std::move(__pred), std::move(__proj));
      }
  };

  inline constexpr __find_if_not_fn find_if_not{};

  template<typename _Iter1, typename _Iter2>
    struct in_in_result
    {
      [[no_unique_address]] _Iter1 in1;
      [[no_unique_address]] _Iter2 in2;

      template<typename _IIter1, typename _IIter2>
 requires convertible_to<const _Iter1&, _IIter1>
   && convertible_to<const _Iter2&, _IIter2>
 constexpr
 operator in_in_result<_IIter1, _IIter2>() const &
 { return {in1, in2}; }

      template<typename _IIter1, typename _IIter2>
 requires convertible_to<_Iter1, _IIter1>
   && convertible_to<_Iter2, _IIter2>
 constexpr
 operator in_in_result<_IIter1, _IIter2>() &&
 { return {std::move(in1), std::move(in2)}; }
    };

  template<typename _Iter1, typename _Iter2>
    using mismatch_result = in_in_result<_Iter1, _Iter2>;

  struct __mismatch_fn
  {
    template<input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
      input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
      typename _Pred = ranges::equal_to,
      typename _Proj1 = identity, typename _Proj2 = identity>
      requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>
      constexpr mismatch_result<_Iter1, _Iter2>
      operator()(_Iter1 __first1, _Sent1 __last1,
   _Iter2 __first2, _Sent2 __last2, _Pred __pred = {},
   _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
      {
 while (__first1 != __last1 && __first2 != __last2
        && (bool)std::__invoke(__pred,
          std::__invoke(__proj1, *__first1),
          std::__invoke(__proj2, *__first2)))
 {
   ++__first1;
   ++__first2;
 }
 return { std::move(__first1), std::move(__first2) };
      }

    template<input_range _Range1, input_range _Range2,
      typename _Pred = ranges::equal_to,
      typename _Proj1 = identity, typename _Proj2 = identity>
      requires indirectly_comparable<iterator_t<_Range1>, iterator_t<_Range2>,
         _Pred, _Proj1, _Proj2>
      constexpr mismatch_result<iterator_t<_Range1>, iterator_t<_Range2>>
      operator()(_Range1&& __r1, _Range2&& __r2, _Pred __pred = {},
   _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
      {
 return (*this)(ranges::begin(__r1), ranges::end(__r1),
         ranges::begin(__r2), ranges::end(__r2),
         std::move(__pred),
         std::move(__proj1), std::move(__proj2));
      }
  };

  inline constexpr __mismatch_fn mismatch{};

  struct __search_fn
  {
    template<forward_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
      forward_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
      typename _Pred = ranges::equal_to,
      typename _Proj1 = identity, typename _Proj2 = identity>
      requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>
      constexpr subrange<_Iter1>
      operator()(_Iter1 __first1, _Sent1 __last1,
   _Iter2 __first2, _Sent2 __last2, _Pred __pred = {},
   _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
      {
 if (__first1 == __last1 || __first2 == __last2)
   return {__first1, __first1};

 for (;;)
   {
     for (;;)
       {
  if (__first1 == __last1)
    return {__first1, __first1};
  if (std::__invoke(__pred,
      std::__invoke(__proj1, *__first1),
      std::__invoke(__proj2, *__first2)))
    break;
  ++__first1;
       }
     auto __cur1 = __first1;
     auto __cur2 = __first2;
     for (;;)
       {
  if (++__cur2 == __last2)
    return {__first1, ++__cur1};
  if (++__cur1 == __last1)
    return {__cur1, __cur1};
  if (!(bool)std::__invoke(__pred,
      std::__invoke(__proj1, *__cur1),
      std::__invoke(__proj2, *__cur2)))
    {
      ++__first1;
      break;
    }
       }
   }
      }

    template<forward_range _Range1, forward_range _Range2,
      typename _Pred = ranges::equal_to,
      typename _Proj1 = identity, typename _Proj2 = identity>
      requires indirectly_comparable<iterator_t<_Range1>, iterator_t<_Range2>,
         _Pred, _Proj1, _Proj2>
      constexpr borrowed_subrange_t<_Range1>
      operator()(_Range1&& __r1, _Range2&& __r2, _Pred __pred = {},
   _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
      {
 return (*this)(ranges::begin(__r1), ranges::end(__r1),
         ranges::begin(__r2), ranges::end(__r2),
         std::move(__pred),
         std::move(__proj1), std::move(__proj2));
      }
  };

  inline constexpr __search_fn search{};

  struct __min_fn
  {
    template<typename _Tp, typename _Proj = identity,
      indirect_strict_weak_order<projected<const _Tp*, _Proj>>
        _Comp = ranges::less>
      constexpr const _Tp&
      operator()(const _Tp& __a, const _Tp& __b,
   _Comp __comp = {}, _Proj __proj = {}) const
      {
 if (std::__invoke(__comp,
     std::__invoke(__proj, __b),
     std::__invoke(__proj, __a)))
   return __b;
 else
   return __a;
      }

    template<input_range _Range, typename _Proj = identity,
      indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>>
        _Comp = ranges::less>
      requires indirectly_copyable_storable<iterator_t<_Range>,
         range_value_t<_Range>*>
      constexpr range_value_t<_Range>
      operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const
      {
 auto __first = ranges::begin(__r);
 auto __last = ranges::end(__r);
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__first != __last), false)) std::__glibcxx_assert_fail(); } while (false);
 auto __result = *__first;
 while (++__first != __last)
   {
     auto __tmp = *__first;
     if (std::__invoke(__comp,
         std::__invoke(__proj, __tmp),
         std::__invoke(__proj, __result)))
       __result = std::move(__tmp);
   }
 return __result;
      }

    template<copyable _Tp, typename _Proj = identity,
      indirect_strict_weak_order<projected<const _Tp*, _Proj>>
        _Comp = ranges::less>
      constexpr _Tp
      operator()(initializer_list<_Tp> __r,
   _Comp __comp = {}, _Proj __proj = {}) const
      {
 return (*this)(ranges::subrange(__r),
         std::move(__comp), std::move(__proj));
      }
  };

  inline constexpr __min_fn min{};

  struct __adjacent_find_fn
  {
    template<forward_iterator _Iter, sentinel_for<_Iter> _Sent,
      typename _Proj = identity,
      indirect_binary_predicate<projected<_Iter, _Proj>,
           projected<_Iter, _Proj>> _Pred
        = ranges::equal_to>
      constexpr _Iter
      operator()(_Iter __first, _Sent __last,
   _Pred __pred = {}, _Proj __proj = {}) const
      {
 if (__first == __last)
   return __first;
 auto __next = __first;
 for (; ++__next != __last; __first = __next)
   {
     if (std::__invoke(__pred,
         std::__invoke(__proj, *__first),
         std::__invoke(__proj, *__next)))
       return __first;
   }
 return __next;
      }

    template<forward_range _Range, typename _Proj = identity,
      indirect_binary_predicate<
        projected<iterator_t<_Range>, _Proj>,
        projected<iterator_t<_Range>, _Proj>> _Pred = ranges::equal_to>
      constexpr borrowed_iterator_t<_Range>
      operator()(_Range&& __r, _Pred __pred = {}, _Proj __proj = {}) const
      {
 return (*this)(ranges::begin(__r), ranges::end(__r),
         std::move(__pred), std::move(__proj));
      }
  };

  inline constexpr __adjacent_find_fn adjacent_find{};

}

  using ranges::get;

  template<typename _Iter, typename _Sent, ranges::subrange_kind _Kind>
    struct tuple_size<ranges::subrange<_Iter, _Sent, _Kind>>
    : integral_constant<size_t, 2>
    { };

  template<typename _Iter, typename _Sent, ranges::subrange_kind _Kind>
    struct tuple_element<0, ranges::subrange<_Iter, _Sent, _Kind>>
    { using type = _Iter; };

  template<typename _Iter, typename _Sent, ranges::subrange_kind _Kind>
    struct tuple_element<1, ranges::subrange<_Iter, _Sent, _Kind>>
    { using type = _Sent; };

  template<typename _Iter, typename _Sent, ranges::subrange_kind _Kind>
    struct tuple_element<0, const ranges::subrange<_Iter, _Sent, _Kind>>
    { using type = _Iter; };

  template<typename _Iter, typename _Sent, ranges::subrange_kind _Kind>
    struct tuple_element<1, const ranges::subrange<_Iter, _Sent, _Kind>>
    { using type = _Sent; };


}
# 45 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tuple" 2 3
# 54 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tuple" 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 1 3
# 47 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 3
       
# 48 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 3
# 55 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tuple" 2 3

namespace std
{







  template<typename... _Elements>
    class tuple;

  template<typename _Tp>
    struct __is_empty_non_tuple : is_empty<_Tp> { };


  template<typename _El0, typename... _El>
    struct __is_empty_non_tuple<tuple<_El0, _El...>> : false_type { };


  template<typename _Tp>
    using __empty_not_final
    = __conditional_t<__is_final(_Tp), false_type,
        __is_empty_non_tuple<_Tp>>;

  template<size_t _Idx, typename _Head,
    bool = __empty_not_final<_Head>::value>
    struct _Head_base;


  template<size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, true>
    {
      constexpr _Head_base()
      : _M_head_impl() { }

      constexpr _Head_base(const _Head& __h)
      : _M_head_impl(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
 constexpr _Head_base(_UHead&& __h)
 : _M_head_impl(std::forward<_UHead>(__h)) { }

      constexpr
      _Head_base(allocator_arg_t, __uses_alloc0)
      : _M_head_impl() { }

      template<typename _Alloc>
 constexpr
 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _M_head_impl(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 constexpr
 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _M_head_impl(*__a._M_a) { }

      template<typename _UHead>
 constexpr
 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 constexpr
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead))
 { }

      template<typename _Alloc, typename _UHead>
 constexpr
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b._M_head_impl; }

      [[__no_unique_address__]] _Head _M_head_impl;
    };
# 195 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tuple" 3
  template<size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, false>
    {
      constexpr _Head_base()
      : _M_head_impl() { }

      constexpr _Head_base(const _Head& __h)
      : _M_head_impl(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
 : _M_head_impl(std::forward<_UHead>(__h)) { }

      constexpr
      _Head_base(allocator_arg_t, __uses_alloc0)
      : _M_head_impl() { }

      template<typename _Alloc>
 constexpr
 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _M_head_impl(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 constexpr
 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _M_head_impl(*__a._M_a) { }

      template<typename _UHead>
 constexpr
 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 constexpr
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead))
 { }

      template<typename _Alloc, typename _UHead>
 constexpr
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b._M_head_impl; }

      _Head _M_head_impl;
    };


  struct __tuple_like_tag_t { explicit __tuple_like_tag_t() = default; };



  template<typename _Cat, typename _Tp, typename _Up>
    constexpr _Cat
    __tuple_cmp(const _Tp&, const _Up&, index_sequence<>);

  template<typename _Cat, typename _Tp, typename _Up,
    size_t _Idx0, size_t... _Idxs>
    constexpr _Cat
    __tuple_cmp(const _Tp& __t, const _Up& __u,
  index_sequence<_Idx0, _Idxs...>);
# 274 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tuple" 3
  template<size_t _Idx, typename... _Elements>
    struct _Tuple_impl;






  template<size_t _Idx, typename _Head, typename... _Tail>
    struct _Tuple_impl<_Idx, _Head, _Tail...>
    : public _Tuple_impl<_Idx + 1, _Tail...>,
      private _Head_base<_Idx, _Head>
    {
      template<size_t, typename...> friend struct _Tuple_impl;

      typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;
      typedef _Head_base<_Idx, _Head> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr _Inherited&
      _M_tail(_Tuple_impl& __t) noexcept { return __t; }

      static constexpr const _Inherited&
      _M_tail(const _Tuple_impl& __t) noexcept { return __t; }

      constexpr _Tuple_impl()
      : _Inherited(), _Base() { }

      explicit constexpr
      _Tuple_impl(const _Head& __head, const _Tail&... __tail)
      : _Inherited(__tail...), _Base(__head)
      { }

      template<typename _UHead, typename... _UTail,
        typename = __enable_if_t<sizeof...(_Tail) == sizeof...(_UTail)>>
 explicit constexpr
 _Tuple_impl(_UHead&& __head, _UTail&&... __tail)
 : _Inherited(std::forward<_UTail>(__tail)...),
   _Base(std::forward<_UHead>(__head))
 { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;



      _Tuple_impl& operator=(const _Tuple_impl&) = delete;

      _Tuple_impl(_Tuple_impl&&) = default;

      template<typename... _UElements>
 constexpr
 _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in))
 { }

      template<typename _UHead, typename... _UTails>
 constexpr
 _Tuple_impl(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in)))
 { }


      template<typename... _UElements>
 constexpr
 _Tuple_impl(_Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in))
 { }

      template<typename _UHead, typename... _UTails>
 constexpr
 _Tuple_impl(const _Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(std::forward<const _UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in)))
 { }



      template<typename _UTuple, size_t... _Is>
 constexpr
 _Tuple_impl(__tuple_like_tag_t, _UTuple&& __u, index_sequence<_Is...>)
 : _Tuple_impl(std::get<_Is>(std::forward<_UTuple>(__u))...)
 { }


      template<typename _Alloc>
 constexpr
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a),
   _Base(__tag, __use_alloc<_Head>(__a))
 { }

      template<typename _Alloc>
 constexpr
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Head& __head, const _Tail&... __tail)
 : _Inherited(__tag, __a, __tail...),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head)
 { }

      template<typename _Alloc, typename _UHead, typename... _UTail,
        typename = __enable_if_t<sizeof...(_Tail) == sizeof...(_UTail)>>
 constexpr
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      _UHead&& __head, _UTail&&... __tail)
 : _Inherited(__tag, __a, std::forward<_UTail>(__tail)...),
   _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
  std::forward<_UHead>(__head))
 { }

      template<typename _Alloc>
 constexpr
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Tuple_impl& __in)
 : _Inherited(__tag, __a, _M_tail(__in)),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in))
 { }

      template<typename _Alloc>
 constexpr
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      _Tuple_impl&& __in)
 : _Inherited(__tag, __a, std::move(_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  std::forward<_Head>(_M_head(__in)))
 { }

      template<typename _Alloc, typename _UHead, typename... _UTails>
 constexpr
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Tuple_impl<_Idx, _UHead, _UTails...>& __in)
 : _Inherited(__tag, __a,
       _Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in)),
   _Base(__use_alloc<_Head, _Alloc, const _UHead&>(__a),
  _Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))
 { }

      template<typename _Alloc, typename _UHead, typename... _UTails>
 constexpr
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      _Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(__tag, __a, std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
  std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in)))
 { }


      template<typename _Alloc, typename _UHead, typename... _UTails>
 constexpr
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      _Tuple_impl<_Idx, _UHead, _UTails...>& __in)
 : _Inherited(__tag, __a,
       _Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in)),
   _Base(__use_alloc<_Head, _Alloc, _UHead&>(__a),
  _Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))
 { }

      template<typename _Alloc, typename _UHead, typename... _UTails>
 constexpr
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(__tag, __a, std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, const _UHead>(__a),
  std::forward<const _UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in)))
 { }



      template<typename _Alloc, typename _UTuple, size_t... _Is>
 constexpr
 _Tuple_impl(__tuple_like_tag_t, allocator_arg_t __tag, const _Alloc& __a,
      _UTuple&& __u, index_sequence<_Is...>)
 : _Tuple_impl(__tag, __a, std::get<_Is>(std::forward<_UTuple>(__u))...)
 { }


      template<typename... _UElements>
 constexpr
 void
 _M_assign(const _Tuple_impl<_Idx, _UElements...>& __in)
 {
   _M_head(*this) = _Tuple_impl<_Idx, _UElements...>::_M_head(__in);
   _M_tail(*this)._M_assign(
       _Tuple_impl<_Idx, _UElements...>::_M_tail(__in));
 }

      template<typename _UHead, typename... _UTails>
 constexpr
 void
 _M_assign(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 {
   _M_head(*this) = std::forward<_UHead>
     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in));
   _M_tail(*this)._M_assign(
       std::move(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in)));
 }


      template<typename... _UElements>
 constexpr void
 _M_assign(const _Tuple_impl<_Idx, _UElements...>& __in) const
 {
   _M_head(*this) = _Tuple_impl<_Idx, _UElements...>::_M_head(__in);
   _M_tail(*this)._M_assign(
       _Tuple_impl<_Idx, _UElements...>::_M_tail(__in));
 }

      template<typename _UHead, typename... _UTails>
 constexpr void
 _M_assign(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in) const
 {
   _M_head(*this) = std::forward<_UHead>
     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in));
   _M_tail(*this)._M_assign(
       std::move(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in)));
 }



      template<typename _UTuple>
 constexpr void
 _M_assign(__tuple_like_tag_t __tag, _UTuple&& __u)
 {
   _M_head(*this) = std::get<_Idx>(std::forward<_UTuple>(__u));
   _M_tail(*this)._M_assign(__tag, std::forward<_UTuple>(__u));
 }

      template<typename _UTuple>
 constexpr void
 _M_assign(__tuple_like_tag_t __tag, _UTuple&& __u) const
 {
   _M_head(*this) = std::get<_Idx>(std::forward<_UTuple>(__u));
   _M_tail(*this)._M_assign(__tag, std::forward<_UTuple>(__u));
 }


    protected:
      constexpr
      void
      _M_swap(_Tuple_impl& __in)
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
 _Inherited::_M_swap(_M_tail(__in));
      }


      constexpr void
      _M_swap(const _Tuple_impl& __in) const
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
 _Inherited::_M_swap(_M_tail(__in));
      }

    };


  template<size_t _Idx, typename _Head>
    struct _Tuple_impl<_Idx, _Head>
    : private _Head_base<_Idx, _Head>
    {
      template<size_t, typename...> friend struct _Tuple_impl;

      typedef _Head_base<_Idx, _Head> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      constexpr
      _Tuple_impl()
      : _Base() { }

      explicit constexpr
      _Tuple_impl(const _Head& __head)
      : _Base(__head)
      { }

      template<typename _UHead>
 explicit constexpr
 _Tuple_impl(_UHead&& __head)
 : _Base(std::forward<_UHead>(__head))
 { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;



      _Tuple_impl& operator=(const _Tuple_impl&) = delete;




      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(is_nothrow_move_constructible<_Head>::value)
      : _Base(static_cast<_Base&&>(__in))
      { }


      template<typename _UHead>
 constexpr
 _Tuple_impl(const _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(_Tuple_impl<_Idx, _UHead>::_M_head(__in))
 { }

      template<typename _UHead>
 constexpr
 _Tuple_impl(_Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }


      template<typename _UHead>
 constexpr
 _Tuple_impl(_Tuple_impl<_Idx, _UHead>& __in)
 : _Base(_Tuple_impl<_Idx, _UHead>::_M_head(__in))
 { }

      template<typename _UHead>
 constexpr
 _Tuple_impl(const _Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(std::forward<const _UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }



      template<typename _UTuple>
 constexpr
 _Tuple_impl(__tuple_like_tag_t, _UTuple&& __u, index_sequence<0>)
 : _Tuple_impl(std::get<0>(std::forward<_UTuple>(__u)))
 { }


      template<typename _Alloc>
 constexpr
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Base(__tag, __use_alloc<_Head>(__a))
 { }

      template<typename _Alloc>
 constexpr
 _Tuple_impl(allocator_arg_t, const _Alloc& __a,
      const _Head& __head)
 : _Base(__use_alloc<_Head, _Alloc, const _Head&>(__a), __head)
 { }

      template<typename _Alloc, typename _UHead>
 constexpr
 _Tuple_impl(allocator_arg_t, const _Alloc& __a,
      _UHead&& __head)
 : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
  std::forward<_UHead>(__head))
 { }

      template<typename _Alloc>
 constexpr
 _Tuple_impl(allocator_arg_t, const _Alloc& __a,
      const _Tuple_impl& __in)
 : _Base(__use_alloc<_Head, _Alloc, const _Head&>(__a), _M_head(__in))
 { }

      template<typename _Alloc>
 constexpr
 _Tuple_impl(allocator_arg_t, const _Alloc& __a,
      _Tuple_impl&& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  std::forward<_Head>(_M_head(__in)))
 { }

      template<typename _Alloc, typename _UHead>
 constexpr
 _Tuple_impl(allocator_arg_t, const _Alloc& __a,
      const _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(__use_alloc<_Head, _Alloc, const _UHead&>(__a),
  _Tuple_impl<_Idx, _UHead>::_M_head(__in))
 { }

      template<typename _Alloc, typename _UHead>
 constexpr
 _Tuple_impl(allocator_arg_t, const _Alloc& __a,
      _Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
  std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }


      template<typename _Alloc, typename _UHead>
 constexpr
 _Tuple_impl(allocator_arg_t, const _Alloc& __a,
      _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(__use_alloc<_Head, _Alloc, _UHead&>(__a),
  _Tuple_impl<_Idx, _UHead>::_M_head(__in))
 { }

      template<typename _Alloc, typename _UHead>
 constexpr
 _Tuple_impl(allocator_arg_t, const _Alloc& __a,
      const _Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(__use_alloc<_Head, _Alloc, const _UHead>(__a),
  std::forward<const _UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }



      template<typename _Alloc, typename _UTuple>
 constexpr
 _Tuple_impl(__tuple_like_tag_t, allocator_arg_t __tag, const _Alloc& __a,
      _UTuple&& __u, index_sequence<0>)
 : _Tuple_impl(__tag, __a, std::get<0>(std::forward<_UTuple>(__u)))
 { }


      template<typename _UHead>
 constexpr
 void
 _M_assign(const _Tuple_impl<_Idx, _UHead>& __in)
 {
   _M_head(*this) = _Tuple_impl<_Idx, _UHead>::_M_head(__in);
 }

      template<typename _UHead>
 constexpr
 void
 _M_assign(_Tuple_impl<_Idx, _UHead>&& __in)
 {
   _M_head(*this)
     = std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in));
 }


      template<typename _UHead>
 constexpr void
 _M_assign(const _Tuple_impl<_Idx, _UHead>& __in) const
 {
   _M_head(*this) = _Tuple_impl<_Idx, _UHead>::_M_head(__in);
 }

      template<typename _UHead>
 constexpr void
 _M_assign(_Tuple_impl<_Idx, _UHead>&& __in) const
 {
   _M_head(*this)
     = std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in));
 }



    template<typename _UTuple>
      constexpr void
      _M_assign(__tuple_like_tag_t, _UTuple&& __u)
      { _M_head(*this) = std::get<_Idx>(std::forward<_UTuple>(__u)); }

    template<typename _UTuple>
      constexpr void
      _M_assign(__tuple_like_tag_t, _UTuple&& __u) const
      { _M_head(*this) = std::get<_Idx>(std::forward<_UTuple>(__u)); }


    protected:
      constexpr
      void
      _M_swap(_Tuple_impl& __in)
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
      }


      constexpr void
      _M_swap(const _Tuple_impl& __in) const
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
      }

    };



  template<bool, typename... _Types>
    struct _TupleConstraints
    {
      template<typename... _UTypes>
 using __constructible = __and_<is_constructible<_Types, _UTypes>...>;

      template<typename... _UTypes>
 using __convertible = __and_<is_convertible<_UTypes, _Types>...>;




      template<typename... _UTypes>
 static constexpr bool __is_implicitly_constructible()
 {
   return __and_<__constructible<_UTypes...>,
   __convertible<_UTypes...>
   >::value;
 }




      template<typename... _UTypes>
 static constexpr bool __is_explicitly_constructible()
 {
   return __and_<__constructible<_UTypes...>,
   __not_<__convertible<_UTypes...>>
   >::value;
 }

      static constexpr bool __is_implicitly_default_constructible()
      {
 return __and_<std::__is_implicitly_default_constructible<_Types>...
        >::value;
      }

      static constexpr bool __is_explicitly_default_constructible()
      {
 return __and_<is_default_constructible<_Types>...,
        __not_<__and_<
   std::__is_implicitly_default_constructible<_Types>...>
        >>::value;
      }
    };



  template<typename... _Types>
    struct _TupleConstraints<false, _Types...>
    {
      template<typename... _UTypes>
 static constexpr bool __is_implicitly_constructible()
 { return false; }

      template<typename... _UTypes>
 static constexpr bool __is_explicitly_constructible()
 { return false; }
    };


  template<typename... _Elements>
    class tuple : public _Tuple_impl<0, _Elements...>
    {
      using _Inherited = _Tuple_impl<0, _Elements...>;


      template<typename... _UTypes>
 static consteval bool
 __constructible()
 {
   if constexpr (sizeof...(_UTypes) == sizeof...(_Elements))
     return __and_v<is_constructible<_Elements, _UTypes>...>;
   else
     return false;
 }

      template<typename... _UTypes>
 static consteval bool
 __nothrow_constructible()
 {
   if constexpr (sizeof...(_UTypes) == sizeof...(_Elements))
     return __and_v<is_nothrow_constructible<_Elements, _UTypes>...>;
   else
     return false;
 }

      template<typename... _UTypes>
 static consteval bool
 __convertible()
 {
   if constexpr (sizeof...(_UTypes) == sizeof...(_Elements))
     return __and_v<is_convertible<_UTypes, _Elements>...>;
   else
     return false;
 }



      template<typename... _UTypes>
 static consteval bool
 __disambiguating_constraint()
 {
   if constexpr (sizeof...(_Elements) != sizeof...(_UTypes))
     return false;
   else if constexpr (sizeof...(_Elements) == 1)
     {
       using _U0 = typename _Nth_type<0, _UTypes...>::type;
       return !is_same_v<remove_cvref_t<_U0>, tuple>;
     }
   else if constexpr (sizeof...(_Elements) < 4)
     {
       using _U0 = typename _Nth_type<0, _UTypes...>::type;
       if constexpr (!is_same_v<remove_cvref_t<_U0>, allocator_arg_t>)
  return true;
       else
  {
    using _T0 = typename _Nth_type<0, _Elements...>::type;
    return is_same_v<remove_cvref_t<_T0>, allocator_arg_t>;
  }
     }
   return true;
 }




      template<typename _Tuple>
 static consteval bool
 __use_other_ctor()
 {
   if constexpr (sizeof...(_Elements) != 1)
     return false;
   else if constexpr (is_same_v<remove_cvref_t<_Tuple>, tuple>)
     return true;
   else
     {
       using _Tp = typename _Nth_type<0, _Elements...>::type;
       if constexpr (is_convertible_v<_Tuple, _Tp>)
  return true;
       else if constexpr (is_constructible_v<_Tp, _Tuple>)
  return true;
     }
   return false;
 }

      template<typename... _Up>
 static consteval bool
 __dangles()
 {

   return (__reference_constructs_from_temporary(_Elements, _Up&&)
      || ...);



 }




      template<typename _UTuple>
 static consteval bool
 __dangles_from_tuple_like()
 {
   return []<size_t... _Is>(index_sequence<_Is...>) {
     return __dangles<decltype(std::get<_Is>(std::declval<_UTuple>()))...>();
   }(index_sequence_for<_Elements...>{});
 }

      template<typename _UTuple>
 static consteval bool
 __constructible_from_tuple_like()
 {
   return []<size_t... _Is>(index_sequence<_Is...>) {
     return __constructible<decltype(std::get<_Is>(std::declval<_UTuple>()))...>();
   }(index_sequence_for<_Elements...>{});
 }

      template<typename _UTuple>
 static consteval bool
 __convertible_from_tuple_like()
 {
   return []<size_t... _Is>(index_sequence<_Is...>) {
     return __convertible<decltype(std::get<_Is>(std::declval<_UTuple>()))...>();
   }(index_sequence_for<_Elements...>{});
 }


    public:
      constexpr
      explicit(!(__is_implicitly_default_constructible_v<_Elements> && ...))
      tuple()
      noexcept((is_nothrow_default_constructible_v<_Elements> && ...))
      requires (is_default_constructible_v<_Elements> && ...)
      : _Inherited()
      { }

      constexpr explicit(!__convertible<const _Elements&...>())
      tuple(const _Elements&... __elements)
      noexcept(__nothrow_constructible<const _Elements&...>())
      requires (__constructible<const _Elements&...>())
      : _Inherited(__elements...)
      { }

      template<typename... _UTypes>
 requires (__disambiguating_constraint<_UTypes...>())
   && (__constructible<_UTypes...>())
   && (!__dangles<_UTypes...>())
 constexpr explicit(!__convertible<_UTypes...>())
 tuple(_UTypes&&... __u)
 noexcept(__nothrow_constructible<_UTypes...>())
 : _Inherited(std::forward<_UTypes>(__u)...)
 { }

      template<typename... _UTypes>
 requires (__disambiguating_constraint<_UTypes...>())
   && (__constructible<_UTypes...>())
   && (__dangles<_UTypes...>())
 tuple(_UTypes&&...) = delete;

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;

      template<typename... _UTypes>
 requires (__constructible<const _UTypes&...>())
   && (!__use_other_ctor<const tuple<_UTypes...>&>())
   && (!__dangles<const _UTypes&...>())
 constexpr explicit(!__convertible<const _UTypes&...>())
 tuple(const tuple<_UTypes...>& __u)
 noexcept(__nothrow_constructible<const _UTypes&...>())
 : _Inherited(static_cast<const _Tuple_impl<0, _UTypes...>&>(__u))
 { }

      template<typename... _UTypes>
 requires (__constructible<const _UTypes&...>())
   && (!__use_other_ctor<const tuple<_UTypes...>&>())
   && (__dangles<const _UTypes&...>())
 tuple(const tuple<_UTypes...>&) = delete;

      template<typename... _UTypes>
 requires (__constructible<_UTypes...>())
   && (!__use_other_ctor<tuple<_UTypes...>>())
   && (!__dangles<_UTypes...>())
 constexpr explicit(!__convertible<_UTypes...>())
 tuple(tuple<_UTypes...>&& __u)
 noexcept(__nothrow_constructible<_UTypes...>())
 : _Inherited(static_cast<_Tuple_impl<0, _UTypes...>&&>(__u))
 { }

      template<typename... _UTypes>
 requires (__constructible<_UTypes...>())
   && (!__use_other_ctor<tuple<_UTypes...>>())
   && (__dangles<_UTypes...>())
 tuple(tuple<_UTypes...>&&) = delete;


      template<typename... _UTypes>
 requires (__constructible<_UTypes&...>())
   && (!__use_other_ctor<tuple<_UTypes...>&>())
   && (!__dangles<_UTypes&...>())
 constexpr explicit(!__convertible<_UTypes&...>())
 tuple(tuple<_UTypes...>& __u)
 noexcept(__nothrow_constructible<_UTypes&...>())
 : _Inherited(static_cast<_Tuple_impl<0, _UTypes...>&>(__u))
 { }

      template<typename... _UTypes>
 requires (__constructible<_UTypes&...>())
   && (!__use_other_ctor<tuple<_UTypes...>&>())
   && (__dangles<_UTypes&...>())
 tuple(tuple<_UTypes...>&) = delete;

      template<typename... _UTypes>
 requires (__constructible<const _UTypes...>())
   && (!__use_other_ctor<const tuple<_UTypes...>>())
   && (!__dangles<const _UTypes...>())
 constexpr explicit(!__convertible<const _UTypes...>())
 tuple(const tuple<_UTypes...>&& __u)
 noexcept(__nothrow_constructible<const _UTypes...>())
 : _Inherited(static_cast<const _Tuple_impl<0, _UTypes...>&&>(__u))
 { }

      template<typename... _UTypes>
 requires (__constructible<const _UTypes...>())
   && (!__use_other_ctor<const tuple<_UTypes...>>())
   && (__dangles<const _UTypes...>())
 tuple(const tuple<_UTypes...>&&) = delete;


      template<typename _U1, typename _U2>
 requires (sizeof...(_Elements) == 2)
   && (__constructible<const _U1&, const _U2&>())
   && (!__dangles<const _U1&, const _U2&>())
 constexpr explicit(!__convertible<const _U1&, const _U2&>())
 tuple(const pair<_U1, _U2>& __u)
 noexcept(__nothrow_constructible<const _U1&, const _U2&>())
 : _Inherited(__u.first, __u.second)
 { }

      template<typename _U1, typename _U2>
 requires (sizeof...(_Elements) == 2)
   && (__constructible<const _U1&, const _U2&>())
   && (__dangles<const _U1&, const _U2&>())
 tuple(const pair<_U1, _U2>&) = delete;

      template<typename _U1, typename _U2>
 requires (sizeof...(_Elements) == 2)
   && (__constructible<_U1, _U2>())
   && (!__dangles<_U1, _U2>())
 constexpr explicit(!__convertible<_U1, _U2>())
 tuple(pair<_U1, _U2>&& __u)
 noexcept(__nothrow_constructible<_U1, _U2>())
 : _Inherited(std::forward<_U1>(__u.first),
       std::forward<_U2>(__u.second))
 { }

      template<typename _U1, typename _U2>
 requires (sizeof...(_Elements) == 2)
   && (__constructible<_U1, _U2>())
   && (__dangles<_U1, _U2>())
 tuple(pair<_U1, _U2>&&) = delete;


      template<typename _U1, typename _U2>
 requires (sizeof...(_Elements) == 2)
   && (__constructible<_U1&, _U2&>())
   && (!__dangles<_U1&, _U2&>())
 constexpr explicit(!__convertible<_U1&, _U2&>())
 tuple(pair<_U1, _U2>& __u)
 noexcept(__nothrow_constructible<_U1&, _U2&>())
 : _Inherited(__u.first, __u.second)
 { }

      template<typename _U1, typename _U2>
 requires (sizeof...(_Elements) == 2)
   && (__constructible<_U1&, _U2&>())
   && (__dangles<_U1&, _U2&>())
 tuple(pair<_U1, _U2>&) = delete;

      template<typename _U1, typename _U2>
 requires (sizeof...(_Elements) == 2)
   && (__constructible<const _U1, const _U2>())
   && (!__dangles<const _U1, const _U2>())
 constexpr explicit(!__convertible<const _U1, const _U2>())
 tuple(const pair<_U1, _U2>&& __u)
 noexcept(__nothrow_constructible<const _U1, const _U2>())
 : _Inherited(std::forward<const _U1>(__u.first),
       std::forward<const _U2>(__u.second))
 { }

      template<typename _U1, typename _U2>
 requires (sizeof...(_Elements) == 2)
   && (__constructible<const _U1, const _U2>())
   && (__dangles<const _U1, const _U2>())
 tuple(const pair<_U1, _U2>&&) = delete;



      template<__eligible_tuple_like<tuple> _UTuple>
 requires (__constructible_from_tuple_like<_UTuple>())
   && (!__use_other_ctor<_UTuple>())
   && (!__dangles_from_tuple_like<_UTuple>())
 constexpr explicit(!__convertible_from_tuple_like<_UTuple>())
 tuple(_UTuple&& __u)
 : _Inherited(__tuple_like_tag_t{},
       std::forward<_UTuple>(__u),
       index_sequence_for<_Elements...>{})
 { }

      template<__eligible_tuple_like<tuple> _UTuple>
 requires (__constructible_from_tuple_like<_UTuple>())
   && (!__use_other_ctor<_UTuple>())
   && (__dangles_from_tuple_like<_UTuple>())
 tuple(_UTuple&&) = delete;




      template<typename _Alloc>
 constexpr
 explicit(!(__is_implicitly_default_constructible_v<_Elements> && ...))
 tuple(allocator_arg_t __tag, const _Alloc& __a)
 requires (is_default_constructible_v<_Elements> && ...)
 : _Inherited(__tag, __a)
 { }

      template<typename _Alloc>
 constexpr explicit(!__convertible<const _Elements&...>())
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _Elements&... __elements)
 requires (__constructible<const _Elements&...>())
 : _Inherited(__tag, __a, __elements...)
 { }

      template<typename _Alloc, typename... _UTypes>
 requires (__disambiguating_constraint<_UTypes...>())
   && (__constructible<_UTypes...>())
   && (!__dangles<_UTypes...>())
 constexpr explicit(!__convertible<_UTypes...>())
 tuple(allocator_arg_t __tag, const _Alloc& __a, _UTypes&&... __u)
 : _Inherited(__tag, __a, std::forward<_UTypes>(__u)...)
 { }

      template<typename _Alloc, typename... _UTypes>
 requires (__disambiguating_constraint<_UTypes...>())
   && (__constructible<_UTypes...>())
   && (__dangles<_UTypes...>())
 tuple(allocator_arg_t, const _Alloc&, _UTypes&&...) = delete;

      template<typename _Alloc>
 constexpr
 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __u)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__u))
 { }

      template<typename _Alloc>
 requires (__constructible<_Elements...>())
 constexpr
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __u)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__u))
 { }

      template<typename _Alloc, typename... _UTypes>
 requires (__constructible<const _UTypes&...>())
   && (!__use_other_ctor<const tuple<_UTypes...>&>())
   && (!__dangles<const _UTypes&...>())
 constexpr explicit(!__convertible<const _UTypes&...>())
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_UTypes...>& __u)
 : _Inherited(__tag, __a,
       static_cast<const _Tuple_impl<0, _UTypes...>&>(__u))
 { }

      template<typename _Alloc, typename... _UTypes>
 requires (__constructible<const _UTypes&...>())
   && (!__use_other_ctor<const tuple<_UTypes...>&>())
   && (__dangles<const _UTypes&...>())
 tuple(allocator_arg_t, const _Alloc&, const tuple<_UTypes...>&) = delete;

      template<typename _Alloc, typename... _UTypes>
 requires (__constructible<_UTypes...>())
   && (!__use_other_ctor<tuple<_UTypes...>>())
   && (!__dangles<_UTypes...>())
 constexpr explicit(!__use_other_ctor<tuple<_UTypes...>>())
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_UTypes...>&& __u)
 : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _UTypes...>&&>(__u))
 { }

      template<typename _Alloc, typename... _UTypes>
 requires (__constructible<_UTypes...>())
   && (!__use_other_ctor<tuple<_UTypes...>>())
   && (__dangles<_UTypes...>())
 tuple(allocator_arg_t, const _Alloc&, tuple<_UTypes...>&&) = delete;


      template<typename _Alloc, typename... _UTypes>
 requires (__constructible<_UTypes&...>())
   && (!__use_other_ctor<tuple<_UTypes...>&>())
   && (!__dangles<_UTypes&...>())
 constexpr explicit(!__convertible<_UTypes&...>())
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_UTypes...>& __u)
 : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _UTypes...>&>(__u))
 { }

      template<typename _Alloc, typename... _UTypes>
 requires (__constructible<_UTypes&...>())
   && (!__use_other_ctor<tuple<_UTypes...>&>())
   && (__dangles<_UTypes&...>())
 tuple(allocator_arg_t, const _Alloc&, tuple<_UTypes...>&) = delete;

      template<typename _Alloc, typename... _UTypes>
 requires (__constructible<const _UTypes...>())
   && (!__use_other_ctor<const tuple<_UTypes...>>())
   && (!__dangles<const _UTypes...>())
 constexpr explicit(!__convertible<const _UTypes...>())
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_UTypes...>&& __u)
 : _Inherited(__tag, __a,
       static_cast<const _Tuple_impl<0, _UTypes...>&&>(__u))
 { }

      template<typename _Alloc, typename... _UTypes>
 requires (__constructible<const _UTypes...>())
   && (!__use_other_ctor<const tuple<_UTypes...>>())
   && (__dangles<const _UTypes...>())
 tuple(allocator_arg_t, const _Alloc&, const tuple<_UTypes...>&&) = delete;


      template<typename _Alloc, typename _U1, typename _U2>
 requires (sizeof...(_Elements) == 2)
   && (__constructible<const _U1&, const _U2&>())
   && (!__dangles<const _U1&, const _U2&>())
 constexpr explicit(!__convertible<const _U1&, const _U2&>())
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const pair<_U1, _U2>& __u)
 noexcept(__nothrow_constructible<const _U1&, const _U2&>())
 : _Inherited(__tag, __a, __u.first, __u.second)
 { }

      template<typename _Alloc, typename _U1, typename _U2>
 requires (sizeof...(_Elements) == 2)
   && (__constructible<const _U1&, const _U2&>())
   && (__dangles<const _U1&, const _U2&>())
 tuple(allocator_arg_t, const _Alloc&, const pair<_U1, _U2>&) = delete;

      template<typename _Alloc, typename _U1, typename _U2>
 requires (sizeof...(_Elements) == 2)
   && (__constructible<_U1, _U2>())
   && (!__dangles<_U1, _U2>())
 constexpr explicit(!__convertible<_U1, _U2>())
 tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __u)
 noexcept(__nothrow_constructible<_U1, _U2>())
 : _Inherited(__tag, __a, std::move(__u.first), std::move(__u.second))
 { }

      template<typename _Alloc, typename _U1, typename _U2>
 requires (sizeof...(_Elements) == 2)
   && (__constructible<_U1, _U2>())
   && (__dangles<_U1, _U2>())
 tuple(allocator_arg_t, const _Alloc&, pair<_U1, _U2>&&) = delete;


      template<typename _Alloc, typename _U1, typename _U2>
 requires (sizeof...(_Elements) == 2)
   && (__constructible<_U1&, _U2&>())
   && (!__dangles<_U1&, _U2&>())
 constexpr explicit(!__convertible<_U1&, _U2&>())
 tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>& __u)
 noexcept(__nothrow_constructible<_U1&, _U2&>())
 : _Inherited(__tag, __a, __u.first, __u.second)
 { }

      template<typename _Alloc, typename _U1, typename _U2>
 requires (sizeof...(_Elements) == 2)
   && (__constructible<_U1&, _U2&>())
   && (__dangles<_U1&, _U2&>())
 tuple(allocator_arg_t, const _Alloc&, pair<_U1, _U2>&) = delete;

      template<typename _Alloc, typename _U1, typename _U2>
 requires (sizeof...(_Elements) == 2)
   && (__constructible<const _U1, const _U2>())
   && (!__dangles<const _U1, const _U2>())
 constexpr explicit(!__convertible<const _U1, const _U2>())
 tuple(allocator_arg_t __tag, const _Alloc& __a,
 const pair<_U1, _U2>&& __u)
 noexcept(__nothrow_constructible<const _U1, const _U2>())
 : _Inherited(__tag, __a, std::move(__u.first), std::move(__u.second))
 { }

      template<typename _Alloc, typename _U1, typename _U2>
 requires (sizeof...(_Elements) == 2)
   && (__constructible<const _U1, const _U2>())
   && (__dangles<const _U1, const _U2>())
 tuple(allocator_arg_t, const _Alloc&, const pair<_U1, _U2>&&) = delete;



      template<typename _Alloc, __eligible_tuple_like<tuple> _UTuple>
 requires (__constructible_from_tuple_like<_UTuple>())
   && (!__use_other_ctor<_UTuple>())
   && (!__dangles_from_tuple_like<_UTuple>())
 constexpr explicit(!__convertible_from_tuple_like<_UTuple>())
 tuple(allocator_arg_t __tag, const _Alloc& __a, _UTuple&& __u)
 : _Inherited(__tuple_like_tag_t{},
       __tag, __a, std::forward<_UTuple>(__u),
       index_sequence_for<_Elements...>{})
 { }

      template<typename _Alloc, __eligible_tuple_like<tuple> _UTuple>
 requires (__constructible_from_tuple_like<_UTuple>())
   && (!__use_other_ctor<_UTuple>())
   && (__dangles_from_tuple_like<_UTuple>())
 tuple(allocator_arg_t, const _Alloc&, _UTuple&&) = delete;
# 1654 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tuple" 3
    private:
      template<typename... _UTypes>
 static consteval bool
 __assignable()
 {
   if constexpr (sizeof...(_UTypes) == sizeof...(_Elements))
     return __and_v<is_assignable<_Elements&, _UTypes>...>;
   else
     return false;
 }

      template<typename... _UTypes>
 static consteval bool
 __nothrow_assignable()
 {
   if constexpr (sizeof...(_UTypes) == sizeof...(_Elements))
     return __and_v<is_nothrow_assignable<_Elements&, _UTypes>...>;
   else
     return false;
 }


      template<typename... _UTypes>
 static consteval bool
 __const_assignable()
 {
   if constexpr (sizeof...(_UTypes) == sizeof...(_Elements))
     return __and_v<is_assignable<const _Elements&, _UTypes>...>;
   else
     return false;
 }



      template<typename _UTuple>
 static consteval bool
 __assignable_from_tuple_like()
 {
   return []<size_t... _Is>(index_sequence<_Is...>) {
     return __assignable<decltype(std::get<_Is>(std::declval<_UTuple>()))...>();
   }(index_sequence_for<_Elements...>{});
 }

      template<typename _UTuple>
 static consteval bool
 __const_assignable_from_tuple_like()
 {
   return []<size_t... _Is>(index_sequence<_Is...>) {
     return __const_assignable<decltype(std::get<_Is>(std::declval<_UTuple>()))...>();
   }(index_sequence_for<_Elements...>{});
 }


    public:

      tuple& operator=(const tuple& __u) = delete;

      constexpr tuple&
      operator=(const tuple& __u)
      noexcept(__nothrow_assignable<const _Elements&...>())
      requires (__assignable<const _Elements&...>())
      {
 this->_M_assign(__u);
 return *this;
      }

      constexpr tuple&
      operator=(tuple&& __u)
      noexcept(__nothrow_assignable<_Elements...>())
      requires (__assignable<_Elements...>())
      {
 this->_M_assign(std::move(__u));
 return *this;
      }

      template<typename... _UTypes>
 requires (__assignable<const _UTypes&...>())
 constexpr tuple&
 operator=(const tuple<_UTypes...>& __u)
 noexcept(__nothrow_assignable<const _UTypes&...>())
 {
   this->_M_assign(__u);
   return *this;
 }

      template<typename... _UTypes>
 requires (__assignable<_UTypes...>())
 constexpr tuple&
 operator=(tuple<_UTypes...>&& __u)
 noexcept(__nothrow_assignable<_UTypes...>())
 {
   this->_M_assign(std::move(__u));
   return *this;
 }


      constexpr const tuple&
      operator=(const tuple& __u) const
      requires (__const_assignable<const _Elements&...>())
      {
 this->_M_assign(__u);
 return *this;
      }

      constexpr const tuple&
      operator=(tuple&& __u) const
      requires (__const_assignable<_Elements...>())
      {
 this->_M_assign(std::move(__u));
 return *this;
      }

      template<typename... _UTypes>
 constexpr const tuple&
 operator=(const tuple<_UTypes...>& __u) const
 requires (__const_assignable<const _UTypes&...>())
 {
   this->_M_assign(__u);
   return *this;
 }

      template<typename... _UTypes>
 constexpr const tuple&
 operator=(tuple<_UTypes...>&& __u) const
 requires (__const_assignable<_UTypes...>())
 {
   this->_M_assign(std::move(__u));
   return *this;
 }


      template<typename _U1, typename _U2>
 requires (__assignable<const _U1&, const _U2&>())
 constexpr tuple&
 operator=(const pair<_U1, _U2>& __u)
 noexcept(__nothrow_assignable<const _U1&, const _U2&>())
 {
   this->_M_head(*this) = __u.first;
   this->_M_tail(*this)._M_head(*this) = __u.second;
   return *this;
 }

      template<typename _U1, typename _U2>
 requires (__assignable<_U1, _U2>())
 constexpr tuple&
 operator=(pair<_U1, _U2>&& __u)
 noexcept(__nothrow_assignable<_U1, _U2>())
 {
   this->_M_head(*this) = std::forward<_U1>(__u.first);
   this->_M_tail(*this)._M_head(*this) = std::forward<_U2>(__u.second);
   return *this;
 }


      template<typename _U1, typename _U2>
 requires (__const_assignable<const _U1&, const _U2>())
 constexpr const tuple&
 operator=(const pair<_U1, _U2>& __u) const
 {
   this->_M_head(*this) = __u.first;
   this->_M_tail(*this)._M_head(*this) = __u.second;
   return *this;
 }

      template<typename _U1, typename _U2>
 requires (__const_assignable<_U1, _U2>())
 constexpr const tuple&
 operator=(pair<_U1, _U2>&& __u) const
 {
   this->_M_head(*this) = std::forward<_U1>(__u.first);
   this->_M_tail(*this)._M_head(*this) = std::forward<_U2>(__u.second);
   return *this;
 }



      template<__eligible_tuple_like<tuple> _UTuple>
 requires (__assignable_from_tuple_like<_UTuple>())
 constexpr tuple&
 operator=(_UTuple&& __u)
 {
   this->_M_assign(__tuple_like_tag_t{}, std::forward<_UTuple>(__u));
   return *this;
 }

      template<__eligible_tuple_like<tuple> _UTuple>
 requires (__const_assignable_from_tuple_like<_UTuple>())
 constexpr const tuple&
 operator=(_UTuple&& __u) const
 {
   this->_M_assign(__tuple_like_tag_t{}, std::forward<_UTuple>(__u));
   return *this;
 }

      template<__tuple_like _UTuple>
 requires (!__is_tuple_v<_UTuple>)
 friend constexpr bool
 operator==(const tuple& __t, const _UTuple& __u)
 {
   static_assert(sizeof...(_Elements) == tuple_size_v<_UTuple>,
       "tuple objects can only be compared if they have equal sizes.");
   return [&]<size_t... _Is>(index_sequence<_Is...>) {
     return (bool(std::get<_Is>(__t) == std::get<_Is>(__u))
      && ...);
   }(index_sequence_for<_Elements...>{});
 }

      template<__tuple_like _UTuple,
        typename = make_index_sequence<tuple_size_v<_UTuple>>>
 struct __tuple_like_common_comparison_category;

      template<__tuple_like _UTuple, size_t... _Is>
 requires requires
   { typename void_t<__detail::__synth3way_t<_Elements, tuple_element_t<_Is, _UTuple>>...>; }
 struct __tuple_like_common_comparison_category<_UTuple, index_sequence<_Is...>>
 {
   using type = common_comparison_category_t
     <__detail::__synth3way_t<_Elements, tuple_element_t<_Is, _UTuple>>...>;
 };

      template<__tuple_like _UTuple>
 requires (!__is_tuple_v<_UTuple>)
 friend constexpr typename __tuple_like_common_comparison_category<_UTuple>::type
 operator<=>(const tuple& __t, const _UTuple& __u)
 {
   using _Cat = typename __tuple_like_common_comparison_category<_UTuple>::type;
   return std::__tuple_cmp<_Cat>(__t, __u, index_sequence_for<_Elements...>());
 }
# 1947 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tuple" 3
      constexpr
      void
      swap(tuple& __in)
      noexcept(__and_<__is_nothrow_swappable<_Elements>...>::value)
      { _Inherited::_M_swap(__in); }
# 1960 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tuple" 3
      constexpr void
      swap(const tuple& __in) const
      noexcept(__and_v<__is_nothrow_swappable<const _Elements>...>)
      requires (is_swappable_v<const _Elements> && ...)
      { _Inherited::_M_swap(__in); }

    };


  template<typename... _UTypes>
    tuple(_UTypes...) -> tuple<_UTypes...>;
  template<typename _T1, typename _T2>
    tuple(pair<_T1, _T2>) -> tuple<_T1, _T2>;
  template<typename _Alloc, typename... _UTypes>
    tuple(allocator_arg_t, _Alloc, _UTypes...) -> tuple<_UTypes...>;
  template<typename _Alloc, typename _T1, typename _T2>
    tuple(allocator_arg_t, _Alloc, pair<_T1, _T2>) -> tuple<_T1, _T2>;
  template<typename _Alloc, typename... _UTypes>
    tuple(allocator_arg_t, _Alloc, tuple<_UTypes...>) -> tuple<_UTypes...>;



  template<>
    class tuple<>
    {
    public:
      constexpr
      void swap(tuple&) noexcept { }

      constexpr void swap(const tuple&) const noexcept { }



      tuple() = default;

      template<typename _Alloc>
 constexpr
 tuple(allocator_arg_t, const _Alloc&) noexcept { }
      template<typename _Alloc>
 constexpr
 tuple(allocator_arg_t, const _Alloc&, const tuple&) noexcept { }
    };
# 2402 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tuple" 3
  template<typename... _Elements>
    struct tuple_size<tuple<_Elements...>>
    : public integral_constant<size_t, sizeof...(_Elements)> { };


  template<typename... _Types>
    inline constexpr size_t tuple_size_v<tuple<_Types...>>
      = sizeof...(_Types);

  template<typename... _Types>
    inline constexpr size_t tuple_size_v<const tuple<_Types...>>
      = sizeof...(_Types);



  template<size_t __i, typename... _Types>
    struct tuple_element<__i, tuple<_Types...>>
    {
      static_assert(__i < sizeof...(_Types), "tuple index must be in range");

      using type = typename _Nth_type<__i, _Types...>::type;
    };

  template<size_t __i, typename _Head, typename... _Tail>
    constexpr _Head&
    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }

  template<size_t __i, typename _Head, typename... _Tail>
    constexpr const _Head&
    __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }


  template<size_t __i, typename... _Types>
    __enable_if_t<(__i >= sizeof...(_Types))>
    __get_helper(const tuple<_Types...>&) = delete;


  template<size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&
    get(tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&
    get(const tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&&
    get(tuple<_Elements...>&& __t) noexcept
    {
      typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
      return std::forward<__element_type>(std::__get_helper<__i>(__t));
    }


  template<size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&&
    get(const tuple<_Elements...>&& __t) noexcept
    {
      typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
      return std::forward<const __element_type>(std::__get_helper<__i>(__t));
    }



  template<size_t __i, typename... _Elements>
    constexpr __enable_if_t<(__i >= sizeof...(_Elements))>
    get(const tuple<_Elements...>&) = delete;




  template <typename _Tp, typename... _Types>
    constexpr _Tp&
    get(tuple<_Types...>& __t) noexcept
    {
      constexpr size_t __idx = __find_uniq_type_in_pack<_Tp, _Types...>();
      static_assert(__idx < sizeof...(_Types),
   "the type T in std::get<T> must occur exactly once in the tuple");
      return std::__get_helper<__idx>(__t);
    }


  template <typename _Tp, typename... _Types>
    constexpr _Tp&&
    get(tuple<_Types...>&& __t) noexcept
    {
      constexpr size_t __idx = __find_uniq_type_in_pack<_Tp, _Types...>();
      static_assert(__idx < sizeof...(_Types),
   "the type T in std::get<T> must occur exactly once in the tuple");
      return std::forward<_Tp>(std::__get_helper<__idx>(__t));
    }


  template <typename _Tp, typename... _Types>
    constexpr const _Tp&
    get(const tuple<_Types...>& __t) noexcept
    {
      constexpr size_t __idx = __find_uniq_type_in_pack<_Tp, _Types...>();
      static_assert(__idx < sizeof...(_Types),
   "the type T in std::get<T> must occur exactly once in the tuple");
      return std::__get_helper<__idx>(__t);
    }



  template <typename _Tp, typename... _Types>
    constexpr const _Tp&&
    get(const tuple<_Types...>&& __t) noexcept
    {
      constexpr size_t __idx = __find_uniq_type_in_pack<_Tp, _Types...>();
      static_assert(__idx < sizeof...(_Types),
   "the type T in std::get<T> must occur exactly once in the tuple");
      return std::forward<const _Tp>(std::__get_helper<__idx>(__t));
    }



  template<typename _Tp, typename _Up, size_t __i, size_t __size>
    struct __tuple_compare
    {
      static constexpr bool
      __eq(const _Tp& __t, const _Up& __u)
      {
 return bool(std::get<__i>(__t) == std::get<__i>(__u))
   && __tuple_compare<_Tp, _Up, __i + 1, __size>::__eq(__t, __u);
      }

      static constexpr bool
      __less(const _Tp& __t, const _Up& __u)
      {
 return bool(std::get<__i>(__t) < std::get<__i>(__u))
   || (!bool(std::get<__i>(__u) < std::get<__i>(__t))
       && __tuple_compare<_Tp, _Up, __i + 1, __size>::__less(__t, __u));
      }
    };

  template<typename _Tp, typename _Up, size_t __size>
    struct __tuple_compare<_Tp, _Up, __size, __size>
    {
      static constexpr bool
      __eq(const _Tp&, const _Up&) { return true; }

      static constexpr bool
      __less(const _Tp&, const _Up&) { return false; }
    };

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator==(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    {
      static_assert(sizeof...(_TElements) == sizeof...(_UElements),
   "tuple objects can only be compared if they have equal sizes.");
      using __compare = __tuple_compare<tuple<_TElements...>,
     tuple<_UElements...>,
     0, sizeof...(_TElements)>;
      return __compare::__eq(__t, __u);
    }


  template<typename _Cat, typename _Tp, typename _Up>
    constexpr _Cat
    __tuple_cmp(const _Tp&, const _Up&, index_sequence<>)
    { return _Cat::equivalent; }

  template<typename _Cat, typename _Tp, typename _Up,
    size_t _Idx0, size_t... _Idxs>
    constexpr _Cat
    __tuple_cmp(const _Tp& __t, const _Up& __u,
  index_sequence<_Idx0, _Idxs...>)
    {
      auto __c
 = __detail::__synth3way(std::get<_Idx0>(__t), std::get<_Idx0>(__u));
      if (__c != 0)
 return __c;
      return std::__tuple_cmp<_Cat>(__t, __u, index_sequence<_Idxs...>());
    }

  template<typename... _Tps, typename... _Ups>
    constexpr
    common_comparison_category_t<__detail::__synth3way_t<_Tps, _Ups>...>
    operator<=>(const tuple<_Tps...>& __t, const tuple<_Ups...>& __u)
    {
      using _Cat
 = common_comparison_category_t<__detail::__synth3way_t<_Tps, _Ups>...>;
      return std::__tuple_cmp<_Cat>(__t, __u, index_sequence_for<_Tps...>());
    }
# 2636 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tuple" 3
  template<typename... _Elements>
    constexpr tuple<typename __decay_and_strip<_Elements>::__type...>
    make_tuple(_Elements&&... __args)
    {
      typedef tuple<typename __decay_and_strip<_Elements>::__type...>
 __result_type;
      return __result_type(std::forward<_Elements>(__args)...);
    }




  template<typename... _Elements>
    constexpr tuple<_Elements&&...>
    forward_as_tuple(_Elements&&... __args) noexcept
    { return tuple<_Elements&&...>(std::forward<_Elements>(__args)...); }


  template<size_t, typename, typename, size_t>
    struct __make_tuple_impl;

  template<size_t _Idx, typename _Tuple, typename... _Tp, size_t _Nm>
    struct __make_tuple_impl<_Idx, tuple<_Tp...>, _Tuple, _Nm>
    : __make_tuple_impl<_Idx + 1,
   tuple<_Tp..., __tuple_element_t<_Idx, _Tuple>>,
   _Tuple, _Nm>
    { };

  template<size_t _Nm, typename _Tuple, typename... _Tp>
    struct __make_tuple_impl<_Nm, tuple<_Tp...>, _Tuple, _Nm>
    {
      typedef tuple<_Tp...> __type;
    };

  template<typename _Tuple>
    struct __do_make_tuple
    : __make_tuple_impl<0, tuple<>, _Tuple, tuple_size<_Tuple>::value>
    { };


  template<typename _Tuple>
    struct __make_tuple
    : public __do_make_tuple<__remove_cvref_t<_Tuple>>
    { };


  template<typename...>
    struct __combine_tuples;

  template<>
    struct __combine_tuples<>
    {
      typedef tuple<> __type;
    };

  template<typename... _Ts>
    struct __combine_tuples<tuple<_Ts...>>
    {
      typedef tuple<_Ts...> __type;
    };

  template<typename... _T1s, typename... _T2s, typename... _Rem>
    struct __combine_tuples<tuple<_T1s...>, tuple<_T2s...>, _Rem...>
    {
      typedef typename __combine_tuples<tuple<_T1s..., _T2s...>,
     _Rem...>::__type __type;
    };


  template<typename... _Tpls>
    struct __tuple_cat_result
    {
      typedef typename __combine_tuples
        <typename __make_tuple<_Tpls>::__type...>::__type __type;
    };



  template<typename...>
    struct __make_1st_indices;

  template<>
    struct __make_1st_indices<>
    {
      typedef _Index_tuple<> __type;
    };

  template<typename _Tp, typename... _Tpls>
    struct __make_1st_indices<_Tp, _Tpls...>
    {
      typedef typename _Build_index_tuple<tuple_size<
 typename remove_reference<_Tp>::type>::value>::__type __type;
    };




  template<typename _Ret, typename _Indices, typename... _Tpls>
    struct __tuple_concater;

  template<typename _Ret, size_t... _Is, typename _Tp, typename... _Tpls>
    struct __tuple_concater<_Ret, _Index_tuple<_Is...>, _Tp, _Tpls...>
    {
      template<typename... _Us>
        static constexpr _Ret
        _S_do(_Tp&& __tp, _Tpls&&... __tps, _Us&&... __us)
        {
   typedef typename __make_1st_indices<_Tpls...>::__type __idx;
   typedef __tuple_concater<_Ret, __idx, _Tpls...> __next;
   return __next::_S_do(std::forward<_Tpls>(__tps)...,
          std::forward<_Us>(__us)...,
          std::get<_Is>(std::forward<_Tp>(__tp))...);
 }
    };

  template<typename _Ret>
    struct __tuple_concater<_Ret, _Index_tuple<>>
    {
      template<typename... _Us>
 static constexpr _Ret
 _S_do(_Us&&... __us)
        {
   return _Ret(std::forward<_Us>(__us)...);
 }
    };

  template<typename... _Tps>
    struct __is_tuple_like_impl<tuple<_Tps...>> : true_type
    { };




  template<__tuple_like... _Tpls>




    constexpr auto
    tuple_cat(_Tpls&&... __tpls)
    -> typename __tuple_cat_result<_Tpls...>::__type
    {
      typedef typename __tuple_cat_result<_Tpls...>::__type __ret;
      typedef typename __make_1st_indices<_Tpls...>::__type __idx;
      typedef __tuple_concater<__ret, __idx, _Tpls...> __concater;
      return __concater::_S_do(std::forward<_Tpls>(__tpls)...);
    }




  template<typename... _Elements>
    constexpr tuple<_Elements&...>
    tie(_Elements&... __args) noexcept
    { return tuple<_Elements&...>(__args...); }


  template<typename... _Elements>
    constexpr
    inline


    typename enable_if<__and_<__is_swappable<_Elements>...>::value
      >::type



    swap(tuple<_Elements...>& __x, tuple<_Elements...>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }


  template<typename... _Elements>
    requires (is_swappable_v<const _Elements> && ...)
    constexpr void
    swap(const tuple<_Elements...>& __x, const tuple<_Elements...>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }




  template<typename... _Elements>
    constexpr
    typename enable_if<!__and_<__is_swappable<_Elements>...>::value>::type
    swap(tuple<_Elements...>&, tuple<_Elements...>&) = delete;






  struct _Swallow_assign
  {
    template<class _Tp>
      constexpr const _Swallow_assign&
      operator=(const _Tp&) const
      { return *this; }
  };
# 2853 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tuple" 3
  inline constexpr _Swallow_assign ignore{};


  template<typename... _Types, typename _Alloc>
    struct uses_allocator<tuple<_Types...>, _Alloc> : true_type { };
# 2868 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tuple" 3
  template<class _T1, class _T2>
    template<typename... _Args1, typename... _Args2>
      constexpr
      inline
      pair<_T1, _T2>::
      pair(piecewise_construct_t,
    tuple<_Args1...> __first, tuple<_Args2...> __second)
      : pair(__first, __second,
      typename _Build_index_tuple<sizeof...(_Args1)>::__type(),
      typename _Build_index_tuple<sizeof...(_Args2)>::__type())
      { }

  template<class _T1, class _T2>
    template<typename... _Args1, size_t... _Indexes1,
      typename... _Args2, size_t... _Indexes2>
      constexpr inline
      pair<_T1, _T2>::
      pair(tuple<_Args1...>& __tuple1, tuple<_Args2...>& __tuple2,
    _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>)
      : first(std::forward<_Args1>(std::get<_Indexes1>(__tuple1))...),
 second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...)
      { }






  template<template<typename...> class _Trait, typename _Tp, typename _Tuple>
    inline constexpr bool __unpack_std_tuple = false;

  template<template<typename...> class _Trait, typename _Tp, typename... _Up>
    inline constexpr bool __unpack_std_tuple<_Trait, _Tp, tuple<_Up...>>
      = _Trait<_Tp, _Up...>::value;

  template<template<typename...> class _Trait, typename _Tp, typename... _Up>
    inline constexpr bool __unpack_std_tuple<_Trait, _Tp, tuple<_Up...>&>
      = _Trait<_Tp, _Up&...>::value;

  template<template<typename...> class _Trait, typename _Tp, typename... _Up>
    inline constexpr bool __unpack_std_tuple<_Trait, _Tp, const tuple<_Up...>>
      = _Trait<_Tp, const _Up...>::value;

  template<template<typename...> class _Trait, typename _Tp, typename... _Up>
    inline constexpr bool __unpack_std_tuple<_Trait, _Tp, const tuple<_Up...>&>
      = _Trait<_Tp, const _Up&...>::value;



  template <typename _Fn, typename _Tuple, size_t... _Idx>
    constexpr decltype(auto)
    __apply_impl(_Fn&& __f, _Tuple&& __t, index_sequence<_Idx...>)
    {
      return std::__invoke(std::forward<_Fn>(__f),
      std::get<_Idx>(std::forward<_Tuple>(__t))...);
    }


  template <typename _Fn, __tuple_like _Tuple>



    constexpr decltype(auto)
    apply(_Fn&& __f, _Tuple&& __t)
    noexcept(__unpack_std_tuple<is_nothrow_invocable, _Fn, _Tuple>)
    {
      using _Indices
 = make_index_sequence<tuple_size_v<remove_reference_t<_Tuple>>>;
      return std::__apply_impl(std::forward<_Fn>(__f),
          std::forward<_Tuple>(__t),
          _Indices{});
    }



  template <typename _Tp, typename _Tuple, size_t... _Idx>
    constexpr _Tp
    __make_from_tuple_impl(_Tuple&& __t, index_sequence<_Idx...>)
    { return _Tp(std::get<_Idx>(std::forward<_Tuple>(__t))...); }


  template <typename _Tp, __tuple_like _Tuple>



    constexpr _Tp
    make_from_tuple(_Tuple&& __t)
    noexcept(__unpack_std_tuple<is_nothrow_constructible, _Tp, _Tuple>)
    {
      constexpr size_t __n = tuple_size_v<remove_reference_t<_Tuple>>;

      if constexpr (__n == 1)
 {
   using _Elt = decltype(std::get<0>(std::declval<_Tuple>()));
   static_assert(!__reference_constructs_from_temporary(_Tp, _Elt));
 }

      return __make_from_tuple_impl<_Tp>(std::forward<_Tuple>(__t),
      make_index_sequence<__n>{});
    }



  template<__tuple_like _TTuple, __tuple_like _UTuple,
    template<typename> class _TQual, template<typename> class _UQual,
    typename = make_index_sequence<tuple_size_v<_TTuple>>>
  struct __tuple_like_common_reference;

  template<__tuple_like _TTuple, __tuple_like _UTuple,
    template<typename> class _TQual, template<typename> class _UQual,
    size_t... _Is>
    requires requires
      { typename tuple<common_reference_t<_TQual<tuple_element_t<_Is, _TTuple>>,
       _UQual<tuple_element_t<_Is, _UTuple>>>...>; }
  struct __tuple_like_common_reference<_TTuple, _UTuple, _TQual, _UQual, index_sequence<_Is...>>
  {
    using type = tuple<common_reference_t<_TQual<tuple_element_t<_Is, _TTuple>>,
       _UQual<tuple_element_t<_Is, _UTuple>>>...>;
  };

  template<__tuple_like _TTuple, __tuple_like _UTuple,
    template<typename> class _TQual, template<typename> class _UQual>
    requires (__is_tuple_v<_TTuple> || __is_tuple_v<_UTuple>)
      && is_same_v<_TTuple, decay_t<_TTuple>>
      && is_same_v<_UTuple, decay_t<_UTuple>>
      && (tuple_size_v<_TTuple> == tuple_size_v<_UTuple>)
      && requires { typename __tuple_like_common_reference<_TTuple, _UTuple, _TQual, _UQual>::type; }
  struct basic_common_reference<_TTuple, _UTuple, _TQual, _UQual>
  {
    using type = typename __tuple_like_common_reference<_TTuple, _UTuple, _TQual, _UQual>::type;
  };

  template<__tuple_like _TTuple, __tuple_like _UTuple,
    typename = make_index_sequence<tuple_size_v<_TTuple>>>
  struct __tuple_like_common_type;

  template<__tuple_like _TTuple, __tuple_like _UTuple, size_t... _Is>
    requires requires
      { typename tuple<common_type_t<tuple_element_t<_Is, _TTuple>,
       tuple_element_t<_Is, _UTuple>>...>; }
  struct __tuple_like_common_type<_TTuple, _UTuple, index_sequence<_Is...>>
  {
    using type = tuple<common_type_t<tuple_element_t<_Is, _TTuple>,
         tuple_element_t<_Is, _UTuple>>...>;
  };

  template<__tuple_like _TTuple, __tuple_like _UTuple>
    requires (__is_tuple_v<_TTuple> || __is_tuple_v<_UTuple>)
      && is_same_v<_TTuple, decay_t<_TTuple>>
      && is_same_v<_UTuple, decay_t<_UTuple>>
      && (tuple_size_v<_TTuple> == tuple_size_v<_UTuple>)
      && requires { typename __tuple_like_common_type<_TTuple, _UTuple>::type; }
  struct common_type<_TTuple, _UTuple>
  {
    using type = typename __tuple_like_common_type<_TTuple, _UTuple>::type;
  };







}
# 35 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/hashtable_policy.h" 2 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/functional_hash.h" 1 3
# 33 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/functional_hash.h" 3
       
# 34 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/functional_hash.h" 3


# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/hash_bytes.h" 1 3
# 33 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/hash_bytes.h" 3
       
# 34 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/hash_bytes.h" 3



namespace std
{







  size_t
  _Hash_bytes(const void* __ptr, size_t __len, size_t __seed);





  size_t
  _Fnv_hash_bytes(const void* __ptr, size_t __len, size_t __seed);


}
# 37 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/functional_hash.h" 2 3

namespace std
{

# 50 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/functional_hash.h" 3
  template<typename _Result, typename _Arg>
    struct __hash_base
    {
      typedef _Result result_type [[__deprecated__]];
      typedef _Arg argument_type [[__deprecated__]];
    };


  template<typename _Tp>
    struct hash;

  template<typename _Tp, typename = void>
    struct __poison_hash
    {
      static constexpr bool __enable_hash_call = false;
    private:

      __poison_hash(__poison_hash&&);
      ~__poison_hash();
    };

  template<typename _Tp>
    struct __poison_hash<_Tp, __void_t<decltype(hash<_Tp>()(declval<_Tp>()))>>
    {
      static constexpr bool __enable_hash_call = true;
    };


  template<typename _Tp, bool = is_enum<_Tp>::value>
    struct __hash_enum
    {
    private:

      __hash_enum(__hash_enum&&);
      ~__hash_enum();
    };


  template<typename _Tp>
    struct __hash_enum<_Tp, true> : public __hash_base<size_t, _Tp>
    {
      size_t
      operator()(_Tp __val) const noexcept
      {
       using __type = typename underlying_type<_Tp>::type;
       return hash<__type>{}(static_cast<__type>(__val));
      }
    };



  template<typename _Tp>
    struct hash : __hash_enum<_Tp>
    { };


  template<typename _Tp>
    struct hash<_Tp*> : public __hash_base<size_t, _Tp*>
    {
      size_t
      operator()(_Tp* __p) const noexcept
      { return reinterpret_cast<size_t>(__p); }
    };
# 125 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/functional_hash.h" 3
  template<> struct hash<bool> : public __hash_base<size_t, bool> { size_t operator()(bool __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char> : public __hash_base<size_t, char> { size_t operator()(char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<signed char> : public __hash_base<size_t, signed char> { size_t operator()(signed char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned char> : public __hash_base<size_t, unsigned char> { size_t operator()(unsigned char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<wchar_t> : public __hash_base<size_t, wchar_t> { size_t operator()(wchar_t __val) const noexcept { return static_cast<size_t>(__val); } };



  template<> struct hash<char8_t> : public __hash_base<size_t, char8_t> { size_t operator()(char8_t __val) const noexcept { return static_cast<size_t>(__val); } };



  template<> struct hash<char16_t> : public __hash_base<size_t, char16_t> { size_t operator()(char16_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char32_t> : public __hash_base<size_t, char32_t> { size_t operator()(char32_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<short> : public __hash_base<size_t, short> { size_t operator()(short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<int> : public __hash_base<size_t, int> { size_t operator()(int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long> : public __hash_base<size_t, long> { size_t operator()(long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long long> : public __hash_base<size_t, long long> { size_t operator()(long long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned short> : public __hash_base<size_t, unsigned short> { size_t operator()(unsigned short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned int> : public __hash_base<size_t, unsigned int> { size_t operator()(unsigned int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long> : public __hash_base<size_t, unsigned long> { size_t operator()(unsigned long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long long> : public __hash_base<size_t, unsigned long long> { size_t operator()(unsigned long long __val) const noexcept { return static_cast<size_t>(__val); } };


  __extension__
  template<> struct hash<__int128> : public __hash_base<size_t, __int128> { size_t operator()(__int128 __val) const noexcept { return static_cast<size_t>(__val); } };
  __extension__
  template<> struct hash<__int128 unsigned> : public __hash_base<size_t, __int128 unsigned> { size_t operator()(__int128 unsigned __val) const noexcept { return static_cast<size_t>(__val); } };
# 201 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/functional_hash.h" 3
  struct _Hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(0xc70f6907UL))
    { return _Hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  struct _Fnv_hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(2166136261UL))
    { return _Fnv_hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  template<>
    struct hash<float> : public __hash_base<size_t, float>
    {
      size_t
      operator()(float __val) const noexcept
      {

 return __val != 0.0f ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<double> : public __hash_base<size_t, double>
    {
      size_t
      operator()(double __val) const noexcept
      {

 return __val != 0.0 ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<long double>
    : public __hash_base<size_t, long double>
    {
      __attribute__ ((__pure__)) size_t
      operator()(long double __val) const noexcept;
    };


  template<>
    struct hash<nullptr_t> : public __hash_base<size_t, nullptr_t>
    {
      size_t
      operator()(nullptr_t) const noexcept
      { return 0; }
    };
# 294 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/functional_hash.h" 3
  template<typename _Hash>
    struct __is_fast_hash : public std::true_type
    { };

  template<>
    struct __is_fast_hash<hash<long double>> : public std::false_type
    { };


}
# 36 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/hashtable_policy.h" 2 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_algobase.h" 1 3
# 60 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_algobase.h" 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/functexcept.h" 1 3
# 42 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/functexcept.h" 3
namespace std
{




  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));

  void
  __throw_bad_array_new_length(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__,__cold__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__,__cold__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_out_of_range_fmt(const char*, ...) __attribute__((__noreturn__,__cold__))
    __attribute__((__format__(__gnu_printf__, 1, 2)));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__,__cold__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_ios_failure(const char*, int) __attribute__((__noreturn__,__cold__));


  void
  __throw_system_error(int) __attribute__((__noreturn__,__cold__));


  void
  __throw_future_error(int) __attribute__((__noreturn__,__cold__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__,__cold__));
# 140 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/functexcept.h" 3

}
# 61 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_algobase.h" 2 3
# 69 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_algobase.h" 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/debug/debug.h" 1 3
# 48 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;

  template<typename _Ite, typename _Seq, typename _Cat>
    struct _Safe_iterator;
}
# 70 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_algobase.h" 2 3

# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/predefined_ops.h" 1 3
# 35 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/predefined_ops.h" 3
namespace __gnu_cxx
{
namespace __ops
{
  struct _Iter_less_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      constexpr
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 < *__it2; }
  };

  constexpr
  inline _Iter_less_iter
  __iter_less_iter()
  { return _Iter_less_iter(); }

  struct _Iter_less_val
  {

    constexpr _Iter_less_val() = default;




    constexpr
    explicit
    _Iter_less_val(_Iter_less_iter) { }

    template<typename _Iterator, typename _Value>
      constexpr
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it < __val; }
  };

  constexpr
  inline _Iter_less_val
  __iter_less_val()
  { return _Iter_less_val(); }

  constexpr
  inline _Iter_less_val
  __iter_comp_val(_Iter_less_iter)
  { return _Iter_less_val(); }

  struct _Val_less_iter
  {

    constexpr _Val_less_iter() = default;




    constexpr
    explicit
    _Val_less_iter(_Iter_less_iter) { }

    template<typename _Value, typename _Iterator>
      constexpr
      bool
      operator()(_Value& __val, _Iterator __it) const
      { return __val < *__it; }
  };

  constexpr
  inline _Val_less_iter
  __val_less_iter()
  { return _Val_less_iter(); }

  constexpr
  inline _Val_less_iter
  __val_comp_iter(_Iter_less_iter)
  { return _Val_less_iter(); }

  struct _Iter_equal_to_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      constexpr
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 == *__it2; }
  };

  constexpr
  inline _Iter_equal_to_iter
  __iter_equal_to_iter()
  { return _Iter_equal_to_iter(); }

  struct _Iter_equal_to_val
  {
    template<typename _Iterator, typename _Value>
      constexpr
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it == __val; }
  };

  constexpr
  inline _Iter_equal_to_val
  __iter_equal_to_val()
  { return _Iter_equal_to_val(); }

  constexpr
  inline _Iter_equal_to_val
  __iter_comp_val(_Iter_equal_to_iter)
  { return _Iter_equal_to_val(); }

  template<typename _Compare>
    struct _Iter_comp_iter
    {
      _Compare _M_comp;

      explicit constexpr
      _Iter_comp_iter(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      template<typename _Iterator1, typename _Iterator2>
        constexpr
        bool
        operator()(_Iterator1 __it1, _Iterator2 __it2)
        { return bool(_M_comp(*__it1, *__it2)); }
    };

  template<typename _Compare>
    constexpr
    inline _Iter_comp_iter<_Compare>
    __iter_comp_iter(_Compare __comp)
    { return _Iter_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    struct _Iter_comp_val
    {
      _Compare _M_comp;

      constexpr
      explicit
      _Iter_comp_val(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      constexpr
      explicit
      _Iter_comp_val(const _Iter_comp_iter<_Compare>& __comp)
 : _M_comp(__comp._M_comp)
      { }


      constexpr
      explicit
      _Iter_comp_val(_Iter_comp_iter<_Compare>&& __comp)
 : _M_comp(std::move(__comp._M_comp))
      { }


      template<typename _Iterator, typename _Value>
 constexpr
 bool
 operator()(_Iterator __it, _Value& __val)
 { return bool(_M_comp(*__it, __val)); }
    };

  template<typename _Compare>
    constexpr
    inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Compare __comp)
    { return _Iter_comp_val<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    constexpr
    inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Iter_comp_iter<_Compare> __comp)
    { return _Iter_comp_val<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    struct _Val_comp_iter
    {
      _Compare _M_comp;

      constexpr
      explicit
      _Val_comp_iter(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      constexpr
      explicit
      _Val_comp_iter(const _Iter_comp_iter<_Compare>& __comp)
 : _M_comp(__comp._M_comp)
      { }


      constexpr
      explicit
      _Val_comp_iter(_Iter_comp_iter<_Compare>&& __comp)
 : _M_comp(std::move(__comp._M_comp))
      { }


      template<typename _Value, typename _Iterator>
 constexpr
 bool
 operator()(_Value& __val, _Iterator __it)
 { return bool(_M_comp(__val, *__it)); }
    };

  template<typename _Compare>
    constexpr
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Compare __comp)
    { return _Val_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    constexpr
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Iter_comp_iter<_Compare> __comp)
    { return _Val_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Value>
    struct _Iter_equals_val
    {
      _Value& _M_value;

      constexpr
      explicit
      _Iter_equals_val(_Value& __value)
 : _M_value(__value)
      { }

      template<typename _Iterator>
 constexpr
 bool
 operator()(_Iterator __it)
 { return *__it == _M_value; }
    };

  template<typename _Value>
    constexpr
    inline _Iter_equals_val<_Value>
    __iter_equals_val(_Value& __val)
    { return _Iter_equals_val<_Value>(__val); }

  template<typename _Iterator1>
    struct _Iter_equals_iter
    {
      _Iterator1 _M_it1;

      constexpr
      explicit
      _Iter_equals_iter(_Iterator1 __it1)
 : _M_it1(__it1)
      { }

      template<typename _Iterator2>
 constexpr
 bool
 operator()(_Iterator2 __it2)
 { return *__it2 == *_M_it1; }
    };

  template<typename _Iterator>
    constexpr
    inline _Iter_equals_iter<_Iterator>
    __iter_comp_iter(_Iter_equal_to_iter, _Iterator __it)
    { return _Iter_equals_iter<_Iterator>(__it); }

  template<typename _Predicate>
    struct _Iter_pred
    {
      _Predicate _M_pred;

      constexpr
      explicit
      _Iter_pred(_Predicate __pred)
 : _M_pred(std::move(__pred))
      { }

      template<typename _Iterator>
 constexpr
 bool
 operator()(_Iterator __it)
 { return bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
    constexpr
    inline _Iter_pred<_Predicate>
    __pred_iter(_Predicate __pred)
    { return _Iter_pred<_Predicate>(std::move(__pred)); }

  template<typename _Compare, typename _Value>
    struct _Iter_comp_to_val
    {
      _Compare _M_comp;
      _Value& _M_value;

      constexpr
      _Iter_comp_to_val(_Compare __comp, _Value& __value)
 : _M_comp(std::move(__comp)), _M_value(__value)
      { }

      template<typename _Iterator>
 constexpr
 bool
 operator()(_Iterator __it)
 { return bool(_M_comp(*__it, _M_value)); }
    };

  template<typename _Compare, typename _Value>
    _Iter_comp_to_val<_Compare, _Value>
    constexpr
    __iter_comp_val(_Compare __comp, _Value &__val)
    {
      return _Iter_comp_to_val<_Compare, _Value>(std::move(__comp), __val);
    }

  template<typename _Compare, typename _Iterator1>
    struct _Iter_comp_to_iter
    {
      _Compare _M_comp;
      _Iterator1 _M_it1;

      constexpr
      _Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)
 : _M_comp(std::move(__comp)), _M_it1(__it1)
      { }

      template<typename _Iterator2>
 constexpr
 bool
 operator()(_Iterator2 __it2)
 { return bool(_M_comp(*__it2, *_M_it1)); }
    };

  template<typename _Compare, typename _Iterator>
    constexpr
    inline _Iter_comp_to_iter<_Compare, _Iterator>
    __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it)
    {
      return _Iter_comp_to_iter<_Compare, _Iterator>(
   std::move(__comp._M_comp), __it);
    }

  template<typename _Predicate>
    struct _Iter_negate
    {
      _Predicate _M_pred;

      constexpr
      explicit
      _Iter_negate(_Predicate __pred)
 : _M_pred(std::move(__pred))
      { }

      template<typename _Iterator>
 constexpr
 bool
 operator()(_Iterator __it)
 { return !bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
    constexpr
    inline _Iter_negate<_Predicate>
    __negate(_Iter_pred<_Predicate> __pred)
    { return _Iter_negate<_Predicate>(std::move(__pred._M_pred)); }

}
}
# 72 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_algobase.h" 2 3




# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bit" 1 3
# 32 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bit" 3
       
# 33 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bit" 3
# 61 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bit" 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 1 3
# 47 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 3
       
# 48 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 3
# 62 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bit" 2 3

namespace std
{

# 85 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bit" 3
  template<typename _To, typename _From>
    [[nodiscard]]
    constexpr _To
    bit_cast(const _From& __from) noexcept

    requires (sizeof(_To) == sizeof(_From))
      && is_trivially_copyable_v<_To> && is_trivially_copyable_v<_From>

    {
      return __builtin_bit_cast(_To, __from);
    }
# 107 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bit" 3
  template<integral _Tp>
    [[nodiscard]]
    constexpr _Tp
    byteswap(_Tp __value) noexcept
    {
      if constexpr (sizeof(_Tp) == 1)
 return __value;

      if !consteval
 {
   if constexpr (sizeof(_Tp) == 2)
     return __builtin_bswap16(__value);
   if constexpr (sizeof(_Tp) == 4)
     return __builtin_bswap32(__value);
   if constexpr (sizeof(_Tp) == 8)
     return __builtin_bswap64(__value);
   if constexpr (sizeof(_Tp) == 16)

     return __builtin_bswap128(__value);




 }



      using _Up = typename __make_unsigned<__remove_cv_t<_Tp>>::__type;
      size_t __diff = 8 * (sizeof(_Tp) - 1);
      _Up __mask1 = static_cast<unsigned char>(~0);
      _Up __mask2 = __mask1 << __diff;
      _Up __val = __value;
      for (size_t __i = 0; __i < sizeof(_Tp) / 2; ++__i)
 {
   _Up __byte1 = __val & __mask1;
   _Up __byte2 = __val & __mask2;
   __val = (__val ^ __byte1 ^ __byte2
     ^ (__byte1 << __diff) ^ (__byte2 >> __diff));
   __mask1 <<= 8;
   __mask2 >>= 8;
   __diff -= 2 * 8;
 }
      return __val;
    }




  template<typename _Tp>
    constexpr _Tp
    __rotl(_Tp __x, int __s) noexcept
    {
      constexpr auto _Nd = __gnu_cxx::__int_traits<_Tp>::__digits;
      if constexpr ((_Nd & (_Nd - 1)) == 0)
 {


   constexpr unsigned __uNd = _Nd;
   const unsigned __r = __s;
   return (__x << (__r % __uNd)) | (__x >> ((-__r) % __uNd));
 }
      const int __r = __s % _Nd;
      if (__r == 0)
 return __x;
      else if (__r > 0)
 return (__x << __r) | (__x >> ((_Nd - __r) % _Nd));
      else
 return (__x >> -__r) | (__x << ((_Nd + __r) % _Nd));
    }

  template<typename _Tp>
    constexpr _Tp
    __rotr(_Tp __x, int __s) noexcept
    {
      constexpr auto _Nd = __gnu_cxx::__int_traits<_Tp>::__digits;
      if constexpr ((_Nd & (_Nd - 1)) == 0)
 {


   constexpr unsigned __uNd = _Nd;
   const unsigned __r = __s;
   return (__x >> (__r % __uNd)) | (__x << ((-__r) % __uNd));
 }
      const int __r = __s % _Nd;
      if (__r == 0)
 return __x;
      else if (__r > 0)
 return (__x >> __r) | (__x << ((_Nd - __r) % _Nd));
      else
 return (__x << -__r) | (__x >> ((_Nd + __r) % _Nd));
    }

  template<typename _Tp>
    constexpr int
    __countl_zero(_Tp __x) noexcept
    {
      using __gnu_cxx::__int_traits;
      constexpr auto _Nd = __int_traits<_Tp>::__digits;

      if (__x == 0)
        return _Nd;

      constexpr auto _Nd_ull = __int_traits<unsigned long long>::__digits;
      constexpr auto _Nd_ul = __int_traits<unsigned long>::__digits;
      constexpr auto _Nd_u = __int_traits<unsigned>::__digits;

      if constexpr (_Nd <= _Nd_u)
 {
   constexpr int __diff = _Nd_u - _Nd;
   return __builtin_clz(__x) - __diff;
 }
      else if constexpr (_Nd <= _Nd_ul)
 {
   constexpr int __diff = _Nd_ul - _Nd;
   return __builtin_clzl(__x) - __diff;
 }
      else if constexpr (_Nd <= _Nd_ull)
 {
   constexpr int __diff = _Nd_ull - _Nd;
   return __builtin_clzll(__x) - __diff;
 }
      else
 {
   static_assert(_Nd <= (2 * _Nd_ull),
   "Maximum supported integer size is 128-bit");

   unsigned long long __high = __x >> _Nd_ull;
   if (__high != 0)
     {
       constexpr int __diff = (2 * _Nd_ull) - _Nd;
       return __builtin_clzll(__high) - __diff;
     }
   constexpr auto __max_ull = __int_traits<unsigned long long>::__max;
   unsigned long long __low = __x & __max_ull;
   return (_Nd - _Nd_ull) + __builtin_clzll(__low);
 }
    }

  template<typename _Tp>
    constexpr int
    __countl_one(_Tp __x) noexcept
    {
      return std::__countl_zero<_Tp>((_Tp)~__x);
    }

  template<typename _Tp>
    constexpr int
    __countr_zero(_Tp __x) noexcept
    {
      using __gnu_cxx::__int_traits;
      constexpr auto _Nd = __int_traits<_Tp>::__digits;

      if (__x == 0)
        return _Nd;

      constexpr auto _Nd_ull = __int_traits<unsigned long long>::__digits;
      constexpr auto _Nd_ul = __int_traits<unsigned long>::__digits;
      constexpr auto _Nd_u = __int_traits<unsigned>::__digits;

      if constexpr (_Nd <= _Nd_u)
 return __builtin_ctz(__x);
      else if constexpr (_Nd <= _Nd_ul)
 return __builtin_ctzl(__x);
      else if constexpr (_Nd <= _Nd_ull)
 return __builtin_ctzll(__x);
      else
 {
   static_assert(_Nd <= (2 * _Nd_ull),
   "Maximum supported integer size is 128-bit");

   constexpr auto __max_ull = __int_traits<unsigned long long>::__max;
   unsigned long long __low = __x & __max_ull;
   if (__low != 0)
     return __builtin_ctzll(__low);
   unsigned long long __high = __x >> _Nd_ull;
   return __builtin_ctzll(__high) + _Nd_ull;
 }
    }

  template<typename _Tp>
    constexpr int
    __countr_one(_Tp __x) noexcept
    {
      return std::__countr_zero((_Tp)~__x);
    }

  template<typename _Tp>
    constexpr int
    __popcount(_Tp __x) noexcept
    {
      using __gnu_cxx::__int_traits;
      constexpr auto _Nd = __int_traits<_Tp>::__digits;

      constexpr auto _Nd_ull = __int_traits<unsigned long long>::__digits;
      constexpr auto _Nd_ul = __int_traits<unsigned long>::__digits;
      constexpr auto _Nd_u = __int_traits<unsigned>::__digits;

      if constexpr (_Nd <= _Nd_u)
 return __builtin_popcount(__x);
      else if constexpr (_Nd <= _Nd_ul)
 return __builtin_popcountl(__x);
      else if constexpr (_Nd <= _Nd_ull)
 return __builtin_popcountll(__x);
      else
 {
   static_assert(_Nd <= (2 * _Nd_ull),
   "Maximum supported integer size is 128-bit");

   constexpr auto __max_ull = __int_traits<unsigned long long>::__max;
   unsigned long long __low = __x & __max_ull;
   unsigned long long __high = __x >> _Nd_ull;
   return __builtin_popcountll(__low) + __builtin_popcountll(__high);
 }
    }

  template<typename _Tp>
    constexpr bool
    __has_single_bit(_Tp __x) noexcept
    { return std::__popcount(__x) == 1; }

  template<typename _Tp>
    constexpr _Tp
    __bit_ceil(_Tp __x) noexcept
    {
      using __gnu_cxx::__int_traits;
      constexpr auto _Nd = __int_traits<_Tp>::__digits;
      if (__x == 0 || __x == 1)
        return 1;
      auto __shift_exponent = _Nd - std::__countl_zero((_Tp)(__x - 1u));




      if (!std::__is_constant_evaluated())
 {
   do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__shift_exponent != __int_traits<_Tp>::__digits), false)) std::__glibcxx_assert_fail(); } while (false);
 }

      using __promoted_type = decltype(__x << 1);
      if constexpr (!is_same<__promoted_type, _Tp>::value)
 {





   const int __extra_exp = sizeof(__promoted_type) / sizeof(_Tp) / 2;
   __shift_exponent |= (__shift_exponent & _Nd) << __extra_exp;
 }
      return (_Tp)1u << __shift_exponent;
    }

  template<typename _Tp>
    constexpr _Tp
    __bit_floor(_Tp __x) noexcept
    {
      constexpr auto _Nd = __gnu_cxx::__int_traits<_Tp>::__digits;
      if (__x == 0)
        return 0;
      return (_Tp)1u << (_Nd - std::__countl_zero((_Tp)(__x >> 1)));
    }

  template<typename _Tp>
    constexpr int
    __bit_width(_Tp __x) noexcept
    {
      constexpr auto _Nd = __gnu_cxx::__int_traits<_Tp>::__digits;
      return _Nd - std::__countl_zero(__x);
    }






  template<typename _Tp>
    concept __unsigned_integer = __is_unsigned_integer<_Tp>::value;





  template<__unsigned_integer _Tp>
    [[nodiscard]] constexpr _Tp
    rotl(_Tp __x, int __s) noexcept
    { return std::__rotl(__x, __s); }


  template<__unsigned_integer _Tp>
    [[nodiscard]] constexpr _Tp
    rotr(_Tp __x, int __s) noexcept
    { return std::__rotr(__x, __s); }




  template<__unsigned_integer _Tp>
    constexpr int
    countl_zero(_Tp __x) noexcept
    { return std::__countl_zero(__x); }


  template<__unsigned_integer _Tp>
    constexpr int
    countl_one(_Tp __x) noexcept
    { return std::__countl_one(__x); }


  template<__unsigned_integer _Tp>
    constexpr int
    countr_zero(_Tp __x) noexcept
    { return std::__countr_zero(__x); }


  template<__unsigned_integer _Tp>
    constexpr int
    countr_one(_Tp __x) noexcept
    { return std::__countr_one(__x); }


  template<__unsigned_integer _Tp>
    constexpr int
    popcount(_Tp __x) noexcept
    { return std::__popcount(__x); }






  template<__unsigned_integer _Tp>
    constexpr bool
    has_single_bit(_Tp __x) noexcept
    { return std::__has_single_bit(__x); }


  template<__unsigned_integer _Tp>
    constexpr _Tp
    bit_ceil(_Tp __x) noexcept
    { return std::__bit_ceil(__x); }


  template<__unsigned_integer _Tp>
    constexpr _Tp
    bit_floor(_Tp __x) noexcept
    { return std::__bit_floor(__x); }




  template<__unsigned_integer _Tp>
    constexpr int
    bit_width(_Tp __x) noexcept
    { return std::__bit_width(__x); }
# 472 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bit" 3
  enum class endian
  {
    little = 1234,
    big = 4321,
    native = 1234
  };





}
# 77 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_algobase.h" 2 3





namespace std
{






  template<typename _Tp, typename _Up>
    constexpr
    inline int
    __memcmp(const _Tp* __first1, const _Up* __first2, size_t __num)
    {

      static_assert(sizeof(_Tp) == sizeof(_Up), "can be compared with memcmp");


      if (std::is_constant_evaluated())
 {
   for(; __num > 0; ++__first1, ++__first2, --__num)
     if (*__first1 != *__first2)
       return *__first1 < *__first2 ? -1 : 1;
   return 0;
 }
      else

 return __builtin_memcmp(__first1, __first2, sizeof(_Tp) * __num);
    }
# 152 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    constexpr
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {

     

     
# 185 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_algobase.h" 3
      swap(*__a, *__b);

    }
# 201 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    constexpr
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {

     

     

      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 230 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _Tp>
    [[__nodiscard__]] constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a)
 return __b;
      return __a;
    }
# 254 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _Tp>
    [[__nodiscard__]] constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b)
 return __b;
      return __a;
    }
# 278 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    [[__nodiscard__]] constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 300 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    [[__nodiscard__]] constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }



  template<typename _Iterator>
    constexpr
    inline _Iterator
    __niter_base(_Iterator __it)
    noexcept(std::is_nothrow_copy_constructible<_Iterator>::value)
    { return __it; }
# 332 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _Ite, typename _Seq>
    constexpr
    decltype(std::__niter_base(std::declval<_Ite>()))
    __niter_base(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq,
   std::random_access_iterator_tag>&)
    noexcept(std::is_nothrow_copy_constructible<_Ite>::value);





  template<typename _From, typename _To>
    constexpr
    inline _From
    __niter_wrap(_From __from, _To __res)
    { return __from + (std::__niter_base(__res) - std::__niter_base(__from)); }


  template<typename _Iterator>
    constexpr
    inline _Iterator
    __niter_wrap(const _Iterator&, _Iterator __res)
    { return __res; }







  template<bool _IsMove, bool _IsSimple, typename _Category>
    struct __copy_move
    {
      template<typename _II, typename _OI>
 constexpr
 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = *__first;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move<true, false, _Category>
    {
      template<typename _II, typename _OI>
 constexpr
 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = std::move(*__first);
   return __result;
 }
    };


  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
 constexpr
 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }

      template<typename _Tp, typename _Up>
 static void
 __assign_one(_Tp* __to, _Up* __from)
 { *__to = *__from; }
    };


  template<>
    struct __copy_move<true, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
 constexpr
 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = std::move(*__first);
       ++__first;
       ++__result;
     }
   return __result;
 }

      template<typename _Tp, typename _Up>
 static void
 __assign_one(_Tp* __to, _Up* __from)
 { *__to = std::move(*__from); }
    };


  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp, typename _Up>
 constexpr
 static _Up*
 __copy_m(_Tp* __first, _Tp* __last, _Up* __result)
 {
   const ptrdiff_t _Num = __last - __first;
   if (__builtin_expect(_Num > 1, true))
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   else if (_Num == 1)
     std::__copy_move<_IsMove, false, random_access_iterator_tag>::
       __assign_one(__result, __first);
   return __result + _Num;
 }
    };



  template<typename _Tp, typename _Ref, typename _Ptr>
    struct _Deque_iterator;

  struct _Bit_iterator;






  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<
      __is_char<_CharT>::__value,
      std::_Deque_iterator<_CharT, _CharT&, _CharT*> >::__type
    __copy_move_a2(
 istreambuf_iterator<_CharT, char_traits<_CharT> >,
 istreambuf_iterator<_CharT, char_traits<_CharT> >,
 std::_Deque_iterator<_CharT, _CharT&, _CharT*>);


  template<bool _IsMove, typename _II, typename _OI>
    constexpr
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::iterator_category _Category;

      if (std::is_constant_evaluated())
 return std::__copy_move<_IsMove, false, _Category>::
   __copy_m(__first, __last, __result);

      return std::__copy_move<_IsMove, __memcpyable<_OI, _II>::__value,
         _Category>::__copy_m(__first, __last, __result);
    }

  template<bool _IsMove,
    typename _Tp, typename _Ref, typename _Ptr, typename _OI>
    _OI
    __copy_move_a1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
     std::_Deque_iterator<_Tp, _Ref, _Ptr>,
     _OI);

  template<bool _IsMove,
    typename _ITp, typename _IRef, typename _IPtr, typename _OTp>
    std::_Deque_iterator<_OTp, _OTp&, _OTp*>
    __copy_move_a1(std::_Deque_iterator<_ITp, _IRef, _IPtr>,
     std::_Deque_iterator<_ITp, _IRef, _IPtr>,
     std::_Deque_iterator<_OTp, _OTp&, _OTp*>);

  template<bool _IsMove, typename _II, typename _Tp>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value,
      std::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type
    __copy_move_a1(_II, _II, std::_Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<bool _IsMove, typename _II, typename _OI>
    constexpr
    inline _OI
    __copy_move_a1(_II __first, _II __last, _OI __result)
    { return std::__copy_move_a2<_IsMove>(__first, __last, __result); }

  template<bool _IsMove, typename _II, typename _OI>
    constexpr
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      return std::__niter_wrap(__result,
  std::__copy_move_a1<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }

  template<bool _IsMove,
    typename _Ite, typename _Seq, typename _Cat, typename _OI>
    constexpr
    _OI
    __copy_move_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
    const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
    _OI);

  template<bool _IsMove,
    typename _II, typename _Ite, typename _Seq, typename _Cat>
    constexpr
    __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
    __copy_move_a(_II, _II,
    const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&);

  template<bool _IsMove,
    typename _IIte, typename _ISeq, typename _ICat,
    typename _OIte, typename _OSeq, typename _OCat>
    constexpr
    ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>
    __copy_move_a(const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
    const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
    const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>&);

  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    constexpr
    _OutputIterator
    __copy_n_a(_InputIterator __first, _Size __n, _OutputIterator __result,
        bool)
    {
      if (__n > 0)
 {
   while (true)
     {
       *__result = *__first;
       ++__result;
       if (--__n > 0)
  ++__first;
       else
  break;
     }
 }
      return __result;
    }


  template<typename _CharT, typename _Size>
    typename __gnu_cxx::__enable_if<
      __is_char<_CharT>::__value, _CharT*>::__type
    __copy_n_a(istreambuf_iterator<_CharT, char_traits<_CharT> >,
        _Size, _CharT*, bool);

  template<typename _CharT, typename _Size>
    typename __gnu_cxx::__enable_if<
      __is_char<_CharT>::__value,
      std::_Deque_iterator<_CharT, _CharT&, _CharT*> >::__type
    __copy_n_a(istreambuf_iterator<_CharT, char_traits<_CharT> >, _Size,
        std::_Deque_iterator<_CharT, _CharT&, _CharT*>,
        bool);
# 639 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    constexpr
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return std::__copy_move_a<__is_move_iterator<_II>::__value>
      (std::__miter_base(__first), std::__miter_base(__last), __result);
    }
# 672 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    constexpr
    inline _OI
    move(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return std::__copy_move_a<true>(std::__miter_base(__first),
          std::__miter_base(__last), __result);
    }






  template<bool _IsMove, bool _IsSimple, typename _Category>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
 constexpr
 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move_backward<true, false, _Category>
    {
      template<typename _BI1, typename _BI2>
 constexpr
 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   while (__first != __last)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
 constexpr
 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   typename iterator_traits<_BI1>::difference_type
     __n = __last - __first;
   for (; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<true, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
 constexpr
 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   typename iterator_traits<_BI1>::difference_type
     __n = __last - __first;
   for (; __n > 0; --__n)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp, typename _Up>
 constexpr
 static _Up*
 __copy_move_b(_Tp* __first, _Tp* __last, _Up* __result)
 {
   const ptrdiff_t _Num = __last - __first;
   if (__builtin_expect(_Num > 1, true))
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   else if (_Num == 1)
     std::__copy_move<_IsMove, false, random_access_iterator_tag>::
       __assign_one(__result - 1, __first);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    constexpr
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::iterator_category _Category;

      if (std::is_constant_evaluated())
 return std::__copy_move_backward<_IsMove, false, _Category>::
   __copy_move_b(__first, __last, __result);

      return std::__copy_move_backward<_IsMove,
           __memcpyable<_BI2, _BI1>::__value,
           _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    constexpr
    inline _BI2
    __copy_move_backward_a1(_BI1 __first, _BI1 __last, _BI2 __result)
    { return std::__copy_move_backward_a2<_IsMove>(__first, __last, __result); }

  template<bool _IsMove,
    typename _Tp, typename _Ref, typename _Ptr, typename _OI>
    _OI
    __copy_move_backward_a1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
       std::_Deque_iterator<_Tp, _Ref, _Ptr>,
       _OI);

  template<bool _IsMove,
    typename _ITp, typename _IRef, typename _IPtr, typename _OTp>
    std::_Deque_iterator<_OTp, _OTp&, _OTp*>
    __copy_move_backward_a1(
   std::_Deque_iterator<_ITp, _IRef, _IPtr>,
   std::_Deque_iterator<_ITp, _IRef, _IPtr>,
   std::_Deque_iterator<_OTp, _OTp&, _OTp*>);

  template<bool _IsMove, typename _II, typename _Tp>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value,
      std::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type
    __copy_move_backward_a1(_II, _II,
       std::_Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<bool _IsMove, typename _II, typename _OI>
    constexpr
    inline _OI
    __copy_move_backward_a(_II __first, _II __last, _OI __result)
    {
      return std::__niter_wrap(__result,
  std::__copy_move_backward_a1<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }

  template<bool _IsMove,
    typename _Ite, typename _Seq, typename _Cat, typename _OI>
    constexpr
    _OI
    __copy_move_backward_a(
  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
  _OI);

  template<bool _IsMove,
    typename _II, typename _Ite, typename _Seq, typename _Cat>
    constexpr
    __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
    __copy_move_backward_a(_II, _II,
  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&);

  template<bool _IsMove,
    typename _IIte, typename _ISeq, typename _ICat,
    typename _OIte, typename _OSeq, typename _OCat>
    constexpr
    ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>
    __copy_move_backward_a(
  const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
  const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
  const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>&);
# 875 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    constexpr
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     

      ;

      return std::__copy_move_backward_a<__is_move_iterator<_BI1>::__value>
      (std::__miter_base(__first), std::__miter_base(__last), __result);
    }
# 910 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    constexpr
    inline _BI2
    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     

      ;

      return std::__copy_move_backward_a<true>(std::__miter_base(__first),
            std::__miter_base(__last),
            __result);
    }






  template<typename _ForwardIterator, typename _Tp>
    constexpr
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
    constexpr
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
    constexpr
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a1(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;

      if (std::is_constant_evaluated())
 {
   for (; __first != __last; ++__first)
     *__first = __tmp;
   return;
 }

      if (const size_t __len = __last - __first)
 __builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
    }

  template<typename _Ite, typename _Cont, typename _Tp>
    constexpr
    inline void
    __fill_a1(::__gnu_cxx::__normal_iterator<_Ite, _Cont> __first,
       ::__gnu_cxx::__normal_iterator<_Ite, _Cont> __last,
       const _Tp& __value)
    { std::__fill_a1(__first.base(), __last.base(), __value); }

  template<typename _Tp, typename _VTp>
    void
    __fill_a1(const std::_Deque_iterator<_Tp, _Tp&, _Tp*>&,
       const std::_Deque_iterator<_Tp, _Tp&, _Tp*>&,
       const _VTp&);

  constexpr
  void
  __fill_a1(std::_Bit_iterator, std::_Bit_iterator,
     const bool&);

  template<typename _FIte, typename _Tp>
    constexpr
    inline void
    __fill_a(_FIte __first, _FIte __last, const _Tp& __value)
    { std::__fill_a1(__first, __last, __value); }

  template<typename _Ite, typename _Seq, typename _Cat, typename _Tp>
    constexpr
    void
    __fill_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
      const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
      const _Tp&);
# 1019 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    constexpr
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {

     

      ;

      std::__fill_a(__first, __last, __value);
    }


  inline constexpr int
  __size_to_integer(int __n) { return __n; }
  inline constexpr unsigned
  __size_to_integer(unsigned __n) { return __n; }
  inline constexpr long
  __size_to_integer(long __n) { return __n; }
  inline constexpr unsigned long
  __size_to_integer(unsigned long __n) { return __n; }
  inline constexpr long long
  __size_to_integer(long long __n) { return __n; }
  inline constexpr unsigned long long
  __size_to_integer(unsigned long long __n) { return __n; }


  __extension__ inline constexpr __int128
  __size_to_integer(__int128 __n) { return __n; }
  __extension__ inline constexpr unsigned __int128
  __size_to_integer(unsigned __int128 __n) { return __n; }
# 1071 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_algobase.h" 3
  inline constexpr long long
  __size_to_integer(float __n) { return (long long)__n; }
  inline constexpr long long
  __size_to_integer(double __n) { return (long long)__n; }
  inline constexpr long long
  __size_to_integer(long double __n) { return (long long)__n; }

  __extension__ inline constexpr long long
  __size_to_integer(__float128 __n) { return (long long)__n; }


  template<typename _OutputIterator, typename _Size, typename _Tp>
    constexpr
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (; __n > 0; --__n, (void) ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    constexpr
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __n > 0; --__n, (void) ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Ite, typename _Seq, typename _Cat, typename _Size,
    typename _Tp>
    constexpr
    ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
    __fill_n_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>& __first,
        _Size __n, const _Tp& __value,
        std::input_iterator_tag);

  template<typename _OutputIterator, typename _Size, typename _Tp>
    constexpr
    inline _OutputIterator
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
        std::output_iterator_tag)
    {

      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

      return __fill_n_a1(__first, __n, __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    constexpr
    inline _OutputIterator
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
        std::input_iterator_tag)
    {

      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

      return __fill_n_a1(__first, __n, __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    constexpr
    inline _OutputIterator
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
        std::random_access_iterator_tag)
    {

      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

      if (__n <= 0)
 return __first;

      ;

      std::__fill_a(__first, __first + __n, __value);
      return __first + __n;
    }
# 1172 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
    constexpr
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {

     

      return std::__fill_n_a(__first, std::__size_to_integer(__n), __value,
          std::__iterator_category(__first));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
 constexpr
 static bool
 equal(_II1 __first1, _II1 __last1, _II2 __first2)
 {
   for (; __first1 != __last1; ++__first1, (void) ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
 constexpr
 static bool
 equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
 {
   if (const size_t __len = (__last1 - __first1))
     return !std::__memcmp(__first1, __first2, __len);
   return true;
 }
    };

  template<typename _Tp, typename _Ref, typename _Ptr, typename _II>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value, bool>::__type
    __equal_aux1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
   std::_Deque_iterator<_Tp, _Ref, _Ptr>,
   _II);

  template<typename _Tp1, typename _Ref1, typename _Ptr1,
    typename _Tp2, typename _Ref2, typename _Ptr2>
    bool
    __equal_aux1(std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
   std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
   std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);

  template<typename _II, typename _Tp, typename _Ref, typename _Ptr>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value, bool>::__type
    __equal_aux1(_II, _II,
  std::_Deque_iterator<_Tp, _Ref, _Ptr>);

  template<typename _II1, typename _II2>
    constexpr
    inline bool
    __equal_aux1(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      const bool __simple = ((__is_integer<_ValueType1>::__value
         || __is_pointer<_ValueType1>::__value)
        && __memcmpable<_II1, _II2>::__value);
      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }

  template<typename _II1, typename _II2>
    constexpr
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      return std::__equal_aux1(std::__niter_base(__first1),
          std::__niter_base(__last1),
          std::__niter_base(__first2));
    }

  template<typename _II1, typename _Seq1, typename _Cat1, typename _II2>
    constexpr
    bool
    __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  _II2);

  template<typename _II1, typename _II2, typename _Seq2, typename _Cat2>
    constexpr
    bool
    __equal_aux(_II1, _II1,
  const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2>&);

  template<typename _II1, typename _Seq1, typename _Cat1,
    typename _II2, typename _Seq2, typename _Cat2>
    constexpr
    bool
    __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2>&);

  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
 constexpr
 static _II1
 __newlast1(_II1, _II1 __last1, _II2, _II2)
 { return __last1; }

      template<typename _II>
 constexpr
 static bool
 __cnd2(_II __first, _II __last)
 { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
 constexpr
 static _RAI1
 __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
 {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
 static constexpr bool
 __cnd2(_RAI, _RAI)
 { return true; }
    };

  template<typename _II1, typename _II2, typename _Compare>
    constexpr
    bool
    __lexicographical_compare_impl(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2,
       _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, (void)++__first2)
 {
   if (__comp(__first1, __first2))
     return true;
   if (__comp(__first2, __first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
 constexpr
 static bool
 __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
 {
   using __gnu_cxx::__ops::__iter_less_iter;
   return std::__lexicographical_compare_impl(__first1, __last1,
           __first2, __last2,
           __iter_less_iter());
 }

      template<typename _II1, typename _II2>
 constexpr
 static int
 __3way(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
 {
   while (__first1 != __last1)
     {
       if (__first2 == __last2)
  return +1;
       if (*__first1 < *__first2)
  return -1;
       if (*__first2 < *__first1)
  return +1;
       ++__first1;
       ++__first2;
     }
   return int(__first2 == __last2) - 1;
 }
    };

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
 constexpr
 static bool
 __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 { return __3way(__first1, __last1, __first2, __last2) < 0; }

      template<typename _Tp, typename _Up>
 constexpr
 static ptrdiff_t
 __3way(const _Tp* __first1, const _Tp* __last1,
        const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   if (const size_t __len = std::min(__len1, __len2))
     if (int __result = std::__memcmp(__first1, __first2, __len))
       return __result;
   return ptrdiff_t(__len1 - __len2);
 }
    };

  template<typename _II1, typename _II2>
    constexpr
    inline bool
    __lexicographical_compare_aux1(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_memcmp_ordered_with<_ValueType1, _ValueType2>::__value
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value




  && !is_volatile_v<remove_reference_t<iter_reference_t<_II1>>>
  && !is_volatile_v<remove_reference_t<iter_reference_t<_II2>>>

  );

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }

  template<typename _Tp1, typename _Ref1, typename _Ptr1,
    typename _Tp2>
    bool
    __lexicographical_compare_aux1(
 std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
 std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
 _Tp2*, _Tp2*);

  template<typename _Tp1,
    typename _Tp2, typename _Ref2, typename _Ptr2>
    bool
    __lexicographical_compare_aux1(_Tp1*, _Tp1*,
 std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>,
 std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);

  template<typename _Tp1, typename _Ref1, typename _Ptr1,
    typename _Tp2, typename _Ref2, typename _Ptr2>
    bool
    __lexicographical_compare_aux1(
 std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
 std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
 std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>,
 std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);

  template<typename _II1, typename _II2>
    constexpr
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      return std::__lexicographical_compare_aux1(std::__niter_base(__first1),
       std::__niter_base(__last1),
       std::__niter_base(__first2),
       std::__niter_base(__last2));
    }

  template<typename _Iter1, typename _Seq1, typename _Cat1,
    typename _II2>
    constexpr
    bool
    __lexicographical_compare_aux(
  const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,
  _II2, _II2);

  template<typename _II1,
    typename _Iter2, typename _Seq2, typename _Cat2>
    constexpr
    bool
    __lexicographical_compare_aux(
  _II1, _II1,
  const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&,
  const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&);

  template<typename _Iter1, typename _Seq1, typename _Cat1,
    typename _Iter2, typename _Seq2, typename _Cat2>
    constexpr
    bool
    __lexicographical_compare_aux(
  const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&,
  const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&);

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    constexpr
    _ForwardIterator
    __lower_bound(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 1524 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    [[__nodiscard__]] constexpr
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {

     
     

      ;

      return std::__lower_bound(__first, __last, __val,
    __gnu_cxx::__ops::__iter_less_val());
    }



  template<typename _Tp>
    inline constexpr _Tp
    __lg(_Tp __n)
    {

      return std::__bit_width(make_unsigned_t<_Tp>(__n)) - 1;
# 1557 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_algobase.h" 3
    }


# 1573 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    [[__nodiscard__]] constexpr
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {

     
     
     


      ;

      return std::__equal_aux(__first1, __last1, __first2);
    }
# 1604 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    [[__nodiscard__]] constexpr
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }



  template<typename _II1, typename _II2>
    constexpr
    inline bool
    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {
      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!(*__first1 == *__first2))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }


  template<typename _II1, typename _II2, typename _BinaryPredicate>
    constexpr
    inline bool
    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2,
      _BinaryPredicate __binary_pred)
    {
      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2,
           __binary_pred);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }
# 1691 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    [[__nodiscard__]] constexpr
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {

     
     
     


      ;
      ;

      return std::__equal4(__first1, __last1, __first2, __last2);
    }
# 1724 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    [[__nodiscard__]] constexpr
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _IIter2 __last2, _BinaryPredicate __binary_pred)
    {

     
     
      ;
      ;

      return std::__equal4(__first1, __last1, __first2, __last2,
          __binary_pred);
    }
# 1756 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    [[__nodiscard__]] constexpr
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {





     
     
     
     
      ;
      ;

      return std::__lexicographical_compare_aux(__first1, __last1,
      __first2, __last2);
    }
# 1791 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
    [[__nodiscard__]] constexpr
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {

     
     
      ;
      ;

      return std::__lexicographical_compare_impl
 (__first1, __last1, __first2, __last2,
  __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }





  template<typename _Iter1, typename _Iter2>
    concept __memcmp_ordered_with
      = (__is_memcmp_ordered_with<iter_value_t<_Iter1>,
      iter_value_t<_Iter2>>::__value)
   && contiguous_iterator<_Iter1> && contiguous_iterator<_Iter2>;



  template<typename _Tp>
    constexpr auto
    __min_cmp(_Tp __x, _Tp __y)
    {
      struct _Res {
 _Tp _M_min;
 decltype(__x <=> __y) _M_cmp;
      };
      auto __c = __x <=> __y;
      if (__c > 0)
 return _Res{__y, __c};
      return _Res{__x, __c};
    }
# 1845 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _InputIter1, typename _InputIter2, typename _Comp>
    [[nodiscard]] constexpr auto
    lexicographical_compare_three_way(_InputIter1 __first1,
          _InputIter1 __last1,
          _InputIter2 __first2,
          _InputIter2 __last2,
          _Comp __comp)
    -> decltype(__comp(*__first1, *__first2))
    {

     
     
      ;
      ;

      using _Cat = decltype(__comp(*__first1, *__first2));
      static_assert(same_as<common_comparison_category_t<_Cat>, _Cat>);

      if (!std::__is_constant_evaluated())
 if constexpr (same_as<_Comp, __detail::_Synth3way>
        || same_as<_Comp, compare_three_way>)
   if constexpr (__memcmp_ordered_with<_InputIter1, _InputIter2>)
     {
       const auto [__len, __lencmp] = std::
  __min_cmp(__last1 - __first1, __last2 - __first2);
       if (__len)
  {
    const auto __blen = __len * sizeof(*__first1);
    const auto __c
      = __builtin_memcmp(&*__first1, &*__first2, __blen) <=> 0;
    if (__c != 0)
      return __c;
  }
       return __lencmp;
     }

      while (__first1 != __last1)
 {
   if (__first2 == __last2)
     return strong_ordering::greater;
   if (auto __cmp = __comp(*__first1, *__first2); __cmp != 0)
     return __cmp;
   ++__first1;
   ++__first2;
 }
      return (__first2 == __last2) <=> true;
    }

  template<typename _InputIter1, typename _InputIter2>
    constexpr auto
    lexicographical_compare_three_way(_InputIter1 __first1,
          _InputIter1 __last1,
          _InputIter2 __first2,
          _InputIter2 __last2)
    {
      return std::
 lexicographical_compare_three_way(__first1, __last1, __first2, __last2,
       compare_three_way{});
    }


  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    constexpr
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __binary_pred(__first1, __first2))
 {
   ++__first1;
   ++__first2;
 }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1934 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    [[__nodiscard__]] constexpr
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {

     
     
     


      ;

      return std::__mismatch(__first1, __last1, __first2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1968 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    [[__nodiscard__]] constexpr
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      return std::__mismatch(__first1, __last1, __first2,
 __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }


  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    constexpr
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __first2 != __last2
      && __binary_pred(__first1, __first2))
 {
   ++__first1;
   ++__first2;
 }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 2016 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    [[__nodiscard__]] constexpr
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 2052 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    [[__nodiscard__]] constexpr
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _BinaryPredicate __binary_pred)
    {

     
     
      ;
      ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }





  template<typename _InputIterator, typename _Predicate>
    constexpr
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
       _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !__pred(__first))
 ++__first;
      return __first;
    }


  template<typename _RandomAccessIterator, typename _Predicate>
    constexpr
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (__pred(__first))
     return __first;
   ++__first;

 case 2:
   if (__pred(__first))
     return __first;
   ++__first;

 case 1:
   if (__pred(__first))
     return __first;
   ++__first;

 case 0:
 default:
   return __last;
 }
    }

  template<typename _Iterator, typename _Predicate>
    constexpr
    inline _Iterator
    __find_if(_Iterator __first, _Iterator __last, _Predicate __pred)
    {
      return __find_if(__first, __last, __pred,
         std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Predicate>
    constexpr
    typename iterator_traits<_InputIterator>::difference_type
    __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (__pred(__first))
   ++__n;
      return __n;
    }

  template<typename _ForwardIterator, typename _Predicate>
    constexpr
    _ForwardIterator
    __remove_if(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred)
    {
      __first = std::__find_if(__first, __last, __pred);
      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for (; __first != __last; ++__first)
 if (!__pred(__first))
   {
     *__result = std::move(*__first);
     ++__result;
   }
      return __result;
    }

  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    constexpr
    _ForwardIterator1
    __search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __predicate)
    {

      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
 return std::__find_if(__first1, __last1,
  __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));


      _ForwardIterator1 __current = __first1;

      for (;;)
 {
   __first1 =
     std::__find_if(__first1, __last1,
  __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));

   if (__first1 == __last1)
     return __last1;

   _ForwardIterator2 __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (__predicate(__current, __p))
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    constexpr
    bool
    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {


      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!__pred(__first1, __first2))
   break;

      if (__first1 == __last1)
 return true;



      _ForwardIterator2 __last2 = __first2;
      std::advance(__last2, std::distance(__first1, __last1));
      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
 {
   if (__scan != std::__find_if(__first1, __scan,
     __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
     continue;

   auto __matches
     = std::__count_if(__first2, __last2,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
   if (0 == __matches ||
       std::__count_if(__scan, __last1,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
       != __matches)
     return false;
 }
      return true;
    }
# 2276 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    constexpr
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2)
    {

     
     
     


      ;

      return std::__is_permutation(__first1, __last1, __first2,
       __gnu_cxx::__ops::__iter_equal_to_iter());
    }



# 2318 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    constexpr
    inline _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _BinaryPredicate __predicate)
    {

     
     
     


      ;
      ;

      return std::__search(__first1, __last1, __first2, __last2,
      __gnu_cxx::__ops::__iter_comp_iter(__predicate));
    }



}
# 37 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/hashtable_policy.h" 2 3

# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/ext/aligned_buffer.h" 1 3
# 32 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/ext/aligned_buffer.h" 3
       
# 33 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/ext/aligned_buffer.h" 3







namespace __gnu_cxx
{




  template<typename _Tp>
    struct __aligned_membuf
    {





      struct _Tp2 { _Tp _M_t; };

      alignas(__alignof__(_Tp2::_M_t)) unsigned char _M_storage[sizeof(_Tp)];

      __aligned_membuf() = default;


      __aligned_membuf(std::nullptr_t) { }

      void*
      _M_addr() noexcept
      { return static_cast<void*>(&_M_storage); }

      const void*
      _M_addr() const noexcept
      { return static_cast<const void*>(&_M_storage); }

      _Tp*
      _M_ptr() noexcept
      { return static_cast<_Tp*>(_M_addr()); }

      const _Tp*
      _M_ptr() const noexcept
      { return static_cast<const _Tp*>(_M_addr()); }
    };





#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"





  template<typename _Tp>
    struct __aligned_buffer
    : std::aligned_storage<sizeof(_Tp), __alignof__(_Tp)>
    {
      typename
 std::aligned_storage<sizeof(_Tp), __alignof__(_Tp)>::type _M_storage;

      __aligned_buffer() = default;


      __aligned_buffer(std::nullptr_t) { }

      void*
      _M_addr() noexcept
      {
        return static_cast<void*>(&_M_storage);
      }

      const void*
      _M_addr() const noexcept
      {
        return static_cast<const void*>(&_M_storage);
      }

      _Tp*
      _M_ptr() noexcept
      { return static_cast<_Tp*>(_M_addr()); }

      const _Tp*
      _M_ptr() const noexcept
      { return static_cast<const _Tp*>(_M_addr()); }
    };
#pragma GCC diagnostic pop


}
# 39 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/hashtable_policy.h" 2 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/ext/alloc_traits.h" 1 3
# 32 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/ext/alloc_traits.h" 3
       
# 33 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/ext/alloc_traits.h" 3

# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/alloc_traits.h" 1 3
# 34 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/alloc_traits.h" 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/memoryfwd.h" 1 3
# 46 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/memoryfwd.h" 3
       
# 47 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/memoryfwd.h" 3



namespace std
{

# 64 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/memoryfwd.h" 3
  template<typename>
    class allocator;

  template<>
    class allocator<void>;



  template<typename, typename>
    struct uses_allocator;

  template<typename>
    struct allocator_traits;





}
# 35 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/alloc_traits.h" 2 3




# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/allocator.h" 1 3
# 46 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/allocator.h" 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/x86_64-w64-mingw32/bits/c++allocator.h" 1 3
# 33 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/x86_64-w64-mingw32/bits/c++allocator.h" 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/new_allocator.h" 1 3
# 41 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/new_allocator.h" 3
namespace std
{

# 62 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/new_allocator.h" 3
  template<typename _Tp>
    class __new_allocator
    {
    public:
      typedef _Tp value_type;
      typedef std::size_t size_type;
      typedef std::ptrdiff_t difference_type;
# 83 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/new_allocator.h" 3
      typedef std::true_type propagate_on_container_move_assignment;


      __attribute__((__always_inline__))
      constexpr
      __new_allocator() noexcept { }

      __attribute__((__always_inline__))
      constexpr
      __new_allocator(const __new_allocator&) noexcept { }

      template<typename _Tp1>
 __attribute__((__always_inline__))
 constexpr
 __new_allocator(const __new_allocator<_Tp1>&) noexcept { }


      __new_allocator& operator=(const __new_allocator&) = default;
# 125 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/new_allocator.h" 3
      [[__nodiscard__]] _Tp*
      allocate(size_type __n, const void* = static_cast<const void*>(0))
      {



 static_assert(sizeof(_Tp) != 0, "cannot allocate incomplete types");


 if (__builtin_expect(__n > this->_M_max_size(), false))
   {


     if (__n > (std::size_t(-1) / sizeof(_Tp)))
       std::__throw_bad_array_new_length();
     std::__throw_bad_alloc();
   }


 if (alignof(_Tp) > 16)
   {
     std::align_val_t __al = std::align_val_t(alignof(_Tp));
     return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp),
          __al));
   }

 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(_Tp* __p, size_type __n __attribute__ ((__unused__)))
      {







 if (alignof(_Tp) > 16)
   {
     ::operator delete((__p), (__n) * sizeof(_Tp),
         std::align_val_t(alignof(_Tp)));
     return;
   }

 ::operator delete((__p), (__n) * sizeof(_Tp));
      }
# 213 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/new_allocator.h" 3
      template<typename _Up>
 friend __attribute__((__always_inline__)) constexpr bool
 operator==(const __new_allocator&, const __new_allocator<_Up>&)
 noexcept
 { return true; }
# 227 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/new_allocator.h" 3
    private:
      __attribute__((__always_inline__))
      constexpr size_type
      _M_max_size() const noexcept
      {

 return std::size_t(0x7fffffffffffffffLL) / sizeof(_Tp);



      }
    };


}
# 34 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/x86_64-w64-mingw32/bits/c++allocator.h" 2 3


namespace std
{
# 46 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/x86_64-w64-mingw32/bits/c++allocator.h" 3
  template<typename _Tp>
    using __allocator_base = __new_allocator<_Tp>;
}
# 47 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/allocator.h" 2 3





namespace std
{

# 72 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/allocator.h" 3
  template<>
    class allocator<void>
    {
    public:
      typedef void value_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
# 93 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/allocator.h" 3
      using propagate_on_container_move_assignment = true_type;

      using is_always_equal
 __attribute__ ((__deprecated__ ("use '" "std::allocator_traits::is_always_equal" "' instead")))
 = true_type;




      allocator() = default;
      ~allocator() = default;

      template<typename _Up>
 __attribute__((__always_inline__))
 constexpr
 allocator(const allocator<_Up>&) noexcept { }






    };
# 127 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/allocator.h" 3
  template<typename _Tp>
    class allocator : public __allocator_base<_Tp>
    {
    public:
      typedef _Tp value_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
# 150 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/allocator.h" 3
      using propagate_on_container_move_assignment = true_type;

      using is_always_equal
 __attribute__ ((__deprecated__ ("use '" "std::allocator_traits::is_always_equal" "' instead")))
 = true_type;




      __attribute__((__always_inline__))
      constexpr
      allocator() noexcept { }

      __attribute__((__always_inline__))
      constexpr
      allocator(const allocator& __a) noexcept
      : __allocator_base<_Tp>(__a) { }



      allocator& operator=(const allocator&) = default;


      template<typename _Tp1>
 __attribute__((__always_inline__))
 constexpr
 allocator(const allocator<_Tp1>&) noexcept { }

      __attribute__((__always_inline__))

      constexpr

      ~allocator() noexcept { }


      [[nodiscard,__gnu__::__always_inline__]]
      constexpr _Tp*
      allocate(size_t __n)
      {
 if (std::__is_constant_evaluated())
   {
     if (__builtin_mul_overflow(__n, sizeof(_Tp), &__n))
       std::__throw_bad_array_new_length();
     return static_cast<_Tp*>(::operator new(__n));
   }

 return __allocator_base<_Tp>::allocate(__n, 0);
      }

      [[__gnu__::__always_inline__]]
      constexpr void
      deallocate(_Tp* __p, size_t __n)
      {
 if (std::__is_constant_evaluated())
   {
     ::operator delete(__p);
     return;
   }
 __allocator_base<_Tp>::deallocate(__p, __n);
      }


      friend __attribute__((__always_inline__)) constexpr
      bool
      operator==(const allocator&, const allocator&) noexcept
      { return true; }
# 225 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/allocator.h" 3
    };






  template<typename _T1, typename _T2>
    __attribute__((__always_inline__))
    inline constexpr bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    noexcept
    { return true; }
# 252 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/allocator.h" 3
  template<typename _Tp>
    class allocator<const _Tp>
    {
    public:
      typedef _Tp value_type;
      allocator() { }
      template<typename _Up> allocator(const allocator<_Up>&) { }
    };

  template<typename _Tp>
    class allocator<volatile _Tp>
    {
    public:
      typedef _Tp value_type;
      allocator() { }
      template<typename _Up> allocator(const allocator<_Up>&) { }
    };

  template<typename _Tp>
    class allocator<const volatile _Tp>
    {
    public:
      typedef _Tp value_type;
      allocator() { }
      template<typename _Up> allocator(const allocator<_Up>&) { }
    };







  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






}
# 40 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/alloc_traits.h" 2 3






namespace std
{




  struct __allocator_traits_base
  {
    template<typename _Tp, typename _Up, typename = void>
      struct __rebind : __replace_first_arg<_Tp, _Up>
      {
 static_assert(is_same<
   typename __replace_first_arg<_Tp, typename _Tp::value_type>::type,
   _Tp>::value,
   "allocator_traits<A>::rebind_alloc<A::value_type> must be A");
      };

    template<typename _Tp, typename _Up>
      struct __rebind<_Tp, _Up,
        __void_t<typename _Tp::template rebind<_Up>::other>>
      {
 using type = typename _Tp::template rebind<_Up>::other;

 static_assert(is_same<
   typename _Tp::template rebind<typename _Tp::value_type>::other,
   _Tp>::value,
   "allocator_traits<A>::rebind_alloc<A::value_type> must be A");
      };

  protected:
    template<typename _Tp>
      using __pointer = typename _Tp::pointer;
    template<typename _Tp>
      using __c_pointer = typename _Tp::const_pointer;
    template<typename _Tp>
      using __v_pointer = typename _Tp::void_pointer;
    template<typename _Tp>
      using __cv_pointer = typename _Tp::const_void_pointer;
    template<typename _Tp>
      using __pocca = typename _Tp::propagate_on_container_copy_assignment;
    template<typename _Tp>
      using __pocma = typename _Tp::propagate_on_container_move_assignment;
    template<typename _Tp>
      using __pocs = typename _Tp::propagate_on_container_swap;
    template<typename _Tp>
      using __equal = __type_identity<typename _Tp::is_always_equal>;
  };

  template<typename _Alloc, typename _Up>
    using __alloc_rebind
      = typename __allocator_traits_base::template __rebind<_Alloc, _Up>::type;
# 105 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/alloc_traits.h" 3
  template<typename _Alloc>
    struct allocator_traits : __allocator_traits_base
    {

      typedef _Alloc allocator_type;

      typedef typename _Alloc::value_type value_type;






      using pointer = __detected_or_t<value_type*, __pointer, _Alloc>;

    private:

      template<template<typename> class _Func, typename _Tp, typename = void>
 struct _Ptr
 {
   using type = typename pointer_traits<pointer>::template rebind<_Tp>;
 };

      template<template<typename> class _Func, typename _Tp>
 struct _Ptr<_Func, _Tp, __void_t<_Func<_Alloc>>>
 {
   using type = _Func<_Alloc>;
 };


      template<typename _A2, typename _PtrT, typename = void>
 struct _Diff
 { using type = typename pointer_traits<_PtrT>::difference_type; };

      template<typename _A2, typename _PtrT>
 struct _Diff<_A2, _PtrT, __void_t<typename _A2::difference_type>>
 { using type = typename _A2::difference_type; };


      template<typename _A2, typename _DiffT, typename = void>
 struct _Size : make_unsigned<_DiffT> { };

      template<typename _A2, typename _DiffT>
 struct _Size<_A2, _DiffT, __void_t<typename _A2::size_type>>
 { using type = typename _A2::size_type; };

    public:






      using const_pointer = typename _Ptr<__c_pointer, const value_type>::type;







      using void_pointer = typename _Ptr<__v_pointer, void>::type;







      using const_void_pointer = typename _Ptr<__cv_pointer, const void>::type;







      using difference_type = typename _Diff<_Alloc, pointer>::type;







      using size_type = typename _Size<_Alloc, difference_type>::type;







      using propagate_on_container_copy_assignment
 = __detected_or_t<false_type, __pocca, _Alloc>;







      using propagate_on_container_move_assignment
 = __detected_or_t<false_type, __pocma, _Alloc>;







      using propagate_on_container_swap
 = __detected_or_t<false_type, __pocs, _Alloc>;







      using is_always_equal
 = typename __detected_or_t<is_empty<_Alloc>, __equal, _Alloc>::type;

      template<typename _Tp>
 using rebind_alloc = __alloc_rebind<_Alloc, _Tp>;
      template<typename _Tp>
 using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;

    private:
      template<typename _Alloc2>
 static constexpr auto
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint, int)
 -> decltype(__a.allocate(__n, __hint))
 { return __a.allocate(__n, __hint); }

      template<typename _Alloc2>
 static constexpr pointer
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer, ...)
 { return __a.allocate(__n); }

      template<typename _Tp, typename... _Args>
 struct __construct_helper
 {
   template<typename _Alloc2,
     typename = decltype(std::declval<_Alloc2*>()->construct(
    std::declval<_Tp*>(), std::declval<_Args>()...))>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   using type = decltype(__test<_Alloc>(0));
 };

      template<typename _Tp, typename... _Args>
 using __has_construct
   = typename __construct_helper<_Tp, _Args...>::type;

      template<typename _Tp, typename... _Args>
 static constexpr _Require<__has_construct<_Tp, _Args...>>
 _S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 noexcept(noexcept(__a.construct(__p, std::forward<_Args>(__args)...)))
 { __a.construct(__p, std::forward<_Args>(__args)...); }

      template<typename _Tp, typename... _Args>
 static constexpr
 _Require<__and_<__not_<__has_construct<_Tp, _Args...>>,
          is_constructible<_Tp, _Args...>>>
 _S_construct(_Alloc&, _Tp* __p, _Args&&... __args)
 noexcept(std::is_nothrow_constructible<_Tp, _Args...>::value)
 {



   std::construct_at(__p, std::forward<_Args>(__args)...);

 }

      template<typename _Alloc2, typename _Tp>
 static constexpr auto
 _S_destroy(_Alloc2& __a, _Tp* __p, int)
 noexcept(noexcept(__a.destroy(__p)))
 -> decltype(__a.destroy(__p))
 { __a.destroy(__p); }

      template<typename _Alloc2, typename _Tp>
 static constexpr void
 _S_destroy(_Alloc2&, _Tp* __p, ...)
 noexcept(std::is_nothrow_destructible<_Tp>::value)
 { std::_Destroy(__p); }

      template<typename _Alloc2>
 static constexpr auto
 _S_max_size(_Alloc2& __a, int)
 -> decltype(__a.max_size())
 { return __a.max_size(); }

      template<typename _Alloc2>
 static constexpr size_type
 _S_max_size(_Alloc2&, ...)
 {


   return __gnu_cxx::__numeric_traits<size_type>::__max
     / sizeof(value_type);
 }

      template<typename _Alloc2>
 static constexpr auto
 _S_select(_Alloc2& __a, int)
 -> decltype(__a.select_on_container_copy_construction())
 { return __a.select_on_container_copy_construction(); }

      template<typename _Alloc2>
 static constexpr _Alloc2
 _S_select(_Alloc2& __a, ...)
 { return __a; }

    public:
# 332 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/alloc_traits.h" 3
      [[__nodiscard__]] static constexpr pointer
      allocate(_Alloc& __a, size_type __n)
      { return __a.allocate(__n); }
# 347 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/alloc_traits.h" 3
      [[__nodiscard__]] static constexpr pointer
      allocate(_Alloc& __a, size_type __n, const_void_pointer __hint)
      { return _S_allocate(__a, __n, __hint, 0); }
# 359 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/alloc_traits.h" 3
      static constexpr void
      deallocate(_Alloc& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 374 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/alloc_traits.h" 3
      template<typename _Tp, typename... _Args>
 static constexpr auto
 construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 noexcept(noexcept(_S_construct(__a, __p,
           std::forward<_Args>(__args)...)))
 -> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...))
 { _S_construct(__a, __p, std::forward<_Args>(__args)...); }
# 390 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/alloc_traits.h" 3
      template<typename _Tp>
 static constexpr void
 destroy(_Alloc& __a, _Tp* __p)
 noexcept(noexcept(_S_destroy(__a, __p, 0)))
 { _S_destroy(__a, __p, 0); }
# 404 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/alloc_traits.h" 3
      static constexpr size_type
      max_size(const _Alloc& __a) noexcept
      { return _S_max_size(__a, 0); }
# 416 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/alloc_traits.h" 3
      static constexpr _Alloc
      select_on_container_copy_construction(const _Alloc& __rhs)
      { return _S_select(__rhs, 0); }
    };



  template<typename _Tp>
    struct allocator_traits<allocator<_Tp>>
    {

      using allocator_type = allocator<_Tp>;


      using value_type = _Tp;


      using pointer = _Tp*;


      using const_pointer = const _Tp*;


      using void_pointer = void*;


      using const_void_pointer = const void*;


      using difference_type = std::ptrdiff_t;


      using size_type = std::size_t;


      using propagate_on_container_copy_assignment = false_type;


      using propagate_on_container_move_assignment = true_type;


      using propagate_on_container_swap = false_type;


      using is_always_equal = true_type;

      template<typename _Up>
 using rebind_alloc = allocator<_Up>;

      template<typename _Up>
 using rebind_traits = allocator_traits<allocator<_Up>>;
# 475 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/alloc_traits.h" 3
      [[__nodiscard__,__gnu__::__always_inline__]]
      static constexpr pointer
      allocate(allocator_type& __a, size_type __n)
      { return __a.allocate(__n); }
# 490 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/alloc_traits.h" 3
      [[__nodiscard__,__gnu__::__always_inline__]]
      static constexpr pointer
      allocate(allocator_type& __a, size_type __n,
        [[maybe_unused]] const_void_pointer __hint)
      {



 return __a.allocate(__n);

      }
# 510 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/alloc_traits.h" 3
      [[__gnu__::__always_inline__]]
      static constexpr void
      deallocate(allocator_type& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 526 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/alloc_traits.h" 3
      template<typename _Up, typename... _Args>
 [[__gnu__::__always_inline__]]
 static constexpr void
 construct(allocator_type& __a __attribute__((__unused__)), _Up* __p,
    _Args&&... __args)
 noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
 {



   std::construct_at(__p, std::forward<_Args>(__args)...);

 }
# 547 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/alloc_traits.h" 3
      template<typename _Up>
 [[__gnu__::__always_inline__]]
 static constexpr void
 destroy(allocator_type& __a __attribute__((__unused__)), _Up* __p)
 noexcept(is_nothrow_destructible<_Up>::value)
 {



   std::destroy_at(__p);

 }






      [[__gnu__::__always_inline__]]
      static constexpr size_type
      max_size(const allocator_type& __a __attribute__((__unused__))) noexcept
      {



 return size_t(-1) / sizeof(value_type);

      }






      [[__gnu__::__always_inline__]]
      static constexpr allocator_type
      select_on_container_copy_construction(const allocator_type& __rhs)
      { return __rhs; }
    };


  template<>
    struct allocator_traits<allocator<void>>
    {

      using allocator_type = allocator<void>;


      using value_type = void;


      using pointer = void*;


      using const_pointer = const void*;


      using void_pointer = void*;


      using const_void_pointer = const void*;


      using difference_type = std::ptrdiff_t;


      using size_type = std::size_t;


      using propagate_on_container_copy_assignment = false_type;


      using propagate_on_container_move_assignment = true_type;


      using propagate_on_container_swap = false_type;


      using is_always_equal = true_type;

      template<typename _Up>
 using rebind_alloc = allocator<_Up>;

      template<typename _Up>
 using rebind_traits = allocator_traits<allocator<_Up>>;


      static void*
      allocate(allocator_type&, size_type, const void* = nullptr) = delete;


      static void
      deallocate(allocator_type&, void*, size_type) = delete;
# 652 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/alloc_traits.h" 3
      template<typename _Up, typename... _Args>
 [[__gnu__::__always_inline__]]
 static constexpr void
 construct(allocator_type&, _Up* __p, _Args&&... __args)
 noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
 { std::_Construct(__p, std::forward<_Args>(__args)...); }
# 666 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/alloc_traits.h" 3
      template<typename _Up>
 [[__gnu__::__always_inline__]]
 static constexpr void
 destroy(allocator_type&, _Up* __p)
 noexcept(is_nothrow_destructible<_Up>::value)
 { std::_Destroy(__p); }


      static size_type
      max_size(const allocator_type&) = delete;






      [[__gnu__::__always_inline__]]
      static constexpr allocator_type
      select_on_container_copy_construction(const allocator_type& __rhs)
      { return __rhs; }
    };
# 704 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/alloc_traits.h" 3
  template<typename _Alloc>
    [[__gnu__::__always_inline__]]
    constexpr inline void
    __alloc_on_copy(_Alloc& __one, const _Alloc& __two)
    {
      using __traits = allocator_traits<_Alloc>;
      using __pocca =
 typename __traits::propagate_on_container_copy_assignment::type;

      if constexpr (__pocca::value)
 __one = __two;



    }

  template<typename _Alloc>
    [[__gnu__::__always_inline__]]
    constexpr _Alloc
    __alloc_on_copy(const _Alloc& __a)
    {
      typedef allocator_traits<_Alloc> __traits;
      return __traits::select_on_container_copy_construction(__a);
    }
# 741 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/alloc_traits.h" 3
  template<typename _Alloc>
    [[__gnu__::__always_inline__]]
    constexpr inline void
    __alloc_on_move(_Alloc& __one, _Alloc& __two)
    {
      using __traits = allocator_traits<_Alloc>;
      using __pocma
 = typename __traits::propagate_on_container_move_assignment::type;

      if constexpr (__pocma::value)
 __one = std::move(__two);



    }
# 772 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/alloc_traits.h" 3
  template<typename _Alloc>
    [[__gnu__::__always_inline__]]
    constexpr inline void
    __alloc_on_swap(_Alloc& __one, _Alloc& __two)
    {
      using __traits = allocator_traits<_Alloc>;
      using __pocs = typename __traits::propagate_on_container_swap::type;

      if constexpr (__pocs::value)
 {
   using std::swap;
   swap(__one, __two);
 }



    }

  template<typename _Alloc, typename _Tp,
    typename _ValueT = __remove_cvref_t<typename _Alloc::value_type>,
    typename = void>
    struct __is_alloc_insertable_impl
    : false_type
    { };

  template<typename _Alloc, typename _Tp, typename _ValueT>
    struct __is_alloc_insertable_impl<_Alloc, _Tp, _ValueT,
      __void_t<decltype(allocator_traits<_Alloc>::construct(
     std::declval<_Alloc&>(), std::declval<_ValueT*>(),
     std::declval<_Tp>()))>>
    : true_type
    { };




  template<typename _Alloc>
    struct __is_copy_insertable
    : __is_alloc_insertable_impl<_Alloc,
     typename _Alloc::value_type const&>::type
    { };



  template<typename _Tp>
    struct __is_copy_insertable<allocator<_Tp>>
    : is_copy_constructible<_Tp>
    { };





  template<typename _Alloc>
    struct __is_move_insertable
    : __is_alloc_insertable_impl<_Alloc, typename _Alloc::value_type>::type
    { };



  template<typename _Tp>
    struct __is_move_insertable<allocator<_Tp>>
    : is_move_constructible<_Tp>
    { };



  template<typename _Alloc, typename = void>
    struct __is_allocator : false_type { };

  template<typename _Alloc>
    struct __is_allocator<_Alloc,
      __void_t<typename _Alloc::value_type,
        decltype(std::declval<_Alloc&>().allocate(size_t{}))>>
    : true_type { };

  template<typename _Alloc>
    using _RequireAllocator
      = typename enable_if<__is_allocator<_Alloc>::value, _Alloc>::type;

  template<typename _Alloc>
    using _RequireNotAllocator
      = typename enable_if<!__is_allocator<_Alloc>::value, _Alloc>::type;


  template<typename _Alloc>
    concept __allocator_like = requires (_Alloc& __a) {
      typename _Alloc::value_type;
      __a.deallocate(__a.allocate(1u), 1u);
    };







  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) noexcept { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two) noexcept
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Tp, bool
    = __or_<is_copy_constructible<typename _Tp::value_type>,
            is_nothrow_move_constructible<typename _Tp::value_type>>::value>
    struct __shrink_to_fit_aux
    { static bool _S_do_it(_Tp&) noexcept { return false; } };

  template<typename _Tp>
    struct __shrink_to_fit_aux<_Tp, true>
    {
      constexpr
      static bool
      _S_do_it(_Tp& __c) noexcept
      {

 try
   {
     _Tp(__make_move_if_noexcept_iterator(__c.begin()),
  __make_move_if_noexcept_iterator(__c.end()),
  __c.get_allocator()).swap(__c);
     return true;
   }
 catch(...)
   { return false; }



      }
    };
# 922 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/alloc_traits.h" 3
  template<typename _ForwardIterator, typename _Allocator>
    constexpr
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator& __alloc)
    {
      for (; __first != __last; ++__first)



 allocator_traits<_Allocator>::destroy(__alloc,
           std::__addressof(*__first));

    }


  template<typename _ForwardIterator, typename _Tp>
    __attribute__((__always_inline__)) constexpr
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>&)
    {
      std::_Destroy(__first, __last);
    }




}
# 35 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/ext/alloc_traits.h" 2 3

namespace __gnu_cxx
{






template<typename _Alloc, typename = typename _Alloc::value_type>
  struct __alloc_traits

  : std::allocator_traits<_Alloc>

  {
    typedef _Alloc allocator_type;

    typedef std::allocator_traits<_Alloc> _Base_type;
    typedef typename _Base_type::value_type value_type;
    typedef typename _Base_type::pointer pointer;
    typedef typename _Base_type::const_pointer const_pointer;
    typedef typename _Base_type::size_type size_type;
    typedef typename _Base_type::difference_type difference_type;

    typedef value_type& reference;
    typedef const value_type& const_reference;
    using _Base_type::allocate;
    using _Base_type::deallocate;
    using _Base_type::construct;
    using _Base_type::destroy;
    using _Base_type::max_size;

  private:
    template<typename _Ptr>
      using __is_custom_pointer
 = std::__and_<std::is_same<pointer, _Ptr>,
        std::__not_<std::is_pointer<_Ptr>>>;

  public:

    template<typename _Ptr, typename... _Args>
      [[__gnu__::__always_inline__]]
      static constexpr
      std::__enable_if_t<__is_custom_pointer<_Ptr>::value>
      construct(_Alloc& __a, _Ptr __p, _Args&&... __args)
      noexcept(noexcept(_Base_type::construct(__a, std::__to_address(__p),
           std::forward<_Args>(__args)...)))
      {
 _Base_type::construct(__a, std::__to_address(__p),
         std::forward<_Args>(__args)...);
      }


    template<typename _Ptr>
      [[__gnu__::__always_inline__]]
      static constexpr
      std::__enable_if_t<__is_custom_pointer<_Ptr>::value>
      destroy(_Alloc& __a, _Ptr __p)
      noexcept(noexcept(_Base_type::destroy(__a, std::__to_address(__p))))
      { _Base_type::destroy(__a, std::__to_address(__p)); }

    [[__gnu__::__always_inline__]]
    static constexpr _Alloc _S_select_on_copy(const _Alloc& __a)
    { return _Base_type::select_on_container_copy_construction(__a); }

    [[__gnu__::__always_inline__]]
    static constexpr void _S_on_swap(_Alloc& __a, _Alloc& __b)
    { std::__alloc_on_swap(__a, __b); }

    [[__gnu__::__always_inline__]]
    static constexpr bool _S_propagate_on_copy_assign()
    { return _Base_type::propagate_on_container_copy_assignment::value; }

    [[__gnu__::__always_inline__]]
    static constexpr bool _S_propagate_on_move_assign()
    { return _Base_type::propagate_on_container_move_assignment::value; }

    [[__gnu__::__always_inline__]]
    static constexpr bool _S_propagate_on_swap()
    { return _Base_type::propagate_on_container_swap::value; }

    [[__gnu__::__always_inline__]]
    static constexpr bool _S_always_equal()
    { return _Base_type::is_always_equal::value; }

    __attribute__((__always_inline__))
    static constexpr bool _S_nothrow_move()
    { return _S_propagate_on_move_assign() || _S_always_equal(); }

    template<typename _Tp>
      struct rebind
      { typedef typename _Base_type::template rebind_alloc<_Tp> other; };
# 180 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/ext/alloc_traits.h" 3
  };


}
# 40 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/hashtable_policy.h" 2 3


namespace std
{



  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    class _Hashtable;

namespace __detail
{





  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _Equal, typename _Hash, typename _RangeHash,
    typename _Unused, typename _Traits>
    struct _Hashtable_base;



  template<typename _Iterator>
    inline typename std::iterator_traits<_Iterator>::difference_type
    __distance_fw(_Iterator __first, _Iterator __last,
    std::input_iterator_tag)
    { return __first != __last ? 1 : 0; }

  template<typename _Iterator>
    inline typename std::iterator_traits<_Iterator>::difference_type
    __distance_fw(_Iterator __first, _Iterator __last,
    std::forward_iterator_tag)
    { return std::distance(__first, __last); }

  template<typename _Iterator>
    inline typename std::iterator_traits<_Iterator>::difference_type
    __distance_fw(_Iterator __first, _Iterator __last)
    { return __distance_fw(__first, __last,
      std::__iterator_category(__first)); }

  struct _Identity
  {
    template<typename _Tp>
      _Tp&&
      operator()(_Tp&& __x) const noexcept
      { return std::forward<_Tp>(__x); }
  };

  struct _Select1st
  {
    template<typename _Pair>
      struct __1st_type;

    template<typename _Tp, typename _Up>
      struct __1st_type<pair<_Tp, _Up>>
      { using type = _Tp; };

    template<typename _Tp, typename _Up>
      struct __1st_type<const pair<_Tp, _Up>>
      { using type = const _Tp; };

    template<typename _Pair>
      struct __1st_type<_Pair&>
      { using type = typename __1st_type<_Pair>::type&; };

    template<typename _Tp>
      typename __1st_type<_Tp>::type&&
      operator()(_Tp&& __x) const noexcept
      { return std::forward<_Tp>(__x).first; }
  };

  template<typename _ExKey, typename _Value>
    struct _ConvertToValueType;

  template<typename _Value>
    struct _ConvertToValueType<_Identity, _Value>
    {
      template<typename _Kt>
 constexpr _Kt&&
 operator()(_Kt&& __k) const noexcept
 { return std::forward<_Kt>(__k); }
    };

  template<typename _Value>
    struct _ConvertToValueType<_Select1st, _Value>
    {
      constexpr _Value&&
      operator()(_Value&& __x) const noexcept
      { return std::move(__x); }

      constexpr const _Value&
      operator()(const _Value& __x) const noexcept
      { return __x; }

      template<typename _Kt, typename _Val>
 constexpr std::pair<_Kt, _Val>&&
 operator()(std::pair<_Kt, _Val>&& __x) const noexcept
 { return std::move(__x); }

      template<typename _Kt, typename _Val>
 constexpr const std::pair<_Kt, _Val>&
 operator()(const std::pair<_Kt, _Val>& __x) const noexcept
 { return __x; }
    };

  template<typename _ExKey>
    struct _NodeBuilder;

  template<>
    struct _NodeBuilder<_Select1st>
    {
      template<typename _Kt, typename _Arg, typename _NodeGenerator>
 static auto
 _S_build(_Kt&& __k, _Arg&& __arg, const _NodeGenerator& __node_gen)
 -> typename _NodeGenerator::__node_ptr
 {
   return __node_gen(std::forward<_Kt>(__k),
       std::forward<_Arg>(__arg).second);
 }
    };

  template<>
    struct _NodeBuilder<_Identity>
    {
      template<typename _Kt, typename _Arg, typename _NodeGenerator>
 static auto
 _S_build(_Kt&& __k, _Arg&&, const _NodeGenerator& __node_gen)
 -> typename _NodeGenerator::__node_ptr
 { return __node_gen(std::forward<_Kt>(__k)); }
    };

  template<typename _HashtableAlloc, typename _NodePtr>
    struct _NodePtrGuard
    {
      _HashtableAlloc& _M_h;
      _NodePtr _M_ptr;

      ~_NodePtrGuard()
      {
 if (_M_ptr)
   _M_h._M_deallocate_node_ptr(_M_ptr);
      }
    };

  template<typename _NodeAlloc>
    struct _Hashtable_alloc;



  template<typename _NodeAlloc>
    struct _ReuseOrAllocNode
    {
    private:
      using __node_alloc_type = _NodeAlloc;
      using __hashtable_alloc = _Hashtable_alloc<__node_alloc_type>;
      using __node_alloc_traits =
 typename __hashtable_alloc::__node_alloc_traits;

    public:
      using __node_ptr = typename __hashtable_alloc::__node_ptr;

      _ReuseOrAllocNode(__node_ptr __nodes, __hashtable_alloc& __h)
      : _M_nodes(__nodes), _M_h(__h) { }
      _ReuseOrAllocNode(const _ReuseOrAllocNode&) = delete;

      ~_ReuseOrAllocNode()
      { _M_h._M_deallocate_nodes(_M_nodes); }

      template<typename... _Args>
 __node_ptr
 operator()(_Args&&... __args) const
 {
   if (!_M_nodes)
     return _M_h._M_allocate_node(std::forward<_Args>(__args)...);

   __node_ptr __node = _M_nodes;
   _M_nodes = _M_nodes->_M_next();
   __node->_M_nxt = nullptr;
   auto& __a = _M_h._M_node_allocator();
   __node_alloc_traits::destroy(__a, __node->_M_valptr());
   _NodePtrGuard<__hashtable_alloc, __node_ptr> __guard { _M_h, __node };
   __node_alloc_traits::construct(__a, __node->_M_valptr(),
      std::forward<_Args>(__args)...);
   __guard._M_ptr = nullptr;
   return __node;
 }

    private:
      mutable __node_ptr _M_nodes;
      __hashtable_alloc& _M_h;
    };



  template<typename _NodeAlloc>
    struct _AllocNode
    {
    private:
      using __hashtable_alloc = _Hashtable_alloc<_NodeAlloc>;

    public:
      using __node_ptr = typename __hashtable_alloc::__node_ptr;

      _AllocNode(__hashtable_alloc& __h)
      : _M_h(__h) { }

      template<typename... _Args>
 __node_ptr
 operator()(_Args&&... __args) const
 { return _M_h._M_allocate_node(std::forward<_Args>(__args)...); }

    private:
      __hashtable_alloc& _M_h;
    };
# 285 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/hashtable_policy.h" 3
  template<bool _Cache_hash_code, bool _Constant_iterators, bool _Unique_keys>
    struct _Hashtable_traits
    {
      using __hash_cached = __bool_constant<_Cache_hash_code>;
      using __constant_iterators = __bool_constant<_Constant_iterators>;
      using __unique_keys = __bool_constant<_Unique_keys>;
    };







  template<typename _Hash>
    struct _Hashtable_hash_traits
    {
      static constexpr std::size_t
      __small_size_threshold() noexcept
      { return std::__is_fast_hash<_Hash>::value ? 0 : 20; }
    };
# 315 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/hashtable_policy.h" 3
  struct _Hash_node_base
  {
    _Hash_node_base* _M_nxt;

    _Hash_node_base() noexcept : _M_nxt() { }

    _Hash_node_base(_Hash_node_base* __next) noexcept : _M_nxt(__next) { }
  };






  template<typename _Value>
    struct _Hash_node_value_base
    {
      typedef _Value value_type;

      __gnu_cxx::__aligned_buffer<_Value> _M_storage;

      [[__gnu__::__always_inline__]]
      _Value*
      _M_valptr() noexcept
      { return _M_storage._M_ptr(); }

      [[__gnu__::__always_inline__]]
      const _Value*
      _M_valptr() const noexcept
      { return _M_storage._M_ptr(); }

      [[__gnu__::__always_inline__]]
      _Value&
      _M_v() noexcept
      { return *_M_valptr(); }

      [[__gnu__::__always_inline__]]
      const _Value&
      _M_v() const noexcept
      { return *_M_valptr(); }
    };




  template<bool _Cache_hash_code>
    struct _Hash_node_code_cache
    { };




  template<>
    struct _Hash_node_code_cache<true>
    { std::size_t _M_hash_code; };

  template<typename _Value, bool _Cache_hash_code>
    struct _Hash_node_value
    : _Hash_node_value_base<_Value>
    , _Hash_node_code_cache<_Cache_hash_code>
    { };




  template<typename _Value, bool _Cache_hash_code>
    struct _Hash_node
    : _Hash_node_base
    , _Hash_node_value<_Value, _Cache_hash_code>
    {
      _Hash_node*
      _M_next() const noexcept
      { return static_cast<_Hash_node*>(this->_M_nxt); }
    };


  template<typename _Value, bool _Cache_hash_code>
    struct _Node_iterator_base
    {
      using __node_type = _Hash_node<_Value, _Cache_hash_code>;

      __node_type* _M_cur;

      _Node_iterator_base() : _M_cur(nullptr) { }
      _Node_iterator_base(__node_type* __p) noexcept
      : _M_cur(__p) { }

      void
      _M_incr() noexcept
      { _M_cur = _M_cur->_M_next(); }

      friend bool
      operator==(const _Node_iterator_base& __x, const _Node_iterator_base& __y)
      noexcept
      { return __x._M_cur == __y._M_cur; }







    };


  template<typename _Value, bool __constant_iterators, bool __cache>
    struct _Node_iterator
    : public _Node_iterator_base<_Value, __cache>
    {
    private:
      using __base_type = _Node_iterator_base<_Value, __cache>;
      using __node_type = typename __base_type::__node_type;

    public:
      using value_type = _Value;
      using difference_type = std::ptrdiff_t;
      using iterator_category = std::forward_iterator_tag;

      using pointer = __conditional_t<__constant_iterators,
          const value_type*, value_type*>;

      using reference = __conditional_t<__constant_iterators,
     const value_type&, value_type&>;

      _Node_iterator() = default;

      explicit
      _Node_iterator(__node_type* __p) noexcept
      : __base_type(__p) { }

      reference
      operator*() const noexcept
      { return this->_M_cur->_M_v(); }

      pointer
      operator->() const noexcept
      { return this->_M_cur->_M_valptr(); }

      _Node_iterator&
      operator++() noexcept
      {
 this->_M_incr();
 return *this;
      }

      _Node_iterator
      operator++(int) noexcept
      {
 _Node_iterator __tmp(*this);
 this->_M_incr();
 return __tmp;
      }
    };


  template<typename _Value, bool __constant_iterators, bool __cache>
    struct _Node_const_iterator
    : public _Node_iterator_base<_Value, __cache>
    {
    private:
      using __base_type = _Node_iterator_base<_Value, __cache>;
      using __node_type = typename __base_type::__node_type;

    public:
      typedef _Value value_type;
      typedef std::ptrdiff_t difference_type;
      typedef std::forward_iterator_tag iterator_category;

      typedef const value_type* pointer;
      typedef const value_type& reference;

      _Node_const_iterator() = default;

      explicit
      _Node_const_iterator(__node_type* __p) noexcept
      : __base_type(__p) { }

      _Node_const_iterator(const _Node_iterator<_Value, __constant_iterators,
      __cache>& __x) noexcept
      : __base_type(__x._M_cur) { }

      reference
      operator*() const noexcept
      { return this->_M_cur->_M_v(); }

      pointer
      operator->() const noexcept
      { return this->_M_cur->_M_valptr(); }

      _Node_const_iterator&
      operator++() noexcept
      {
 this->_M_incr();
 return *this;
      }

      _Node_const_iterator
      operator++(int) noexcept
      {
 _Node_const_iterator __tmp(*this);
 this->_M_incr();
 return __tmp;
      }
    };






  struct _Mod_range_hashing
  {
    typedef std::size_t first_argument_type;
    typedef std::size_t second_argument_type;
    typedef std::size_t result_type;

    result_type
    operator()(first_argument_type __num,
        second_argument_type __den) const noexcept
    { return __num % __den; }
  };






  struct _Default_ranged_hash { };



  struct _Prime_rehash_policy
  {
    using __has_load_factor = true_type;

    _Prime_rehash_policy(float __z = 1.0) noexcept
    : _M_max_load_factor(__z), _M_next_resize(0) { }

    float
    max_load_factor() const noexcept
    { return _M_max_load_factor; }


    std::size_t
    _M_next_bkt(std::size_t __n) const;


    std::size_t
    _M_bkt_for_elements(std::size_t __n) const
    { return __builtin_ceil(__n / (double)_M_max_load_factor); }





    std::pair<bool, std::size_t>
    _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt,
     std::size_t __n_ins) const;

    typedef std::size_t _State;

    _State
    _M_state() const
    { return _M_next_resize; }

    void
    _M_reset() noexcept
    { _M_next_resize = 0; }

    void
    _M_reset(_State __state)
    { _M_next_resize = __state; }

    static const std::size_t _S_growth_factor = 2;

    float _M_max_load_factor;
    mutable std::size_t _M_next_resize;
  };


  struct _Mask_range_hashing
  {
    typedef std::size_t first_argument_type;
    typedef std::size_t second_argument_type;
    typedef std::size_t result_type;

    result_type
    operator()(first_argument_type __num,
        second_argument_type __den) const noexcept
    { return __num & (__den - 1); }
  };


  inline std::size_t
  __clp2(std::size_t __n) noexcept
  {
    using __gnu_cxx::__int_traits;

    if (__n < 2)
      return __n;
    const unsigned __lz = sizeof(size_t) > sizeof(long)
      ? __builtin_clzll(__n - 1ull)
      : __builtin_clzl(__n - 1ul);

    return (size_t(1) << (__int_traits<size_t>::__digits - __lz - 1)) << 1;
  }



  struct _Power2_rehash_policy
  {
    using __has_load_factor = true_type;

    _Power2_rehash_policy(float __z = 1.0) noexcept
    : _M_max_load_factor(__z), _M_next_resize(0) { }

    float
    max_load_factor() const noexcept
    { return _M_max_load_factor; }



    std::size_t
    _M_next_bkt(std::size_t __n) noexcept
    {
      if (__n == 0)



 return 1;

      const auto __max_width = std::min<size_t>(sizeof(size_t), 8);
      const auto __max_bkt = size_t(1) << (__max_width * 8 - 1);
      std::size_t __res = __clp2(__n);

      if (__res == 0)
 __res = __max_bkt;
      else if (__res == 1)



 __res = 2;

      if (__res == __max_bkt)



 _M_next_resize = size_t(-1);
      else
 _M_next_resize
   = __builtin_floor(__res * (double)_M_max_load_factor);

      return __res;
    }


    std::size_t
    _M_bkt_for_elements(std::size_t __n) const noexcept
    { return __builtin_ceil(__n / (double)_M_max_load_factor); }





    std::pair<bool, std::size_t>
    _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt,
     std::size_t __n_ins) noexcept
    {
      if (__n_elt + __n_ins > _M_next_resize)
 {



   double __min_bkts
     = std::max<std::size_t>(__n_elt + __n_ins, _M_next_resize ? 0 : 11)
       / (double)_M_max_load_factor;
   if (__min_bkts >= __n_bkt)
     return { true,
       _M_next_bkt(std::max<std::size_t>(__builtin_floor(__min_bkts) + 1,
      __n_bkt * _S_growth_factor)) };

   _M_next_resize
     = __builtin_floor(__n_bkt * (double)_M_max_load_factor);
   return { false, 0 };
 }
      else
 return { false, 0 };
    }

    typedef std::size_t _State;

    _State
    _M_state() const noexcept
    { return _M_next_resize; }

    void
    _M_reset() noexcept
    { _M_next_resize = 0; }

    void
    _M_reset(_State __state) noexcept
    { _M_next_resize = __state; }

    static const std::size_t _S_growth_factor = 2;

    float _M_max_load_factor;
    std::size_t _M_next_resize;
  };

  template<typename _RehashPolicy>
    struct _RehashStateGuard
    {
      _RehashPolicy* _M_guarded_obj;
      typename _RehashPolicy::_State _M_prev_state;

      _RehashStateGuard(_RehashPolicy& __policy)
      : _M_guarded_obj(std::__addressof(__policy))
      , _M_prev_state(__policy._M_state())
      { }
      _RehashStateGuard(const _RehashStateGuard&) = delete;

      ~_RehashStateGuard()
      {
 if (_M_guarded_obj)
   _M_guarded_obj->_M_reset(_M_prev_state);
      }
    };
# 761 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/hashtable_policy.h" 3
  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits,
    bool _Unique_keys = _Traits::__unique_keys::value>
    struct _Map_base { };


  template<typename _Key, typename _Val, typename _Alloc, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    struct _Map_base<_Key, pair<const _Key, _Val>, _Alloc, _Select1st, _Equal,
       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, false>
    {
      using mapped_type = _Val;
    };


  template<typename _Key, typename _Val, typename _Alloc, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    struct _Map_base<_Key, pair<const _Key, _Val>, _Alloc, _Select1st, _Equal,
       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>
    {
    private:
      using __hashtable_base = _Hashtable_base<_Key, pair<const _Key, _Val>,
            _Select1st, _Equal, _Hash,
            _RangeHash, _Unused,
            _Traits>;

      using __hashtable = _Hashtable<_Key, pair<const _Key, _Val>, _Alloc,
         _Select1st, _Equal, _Hash, _RangeHash,
         _Unused, _RehashPolicy, _Traits>;

      using __hash_code = typename __hashtable_base::__hash_code;

    public:
      using key_type = typename __hashtable_base::key_type;
      using mapped_type = _Val;

      mapped_type&
      operator[](const key_type& __k);

      mapped_type&
      operator[](key_type&& __k);



      mapped_type&
      at(const key_type& __k)
      {
 auto __ite = static_cast<__hashtable*>(this)->find(__k);
 if (!__ite._M_cur)
   __throw_out_of_range(("unordered_map::at"));
 return __ite->second;
      }

      const mapped_type&
      at(const key_type& __k) const
      {
 auto __ite = static_cast<const __hashtable*>(this)->find(__k);
 if (!__ite._M_cur)
   __throw_out_of_range(("unordered_map::at"));
 return __ite->second;
      }
    };

  template<typename _Key, typename _Val, typename _Alloc, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    auto
    _Map_base<_Key, pair<const _Key, _Val>, _Alloc, _Select1st, _Equal,
       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>::
    operator[](const key_type& __k)
    -> mapped_type&
    {
      __hashtable* __h = static_cast<__hashtable*>(this);
      __hash_code __code = __h->_M_hash_code(__k);
      std::size_t __bkt = __h->_M_bucket_index(__code);
      if (auto __node = __h->_M_find_node(__bkt, __k, __code))
 return __node->_M_v().second;

      typename __hashtable::_Scoped_node __node {
 __h,
 std::piecewise_construct,
 std::tuple<const key_type&>(__k),
 std::tuple<>()
      };
      auto __pos
 = __h->_M_insert_unique_node(__bkt, __code, __node._M_node);
      __node._M_node = nullptr;
      return __pos->second;
    }

  template<typename _Key, typename _Val, typename _Alloc, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    auto
    _Map_base<_Key, pair<const _Key, _Val>, _Alloc, _Select1st, _Equal,
       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>::
    operator[](key_type&& __k)
    -> mapped_type&
    {
      __hashtable* __h = static_cast<__hashtable*>(this);
      __hash_code __code = __h->_M_hash_code(__k);
      std::size_t __bkt = __h->_M_bucket_index(__code);
      if (auto __node = __h->_M_find_node(__bkt, __k, __code))
 return __node->_M_v().second;

      typename __hashtable::_Scoped_node __node {
 __h,
 std::piecewise_construct,
 std::forward_as_tuple(std::move(__k)),
 std::tuple<>()
      };
      auto __pos
 = __h->_M_insert_unique_node(__bkt, __code, __node._M_node);
      __node._M_node = nullptr;
      return __pos->second;
    }


  template<typename _Key, typename _Val, typename _Alloc, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits, bool __uniq>
    struct _Map_base<const _Key, pair<const _Key, _Val>,
       _Alloc, _Select1st, _Equal, _Hash,
       _RangeHash, _Unused, _RehashPolicy, _Traits, __uniq>
    : _Map_base<_Key, pair<const _Key, _Val>, _Alloc, _Select1st, _Equal, _Hash,
  _RangeHash, _Unused, _RehashPolicy, _Traits, __uniq>
    { };






  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    struct _Insert_base
    {
    protected:
      using __hashtable_base = _Hashtable_base<_Key, _Value, _ExtractKey,
            _Equal, _Hash, _RangeHash,
            _Unused, _Traits>;

      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         _Hash, _RangeHash,
         _Unused, _RehashPolicy, _Traits>;

      using __hash_cached = typename _Traits::__hash_cached;
      using __constant_iterators = typename _Traits::__constant_iterators;

      using __hashtable_alloc = _Hashtable_alloc<
 __alloc_rebind<_Alloc, _Hash_node<_Value,
       __hash_cached::value>>>;

      using value_type = typename __hashtable_base::value_type;
      using size_type = typename __hashtable_base::size_type;

      using __unique_keys = typename _Traits::__unique_keys;
      using __node_alloc_type = typename __hashtable_alloc::__node_alloc_type;
      using __node_gen_type = _AllocNode<__node_alloc_type>;

      __hashtable&
      _M_conjure_hashtable()
      { return *(static_cast<__hashtable*>(this)); }

      template<typename _InputIterator, typename _NodeGetter>
 void
 _M_insert_range(_InputIterator __first, _InputIterator __last,
   const _NodeGetter&, true_type __uks);

      template<typename _InputIterator, typename _NodeGetter>
 void
 _M_insert_range(_InputIterator __first, _InputIterator __last,
   const _NodeGetter&, false_type __uks);

    public:
      using iterator = _Node_iterator<_Value, __constant_iterators::value,
          __hash_cached::value>;

      using const_iterator = _Node_const_iterator<_Value,
        __constant_iterators::value,
        __hash_cached::value>;

      using __ireturn_type = __conditional_t<__unique_keys::value,
          std::pair<iterator, bool>,
          iterator>;

      __ireturn_type
      insert(const value_type& __v)
      {
 __hashtable& __h = _M_conjure_hashtable();
 __node_gen_type __node_gen(__h);
 return __h._M_insert(__v, __node_gen, __unique_keys{});
      }

      iterator
      insert(const_iterator __hint, const value_type& __v)
      {
 __hashtable& __h = _M_conjure_hashtable();
 __node_gen_type __node_gen(__h);
 return __h._M_insert(__hint, __v, __node_gen, __unique_keys{});
      }

      template<typename _KType, typename... _Args>
 std::pair<iterator, bool>
 try_emplace(const_iterator, _KType&& __k, _Args&&... __args)
 {
   __hashtable& __h = _M_conjure_hashtable();
   auto __code = __h._M_hash_code(__k);
   std::size_t __bkt = __h._M_bucket_index(__code);
   if (auto __node = __h._M_find_node(__bkt, __k, __code))
     return { iterator(__node), false };

   typename __hashtable::_Scoped_node __node {
     &__h,
     std::piecewise_construct,
     std::forward_as_tuple(std::forward<_KType>(__k)),
     std::forward_as_tuple(std::forward<_Args>(__args)...)
     };
   auto __it
     = __h._M_insert_unique_node(__bkt, __code, __node._M_node);
   __node._M_node = nullptr;
   return { __it, true };
 }

      void
      insert(initializer_list<value_type> __l)
      { this->insert(__l.begin(), __l.end()); }

      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 {
   __hashtable& __h = _M_conjure_hashtable();
   __node_gen_type __node_gen(__h);
   return _M_insert_range(__first, __last, __node_gen, __unique_keys{});
 }
    };

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    template<typename _InputIterator, typename _NodeGetter>
      void
      _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
     _Hash, _RangeHash, _Unused,
     _RehashPolicy, _Traits>::
      _M_insert_range(_InputIterator __first, _InputIterator __last,
        const _NodeGetter& __node_gen, true_type __uks)
      {
 __hashtable& __h = _M_conjure_hashtable();
 for (; __first != __last; ++__first)
   __h._M_insert(*__first, __node_gen, __uks);
      }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    template<typename _InputIterator, typename _NodeGetter>
      void
      _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
     _Hash, _RangeHash, _Unused,
     _RehashPolicy, _Traits>::
      _M_insert_range(_InputIterator __first, _InputIterator __last,
        const _NodeGetter& __node_gen, false_type __uks)
      {
 using __rehash_guard_t = typename __hashtable::__rehash_guard_t;
 using __pair_type = std::pair<bool, std::size_t>;

 size_type __n_elt = __detail::__distance_fw(__first, __last);
 if (__n_elt == 0)
   return;

 __hashtable& __h = _M_conjure_hashtable();
 __rehash_guard_t __rehash_guard(__h._M_rehash_policy);
 __pair_type __do_rehash
   = __h._M_rehash_policy._M_need_rehash(__h._M_bucket_count,
      __h._M_element_count,
      __n_elt);

 if (__do_rehash.first)
   __h._M_rehash(__do_rehash.second, __uks);

 __rehash_guard._M_guarded_obj = nullptr;
 for (; __first != __last; ++__first)
   __h._M_insert(*__first, __node_gen, __uks);
      }







  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits,
    bool _Constant_iterators = _Traits::__constant_iterators::value>
    struct _Insert;


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal,
     _Hash, _RangeHash, _Unused,
     _RehashPolicy, _Traits, true>
    : public _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
     _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>
    {
      using __base_type = _Insert_base<_Key, _Value, _Alloc, _ExtractKey,
           _Equal, _Hash, _RangeHash, _Unused,
           _RehashPolicy, _Traits>;

      using value_type = typename __base_type::value_type;
      using iterator = typename __base_type::iterator;
      using const_iterator = typename __base_type::const_iterator;
      using __ireturn_type = typename __base_type::__ireturn_type;

      using __unique_keys = typename __base_type::__unique_keys;
      using __hashtable = typename __base_type::__hashtable;
      using __node_gen_type = typename __base_type::__node_gen_type;

      using __base_type::insert;

      __ireturn_type
      insert(value_type&& __v)
      {
 __hashtable& __h = this->_M_conjure_hashtable();
 __node_gen_type __node_gen(__h);
 return __h._M_insert(std::move(__v), __node_gen, __unique_keys{});
      }

      iterator
      insert(const_iterator __hint, value_type&& __v)
      {
 __hashtable& __h = this->_M_conjure_hashtable();
 __node_gen_type __node_gen(__h);
 return __h._M_insert(__hint, std::move(__v), __node_gen,
        __unique_keys{});
      }
    };


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal,
     _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, false>
    : public _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
     _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>
    {
      using __base_type = _Insert_base<_Key, _Value, _Alloc, _ExtractKey,
           _Equal, _Hash, _RangeHash, _Unused,
           _RehashPolicy, _Traits>;
      using value_type = typename __base_type::value_type;
      using iterator = typename __base_type::iterator;
      using const_iterator = typename __base_type::const_iterator;

      using __unique_keys = typename __base_type::__unique_keys;
      using __hashtable = typename __base_type::__hashtable;
      using __ireturn_type = typename __base_type::__ireturn_type;

      using __base_type::insert;

      template<typename _Pair>
 using __is_cons = std::is_constructible<value_type, _Pair&&>;

      template<typename _Pair>
 using _IFcons = std::enable_if<__is_cons<_Pair>::value>;

      template<typename _Pair>
 using _IFconsp = typename _IFcons<_Pair>::type;

      template<typename _Pair, typename = _IFconsp<_Pair>>
 __ireturn_type
 insert(_Pair&& __v)
 {
   __hashtable& __h = this->_M_conjure_hashtable();
   return __h._M_emplace(__unique_keys{}, std::forward<_Pair>(__v));
 }

      template<typename _Pair, typename = _IFconsp<_Pair>>
 iterator
 insert(const_iterator __hint, _Pair&& __v)
 {
   __hashtable& __h = this->_M_conjure_hashtable();
   return __h._M_emplace(__hint, __unique_keys{},
    std::forward<_Pair>(__v));
 }
   };

  template<typename _Policy>
    using __has_load_factor = typename _Policy::__has_load_factor;







  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits,
    typename =
      __detected_or_t<false_type, __has_load_factor, _RehashPolicy>>
    struct _Rehash_base;


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    struct _Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits,
   false_type >
    {
    };


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    struct _Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits,
   true_type >
    {
    private:
      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey,
         _Equal, _Hash, _RangeHash, _Unused,
         _RehashPolicy, _Traits>;

    public:
      float
      max_load_factor() const noexcept
      {
 const __hashtable* __this = static_cast<const __hashtable*>(this);
 return __this->__rehash_policy().max_load_factor();
      }

      void
      max_load_factor(float __z)
      {
 __hashtable* __this = static_cast<__hashtable*>(this);
 __this->__rehash_policy(_RehashPolicy(__z));
      }

      void
      reserve(std::size_t __n)
      {
 __hashtable* __this = static_cast<__hashtable*>(this);
 __this->rehash(__this->__rehash_policy()._M_bkt_for_elements(__n));
      }
    };







  template<int _Nm, typename _Tp,
    bool __use_ebo = !__is_final(_Tp) && __is_empty(_Tp)>
    struct _Hashtable_ebo_helper;


  template<int _Nm, typename _Tp>
    struct _Hashtable_ebo_helper<_Nm, _Tp, true>
    : private _Tp
    {
      _Hashtable_ebo_helper() noexcept(noexcept(_Tp())) : _Tp() { }

      template<typename _OtherTp>
 _Hashtable_ebo_helper(_OtherTp&& __tp)
 : _Tp(std::forward<_OtherTp>(__tp))
 { }

      const _Tp& _M_cget() const { return static_cast<const _Tp&>(*this); }
      _Tp& _M_get() { return static_cast<_Tp&>(*this); }
    };


  template<int _Nm, typename _Tp>
    struct _Hashtable_ebo_helper<_Nm, _Tp, false>
    {
      _Hashtable_ebo_helper() = default;

      template<typename _OtherTp>
 _Hashtable_ebo_helper(_OtherTp&& __tp)
 : _M_tp(std::forward<_OtherTp>(__tp))
 { }

      const _Tp& _M_cget() const { return _M_tp; }
      _Tp& _M_get() { return _M_tp; }

    private:
      _Tp _M_tp{};
    };







  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _Hash, typename _RangeHash, typename _Unused,
    bool __cache_hash_code>
    struct _Local_iterator_base;
# 1301 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/hashtable_policy.h" 3
  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _Hash, typename _RangeHash, typename _Unused,
    bool __cache_hash_code>
    struct _Hash_code_base
    : private _Hashtable_ebo_helper<1, _Hash>
    {
    private:
      using __ebo_hash = _Hashtable_ebo_helper<1, _Hash>;


      friend struct _Local_iterator_base<_Key, _Value, _ExtractKey,
      _Hash, _RangeHash, _Unused, false>;

    public:
      typedef _Hash hasher;

      hasher
      hash_function() const
      { return _M_hash(); }

    protected:
      typedef std::size_t __hash_code;



      _Hash_code_base() = default;

      _Hash_code_base(const _Hash& __hash) : __ebo_hash(__hash) { }

      __hash_code
      _M_hash_code(const _Key& __k) const
      {
 static_assert(__is_invocable<const _Hash&, const _Key&>{},
     "hash function must be invocable with an argument of key type");
 return _M_hash()(__k);
      }

      template<typename _Kt>
 __hash_code
 _M_hash_code_tr(const _Kt& __k) const
 {
   static_assert(__is_invocable<const _Hash&, const _Kt&>{},
     "hash function must be invocable with an argument of key type");
   return _M_hash()(__k);
 }

      __hash_code
      _M_hash_code(const _Hash_node_value<_Value, false>& __n) const
      { return _M_hash_code(_ExtractKey{}(__n._M_v())); }

      __hash_code
      _M_hash_code(const _Hash_node_value<_Value, true>& __n) const
      { return __n._M_hash_code; }

      std::size_t
      _M_bucket_index(__hash_code __c, std::size_t __bkt_count) const
      { return _RangeHash{}(__c, __bkt_count); }

      std::size_t
      _M_bucket_index(const _Hash_node_value<_Value, false>& __n,
        std::size_t __bkt_count) const
 noexcept( noexcept(declval<const _Hash&>()(declval<const _Key&>()))
    && noexcept(declval<const _RangeHash&>()((__hash_code)0,
          (std::size_t)0)) )
      {
 return _RangeHash{}(_M_hash_code(_ExtractKey{}(__n._M_v())),
       __bkt_count);
      }

      std::size_t
      _M_bucket_index(const _Hash_node_value<_Value, true>& __n,
        std::size_t __bkt_count) const
 noexcept( noexcept(declval<const _RangeHash&>()((__hash_code)0,
       (std::size_t)0)) )
      { return _RangeHash{}(__n._M_hash_code, __bkt_count); }

      void
      _M_store_code(_Hash_node_code_cache<false>&, __hash_code) const
      { }

      void
      _M_copy_code(_Hash_node_code_cache<false>&,
     const _Hash_node_code_cache<false>&) const
      { }

      void
      _M_store_code(_Hash_node_code_cache<true>& __n, __hash_code __c) const
      { __n._M_hash_code = __c; }

      void
      _M_copy_code(_Hash_node_code_cache<true>& __to,
     const _Hash_node_code_cache<true>& __from) const
      { __to._M_hash_code = __from._M_hash_code; }

      void
      _M_swap(_Hash_code_base& __x)
      { std::swap(__ebo_hash::_M_get(), __x.__ebo_hash::_M_get()); }

      const _Hash&
      _M_hash() const { return __ebo_hash::_M_cget(); }
    };


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _Hash, typename _RangeHash, typename _Unused>
    struct _Local_iterator_base<_Key, _Value, _ExtractKey,
    _Hash, _RangeHash, _Unused, true>
    : public _Node_iterator_base<_Value, true>
    {
    protected:
      using __base_node_iter = _Node_iterator_base<_Value, true>;
      using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,
           _Hash, _RangeHash, _Unused, true>;

      _Local_iterator_base() = default;
      _Local_iterator_base(const __hash_code_base&,
      _Hash_node<_Value, true>* __p,
      std::size_t __bkt, std::size_t __bkt_count)
      : __base_node_iter(__p), _M_bucket(__bkt), _M_bucket_count(__bkt_count)
      { }

      void
      _M_incr()
      {
 __base_node_iter::_M_incr();
 if (this->_M_cur)
   {
     std::size_t __bkt
       = _RangeHash{}(this->_M_cur->_M_hash_code, _M_bucket_count);
     if (__bkt != _M_bucket)
       this->_M_cur = nullptr;
   }
      }

      std::size_t _M_bucket;
      std::size_t _M_bucket_count;

    public:
      std::size_t
      _M_get_bucket() const { return _M_bucket; }
    };





  template<typename _Tp, bool _IsEmpty = std::is_empty<_Tp>::value>
    struct _Hash_code_storage
    {
      __gnu_cxx::__aligned_buffer<_Tp> _M_storage;

      _Tp*
      _M_h() { return _M_storage._M_ptr(); }

      const _Tp*
      _M_h() const { return _M_storage._M_ptr(); }
    };


  template<typename _Tp>
    struct _Hash_code_storage<_Tp, true>
    {
      static_assert( std::is_empty<_Tp>::value, "Type must be empty" );



      _Tp*
      _M_h() { return reinterpret_cast<_Tp*>(this); }

      const _Tp*
      _M_h() const { return reinterpret_cast<const _Tp*>(this); }
    };

  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _Hash, typename _RangeHash, typename _Unused>
    using __hash_code_for_local_iter
      = _Hash_code_storage<_Hash_code_base<_Key, _Value, _ExtractKey,
        _Hash, _RangeHash, _Unused, false>>;


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _Hash, typename _RangeHash, typename _Unused>
    struct _Local_iterator_base<_Key, _Value, _ExtractKey,
    _Hash, _RangeHash, _Unused, false>
    : __hash_code_for_local_iter<_Key, _Value, _ExtractKey, _Hash, _RangeHash,
     _Unused>
    , _Node_iterator_base<_Value, false>
    {
    protected:
      using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,
          _Hash, _RangeHash, _Unused, false>;
      using __node_iter_base = _Node_iterator_base<_Value, false>;

      _Local_iterator_base() : _M_bucket_count(-1) { }

      _Local_iterator_base(const __hash_code_base& __base,
      _Hash_node<_Value, false>* __p,
      std::size_t __bkt, std::size_t __bkt_count)
      : __node_iter_base(__p), _M_bucket(__bkt), _M_bucket_count(__bkt_count)
      { _M_init(__base); }

      ~_Local_iterator_base()
      {
 if (_M_bucket_count != size_t(-1))
   _M_destroy();
      }

      _Local_iterator_base(const _Local_iterator_base& __iter)
      : __node_iter_base(__iter._M_cur), _M_bucket(__iter._M_bucket)
      , _M_bucket_count(__iter._M_bucket_count)
      {
 if (_M_bucket_count != size_t(-1))
   _M_init(*__iter._M_h());
      }

      _Local_iterator_base&
      operator=(const _Local_iterator_base& __iter)
      {
 if (_M_bucket_count != -1)
   _M_destroy();
 this->_M_cur = __iter._M_cur;
 _M_bucket = __iter._M_bucket;
 _M_bucket_count = __iter._M_bucket_count;
 if (_M_bucket_count != -1)
   _M_init(*__iter._M_h());
 return *this;
      }

      void
      _M_incr()
      {
 __node_iter_base::_M_incr();
 if (this->_M_cur)
   {
     std::size_t __bkt = this->_M_h()->_M_bucket_index(*this->_M_cur,
             _M_bucket_count);
     if (__bkt != _M_bucket)
       this->_M_cur = nullptr;
   }
      }

      std::size_t _M_bucket;
      std::size_t _M_bucket_count;

      void
      _M_init(const __hash_code_base& __base)
      { ::new(this->_M_h()) __hash_code_base(__base); }

      void
      _M_destroy() { this->_M_h()->~__hash_code_base(); }

    public:
      std::size_t
      _M_get_bucket() const { return _M_bucket; }
    };


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _Hash, typename _RangeHash, typename _Unused,
    bool __constant_iterators, bool __cache>
    struct _Local_iterator
    : public _Local_iterator_base<_Key, _Value, _ExtractKey,
      _Hash, _RangeHash, _Unused, __cache>
    {
    private:
      using __base_type = _Local_iterator_base<_Key, _Value, _ExtractKey,
        _Hash, _RangeHash, _Unused, __cache>;
      using __hash_code_base = typename __base_type::__hash_code_base;

    public:
      using value_type = _Value;
      using pointer = __conditional_t<__constant_iterators,
          const value_type*, value_type*>;
      using reference = __conditional_t<__constant_iterators,
     const value_type&, value_type&>;
      using difference_type = ptrdiff_t;
      using iterator_category = forward_iterator_tag;

      _Local_iterator() = default;

      _Local_iterator(const __hash_code_base& __base,
        _Hash_node<_Value, __cache>* __n,
        std::size_t __bkt, std::size_t __bkt_count)
      : __base_type(__base, __n, __bkt, __bkt_count)
      { }

      reference
      operator*() const
      { return this->_M_cur->_M_v(); }

      pointer
      operator->() const
      { return this->_M_cur->_M_valptr(); }

      _Local_iterator&
      operator++()
      {
 this->_M_incr();
 return *this;
      }

      _Local_iterator
      operator++(int)
      {
 _Local_iterator __tmp(*this);
 this->_M_incr();
 return __tmp;
      }
    };


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _Hash, typename _RangeHash, typename _Unused,
    bool __constant_iterators, bool __cache>
    struct _Local_const_iterator
    : public _Local_iterator_base<_Key, _Value, _ExtractKey,
      _Hash, _RangeHash, _Unused, __cache>
    {
    private:
      using __base_type = _Local_iterator_base<_Key, _Value, _ExtractKey,
        _Hash, _RangeHash, _Unused, __cache>;
      using __hash_code_base = typename __base_type::__hash_code_base;

    public:
      typedef _Value value_type;
      typedef const value_type* pointer;
      typedef const value_type& reference;
      typedef std::ptrdiff_t difference_type;
      typedef std::forward_iterator_tag iterator_category;

      _Local_const_iterator() = default;

      _Local_const_iterator(const __hash_code_base& __base,
       _Hash_node<_Value, __cache>* __n,
       std::size_t __bkt, std::size_t __bkt_count)
      : __base_type(__base, __n, __bkt, __bkt_count)
      { }

      _Local_const_iterator(const _Local_iterator<_Key, _Value, _ExtractKey,
        _Hash, _RangeHash, _Unused,
        __constant_iterators,
        __cache>& __x)
      : __base_type(__x)
      { }

      reference
      operator*() const
      { return this->_M_cur->_M_v(); }

      pointer
      operator->() const
      { return this->_M_cur->_M_valptr(); }

      _Local_const_iterator&
      operator++()
      {
 this->_M_incr();
 return *this;
      }

      _Local_const_iterator
      operator++(int)
      {
 _Local_const_iterator __tmp(*this);
 this->_M_incr();
 return __tmp;
      }
    };
# 1680 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/hashtable_policy.h" 3
  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _Equal, typename _Hash, typename _RangeHash,
    typename _Unused, typename _Traits>
    struct _Hashtable_base
    : public _Hash_code_base<_Key, _Value, _ExtractKey, _Hash, _RangeHash,
        _Unused, _Traits::__hash_cached::value>,
      private _Hashtable_ebo_helper<0, _Equal>
    {
    public:
      typedef _Key key_type;
      typedef _Value value_type;
      typedef _Equal key_equal;
      typedef std::size_t size_type;
      typedef std::ptrdiff_t difference_type;

      using __traits_type = _Traits;
      using __hash_cached = typename __traits_type::__hash_cached;

      using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,
            _Hash, _RangeHash, _Unused,
            __hash_cached::value>;

      using __hash_code = typename __hash_code_base::__hash_code;

    private:
      using _EqualEBO = _Hashtable_ebo_helper<0, _Equal>;

      static bool
      _S_equals(__hash_code, const _Hash_node_code_cache<false>&)
      { return true; }

      static bool
      _S_node_equals(const _Hash_node_code_cache<false>&,
       const _Hash_node_code_cache<false>&)
      { return true; }

      static bool
      _S_equals(__hash_code __c, const _Hash_node_code_cache<true>& __n)
      { return __c == __n._M_hash_code; }

      static bool
      _S_node_equals(const _Hash_node_code_cache<true>& __lhn,
       const _Hash_node_code_cache<true>& __rhn)
      { return __lhn._M_hash_code == __rhn._M_hash_code; }

    protected:
      _Hashtable_base() = default;

      _Hashtable_base(const _Hash& __hash, const _Equal& __eq)
      : __hash_code_base(__hash), _EqualEBO(__eq)
      { }

      bool
      _M_key_equals(const _Key& __k,
      const _Hash_node_value<_Value,
        __hash_cached::value>& __n) const
      {
 static_assert(__is_invocable<const _Equal&, const _Key&, const _Key&>{},
   "key equality predicate must be invocable with two arguments of "
   "key type");
 return _M_eq()(__k, _ExtractKey{}(__n._M_v()));
      }

      template<typename _Kt>
 bool
 _M_key_equals_tr(const _Kt& __k,
    const _Hash_node_value<_Value,
          __hash_cached::value>& __n) const
 {
   static_assert(
     __is_invocable<const _Equal&, const _Kt&, const _Key&>{},
     "key equality predicate must be invocable with two arguments of "
     "key type");
   return _M_eq()(__k, _ExtractKey{}(__n._M_v()));
 }

      bool
      _M_equals(const _Key& __k, __hash_code __c,
  const _Hash_node_value<_Value, __hash_cached::value>& __n) const
      { return _S_equals(__c, __n) && _M_key_equals(__k, __n); }

      template<typename _Kt>
 bool
 _M_equals_tr(const _Kt& __k, __hash_code __c,
       const _Hash_node_value<_Value,
         __hash_cached::value>& __n) const
 { return _S_equals(__c, __n) && _M_key_equals_tr(__k, __n); }

      bool
      _M_node_equals(
 const _Hash_node_value<_Value, __hash_cached::value>& __lhn,
 const _Hash_node_value<_Value, __hash_cached::value>& __rhn) const
      {
 return _S_node_equals(__lhn, __rhn)
   && _M_key_equals(_ExtractKey{}(__lhn._M_v()), __rhn);
      }

      void
      _M_swap(_Hashtable_base& __x)
      {
 __hash_code_base::_M_swap(__x);
 std::swap(_EqualEBO::_M_get(), __x._EqualEBO::_M_get());
      }

      const _Equal&
      _M_eq() const { return _EqualEBO::_M_cget(); }
    };
# 1796 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/hashtable_policy.h" 3
  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits,
    bool _Unique_keys = _Traits::__unique_keys::value>
    struct _Equality;


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    struct _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>
    {
      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         _Hash, _RangeHash, _Unused,
         _RehashPolicy, _Traits>;

      bool
      _M_equal(const __hashtable&) const;
    };

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    bool
    _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>::
    _M_equal(const __hashtable& __other) const
    {
      using __node_ptr = typename __hashtable::__node_ptr;
      const __hashtable* __this = static_cast<const __hashtable*>(this);
      if (__this->size() != __other.size())
 return false;

      for (auto __x_n = __this->_M_begin(); __x_n; __x_n = __x_n->_M_next())
 {
   std::size_t __ybkt = __other._M_bucket_index(*__x_n);
   auto __prev_n = __other._M_buckets[__ybkt];
   if (!__prev_n)
     return false;

   for (__node_ptr __n = static_cast<__node_ptr>(__prev_n->_M_nxt);;
        __n = __n->_M_next())
     {
       if (__n->_M_v() == __x_n->_M_v())
  break;

       if (!__n->_M_nxt
    || __other._M_bucket_index(*__n->_M_next()) != __ybkt)
  return false;
     }
 }

      return true;
    }


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    struct _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, false>
    {
      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         _Hash, _RangeHash, _Unused,
         _RehashPolicy, _Traits>;

      bool
      _M_equal(const __hashtable&) const;
    };

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    bool
    _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, false>::
    _M_equal(const __hashtable& __other) const
    {
      using __node_ptr = typename __hashtable::__node_ptr;
      using const_iterator = typename __hashtable::const_iterator;
      const __hashtable* __this = static_cast<const __hashtable*>(this);
      if (__this->size() != __other.size())
 return false;

      for (auto __x_n = __this->_M_begin(); __x_n;)
 {
   std::size_t __x_count = 1;
   auto __x_n_end = __x_n->_M_next();
   for (; __x_n_end
   && __this->key_eq()(_ExtractKey{}(__x_n->_M_v()),
         _ExtractKey{}(__x_n_end->_M_v()));
        __x_n_end = __x_n_end->_M_next())
     ++__x_count;

   std::size_t __ybkt = __other._M_bucket_index(*__x_n);
   auto __y_prev_n = __other._M_buckets[__ybkt];
   if (!__y_prev_n)
     return false;

   __node_ptr __y_n = static_cast<__node_ptr>(__y_prev_n->_M_nxt);
   for (;;)
     {
       if (__this->key_eq()(_ExtractKey{}(__y_n->_M_v()),
       _ExtractKey{}(__x_n->_M_v())))
  break;

       auto __y_ref_n = __y_n;
       for (__y_n = __y_n->_M_next(); __y_n; __y_n = __y_n->_M_next())
  if (!__other._M_node_equals(*__y_ref_n, *__y_n))
    break;

       if (!__y_n || __other._M_bucket_index(*__y_n) != __ybkt)
  return false;
     }

   auto __y_n_end = __y_n;
   for (; __y_n_end; __y_n_end = __y_n_end->_M_next())
     if (--__x_count == 0)
       break;

   if (__x_count != 0)
     return false;

   const_iterator __itx(__x_n), __itx_end(__x_n_end);
   const_iterator __ity(__y_n);
   if (!std::is_permutation(__itx, __itx_end, __ity))
     return false;

   __x_n = __x_n_end;
 }
      return true;
    }





  template<typename _NodeAlloc>
    struct _Hashtable_alloc : private _Hashtable_ebo_helper<0, _NodeAlloc>
    {
    private:
      using __ebo_node_alloc = _Hashtable_ebo_helper<0, _NodeAlloc>;

      template<typename>
 struct __get_value_type;
      template<typename _Val, bool _Cache_hash_code>
 struct __get_value_type<_Hash_node<_Val, _Cache_hash_code>>
 { using type = _Val; };

    public:
      using __node_type = typename _NodeAlloc::value_type;
      using __node_alloc_type = _NodeAlloc;

      using __node_alloc_traits = __gnu_cxx::__alloc_traits<__node_alloc_type>;

      using __value_alloc_traits = typename __node_alloc_traits::template
 rebind_traits<typename __get_value_type<__node_type>::type>;

      using __node_ptr = __node_type*;
      using __node_base = _Hash_node_base;
      using __node_base_ptr = __node_base*;
      using __buckets_alloc_type =
 __alloc_rebind<__node_alloc_type, __node_base_ptr>;
      using __buckets_alloc_traits = std::allocator_traits<__buckets_alloc_type>;
      using __buckets_ptr = __node_base_ptr*;

      _Hashtable_alloc() = default;
      _Hashtable_alloc(const _Hashtable_alloc&) = default;
      _Hashtable_alloc(_Hashtable_alloc&&) = default;

      template<typename _Alloc>
 _Hashtable_alloc(_Alloc&& __a)
 : __ebo_node_alloc(std::forward<_Alloc>(__a))
 { }

      __node_alloc_type&
      _M_node_allocator()
      { return __ebo_node_alloc::_M_get(); }

      const __node_alloc_type&
      _M_node_allocator() const
      { return __ebo_node_alloc::_M_cget(); }


      template<typename... _Args>
 __node_ptr
 _M_allocate_node(_Args&&... __args);


      void
      _M_deallocate_node(__node_ptr __n);


      void
      _M_deallocate_node_ptr(__node_ptr __n);



      void
      _M_deallocate_nodes(__node_ptr __n);

      __buckets_ptr
      _M_allocate_buckets(std::size_t __bkt_count);

      void
      _M_deallocate_buckets(__buckets_ptr, std::size_t __bkt_count);
    };



  template<typename _NodeAlloc>
    template<typename... _Args>
      auto
      _Hashtable_alloc<_NodeAlloc>::_M_allocate_node(_Args&&... __args)
      -> __node_ptr
      {
 auto& __alloc = _M_node_allocator();
 auto __nptr = __node_alloc_traits::allocate(__alloc, 1);
 __node_ptr __n = std::__to_address(__nptr);
 try
   {
     ::new ((void*)__n) __node_type;
     __node_alloc_traits::construct(__alloc, __n->_M_valptr(),
        std::forward<_Args>(__args)...);
     return __n;
   }
 catch(...)
   {
     __n->~__node_type();
     __node_alloc_traits::deallocate(__alloc, __nptr, 1);
     throw;
   }
      }

  template<typename _NodeAlloc>
    void
    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node(__node_ptr __n)
    {
      __node_alloc_traits::destroy(_M_node_allocator(), __n->_M_valptr());
      _M_deallocate_node_ptr(__n);
    }

  template<typename _NodeAlloc>
    void
    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node_ptr(__node_ptr __n)
    {
      typedef typename __node_alloc_traits::pointer _Ptr;
      auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__n);
      __n->~__node_type();
      __node_alloc_traits::deallocate(_M_node_allocator(), __ptr, 1);
    }

  template<typename _NodeAlloc>
    void
    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_nodes(__node_ptr __n)
    {
      while (__n)
 {
   __node_ptr __tmp = __n;
   __n = __n->_M_next();
   _M_deallocate_node(__tmp);
 }
    }

  template<typename _NodeAlloc>
    auto
    _Hashtable_alloc<_NodeAlloc>::_M_allocate_buckets(std::size_t __bkt_count)
    -> __buckets_ptr
    {
      __buckets_alloc_type __alloc(_M_node_allocator());

      auto __ptr = __buckets_alloc_traits::allocate(__alloc, __bkt_count);
      __buckets_ptr __p = std::__to_address(__ptr);
      __builtin_memset(__p, 0, __bkt_count * sizeof(__node_base_ptr));
      return __p;
    }

  template<typename _NodeAlloc>
    void
    _Hashtable_alloc<_NodeAlloc>::
    _M_deallocate_buckets(__buckets_ptr __bkts,
     std::size_t __bkt_count)
    {
      typedef typename __buckets_alloc_traits::pointer _Ptr;
      auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__bkts);
      __buckets_alloc_type __alloc(_M_node_allocator());
      __buckets_alloc_traits::deallocate(__alloc, __ptr, __bkt_count);
    }


}


}
# 36 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/hashtable.h" 2 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/enable_special_members.h" 1 3
# 33 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/enable_special_members.h" 3
       
# 34 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/enable_special_members.h" 3



namespace std
{



  struct _Enable_default_constructor_tag
  {
    explicit constexpr _Enable_default_constructor_tag() = default;
  };






template<bool _Switch, typename _Tag = void>
  struct _Enable_default_constructor
  {
    constexpr _Enable_default_constructor() noexcept = default;
    constexpr _Enable_default_constructor(_Enable_default_constructor const&)
      noexcept = default;
    constexpr _Enable_default_constructor(_Enable_default_constructor&&)
      noexcept = default;
    _Enable_default_constructor&
    operator=(_Enable_default_constructor const&) noexcept = default;
    _Enable_default_constructor&
    operator=(_Enable_default_constructor&&) noexcept = default;


    constexpr explicit
    _Enable_default_constructor(_Enable_default_constructor_tag) { }
  };







template<bool _Switch, typename _Tag = void>
  struct _Enable_destructor { };






template<bool _Copy, bool _CopyAssignment,
         bool _Move, bool _MoveAssignment,
         typename _Tag = void>
  struct _Enable_copy_move { };
# 96 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/enable_special_members.h" 3
template<bool _Default, bool _Destructor,
         bool _Copy, bool _CopyAssignment,
         bool _Move, bool _MoveAssignment,
         typename _Tag = void>
  struct _Enable_special_members
  : private _Enable_default_constructor<_Default, _Tag>,
    private _Enable_destructor<_Destructor, _Tag>,
    private _Enable_copy_move<_Copy, _CopyAssignment,
                              _Move, _MoveAssignment,
                              _Tag>
  { };



template<typename _Tag>
  struct _Enable_default_constructor<false, _Tag>
  {
    constexpr _Enable_default_constructor() noexcept = delete;
    constexpr _Enable_default_constructor(_Enable_default_constructor const&)
      noexcept = default;
    constexpr _Enable_default_constructor(_Enable_default_constructor&&)
      noexcept = default;
    _Enable_default_constructor&
    operator=(_Enable_default_constructor const&) noexcept = default;
    _Enable_default_constructor&
    operator=(_Enable_default_constructor&&) noexcept = default;


    constexpr explicit
    _Enable_default_constructor(_Enable_default_constructor_tag) { }
  };

template<typename _Tag>
  struct _Enable_destructor<false, _Tag>
  { ~_Enable_destructor() noexcept = delete; };

template<typename _Tag>
  struct _Enable_copy_move<false, true, true, true, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = default;
  };

template<typename _Tag>
  struct _Enable_copy_move<true, false, true, true, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = default;
  };

template<typename _Tag>
  struct _Enable_copy_move<false, false, true, true, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = default;
  };

template<typename _Tag>
  struct _Enable_copy_move<true, true, false, true, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = default;
  };

template<typename _Tag>
  struct _Enable_copy_move<false, true, false, true, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = default;
  };

template<typename _Tag>
  struct _Enable_copy_move<true, false, false, true, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = default;
  };

template<typename _Tag>
  struct _Enable_copy_move<false, false, false, true, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = default;
  };

template<typename _Tag>
  struct _Enable_copy_move<true, true, true, false, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = delete;
  };

template<typename _Tag>
  struct _Enable_copy_move<false, true, true, false, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = delete;
  };

template<typename _Tag>
  struct _Enable_copy_move<true, false, true, false, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = delete;
  };

template<typename _Tag>
  struct _Enable_copy_move<false, false, true, false, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = delete;
  };

template<typename _Tag>
  struct _Enable_copy_move<true, true, false, false, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = delete;
  };

template<typename _Tag>
  struct _Enable_copy_move<false, true, false, false, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = delete;
  };

template<typename _Tag>
  struct _Enable_copy_move<true, false, false, false, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = delete;
  };

template<typename _Tag>
  struct _Enable_copy_move<false, false, false, false, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = delete;
  };



}
# 37 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/hashtable.h" 2 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_function.h" 1 3
# 63 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_function.h" 3
namespace std
{

# 116 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    struct unary_function
    {

      typedef _Arg argument_type;


      typedef _Result result_type;
    } __attribute__ ((__deprecated__));





  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {

      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;


      typedef _Result result_type;
    } __attribute__ ((__deprecated__));
# 157 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_function.h" 3
  struct __is_transparent;

  template<typename _Tp = void>
    struct plus;

  template<typename _Tp = void>
    struct minus;

  template<typename _Tp = void>
    struct multiplies;

  template<typename _Tp = void>
    struct divides;

  template<typename _Tp = void>
    struct modulus;

  template<typename _Tp = void>
    struct negate;



#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"


  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {

      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };
#pragma GCC diagnostic pop


  template<>
    struct plus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) + std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) + std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) + std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct minus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) - std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) - std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) - std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct multiplies<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) * std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) * std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) * std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct divides<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) / std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) / std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) / std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct modulus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) % std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) % std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) % std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct negate<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(-std::forward<_Tp>(__t)))
 -> decltype(-std::forward<_Tp>(__t))
 { return -std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };
# 346 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_function.h" 3
  template<typename _Tp = void>
    struct equal_to;

  template<typename _Tp = void>
    struct not_equal_to;

  template<typename _Tp = void>
    struct greater;

  template<typename _Tp = void>
    struct less;

  template<typename _Tp = void>
    struct greater_equal;

  template<typename _Tp = void>
    struct less_equal;


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"


  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };


  template<typename _Tp>
    struct greater<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
      constexpr bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {

 if (std::__is_constant_evaluated())
   return __x > __y;

 return (long long unsigned int)__x > (long long unsigned int)__y;
      }
    };


  template<typename _Tp>
    struct less<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
      constexpr bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {

 if (std::__is_constant_evaluated())
   return __x < __y;

 return (long long unsigned int)__x < (long long unsigned int)__y;
      }
    };


  template<typename _Tp>
    struct greater_equal<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
      constexpr bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {

 if (std::__is_constant_evaluated())
   return __x >= __y;

 return (long long unsigned int)__x >= (long long unsigned int)__y;
      }
    };


  template<typename _Tp>
    struct less_equal<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
      constexpr bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {

 if (std::__is_constant_evaluated())
   return __x <= __y;

 return (long long unsigned int)__x <= (long long unsigned int)__y;
      }
    };
#pragma GCC diagnostic pop



  template<>
    struct equal_to<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) == std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) == std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct not_equal_to<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) != std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) != std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) != std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct greater<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) > std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) > std::forward<_Up>(__u))
 {
   return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
   __ptr_cmp<_Tp, _Up>{});
 }

      template<typename _Tp, typename _Up>
 constexpr bool
 operator()(_Tp* __t, _Up* __u) const noexcept
 { return greater<common_type_t<_Tp*, _Up*>>{}(__t, __u); }

      typedef __is_transparent is_transparent;

    private:
      template <typename _Tp, typename _Up>
 static constexpr decltype(auto)
 _S_cmp(_Tp&& __t, _Up&& __u, false_type)
 { return std::forward<_Tp>(__t) > std::forward<_Up>(__u); }

      template <typename _Tp, typename _Up>
 static constexpr bool
 _S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
 {
   return greater<const volatile void*>{}(
       static_cast<const volatile void*>(std::forward<_Tp>(__t)),
       static_cast<const volatile void*>(std::forward<_Up>(__u)));
 }


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded2 : true_type { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded2<_Tp, _Up, __void_t<
   decltype(std::declval<_Tp>().operator>(std::declval<_Up>()))>>
 : false_type { };


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded : __not_overloaded2<_Tp, _Up> { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded<_Tp, _Up, __void_t<
   decltype(operator>(std::declval<_Tp>(), std::declval<_Up>()))>>
 : false_type { };

      template<typename _Tp, typename _Up>
 using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
       is_convertible<_Tp, const volatile void*>,
       is_convertible<_Up, const volatile void*>>;
    };


  template<>
    struct less<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) < std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) < std::forward<_Up>(__u))
 {
   return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
   __ptr_cmp<_Tp, _Up>{});
 }

      template<typename _Tp, typename _Up>
 constexpr bool
 operator()(_Tp* __t, _Up* __u) const noexcept
 { return less<common_type_t<_Tp*, _Up*>>{}(__t, __u); }

      typedef __is_transparent is_transparent;

    private:
      template <typename _Tp, typename _Up>
 static constexpr decltype(auto)
 _S_cmp(_Tp&& __t, _Up&& __u, false_type)
 { return std::forward<_Tp>(__t) < std::forward<_Up>(__u); }

      template <typename _Tp, typename _Up>
 static constexpr bool
 _S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
 {
   return less<const volatile void*>{}(
       static_cast<const volatile void*>(std::forward<_Tp>(__t)),
       static_cast<const volatile void*>(std::forward<_Up>(__u)));
 }


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded2 : true_type { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded2<_Tp, _Up, __void_t<
   decltype(std::declval<_Tp>().operator<(std::declval<_Up>()))>>
 : false_type { };


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded : __not_overloaded2<_Tp, _Up> { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded<_Tp, _Up, __void_t<
   decltype(operator<(std::declval<_Tp>(), std::declval<_Up>()))>>
 : false_type { };

      template<typename _Tp, typename _Up>
 using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
       is_convertible<_Tp, const volatile void*>,
       is_convertible<_Up, const volatile void*>>;
    };


  template<>
    struct greater_equal<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) >= std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) >= std::forward<_Up>(__u))
 {
   return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
   __ptr_cmp<_Tp, _Up>{});
 }

      template<typename _Tp, typename _Up>
 constexpr bool
 operator()(_Tp* __t, _Up* __u) const noexcept
 { return greater_equal<common_type_t<_Tp*, _Up*>>{}(__t, __u); }

      typedef __is_transparent is_transparent;

    private:
      template <typename _Tp, typename _Up>
 static constexpr decltype(auto)
 _S_cmp(_Tp&& __t, _Up&& __u, false_type)
 { return std::forward<_Tp>(__t) >= std::forward<_Up>(__u); }

      template <typename _Tp, typename _Up>
 static constexpr bool
 _S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
 {
   return greater_equal<const volatile void*>{}(
       static_cast<const volatile void*>(std::forward<_Tp>(__t)),
       static_cast<const volatile void*>(std::forward<_Up>(__u)));
 }


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded2 : true_type { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded2<_Tp, _Up, __void_t<
   decltype(std::declval<_Tp>().operator>=(std::declval<_Up>()))>>
 : false_type { };


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded : __not_overloaded2<_Tp, _Up> { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded<_Tp, _Up, __void_t<
   decltype(operator>=(std::declval<_Tp>(), std::declval<_Up>()))>>
 : false_type { };

      template<typename _Tp, typename _Up>
 using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
       is_convertible<_Tp, const volatile void*>,
       is_convertible<_Up, const volatile void*>>;
    };


  template<>
    struct less_equal<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) <= std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) <= std::forward<_Up>(__u))
 {
   return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
   __ptr_cmp<_Tp, _Up>{});
 }

      template<typename _Tp, typename _Up>
 constexpr bool
 operator()(_Tp* __t, _Up* __u) const noexcept
 { return less_equal<common_type_t<_Tp*, _Up*>>{}(__t, __u); }

      typedef __is_transparent is_transparent;

    private:
      template <typename _Tp, typename _Up>
 static constexpr decltype(auto)
 _S_cmp(_Tp&& __t, _Up&& __u, false_type)
 { return std::forward<_Tp>(__t) <= std::forward<_Up>(__u); }

      template <typename _Tp, typename _Up>
 static constexpr bool
 _S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
 {
   return less_equal<const volatile void*>{}(
       static_cast<const volatile void*>(std::forward<_Tp>(__t)),
       static_cast<const volatile void*>(std::forward<_Up>(__u)));
 }


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded2 : true_type { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded2<_Tp, _Up, __void_t<
   decltype(std::declval<_Tp>().operator<=(std::declval<_Up>()))>>
 : false_type { };


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded : __not_overloaded2<_Tp, _Up> { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded<_Tp, _Up, __void_t<
   decltype(operator<=(std::declval<_Tp>(), std::declval<_Up>()))>>
 : false_type { };

      template<typename _Tp, typename _Up>
 using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
       is_convertible<_Tp, const volatile void*>,
       is_convertible<_Up, const volatile void*>>;
    };
# 778 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_function.h" 3
  template<typename _Tp = void>
    struct logical_and;

  template<typename _Tp = void>
    struct logical_or;

  template<typename _Tp = void>
    struct logical_not;


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"


  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };
#pragma GCC diagnostic pop



  template<>
    struct logical_and<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) && std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) && std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) && std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct logical_or<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) || std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) || std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) || std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct logical_not<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(!std::forward<_Tp>(__t)))
 -> decltype(!std::forward<_Tp>(__t))
 { return !std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };




  template<typename _Tp = void>
    struct bit_and;

  template<typename _Tp = void>
    struct bit_or;

  template<typename _Tp = void>
    struct bit_xor;

  template<typename _Tp = void>
    struct bit_not;


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"



  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };

  template<typename _Tp>
    struct bit_not : public unary_function<_Tp, _Tp>
    {
    constexpr
      _Tp
      operator()(const _Tp& __x) const
      { return ~__x; }
    };
#pragma GCC diagnostic pop


  template <>
    struct bit_and<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) & std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) & std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) & std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_or<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) | std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) | std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) | std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_xor<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) ^ std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_not<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(~std::forward<_Tp>(__t)))
 -> decltype(~std::forward<_Tp>(__t))
 { return ~std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
# 1020 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_function.h" 3
  template<typename _Predicate>
    class [[__deprecated__]] unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      constexpr
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

      constexpr
      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>
    __attribute__ ((__deprecated__ ("use '" "std::not_fn" "' instead")))
    constexpr
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class [[__deprecated__]] binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      constexpr
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

      constexpr
      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>
    __attribute__ ((__deprecated__ ("use '" "std::not_fn" "' instead")))
    constexpr
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
# 1101 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    } __attribute__ ((__deprecated__));


  template<typename _Arg, typename _Result>
    __attribute__ ((__deprecated__ ("use '" "std::function" "' instead")))
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    } __attribute__ ((__deprecated__));


  template<typename _Arg1, typename _Arg2, typename _Result>
    __attribute__ ((__deprecated__ ("use '" "std::function" "' instead")))
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity
    : public unary_function<_Tp, _Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };


  template<typename _Tp> struct _Identity<const _Tp> : _Identity<_Tp> { };

  template<typename _Pair>
    struct _Select1st
    : public unary_function<_Pair, typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }


      template<typename _Pair2>
        typename _Pair2::first_type&
        operator()(_Pair2& __x) const
        { return __x.first; }

      template<typename _Pair2>
        const typename _Pair2::first_type&
        operator()(const _Pair2& __x) const
        { return __x.first; }

    };

  template<typename _Pair>
    struct _Select2nd
    : public unary_function<_Pair, typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
# 1228 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    } __attribute__ ((__deprecated__));


  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    } __attribute__ ((__deprecated__));


  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    } __attribute__ ((__deprecated__));


  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    } __attribute__ ((__deprecated__));


  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    } __attribute__ ((__deprecated__));


  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    } __attribute__ ((__deprecated__));


  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    } __attribute__ ((__deprecated__));


  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    } __attribute__ ((__deprecated__));



  template<typename _Ret, typename _Tp>
    __attribute__ ((__deprecated__ ("use '" "std::mem_fn" "' instead")))
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    __attribute__ ((__deprecated__ ("use '" "std::mem_fn" "' instead")))
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    __attribute__ ((__deprecated__ ("use '" "std::mem_fn" "' instead")))
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    __attribute__ ((__deprecated__ ("use '" "std::mem_fn" "' instead")))
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    __attribute__ ((__deprecated__ ("use '" "std::mem_fn" "' instead")))
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    __attribute__ ((__deprecated__ ("use '" "std::mem_fn" "' instead")))
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    __attribute__ ((__deprecated__ ("use '" "std::mem_fn" "' instead")))
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    __attribute__ ((__deprecated__ ("use '" "std::mem_fn" "' instead")))
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }
#pragma GCC diagnostic pop




  template<typename _Func, typename _SfinaeType, typename = __void_t<>>
    struct __has_is_transparent
    { };

  template<typename _Func, typename _SfinaeType>
    struct __has_is_transparent<_Func, _SfinaeType,
    __void_t<typename _Func::is_transparent>>
    { typedef void type; };

  template<typename _Func, typename _SfinaeType>
    using __has_is_transparent_t
      = typename __has_is_transparent<_Func, _SfinaeType>::type;



}


# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/backward/binders.h" 1 3
# 60 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/backward/binders.h" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

namespace std
{

# 107 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/backward/binders.h" 3
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } __attribute__ ((__deprecated__ ("use '" "std::bind" "' instead")));


  template<typename _Operation, typename _Tp>
    __attribute__ ((__deprecated__ ("use '" "std::bind" "' instead")))
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } __attribute__ ((__deprecated__ ("use '" "std::bind" "' instead")));


  template<typename _Operation, typename _Tp>
    __attribute__ ((__deprecated__ ("use '" "std::bind" "' instead")))
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }



}

#pragma GCC diagnostic pop
# 1436 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/stl_function.h" 2 3
# 38 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/hashtable.h" 2 3

# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/node_handle.h" 1 3
# 34 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/node_handle.h" 3
       
# 35 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/node_handle.h" 3

# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 1 3
# 47 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 3
       
# 48 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 3
# 37 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/node_handle.h" 2 3







namespace std
{

# 64 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/node_handle.h" 3
  template<typename _Val, typename _NodeAlloc>
    class _Node_handle_common
    {
      using _AllocTraits = allocator_traits<_NodeAlloc>;

    public:
      using allocator_type = __alloc_rebind<_NodeAlloc, _Val>;

      allocator_type
      get_allocator() const noexcept
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(!this->empty()), false)) std::__glibcxx_assert_fail(); } while (false);
 return allocator_type(_M_alloc._M_alloc);
      }

      explicit operator bool() const noexcept { return _M_ptr != nullptr; }

      [[nodiscard]] bool empty() const noexcept { return _M_ptr == nullptr; }


    protected:
      constexpr _Node_handle_common() noexcept : _M_ptr() { }

      ~_Node_handle_common()
      {
 if (!empty())
   _M_reset();
      }

      _Node_handle_common(_Node_handle_common&& __nh) noexcept
      : _M_ptr(__nh._M_ptr)
      {
 if (_M_ptr)
   _M_move(std::move(__nh));
      }

      _Node_handle_common&
      operator=(_Node_handle_common&& __nh) noexcept
      {
 if (empty())
   {
     if (!__nh.empty())
       _M_move(std::move(__nh));
   }
 else if (__nh.empty())
   _M_reset();
 else
   {

     _AllocTraits::destroy(*_M_alloc, _M_ptr->_M_valptr());
     _AllocTraits::deallocate(*_M_alloc, _M_ptr, 1);

     _M_alloc = __nh._M_alloc.release();
     _M_ptr = __nh._M_ptr;
     __nh._M_ptr = nullptr;
   }
 return *this;
      }

      _Node_handle_common(typename _AllocTraits::pointer __ptr,
     const _NodeAlloc& __alloc)
      : _M_ptr(__ptr), _M_alloc(__alloc)
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__ptr != nullptr), false)) std::__glibcxx_assert_fail(); } while (false);
      }

      void
      _M_swap(_Node_handle_common& __nh) noexcept
      {
 if (empty())
   {
     if (!__nh.empty())
       _M_move(std::move(__nh));
   }
 else if (__nh.empty())
   __nh._M_move(std::move(*this));
 else
   {
     using std::swap;
     swap(_M_ptr, __nh._M_ptr);
     _M_alloc.swap(__nh._M_alloc);
   }
      }

    private:



      void
      _M_move(_Node_handle_common&& __nh) noexcept
      {
 ::new (std::__addressof(_M_alloc)) _NodeAlloc(__nh._M_alloc.release());
 _M_ptr = __nh._M_ptr;
 __nh._M_ptr = nullptr;
      }




      void
      _M_reset() noexcept
      {
 _NodeAlloc __alloc = _M_alloc.release();
 _AllocTraits::destroy(__alloc, _M_ptr->_M_valptr());
 _AllocTraits::deallocate(__alloc, _M_ptr, 1);
 _M_ptr = nullptr;
      }




      void
      release() noexcept
      {
 _M_alloc.release();
 _M_ptr = nullptr;
      }

    protected:
      typename _AllocTraits::pointer _M_ptr;

    private:


      union _Optional_alloc
      {
 _Optional_alloc() { }
 ~_Optional_alloc() { }

 _Optional_alloc(_Optional_alloc&&) = delete;
 _Optional_alloc& operator=(_Optional_alloc&&) = delete;

 _Optional_alloc(const _NodeAlloc& __alloc) noexcept
 : _M_alloc(__alloc)
 { }


 void
 operator=(_NodeAlloc&& __alloc) noexcept
 {
   using _ATr = _AllocTraits;
   if constexpr (_ATr::propagate_on_container_move_assignment::value)
     _M_alloc = std::move(__alloc);
   else if constexpr (!_AllocTraits::is_always_equal::value)
     do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(_M_alloc == __alloc), false)) std::__glibcxx_assert_fail(); } while (false);
 }


 void
 swap(_Optional_alloc& __other) noexcept
 {
   using std::swap;
   if constexpr (_AllocTraits::propagate_on_container_swap::value)
     swap(_M_alloc, __other._M_alloc);
   else if constexpr (!_AllocTraits::is_always_equal::value)
     do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(_M_alloc == __other._M_alloc), false)) std::__glibcxx_assert_fail(); } while (false);
 }


 _NodeAlloc& operator*() noexcept { return _M_alloc; }


 _NodeAlloc release() noexcept
 {
   _NodeAlloc __tmp = std::move(_M_alloc);
   _M_alloc.~_NodeAlloc();
   return __tmp;
 }

 [[__no_unique_address__]] _NodeAlloc _M_alloc;
      };

      [[__no_unique_address__]] _Optional_alloc _M_alloc;

      template<typename _Key2, typename _Value2, typename _KeyOfValue,
        typename _Compare, typename _ValueAlloc>
 friend class _Rb_tree;

      template<typename _Key2, typename _Value2, typename _ValueAlloc,
        typename _ExtractKey, typename _Equal,
        typename _Hash, typename _RangeHash, typename _Unused,
        typename _RehashPolicy, typename _Traits>
 friend class _Hashtable;


    };


  template<typename _Key, typename _Value, typename _NodeAlloc>
    class _Node_handle : public _Node_handle_common<_Value, _NodeAlloc>
    {
    public:
      constexpr _Node_handle() noexcept = default;
      ~_Node_handle() = default;
      _Node_handle(_Node_handle&&) noexcept = default;

      _Node_handle&
      operator=(_Node_handle&&) noexcept = default;

      using key_type = _Key;
      using mapped_type = typename _Value::second_type;

      key_type&
      key() const noexcept
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(!this->empty()), false)) std::__glibcxx_assert_fail(); } while (false);
 return *_M_pkey;
      }

      mapped_type&
      mapped() const noexcept
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(!this->empty()), false)) std::__glibcxx_assert_fail(); } while (false);
 return *_M_pmapped;
      }

      void
      swap(_Node_handle& __nh) noexcept
      {
 this->_M_swap(__nh);
 using std::swap;
 swap(_M_pkey, __nh._M_pkey);
 swap(_M_pmapped, __nh._M_pmapped);
      }

      friend void
      swap(_Node_handle& __x, _Node_handle& __y)
      noexcept(noexcept(__x.swap(__y)))
      { __x.swap(__y); }

    private:
      using _AllocTraits = allocator_traits<_NodeAlloc>;

      _Node_handle(typename _AllocTraits::pointer __ptr,
     const _NodeAlloc& __alloc)
      : _Node_handle_common<_Value, _NodeAlloc>(__ptr, __alloc)
      {
 if (__ptr)
   {
     auto& __key = const_cast<_Key&>(__ptr->_M_valptr()->first);
     _M_pkey = _S_pointer_to(__key);
     _M_pmapped = _S_pointer_to(__ptr->_M_valptr()->second);
   }
 else
   {
     _M_pkey = nullptr;
     _M_pmapped = nullptr;
   }
      }

      template<typename _Tp>
 using __pointer
   = __ptr_rebind<typename _AllocTraits::pointer,
    remove_reference_t<_Tp>>;

      __pointer<_Key> _M_pkey = nullptr;
      __pointer<typename _Value::second_type> _M_pmapped = nullptr;

      template<typename _Tp>
 __pointer<_Tp>
 _S_pointer_to(_Tp& __obj)
 { return pointer_traits<__pointer<_Tp>>::pointer_to(__obj); }

      const key_type&
      _M_key() const noexcept { return key(); }

      template<typename _Key2, typename _Value2, typename _KeyOfValue,
        typename _Compare, typename _ValueAlloc>
 friend class _Rb_tree;

      template<typename _Key2, typename _Value2, typename _ValueAlloc,
        typename _ExtractKey, typename _Equal,
        typename _Hash, typename _RangeHash, typename _Unused,
        typename _RehashPolicy, typename _Traits>
 friend class _Hashtable;
    };


  template<typename _Value, typename _NodeAlloc>
    class _Node_handle<_Value, _Value, _NodeAlloc>
    : public _Node_handle_common<_Value, _NodeAlloc>
    {
    public:
      constexpr _Node_handle() noexcept = default;
      ~_Node_handle() = default;
      _Node_handle(_Node_handle&&) noexcept = default;

      _Node_handle&
      operator=(_Node_handle&&) noexcept = default;

      using value_type = _Value;

      value_type&
      value() const noexcept
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(!this->empty()), false)) std::__glibcxx_assert_fail(); } while (false);
 return *this->_M_ptr->_M_valptr();
      }

      void
      swap(_Node_handle& __nh) noexcept
      { this->_M_swap(__nh); }

      friend void
      swap(_Node_handle& __x, _Node_handle& __y)
      noexcept(noexcept(__x.swap(__y)))
      { __x.swap(__y); }

    private:
      using _AllocTraits = allocator_traits<_NodeAlloc>;

      _Node_handle(typename _AllocTraits::pointer __ptr,
     const _NodeAlloc& __alloc)
      : _Node_handle_common<_Value, _NodeAlloc>(__ptr, __alloc) { }

      const value_type&
      _M_key() const noexcept { return value(); }

      template<typename _Key, typename _Val, typename _KeyOfValue,
        typename _Compare, typename _Alloc>
 friend class _Rb_tree;

      template<typename _Key2, typename _Value2, typename _ValueAlloc,
        typename _ExtractKey, typename _Equal,
        typename _Hash, typename _RangeHash, typename _Unused,
        typename _RehashPolicy, typename _Traits>
 friend class _Hashtable;
    };


  template<typename _Iterator, typename _NodeHandle>
    struct _Node_insert_return
    {
      _Iterator position = _Iterator();
      bool inserted = false;
      _NodeHandle node;
    };




}
# 40 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/hashtable.h" 2 3


namespace std
{



  template<typename _Tp, typename _Hash>
    using __cache_default
      = __not_<__and_<
         __is_fast_hash<_Hash>,

         __is_nothrow_invocable<const _Hash&, const _Tp&>>>;




  template<typename _Equal, typename _Hash, typename _Allocator>
    using _Hashtable_enable_default_ctor
      = _Enable_default_constructor<__and_<is_default_constructible<_Equal>,
           is_default_constructible<_Hash>,
           is_default_constructible<_Allocator>>{},
        __detail::_Hash_node_base>;
# 181 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/hashtable.h" 3
  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    class _Hashtable
    : public __detail::_Hashtable_base<_Key, _Value, _ExtractKey, _Equal,
           _Hash, _RangeHash, _Unused, _Traits>,
      public __detail::_Map_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
     _Hash, _RangeHash, _Unused,
     _RehashPolicy, _Traits>,
      public __detail::_Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal,
          _Hash, _RangeHash, _Unused,
          _RehashPolicy, _Traits>,
      public __detail::_Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused,
        _RehashPolicy, _Traits>,
      public __detail::_Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
     _Hash, _RangeHash, _Unused,
     _RehashPolicy, _Traits>,
      private __detail::_Hashtable_alloc<
 __alloc_rebind<_Alloc,
         __detail::_Hash_node<_Value,
         _Traits::__hash_cached::value>>>,
      private _Hashtable_enable_default_ctor<_Equal, _Hash, _Alloc>
    {
      static_assert(is_same<typename remove_cv<_Value>::type, _Value>::value,
   "unordered container must have a non-const, non-volatile value_type");

      static_assert(is_same<typename _Alloc::value_type, _Value>{},
   "unordered container must have the same value_type as its allocator");


      using __traits_type = _Traits;
      using __hash_cached = typename __traits_type::__hash_cached;
      using __constant_iterators = typename __traits_type::__constant_iterators;
      using __node_type = __detail::_Hash_node<_Value, __hash_cached::value>;
      using __node_alloc_type = __alloc_rebind<_Alloc, __node_type>;

      using __hashtable_alloc = __detail::_Hashtable_alloc<__node_alloc_type>;

      using __node_value_type =
 __detail::_Hash_node_value<_Value, __hash_cached::value>;
      using __node_ptr = typename __hashtable_alloc::__node_ptr;
      using __value_alloc_traits =
 typename __hashtable_alloc::__value_alloc_traits;
      using __node_alloc_traits =
 typename __hashtable_alloc::__node_alloc_traits;
      using __node_base = typename __hashtable_alloc::__node_base;
      using __node_base_ptr = typename __hashtable_alloc::__node_base_ptr;
      using __buckets_ptr = typename __hashtable_alloc::__buckets_ptr;

      using __insert_base = __detail::_Insert<_Key, _Value, _Alloc, _ExtractKey,
           _Equal, _Hash,
           _RangeHash, _Unused,
           _RehashPolicy, _Traits>;
      using __enable_default_ctor
 = _Hashtable_enable_default_ctor<_Equal, _Hash, _Alloc>;
      using __rehash_guard_t
 = __detail::_RehashStateGuard<_RehashPolicy>;

    public:
      typedef _Key key_type;
      typedef _Value value_type;
      typedef _Alloc allocator_type;
      typedef _Equal key_equal;



      typedef typename __value_alloc_traits::pointer pointer;
      typedef typename __value_alloc_traits::const_pointer const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;

      using iterator = typename __insert_base::iterator;

      using const_iterator = typename __insert_base::const_iterator;

      using local_iterator = __detail::_Local_iterator<key_type, _Value,
   _ExtractKey, _Hash, _RangeHash, _Unused,
          __constant_iterators::value,
          __hash_cached::value>;

      using const_local_iterator = __detail::_Local_const_iterator<
   key_type, _Value,
   _ExtractKey, _Hash, _RangeHash, _Unused,
   __constant_iterators::value, __hash_cached::value>;

    private:
      using __rehash_type = _RehashPolicy;

      using __unique_keys = typename __traits_type::__unique_keys;

      using __hashtable_base = __detail::
 _Hashtable_base<_Key, _Value, _ExtractKey,
   _Equal, _Hash, _RangeHash, _Unused, _Traits>;

      using __hash_code_base = typename __hashtable_base::__hash_code_base;
      using __hash_code = typename __hashtable_base::__hash_code;
      using __ireturn_type = typename __insert_base::__ireturn_type;

      using __map_base = __detail::_Map_base<_Key, _Value, _Alloc, _ExtractKey,
          _Equal, _Hash, _RangeHash, _Unused,
          _RehashPolicy, _Traits>;

      using __rehash_base = __detail::_Rehash_base<_Key, _Value, _Alloc,
         _ExtractKey, _Equal,
         _Hash, _RangeHash, _Unused,
         _RehashPolicy, _Traits>;

      using __eq_base = __detail::_Equality<_Key, _Value, _Alloc, _ExtractKey,
         _Equal, _Hash, _RangeHash, _Unused,
         _RehashPolicy, _Traits>;

      using __reuse_or_alloc_node_gen_t =
 __detail::_ReuseOrAllocNode<__node_alloc_type>;
      using __alloc_node_gen_t =
 __detail::_AllocNode<__node_alloc_type>;
      using __node_builder_t =
 __detail::_NodeBuilder<_ExtractKey>;


      struct _Scoped_node
      {

 _Scoped_node(__node_ptr __n, __hashtable_alloc* __h)
 : _M_h(__h), _M_node(__n) { }


 template<typename... _Args>
   _Scoped_node(__hashtable_alloc* __h, _Args&&... __args)
   : _M_h(__h),
     _M_node(__h->_M_allocate_node(std::forward<_Args>(__args)...))
   { }


 ~_Scoped_node() { if (_M_node) _M_h->_M_deallocate_node(_M_node); };

 _Scoped_node(const _Scoped_node&) = delete;
 _Scoped_node& operator=(const _Scoped_node&) = delete;

 __hashtable_alloc* _M_h;
 __node_ptr _M_node;
      };

      template<typename _Ht>
 static constexpr
 __conditional_t<std::is_lvalue_reference<_Ht>::value,
   const value_type&, value_type&&>
 __fwd_value_for(value_type& __val) noexcept
 { return std::move(__val); }





      struct __hash_code_base_access : __hash_code_base
      { using __hash_code_base::_M_bucket_index; };


      static_assert(is_nothrow_default_constructible<_RangeHash>::value,
      "Functor used to map hash code to bucket index"
      " must be nothrow default constructible");
      static_assert(noexcept(
 std::declval<const _RangeHash&>()((std::size_t)0, (std::size_t)0)),
      "Functor used to map hash code to bucket index must be"
      " noexcept");


      static_assert(is_nothrow_default_constructible<_ExtractKey>::value,
      "_ExtractKey must be nothrow default constructible");
      static_assert(noexcept(
 std::declval<const _ExtractKey&>()(std::declval<_Value>())),
      "_ExtractKey functor must be noexcept invocable");

      template<typename _Keya, typename _Valuea, typename _Alloca,
        typename _ExtractKeya, typename _Equala,
        typename _Hasha, typename _RangeHasha, typename _Unuseda,
        typename _RehashPolicya, typename _Traitsa,
        bool _Unique_keysa>
 friend struct __detail::_Map_base;

      template<typename _Keya, typename _Valuea, typename _Alloca,
        typename _ExtractKeya, typename _Equala,
        typename _Hasha, typename _RangeHasha, typename _Unuseda,
        typename _RehashPolicya, typename _Traitsa>
 friend struct __detail::_Insert_base;

      template<typename _Keya, typename _Valuea, typename _Alloca,
        typename _ExtractKeya, typename _Equala,
        typename _Hasha, typename _RangeHasha, typename _Unuseda,
        typename _RehashPolicya, typename _Traitsa,
        bool _Constant_iteratorsa>
 friend struct __detail::_Insert;

      template<typename _Keya, typename _Valuea, typename _Alloca,
        typename _ExtractKeya, typename _Equala,
        typename _Hasha, typename _RangeHasha, typename _Unuseda,
        typename _RehashPolicya, typename _Traitsa,
        bool _Unique_keysa>
 friend struct __detail::_Equality;

    public:
      using size_type = typename __hashtable_base::size_type;
      using difference_type = typename __hashtable_base::difference_type;


      using node_type = _Node_handle<_Key, _Value, __node_alloc_type>;
      using insert_return_type = _Node_insert_return<iterator, node_type>;


    private:
      __buckets_ptr _M_buckets = &_M_single_bucket;
      size_type _M_bucket_count = 1;
      __node_base _M_before_begin;
      size_type _M_element_count = 0;
      _RehashPolicy _M_rehash_policy;







      __node_base_ptr _M_single_bucket = nullptr;

      void
      _M_update_bbegin()
      {
 if (auto __begin = _M_begin())
   _M_buckets[_M_bucket_index(*__begin)] = &_M_before_begin;
      }

      void
      _M_update_bbegin(__node_ptr __n)
      {
 _M_before_begin._M_nxt = __n;
 _M_update_bbegin();
      }

      bool
      _M_uses_single_bucket(__buckets_ptr __bkts) const
      { return __builtin_expect(__bkts == &_M_single_bucket, false); }

      bool
      _M_uses_single_bucket() const
      { return _M_uses_single_bucket(_M_buckets); }

      static constexpr size_t
      __small_size_threshold() noexcept
      {
 return
   __detail::_Hashtable_hash_traits<_Hash>::__small_size_threshold();
      }

      __hashtable_alloc&
      _M_base_alloc() { return *this; }

      __buckets_ptr
      _M_allocate_buckets(size_type __bkt_count)
      {
 if (__builtin_expect(__bkt_count == 1, false))
   {
     _M_single_bucket = nullptr;
     return &_M_single_bucket;
   }

 return __hashtable_alloc::_M_allocate_buckets(__bkt_count);
      }

      void
      _M_deallocate_buckets(__buckets_ptr __bkts, size_type __bkt_count)
      {
 if (_M_uses_single_bucket(__bkts))
   return;

 __hashtable_alloc::_M_deallocate_buckets(__bkts, __bkt_count);
      }

      void
      _M_deallocate_buckets()
      { _M_deallocate_buckets(_M_buckets, _M_bucket_count); }



      __node_ptr
      _M_bucket_begin(size_type __bkt) const
      {
 __node_base_ptr __n = _M_buckets[__bkt];
 return __n ? static_cast<__node_ptr>(__n->_M_nxt) : nullptr;
      }

      __node_ptr
      _M_begin() const
      { return static_cast<__node_ptr>(_M_before_begin._M_nxt); }



      template<typename _Ht>
 void
 _M_assign_elements(_Ht&&);

      template<typename _Ht, typename _NodeGenerator>
 void
 _M_assign(_Ht&&, const _NodeGenerator&);

      void
      _M_move_assign(_Hashtable&&, true_type);

      void
      _M_move_assign(_Hashtable&&, false_type);

      void
      _M_reset() noexcept;

      _Hashtable(const _Hash& __h, const _Equal& __eq,
   const allocator_type& __a)
      : __hashtable_base(__h, __eq),
 __hashtable_alloc(__node_alloc_type(__a)),
 __enable_default_ctor(_Enable_default_constructor_tag{})
      { }

      template<bool _No_realloc = true>
 static constexpr bool
 _S_nothrow_move()
 {





   if constexpr (_No_realloc)
     if constexpr (is_nothrow_copy_constructible<_Hash>())
       return is_nothrow_copy_constructible<_Equal>();
   return false;

 }

      _Hashtable(_Hashtable&& __ht, __node_alloc_type&& __a,
   true_type )
 noexcept(_S_nothrow_move());

      _Hashtable(_Hashtable&&, __node_alloc_type&&,
   false_type );

      template<typename _InputIterator>
 _Hashtable(_InputIterator __first, _InputIterator __last,
     size_type __bkt_count_hint,
     const _Hash&, const _Equal&, const allocator_type&,
     true_type __uks);

      template<typename _InputIterator>
 _Hashtable(_InputIterator __first, _InputIterator __last,
     size_type __bkt_count_hint,
     const _Hash&, const _Equal&, const allocator_type&,
     false_type __uks);

    public:

      _Hashtable() = default;

      _Hashtable(const _Hashtable&);

      _Hashtable(const _Hashtable&, const allocator_type&);

      explicit
      _Hashtable(size_type __bkt_count_hint,
   const _Hash& __hf = _Hash(),
   const key_equal& __eql = key_equal(),
   const allocator_type& __a = allocator_type());


      _Hashtable(_Hashtable&& __ht)
 noexcept(_S_nothrow_move())
      : _Hashtable(std::move(__ht), std::move(__ht._M_node_allocator()),
     true_type{})
      { }

      _Hashtable(_Hashtable&& __ht, const allocator_type& __a)
 noexcept(_S_nothrow_move<__node_alloc_traits::_S_always_equal()>())
      : _Hashtable(std::move(__ht), __node_alloc_type(__a),
     typename __node_alloc_traits::is_always_equal{})
      { }

      explicit
      _Hashtable(const allocator_type& __a)
      : __hashtable_alloc(__node_alloc_type(__a)),
 __enable_default_ctor(_Enable_default_constructor_tag{})
      { }

      template<typename _InputIterator>
 _Hashtable(_InputIterator __f, _InputIterator __l,
     size_type __bkt_count_hint = 0,
     const _Hash& __hf = _Hash(),
     const key_equal& __eql = key_equal(),
     const allocator_type& __a = allocator_type())
 : _Hashtable(__f, __l, __bkt_count_hint, __hf, __eql, __a,
       __unique_keys{})
 { }

      _Hashtable(initializer_list<value_type> __l,
   size_type __bkt_count_hint = 0,
   const _Hash& __hf = _Hash(),
   const key_equal& __eql = key_equal(),
   const allocator_type& __a = allocator_type())
      : _Hashtable(__l.begin(), __l.end(), __bkt_count_hint,
     __hf, __eql, __a, __unique_keys{})
      { }

      _Hashtable&
      operator=(const _Hashtable& __ht);

      _Hashtable&
      operator=(_Hashtable&& __ht)
      noexcept(__node_alloc_traits::_S_nothrow_move()
        && is_nothrow_move_assignable<_Hash>::value
        && is_nothrow_move_assignable<_Equal>::value)
      {
 constexpr bool __move_storage =
   __node_alloc_traits::_S_propagate_on_move_assign()
   || __node_alloc_traits::_S_always_equal();
 _M_move_assign(std::move(__ht), __bool_constant<__move_storage>());
 return *this;
      }

      _Hashtable&
      operator=(initializer_list<value_type> __l)
      {
 __reuse_or_alloc_node_gen_t __roan(_M_begin(), *this);
 _M_before_begin._M_nxt = nullptr;
 clear();


 auto __l_bkt_count = _M_rehash_policy._M_bkt_for_elements(__l.size());


 if (_M_bucket_count < __l_bkt_count)
   rehash(__l_bkt_count);

 this->_M_insert_range(__l.begin(), __l.end(), __roan, __unique_keys{});
 return *this;
      }

      ~_Hashtable() noexcept;

      void
      swap(_Hashtable&)
      noexcept(__and_<__is_nothrow_swappable<_Hash>,
        __is_nothrow_swappable<_Equal>>::value);


      iterator
      begin() noexcept
      { return iterator(_M_begin()); }

      const_iterator
      begin() const noexcept
      { return const_iterator(_M_begin()); }

      iterator
      end() noexcept
      { return iterator(nullptr); }

      const_iterator
      end() const noexcept
      { return const_iterator(nullptr); }

      const_iterator
      cbegin() const noexcept
      { return const_iterator(_M_begin()); }

      const_iterator
      cend() const noexcept
      { return const_iterator(nullptr); }

      size_type
      size() const noexcept
      { return _M_element_count; }

      [[__nodiscard__]] bool
      empty() const noexcept
      { return size() == 0; }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(this->_M_node_allocator()); }

      size_type
      max_size() const noexcept
      { return __node_alloc_traits::max_size(this->_M_node_allocator()); }


      key_equal
      key_eq() const
      { return this->_M_eq(); }




      size_type
      bucket_count() const noexcept
      { return _M_bucket_count; }

      size_type
      max_bucket_count() const noexcept
      { return max_size(); }

      size_type
      bucket_size(size_type __bkt) const
      { return std::distance(begin(__bkt), end(__bkt)); }

      size_type
      bucket(const key_type& __k) const
      { return _M_bucket_index(this->_M_hash_code(__k)); }

      local_iterator
      begin(size_type __bkt)
      {
 return local_iterator(*this, _M_bucket_begin(__bkt),
         __bkt, _M_bucket_count);
      }

      local_iterator
      end(size_type __bkt)
      { return local_iterator(*this, nullptr, __bkt, _M_bucket_count); }

      const_local_iterator
      begin(size_type __bkt) const
      {
 return const_local_iterator(*this, _M_bucket_begin(__bkt),
        __bkt, _M_bucket_count);
      }

      const_local_iterator
      end(size_type __bkt) const
      { return const_local_iterator(*this, nullptr, __bkt, _M_bucket_count); }


      const_local_iterator
      cbegin(size_type __bkt) const
      {
 return const_local_iterator(*this, _M_bucket_begin(__bkt),
        __bkt, _M_bucket_count);
      }

      const_local_iterator
      cend(size_type __bkt) const
      { return const_local_iterator(*this, nullptr, __bkt, _M_bucket_count); }

      float
      load_factor() const noexcept
      {
 return static_cast<float>(size()) / static_cast<float>(bucket_count());
      }






      const _RehashPolicy&
      __rehash_policy() const
      { return _M_rehash_policy; }

      void
      __rehash_policy(const _RehashPolicy& __pol)
      { _M_rehash_policy = __pol; }


      iterator
      find(const key_type& __k);

      const_iterator
      find(const key_type& __k) const;

      size_type
      count(const key_type& __k) const;

      std::pair<iterator, iterator>
      equal_range(const key_type& __k);

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __k) const;


      template<typename _Kt,
        typename = __has_is_transparent_t<_Hash, _Kt>,
        typename = __has_is_transparent_t<_Equal, _Kt>>
 iterator
 _M_find_tr(const _Kt& __k);

      template<typename _Kt,
        typename = __has_is_transparent_t<_Hash, _Kt>,
        typename = __has_is_transparent_t<_Equal, _Kt>>
 const_iterator
 _M_find_tr(const _Kt& __k) const;

      template<typename _Kt,
        typename = __has_is_transparent_t<_Hash, _Kt>,
        typename = __has_is_transparent_t<_Equal, _Kt>>
 size_type
 _M_count_tr(const _Kt& __k) const;

      template<typename _Kt,
        typename = __has_is_transparent_t<_Hash, _Kt>,
        typename = __has_is_transparent_t<_Equal, _Kt>>
 pair<iterator, iterator>
 _M_equal_range_tr(const _Kt& __k);

      template<typename _Kt,
        typename = __has_is_transparent_t<_Hash, _Kt>,
        typename = __has_is_transparent_t<_Equal, _Kt>>
 pair<const_iterator, const_iterator>
 _M_equal_range_tr(const _Kt& __k) const;


    private:

      size_type
      _M_bucket_index(const __node_value_type& __n) const noexcept
      { return __hash_code_base::_M_bucket_index(__n, _M_bucket_count); }

      size_type
      _M_bucket_index(__hash_code __c) const
      { return __hash_code_base::_M_bucket_index(__c, _M_bucket_count); }

      __node_base_ptr
      _M_find_before_node(const key_type&);



      __node_base_ptr
      _M_find_before_node(size_type, const key_type&, __hash_code) const;

      template<typename _Kt>
 __node_base_ptr
 _M_find_before_node_tr(size_type, const _Kt&, __hash_code) const;

      __node_ptr
      _M_find_node(size_type __bkt, const key_type& __key,
     __hash_code __c) const
      {
 __node_base_ptr __before_n = _M_find_before_node(__bkt, __key, __c);
 if (__before_n)
   return static_cast<__node_ptr>(__before_n->_M_nxt);
 return nullptr;
      }

      template<typename _Kt>
 __node_ptr
 _M_find_node_tr(size_type __bkt, const _Kt& __key,
   __hash_code __c) const
 {
   auto __before_n = _M_find_before_node_tr(__bkt, __key, __c);
   if (__before_n)
     return static_cast<__node_ptr>(__before_n->_M_nxt);
   return nullptr;
 }


      void
      _M_insert_bucket_begin(size_type __bkt, __node_ptr __node)
      {
 if (_M_buckets[__bkt])
   {


     __node->_M_nxt = _M_buckets[__bkt]->_M_nxt;
     _M_buckets[__bkt]->_M_nxt = __node;
   }
 else
   {



     __node->_M_nxt = _M_before_begin._M_nxt;
     _M_before_begin._M_nxt = __node;

     if (__node->_M_nxt)


       _M_buckets[_M_bucket_index(*__node->_M_next())] = __node;

     _M_buckets[__bkt] = &_M_before_begin;
   }
      }


      void
      _M_remove_bucket_begin(size_type __bkt, __node_ptr __next_n,
        size_type __next_bkt)
      {
 if (!__next_n)
   _M_buckets[__bkt] = nullptr;
 else if (__next_bkt != __bkt)
   {
     _M_buckets[__next_bkt] = _M_buckets[__bkt];
     _M_buckets[__bkt] = nullptr;
   }
      }


      __node_base_ptr
      _M_get_previous_node(size_type __bkt, __node_ptr __n);

      pair<__node_ptr, __hash_code>
      _M_compute_hash_code(__node_ptr __hint, const key_type& __k) const;




      iterator
      _M_insert_unique_node(size_type __bkt, __hash_code,
       __node_ptr __n, size_type __n_elt = 1);



      iterator
      _M_insert_multi_node(__node_ptr __hint,
      __hash_code __code, __node_ptr __n);

      template<typename... _Args>
 std::pair<iterator, bool>
 _M_emplace(true_type __uks, _Args&&... __args);

      template<typename... _Args>
 iterator
 _M_emplace(false_type __uks, _Args&&... __args)
 { return _M_emplace(cend(), __uks, std::forward<_Args>(__args)...); }


      template<typename... _Args>
 iterator
 _M_emplace(const_iterator, true_type __uks, _Args&&... __args)
 { return _M_emplace(__uks, std::forward<_Args>(__args)...).first; }

      template<typename... _Args>
 iterator
 _M_emplace(const_iterator, false_type __uks, _Args&&... __args);

      template<typename _Kt, typename _Arg, typename _NodeGenerator>
 std::pair<iterator, bool>
 _M_insert_unique(_Kt&&, _Arg&&, const _NodeGenerator&);

      template<typename _Kt>
 static __conditional_t<
   __and_<__is_nothrow_invocable<_Hash&, const key_type&>,
   __not_<__is_nothrow_invocable<_Hash&, _Kt>>>::value,
   key_type, _Kt&&>
 _S_forward_key(_Kt&& __k)
 { return std::forward<_Kt>(__k); }

      static const key_type&
      _S_forward_key(const key_type& __k)
      { return __k; }

      static key_type&&
      _S_forward_key(key_type&& __k)
      { return std::move(__k); }

      template<typename _Arg, typename _NodeGenerator>
 std::pair<iterator, bool>
 _M_insert_unique_aux(_Arg&& __arg, const _NodeGenerator& __node_gen)
 {
   return _M_insert_unique(
     _S_forward_key(_ExtractKey{}(std::forward<_Arg>(__arg))),
     std::forward<_Arg>(__arg), __node_gen);
 }

      template<typename _Arg, typename _NodeGenerator>
 std::pair<iterator, bool>
 _M_insert(_Arg&& __arg, const _NodeGenerator& __node_gen,
    true_type )
 {
   using __to_value
     = __detail::_ConvertToValueType<_ExtractKey, value_type>;
   return _M_insert_unique_aux(
     __to_value{}(std::forward<_Arg>(__arg)), __node_gen);
 }

      template<typename _Arg, typename _NodeGenerator>
 iterator
 _M_insert(_Arg&& __arg, const _NodeGenerator& __node_gen,
    false_type __uks)
 {
   using __to_value
     = __detail::_ConvertToValueType<_ExtractKey, value_type>;
   return _M_insert(cend(),
     __to_value{}(std::forward<_Arg>(__arg)), __node_gen, __uks);
 }


      template<typename _Arg, typename _NodeGenerator>
 iterator
 _M_insert(const_iterator, _Arg&& __arg,
    const _NodeGenerator& __node_gen, true_type __uks)
 {
   return
     _M_insert(std::forward<_Arg>(__arg), __node_gen, __uks).first;
 }


      template<typename _Arg, typename _NodeGenerator>
 iterator
 _M_insert(const_iterator, _Arg&&,
    const _NodeGenerator&, false_type __uks);

      size_type
      _M_erase(true_type __uks, const key_type&);

      size_type
      _M_erase(false_type __uks, const key_type&);

      iterator
      _M_erase(size_type __bkt, __node_base_ptr __prev_n, __node_ptr __n);

    public:

      template<typename... _Args>
 __ireturn_type
 emplace(_Args&&... __args)
 { return _M_emplace(__unique_keys{}, std::forward<_Args>(__args)...); }

      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __hint, _Args&&... __args)
 {
   return _M_emplace(__hint, __unique_keys{},
       std::forward<_Args>(__args)...);
 }




      iterator
      erase(const_iterator);


      iterator
      erase(iterator __it)
      { return erase(const_iterator(__it)); }

      size_type
      erase(const key_type& __k)
      { return _M_erase(__unique_keys{}, __k); }

      iterator
      erase(const_iterator, const_iterator);

      void
      clear() noexcept;



      void rehash(size_type __bkt_count);






      insert_return_type
      _M_reinsert_node(node_type&& __nh)
      {
 insert_return_type __ret;
 if (__nh.empty())
   __ret.position = end();
 else
   {
     do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(get_allocator() == __nh.get_allocator()), false)) std::__glibcxx_assert_fail(); } while (false);

     __node_ptr __n = nullptr;
     const key_type& __k = __nh._M_key();
     const size_type __size = size();
     if (__size <= __small_size_threshold())
       {
  for (__n = _M_begin(); __n; __n = __n->_M_next())
    if (this->_M_key_equals(__k, *__n))
      break;
       }

     __hash_code __code;
     size_type __bkt;
     if (!__n)
       {
  __code = this->_M_hash_code(__k);
  __bkt = _M_bucket_index(__code);
  if (__size > __small_size_threshold())
    __n = _M_find_node(__bkt, __k, __code);
       }

     if (__n)
       {
  __ret.node = std::move(__nh);
  __ret.position = iterator(__n);
  __ret.inserted = false;
       }
     else
       {
  __ret.position
    = _M_insert_unique_node(__bkt, __code, __nh._M_ptr);
  __nh.release();
  __ret.inserted = true;
       }
   }
 return __ret;
      }


      iterator
      _M_reinsert_node_multi(const_iterator __hint, node_type&& __nh)
      {
 if (__nh.empty())
   return end();

 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(get_allocator() == __nh.get_allocator()), false)) std::__glibcxx_assert_fail(); } while (false);

 const key_type& __k = __nh._M_key();
 auto __code = this->_M_hash_code(__k);
 auto __ret
   = _M_insert_multi_node(__hint._M_cur, __code, __nh._M_ptr);
 __nh.release();
 return __ret;
      }

    private:
      node_type
      _M_extract_node(size_t __bkt, __node_base_ptr __prev_n)
      {
 __node_ptr __n = static_cast<__node_ptr>(__prev_n->_M_nxt);
 if (__prev_n == _M_buckets[__bkt])
   _M_remove_bucket_begin(__bkt, __n->_M_next(),
      __n->_M_nxt ? _M_bucket_index(*__n->_M_next()) : 0);
 else if (__n->_M_nxt)
   {
     size_type __next_bkt = _M_bucket_index(*__n->_M_next());
     if (__next_bkt != __bkt)
       _M_buckets[__next_bkt] = __prev_n;
   }

 __prev_n->_M_nxt = __n->_M_nxt;
 __n->_M_nxt = nullptr;
 --_M_element_count;
 return { __n, this->_M_node_allocator() };
      }



      template<typename _H2>
 __hash_code
 _M_src_hash_code(const _H2&, const key_type& __k,
    const __node_value_type& __src_n) const
 {
   if constexpr (std::is_same_v<_H2, _Hash>)
     if constexpr (std::is_empty_v<_Hash>)
       return this->_M_hash_code(__src_n);

   return this->_M_hash_code(__k);
 }

    public:

      node_type
      extract(const_iterator __pos)
      {
 size_t __bkt = _M_bucket_index(*__pos._M_cur);
 return _M_extract_node(__bkt,
          _M_get_previous_node(__bkt, __pos._M_cur));
      }


      node_type
      extract(const _Key& __k)
      {
 node_type __nh;
 __hash_code __code = this->_M_hash_code(__k);
 std::size_t __bkt = _M_bucket_index(__code);
 if (__node_base_ptr __prev_node = _M_find_before_node(__bkt, __k, __code))
   __nh = _M_extract_node(__bkt, __prev_node);
 return __nh;
      }


      template<typename _Compatible_Hashtable>
 void
 _M_merge_unique(_Compatible_Hashtable& __src)
 {
   static_assert(is_same_v<typename _Compatible_Hashtable::node_type,
       node_type>, "Node types are compatible");
   do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(get_allocator() == __src.get_allocator()), false)) std::__glibcxx_assert_fail(); } while (false);

   auto __n_elt = __src.size();
   for (auto __i = __src.cbegin(), __end = __src.cend(); __i != __end;)
     {
       auto __pos = __i++;
       const size_type __size = size();
       const key_type& __k = _ExtractKey{}(*__pos);
       if (__size <= __small_size_threshold())
  {
    bool __found = false;
    for (auto __n = _M_begin(); __n; __n = __n->_M_next())
      if (this->_M_key_equals(__k, *__n))
        {
   __found = true;
   break;
        }

    if (__found)
      {
        if (__n_elt != 1)
   --__n_elt;
        continue;
      }
  }

       __hash_code __code
  = _M_src_hash_code(__src.hash_function(), __k, *__pos._M_cur);
       size_type __bkt = _M_bucket_index(__code);
       if (__size <= __small_size_threshold()
    || _M_find_node(__bkt, __k, __code) == nullptr)
  {
    auto __nh = __src.extract(__pos);
    _M_insert_unique_node(__bkt, __code, __nh._M_ptr, __n_elt);
    __nh.release();
    __n_elt = 1;
  }
       else if (__n_elt != 1)
  --__n_elt;
     }
 }


      template<typename _Compatible_Hashtable>
 void
 _M_merge_multi(_Compatible_Hashtable& __src)
 {
   static_assert(is_same_v<typename _Compatible_Hashtable::node_type,
       node_type>, "Node types are compatible");
   do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(get_allocator() == __src.get_allocator()), false)) std::__glibcxx_assert_fail(); } while (false);

   __node_ptr __hint = nullptr;
   this->reserve(size() + __src.size());
   for (auto __i = __src.cbegin(), __end = __src.cend(); __i != __end;)
     {
       auto __pos = __i++;
       const key_type& __k = _ExtractKey{}(*__pos);
       __hash_code __code
  = _M_src_hash_code(__src.hash_function(), __k, *__pos._M_cur);
       auto __nh = __src.extract(__pos);
       __hint = _M_insert_multi_node(__hint, __code, __nh._M_ptr)._M_cur;
       __nh.release();
     }
 }


    private:

      void _M_rehash(size_type __bkt_count, true_type __uks);


      void _M_rehash(size_type __bkt_count, false_type __uks);
    };


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    _Hashtable(size_type __bkt_count_hint,
        const _Hash& __h, const _Equal& __eq, const allocator_type& __a)
    : _Hashtable(__h, __eq, __a)
    {
      auto __bkt_count = _M_rehash_policy._M_next_bkt(__bkt_count_hint);
      if (__bkt_count > _M_bucket_count)
 {
   _M_buckets = _M_allocate_buckets(__bkt_count);
   _M_bucket_count = __bkt_count;
 }
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    template<typename _InputIterator>
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
      _Hashtable(_InputIterator __f, _InputIterator __l,
   size_type __bkt_count_hint,
   const _Hash& __h, const _Equal& __eq,
   const allocator_type& __a, true_type )
      : _Hashtable(__bkt_count_hint, __h, __eq, __a)
      { this->insert(__f, __l); }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    template<typename _InputIterator>
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
      _Hashtable(_InputIterator __f, _InputIterator __l,
   size_type __bkt_count_hint,
   const _Hash& __h, const _Equal& __eq,
   const allocator_type& __a, false_type __uks)
      : _Hashtable(__h, __eq, __a)
      {
 auto __nb_elems = __detail::__distance_fw(__f, __l);
 auto __bkt_count =
   _M_rehash_policy._M_next_bkt(
     std::max(_M_rehash_policy._M_bkt_for_elements(__nb_elems),
       __bkt_count_hint));

 if (__bkt_count > _M_bucket_count)
   {
     _M_buckets = _M_allocate_buckets(__bkt_count);
     _M_bucket_count = __bkt_count;
   }

 __alloc_node_gen_t __node_gen(*this);
 for (; __f != __l; ++__f)
   _M_insert(*__f, __node_gen, __uks);
      }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    operator=(const _Hashtable& __ht)
    -> _Hashtable&
    {
      if (&__ht == this)
 return *this;

      if (__node_alloc_traits::_S_propagate_on_copy_assign())
 {
   auto& __this_alloc = this->_M_node_allocator();
   auto& __that_alloc = __ht._M_node_allocator();
   if (!__node_alloc_traits::_S_always_equal()
       && __this_alloc != __that_alloc)
     {

       this->_M_deallocate_nodes(_M_begin());
       _M_before_begin._M_nxt = nullptr;
       _M_deallocate_buckets();
       _M_buckets = nullptr;
       std::__alloc_on_copy(__this_alloc, __that_alloc);
       __hashtable_base::operator=(__ht);
       _M_bucket_count = __ht._M_bucket_count;
       _M_element_count = __ht._M_element_count;
       _M_rehash_policy = __ht._M_rehash_policy;
       __alloc_node_gen_t __alloc_node_gen(*this);
       try
  {
    _M_assign(__ht, __alloc_node_gen);
  }
       catch(...)
  {


    _M_reset();
    throw;
  }
       return *this;
     }
   std::__alloc_on_copy(__this_alloc, __that_alloc);
 }


      _M_assign_elements(__ht);
      return *this;
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    template<typename _Ht>
      void
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
      _M_assign_elements(_Ht&& __ht)
      {
 __buckets_ptr __former_buckets = nullptr;
 std::size_t __former_bucket_count = _M_bucket_count;
 __rehash_guard_t __rehash_guard(_M_rehash_policy);

 if (_M_bucket_count != __ht._M_bucket_count)
   {
     __former_buckets = _M_buckets;
     _M_buckets = _M_allocate_buckets(__ht._M_bucket_count);
     _M_bucket_count = __ht._M_bucket_count;
   }
 else
   __builtin_memset(_M_buckets, 0,
      _M_bucket_count * sizeof(__node_base_ptr));

 try
   {
     __hashtable_base::operator=(std::forward<_Ht>(__ht));
     _M_element_count = __ht._M_element_count;
     _M_rehash_policy = __ht._M_rehash_policy;
     __reuse_or_alloc_node_gen_t __roan(_M_begin(), *this);
     _M_before_begin._M_nxt = nullptr;
     _M_assign(std::forward<_Ht>(__ht), __roan);
     if (__former_buckets)
       _M_deallocate_buckets(__former_buckets, __former_bucket_count);
     __rehash_guard._M_guarded_obj = nullptr;
   }
 catch(...)
   {
     if (__former_buckets)
       {

  _M_deallocate_buckets();
  _M_buckets = __former_buckets;
  _M_bucket_count = __former_bucket_count;
       }
     __builtin_memset(_M_buckets, 0,
        _M_bucket_count * sizeof(__node_base_ptr));
     throw;
   }
      }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    template<typename _Ht, typename _NodeGenerator>
      void
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
      _M_assign(_Ht&& __ht, const _NodeGenerator& __node_gen)
      {
 __buckets_ptr __buckets = nullptr;
 if (!_M_buckets)
   _M_buckets = __buckets = _M_allocate_buckets(_M_bucket_count);

 try
   {
     if (!__ht._M_before_begin._M_nxt)
       return;



     __node_ptr __ht_n = __ht._M_begin();
     __node_ptr __this_n
       = __node_gen(__fwd_value_for<_Ht>(__ht_n->_M_v()));
     this->_M_copy_code(*__this_n, *__ht_n);
     _M_update_bbegin(__this_n);


     __node_ptr __prev_n = __this_n;
     for (__ht_n = __ht_n->_M_next(); __ht_n; __ht_n = __ht_n->_M_next())
       {
  __this_n = __node_gen(__fwd_value_for<_Ht>(__ht_n->_M_v()));
  __prev_n->_M_nxt = __this_n;
  this->_M_copy_code(*__this_n, *__ht_n);
  size_type __bkt = _M_bucket_index(*__this_n);
  if (!_M_buckets[__bkt])
    _M_buckets[__bkt] = __prev_n;
  __prev_n = __this_n;
       }
   }
 catch(...)
   {
     clear();
     if (__buckets)
       _M_deallocate_buckets();
     throw;
   }
      }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    _M_reset() noexcept
    {
      _M_rehash_policy._M_reset();
      _M_bucket_count = 1;
      _M_single_bucket = nullptr;
      _M_buckets = &_M_single_bucket;
      _M_before_begin._M_nxt = nullptr;
      _M_element_count = 0;
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    _M_move_assign(_Hashtable&& __ht, true_type)
    {
      if (__builtin_expect(std::__addressof(__ht) == this, false))
 return;

      this->_M_deallocate_nodes(_M_begin());
      _M_deallocate_buckets();
      __hashtable_base::operator=(std::move(__ht));
      _M_rehash_policy = __ht._M_rehash_policy;
      if (!__ht._M_uses_single_bucket())
 _M_buckets = __ht._M_buckets;
      else
 {
   _M_buckets = &_M_single_bucket;
   _M_single_bucket = __ht._M_single_bucket;
 }

      _M_bucket_count = __ht._M_bucket_count;
      _M_before_begin._M_nxt = __ht._M_before_begin._M_nxt;
      _M_element_count = __ht._M_element_count;
      std::__alloc_on_move(this->_M_node_allocator(), __ht._M_node_allocator());


      _M_update_bbegin();
      __ht._M_reset();
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    _M_move_assign(_Hashtable&& __ht, false_type)
    {
      if (__ht._M_node_allocator() == this->_M_node_allocator())
 _M_move_assign(std::move(__ht), true_type{});
      else
 {

   _M_assign_elements(std::move(__ht));
   __ht.clear();
 }
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    _Hashtable(const _Hashtable& __ht)
    : __hashtable_base(__ht),
      __map_base(__ht),
      __rehash_base(__ht),
      __hashtable_alloc(
 __node_alloc_traits::_S_select_on_copy(__ht._M_node_allocator())),
      __enable_default_ctor(__ht),
      _M_buckets(nullptr),
      _M_bucket_count(__ht._M_bucket_count),
      _M_element_count(__ht._M_element_count),
      _M_rehash_policy(__ht._M_rehash_policy)
    {
      __alloc_node_gen_t __alloc_node_gen(*this);
      _M_assign(__ht, __alloc_node_gen);
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    _Hashtable(_Hashtable&& __ht, __node_alloc_type&& __a,
        true_type )
    noexcept(_S_nothrow_move())
    : __hashtable_base(__ht),
      __map_base(__ht),
      __rehash_base(__ht),
      __hashtable_alloc(std::move(__a)),
      __enable_default_ctor(__ht),
      _M_buckets(__ht._M_buckets),
      _M_bucket_count(__ht._M_bucket_count),
      _M_before_begin(__ht._M_before_begin._M_nxt),
      _M_element_count(__ht._M_element_count),
      _M_rehash_policy(__ht._M_rehash_policy)
    {

      if (__ht._M_uses_single_bucket())
 {
   _M_buckets = &_M_single_bucket;
   _M_single_bucket = __ht._M_single_bucket;
 }


      _M_update_bbegin();

      __ht._M_reset();
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    _Hashtable(const _Hashtable& __ht, const allocator_type& __a)
    : __hashtable_base(__ht),
      __map_base(__ht),
      __rehash_base(__ht),
      __hashtable_alloc(__node_alloc_type(__a)),
      __enable_default_ctor(__ht),
      _M_buckets(),
      _M_bucket_count(__ht._M_bucket_count),
      _M_element_count(__ht._M_element_count),
      _M_rehash_policy(__ht._M_rehash_policy)
    {
      __alloc_node_gen_t __alloc_node_gen(*this);
      _M_assign(__ht, __alloc_node_gen);
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    _Hashtable(_Hashtable&& __ht, __node_alloc_type&& __a,
        false_type )
    : __hashtable_base(__ht),
      __map_base(__ht),
      __rehash_base(__ht),
      __hashtable_alloc(std::move(__a)),
      __enable_default_ctor(__ht),
      _M_buckets(nullptr),
      _M_bucket_count(__ht._M_bucket_count),
      _M_element_count(__ht._M_element_count),
      _M_rehash_policy(__ht._M_rehash_policy)
    {
      if (__ht._M_node_allocator() == this->_M_node_allocator())
 {
   if (__ht._M_uses_single_bucket())
     {
       _M_buckets = &_M_single_bucket;
       _M_single_bucket = __ht._M_single_bucket;
     }
   else
     _M_buckets = __ht._M_buckets;



   _M_update_bbegin(__ht._M_begin());

   __ht._M_reset();
 }
      else
 {
   __alloc_node_gen_t __alloc_gen(*this);

   using _Fwd_Ht = __conditional_t<
     __move_if_noexcept_cond<value_type>::value,
     const _Hashtable&, _Hashtable&&>;
   _M_assign(std::forward<_Fwd_Ht>(__ht), __alloc_gen);
   __ht.clear();
 }
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    ~_Hashtable() noexcept
    {



      static_assert(noexcept(declval<const __hash_code_base_access&>()
   ._M_bucket_index(declval<const __node_value_type&>(),
      (std::size_t)0)),
      "Cache the hash code or qualify your functors involved"
      " in hash code and bucket index computation with noexcept");

      clear();
      _M_deallocate_buckets();
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    swap(_Hashtable& __x)
    noexcept(__and_<__is_nothrow_swappable<_Hash>,
   __is_nothrow_swappable<_Equal>>::value)
    {



      this->_M_swap(__x);

      std::__alloc_on_swap(this->_M_node_allocator(), __x._M_node_allocator());
      std::swap(_M_rehash_policy, __x._M_rehash_policy);


      if (this->_M_uses_single_bucket())
 {
   if (!__x._M_uses_single_bucket())
     {
       _M_buckets = __x._M_buckets;
       __x._M_buckets = &__x._M_single_bucket;
     }
 }
      else if (__x._M_uses_single_bucket())
 {
   __x._M_buckets = _M_buckets;
   _M_buckets = &_M_single_bucket;
 }
      else
 std::swap(_M_buckets, __x._M_buckets);

      std::swap(_M_bucket_count, __x._M_bucket_count);
      std::swap(_M_before_begin._M_nxt, __x._M_before_begin._M_nxt);
      std::swap(_M_element_count, __x._M_element_count);
      std::swap(_M_single_bucket, __x._M_single_bucket);



      _M_update_bbegin();
      __x._M_update_bbegin();
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    find(const key_type& __k)
    -> iterator
    {
      if (size() <= __small_size_threshold())
 {
   for (auto __it = _M_begin(); __it; __it = __it->_M_next())
     if (this->_M_key_equals(__k, *__it))
       return iterator(__it);
   return end();
 }

      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __bkt = _M_bucket_index(__code);
      return iterator(_M_find_node(__bkt, __k, __code));
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    find(const key_type& __k) const
    -> const_iterator
    {
      if (size() <= __small_size_threshold())
 {
   for (auto __it = _M_begin(); __it; __it = __it->_M_next())
     if (this->_M_key_equals(__k, *__it))
       return const_iterator(__it);
   return end();
 }

      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __bkt = _M_bucket_index(__code);
      return const_iterator(_M_find_node(__bkt, __k, __code));
    }


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    template<typename _Kt, typename, typename>
      auto
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
      _M_find_tr(const _Kt& __k)
      -> iterator
      {
 if (size() <= __small_size_threshold())
   {
     for (auto __n = _M_begin(); __n; __n = __n->_M_next())
       if (this->_M_key_equals_tr(__k, *__n))
  return iterator(__n);
     return end();
   }

 __hash_code __code = this->_M_hash_code_tr(__k);
 std::size_t __bkt = _M_bucket_index(__code);
 return iterator(_M_find_node_tr(__bkt, __k, __code));
      }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    template<typename _Kt, typename, typename>
      auto
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
      _M_find_tr(const _Kt& __k) const
      -> const_iterator
      {
 if (size() <= __small_size_threshold())
   {
     for (auto __n = _M_begin(); __n; __n = __n->_M_next())
       if (this->_M_key_equals_tr(__k, *__n))
  return const_iterator(__n);
     return end();
   }

 __hash_code __code = this->_M_hash_code_tr(__k);
 std::size_t __bkt = _M_bucket_index(__code);
 return const_iterator(_M_find_node_tr(__bkt, __k, __code));
      }


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    count(const key_type& __k) const
    -> size_type
    {
      auto __it = find(__k);
      if (!__it._M_cur)
 return 0;

      if (__unique_keys::value)
 return 1;

      size_type __result = 1;
      for (auto __ref = __it++;
    __it._M_cur && this->_M_node_equals(*__ref._M_cur, *__it._M_cur);
    ++__it)
 ++__result;

      return __result;
    }


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    template<typename _Kt, typename, typename>
      auto
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
      _M_count_tr(const _Kt& __k) const
      -> size_type
      {
 if (size() <= __small_size_threshold())
   {
     size_type __result = 0;
     for (auto __n = _M_begin(); __n; __n = __n->_M_next())
       {
  if (this->_M_key_equals_tr(__k, *__n))
    {
      ++__result;
      continue;
    }

  if (__result)
    break;
       }

     return __result;
   }

 __hash_code __code = this->_M_hash_code_tr(__k);
 std::size_t __bkt = _M_bucket_index(__code);
 auto __n = _M_find_node_tr(__bkt, __k, __code);
 if (!__n)
   return 0;

 iterator __it(__n);
 size_type __result = 1;
 for (++__it;
      __it._M_cur && this->_M_equals_tr(__k, __code, *__it._M_cur);
      ++__it)
   ++__result;

 return __result;
      }


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    equal_range(const key_type& __k)
    -> pair<iterator, iterator>
    {
      auto __ite = find(__k);
      if (!__ite._M_cur)
 return { __ite, __ite };

      auto __beg = __ite++;
      if (__unique_keys::value)
 return { __beg, __ite };

      while (__ite._M_cur && this->_M_node_equals(*__beg._M_cur, *__ite._M_cur))
 ++__ite;

      return { __beg, __ite };
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    equal_range(const key_type& __k) const
    -> pair<const_iterator, const_iterator>
    {
      auto __ite = find(__k);
      if (!__ite._M_cur)
 return { __ite, __ite };

      auto __beg = __ite++;
      if (__unique_keys::value)
 return { __beg, __ite };

      while (__ite._M_cur && this->_M_node_equals(*__beg._M_cur, *__ite._M_cur))
 ++__ite;

      return { __beg, __ite };
    }


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    template<typename _Kt, typename, typename>
      auto
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
      _M_equal_range_tr(const _Kt& __k)
      -> pair<iterator, iterator>
      {
 if (size() <= __small_size_threshold())
   {
     __node_ptr __n, __beg = nullptr;
     for (__n = _M_begin(); __n; __n = __n->_M_next())
       {
  if (this->_M_key_equals_tr(__k, *__n))
    {
      if (!__beg)
        __beg = __n;
      continue;
    }

  if (__beg)
    break;
       }

     return { iterator(__beg), iterator(__n) };
   }

 __hash_code __code = this->_M_hash_code_tr(__k);
 std::size_t __bkt = _M_bucket_index(__code);
 auto __n = _M_find_node_tr(__bkt, __k, __code);
 iterator __ite(__n);
 if (!__n)
   return { __ite, __ite };

 auto __beg = __ite++;
 while (__ite._M_cur && this->_M_equals_tr(__k, __code, *__ite._M_cur))
   ++__ite;

 return { __beg, __ite };
      }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    template<typename _Kt, typename, typename>
      auto
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
      _M_equal_range_tr(const _Kt& __k) const
      -> pair<const_iterator, const_iterator>
      {
 if (size() <= __small_size_threshold())
   {
     __node_ptr __n, __beg = nullptr;
     for (__n = _M_begin(); __n; __n = __n->_M_next())
       {
  if (this->_M_key_equals_tr(__k, *__n))
    {
      if (!__beg)
        __beg = __n;
      continue;
    }

  if (__beg)
    break;
       }

     return { const_iterator(__beg), const_iterator(__n) };
   }

 __hash_code __code = this->_M_hash_code_tr(__k);
 std::size_t __bkt = _M_bucket_index(__code);
 auto __n = _M_find_node_tr(__bkt, __k, __code);
 const_iterator __ite(__n);
 if (!__n)
   return { __ite, __ite };

 auto __beg = __ite++;
 while (__ite._M_cur && this->_M_equals_tr(__k, __code, *__ite._M_cur))
   ++__ite;

 return { __beg, __ite };
      }




  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    _M_find_before_node(const key_type& __k)
    -> __node_base_ptr
    {
      __node_base_ptr __prev_p = &_M_before_begin;
      if (!__prev_p->_M_nxt)
 return nullptr;

      for (__node_ptr __p = static_cast<__node_ptr>(__prev_p->_M_nxt);
    __p != nullptr;
    __p = __p->_M_next())
 {
   if (this->_M_key_equals(__k, *__p))
     return __prev_p;

   __prev_p = __p;
 }

      return nullptr;
    }



  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    _M_find_before_node(size_type __bkt, const key_type& __k,
   __hash_code __code) const
    -> __node_base_ptr
    {
      __node_base_ptr __prev_p = _M_buckets[__bkt];
      if (!__prev_p)
 return nullptr;

      for (__node_ptr __p = static_cast<__node_ptr>(__prev_p->_M_nxt);;
    __p = __p->_M_next())
 {
   if (this->_M_equals(__k, __code, *__p))
     return __prev_p;

   if (!__p->_M_nxt || _M_bucket_index(*__p->_M_next()) != __bkt)
     break;
   __prev_p = __p;
 }

      return nullptr;
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    template<typename _Kt>
      auto
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
      _M_find_before_node_tr(size_type __bkt, const _Kt& __k,
        __hash_code __code) const
      -> __node_base_ptr
      {
 __node_base_ptr __prev_p = _M_buckets[__bkt];
 if (!__prev_p)
   return nullptr;

 for (__node_ptr __p = static_cast<__node_ptr>(__prev_p->_M_nxt);;
      __p = __p->_M_next())
   {
     if (this->_M_equals_tr(__k, __code, *__p))
       return __prev_p;

     if (!__p->_M_nxt || _M_bucket_index(*__p->_M_next()) != __bkt)
       break;
     __prev_p = __p;
   }

 return nullptr;
      }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    _M_get_previous_node(size_type __bkt, __node_ptr __n)
    -> __node_base_ptr
    {
      __node_base_ptr __prev_n = _M_buckets[__bkt];
      while (__prev_n->_M_nxt != __n)
 __prev_n = __prev_n->_M_nxt;
      return __prev_n;
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    template<typename... _Args>
      auto
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
      _M_emplace(true_type , _Args&&... __args)
      -> pair<iterator, bool>
      {

 _Scoped_node __node { this, std::forward<_Args>(__args)... };
 const key_type& __k = _ExtractKey{}(__node._M_node->_M_v());
 const size_type __size = size();
 if (__size <= __small_size_threshold())
   {
     for (auto __it = _M_begin(); __it; __it = __it->_M_next())
       if (this->_M_key_equals(__k, *__it))

  return { iterator(__it), false };
   }

 __hash_code __code = this->_M_hash_code(__k);
 size_type __bkt = _M_bucket_index(__code);
 if (__size > __small_size_threshold())
   if (__node_ptr __p = _M_find_node(__bkt, __k, __code))

     return { iterator(__p), false };


 auto __pos = _M_insert_unique_node(__bkt, __code, __node._M_node);
 __node._M_node = nullptr;
 return { __pos, true };
      }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    template<typename... _Args>
      auto
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
      _M_emplace(const_iterator __hint, false_type ,
   _Args&&... __args)
      -> iterator
      {

 _Scoped_node __node { this, std::forward<_Args>(__args)... };
 const key_type& __k = _ExtractKey{}(__node._M_node->_M_v());

 auto __res = this->_M_compute_hash_code(__hint._M_cur, __k);
 auto __pos
   = _M_insert_multi_node(__res.first, __res.second, __node._M_node);
 __node._M_node = nullptr;
 return __pos;
      }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    _M_compute_hash_code(__node_ptr __hint, const key_type& __k) const
    -> pair<__node_ptr, __hash_code>
    {
      if (size() <= __small_size_threshold())
 {
   if (__hint)
     {
       for (auto __it = __hint; __it; __it = __it->_M_next())
  if (this->_M_key_equals(__k, *__it))
    return { __it, this->_M_hash_code(*__it) };
     }

   for (auto __it = _M_begin(); __it != __hint; __it = __it->_M_next())
     if (this->_M_key_equals(__k, *__it))
       return { __it, this->_M_hash_code(*__it) };

   __hint = nullptr;
 }

      return { __hint, this->_M_hash_code(__k) };
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    _M_insert_unique_node(size_type __bkt, __hash_code __code,
     __node_ptr __node, size_type __n_elt)
    -> iterator
    {
      __rehash_guard_t __rehash_guard(_M_rehash_policy);
      std::pair<bool, std::size_t> __do_rehash
 = _M_rehash_policy._M_need_rehash(_M_bucket_count, _M_element_count,
       __n_elt);

      if (__do_rehash.first)
 {
   _M_rehash(__do_rehash.second, true_type{});
   __bkt = _M_bucket_index(__code);
 }

      __rehash_guard._M_guarded_obj = nullptr;
      this->_M_store_code(*__node, __code);


      _M_insert_bucket_begin(__bkt, __node);
      ++_M_element_count;
      return iterator(__node);
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    _M_insert_multi_node(__node_ptr __hint,
    __hash_code __code, __node_ptr __node)
    -> iterator
    {
      __rehash_guard_t __rehash_guard(_M_rehash_policy);
      std::pair<bool, std::size_t> __do_rehash
 = _M_rehash_policy._M_need_rehash(_M_bucket_count, _M_element_count, 1);

      if (__do_rehash.first)
 _M_rehash(__do_rehash.second, false_type{});

      __rehash_guard._M_guarded_obj = nullptr;
      this->_M_store_code(*__node, __code);
      const key_type& __k = _ExtractKey{}(__node->_M_v());
      size_type __bkt = _M_bucket_index(__code);



      __node_base_ptr __prev
 = __builtin_expect(__hint != nullptr, false)
   && this->_M_equals(__k, __code, *__hint)
     ? __hint
     : _M_find_before_node(__bkt, __k, __code);

      if (__prev)
 {

   __node->_M_nxt = __prev->_M_nxt;
   __prev->_M_nxt = __node;
   if (__builtin_expect(__prev == __hint, false))


     if (__node->_M_nxt
  && !this->_M_equals(__k, __code, *__node->_M_next()))
       {
  size_type __next_bkt = _M_bucket_index(*__node->_M_next());
  if (__next_bkt != __bkt)
    _M_buckets[__next_bkt] = __node;
       }
 }
      else



 _M_insert_bucket_begin(__bkt, __node);
      ++_M_element_count;
      return iterator(__node);
    }


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    template<typename _Kt, typename _Arg, typename _NodeGenerator>
      auto
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
      _M_insert_unique(_Kt&& __k, _Arg&& __v,
         const _NodeGenerator& __node_gen)
      -> pair<iterator, bool>
      {
 const size_type __size = size();
 if (__size <= __small_size_threshold())
   for (auto __it = _M_begin(); __it; __it = __it->_M_next())
     if (this->_M_key_equals_tr(__k, *__it))
       return { iterator(__it), false };

 __hash_code __code = this->_M_hash_code_tr(__k);
 size_type __bkt = _M_bucket_index(__code);

 if (__size > __small_size_threshold())
   if (__node_ptr __node = _M_find_node_tr(__bkt, __k, __code))
     return { iterator(__node), false };

 _Scoped_node __node {
   __node_builder_t::_S_build(std::forward<_Kt>(__k),
         std::forward<_Arg>(__v),
         __node_gen),
   this
 };
 auto __pos
   = _M_insert_unique_node(__bkt, __code, __node._M_node);
 __node._M_node = nullptr;
 return { __pos, true };
      }


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    template<typename _Arg, typename _NodeGenerator>
      auto
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
      _M_insert(const_iterator __hint, _Arg&& __v,
  const _NodeGenerator& __node_gen,
  false_type )
      -> iterator
      {

 _Scoped_node __node{ __node_gen(std::forward<_Arg>(__v)), this };


 auto __res = this->_M_compute_hash_code(
   __hint._M_cur, _ExtractKey{}(__node._M_node->_M_v()));

 auto __pos
   = _M_insert_multi_node(__res.first, __res.second, __node._M_node);
 __node._M_node = nullptr;
 return __pos;
      }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    erase(const_iterator __it)
    -> iterator
    {
      __node_ptr __n = __it._M_cur;
      std::size_t __bkt = _M_bucket_index(*__n);




      __node_base_ptr __prev_n = _M_get_previous_node(__bkt, __n);
      return _M_erase(__bkt, __prev_n, __n);
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    _M_erase(size_type __bkt, __node_base_ptr __prev_n, __node_ptr __n)
    -> iterator
    {
      if (__prev_n == _M_buckets[__bkt])
 _M_remove_bucket_begin(__bkt, __n->_M_next(),
   __n->_M_nxt ? _M_bucket_index(*__n->_M_next()) : 0);
      else if (__n->_M_nxt)
 {
   size_type __next_bkt = _M_bucket_index(*__n->_M_next());
   if (__next_bkt != __bkt)
     _M_buckets[__next_bkt] = __prev_n;
 }

      __prev_n->_M_nxt = __n->_M_nxt;
      iterator __result(__n->_M_next());
      this->_M_deallocate_node(__n);
      --_M_element_count;

      return __result;
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    _M_erase(true_type , const key_type& __k)
    -> size_type
    {
      __node_base_ptr __prev_n;
      __node_ptr __n;
      std::size_t __bkt;
      if (size() <= __small_size_threshold())
 {
   __prev_n = _M_find_before_node(__k);
   if (!__prev_n)
     return 0;


   __n = static_cast<__node_ptr>(__prev_n->_M_nxt);
   __bkt = _M_bucket_index(*__n);
 }
      else
 {
   __hash_code __code = this->_M_hash_code(__k);
   __bkt = _M_bucket_index(__code);


   __prev_n = _M_find_before_node(__bkt, __k, __code);
   if (!__prev_n)
     return 0;


   __n = static_cast<__node_ptr>(__prev_n->_M_nxt);
 }

      _M_erase(__bkt, __prev_n, __n);
      return 1;
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    _M_erase(false_type , const key_type& __k)
    -> size_type
    {
      std::size_t __bkt;
      __node_base_ptr __prev_n;
      __node_ptr __n;
      if (size() <= __small_size_threshold())
 {
   __prev_n = _M_find_before_node(__k);
   if (!__prev_n)
     return 0;


   __n = static_cast<__node_ptr>(__prev_n->_M_nxt);
   __bkt = _M_bucket_index(*__n);
 }
      else
 {
   __hash_code __code = this->_M_hash_code(__k);
   __bkt = _M_bucket_index(__code);


   __prev_n = _M_find_before_node(__bkt, __k, __code);
   if (!__prev_n)
     return 0;

   __n = static_cast<__node_ptr>(__prev_n->_M_nxt);
 }







      __node_ptr __n_last = __n->_M_next();
      while (__n_last && this->_M_node_equals(*__n, *__n_last))
 __n_last = __n_last->_M_next();

      std::size_t __n_last_bkt = __n_last ? _M_bucket_index(*__n_last) : __bkt;


      size_type __result = 0;
      do
 {
   __node_ptr __p = __n->_M_next();
   this->_M_deallocate_node(__n);
   __n = __p;
   ++__result;
 }
      while (__n != __n_last);

      _M_element_count -= __result;
      if (__prev_n == _M_buckets[__bkt])
 _M_remove_bucket_begin(__bkt, __n_last, __n_last_bkt);
      else if (__n_last_bkt != __bkt)
 _M_buckets[__n_last_bkt] = __prev_n;
      __prev_n->_M_nxt = __n_last;
      return __result;
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    erase(const_iterator __first, const_iterator __last)
    -> iterator
    {
      __node_ptr __n = __first._M_cur;
      __node_ptr __last_n = __last._M_cur;
      if (__n == __last_n)
 return iterator(__n);

      std::size_t __bkt = _M_bucket_index(*__n);

      __node_base_ptr __prev_n = _M_get_previous_node(__bkt, __n);
      bool __is_bucket_begin = __n == _M_bucket_begin(__bkt);
      std::size_t __n_bkt = __bkt;
      for (;;)
 {
   do
     {
       __node_ptr __tmp = __n;
       __n = __n->_M_next();
       this->_M_deallocate_node(__tmp);
       --_M_element_count;
       if (!__n)
  break;
       __n_bkt = _M_bucket_index(*__n);
     }
   while (__n != __last_n && __n_bkt == __bkt);
   if (__is_bucket_begin)
     _M_remove_bucket_begin(__bkt, __n, __n_bkt);
   if (__n == __last_n)
     break;
   __is_bucket_begin = true;
   __bkt = __n_bkt;
 }

      if (__n && (__n_bkt != __bkt || __is_bucket_begin))
 _M_buckets[__n_bkt] = __prev_n;
      __prev_n->_M_nxt = __n;
      return iterator(__n);
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    clear() noexcept
    {
      this->_M_deallocate_nodes(_M_begin());
      __builtin_memset(_M_buckets, 0,
         _M_bucket_count * sizeof(__node_base_ptr));
      _M_element_count = 0;
      _M_before_begin._M_nxt = nullptr;
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    rehash(size_type __bkt_count)
    {
      __rehash_guard_t __rehash_guard(_M_rehash_policy);
      __bkt_count
 = std::max(_M_rehash_policy._M_bkt_for_elements(_M_element_count + 1),
     __bkt_count);
      __bkt_count = _M_rehash_policy._M_next_bkt(__bkt_count);

      if (__bkt_count != _M_bucket_count)
 {
   _M_rehash(__bkt_count, __unique_keys{});
   __rehash_guard._M_guarded_obj = nullptr;
 }
    }


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    _M_rehash(size_type __bkt_count, true_type )
    {
      __buckets_ptr __new_buckets = _M_allocate_buckets(__bkt_count);
      __node_ptr __p = _M_begin();
      _M_before_begin._M_nxt = nullptr;
      std::size_t __bbegin_bkt = 0;
      while (__p)
 {
   __node_ptr __next = __p->_M_next();
   std::size_t __bkt
     = __hash_code_base::_M_bucket_index(*__p, __bkt_count);
   if (!__new_buckets[__bkt])
     {
       __p->_M_nxt = _M_before_begin._M_nxt;
       _M_before_begin._M_nxt = __p;
       __new_buckets[__bkt] = &_M_before_begin;
       if (__p->_M_nxt)
  __new_buckets[__bbegin_bkt] = __p;
       __bbegin_bkt = __bkt;
     }
   else
     {
       __p->_M_nxt = __new_buckets[__bkt]->_M_nxt;
       __new_buckets[__bkt]->_M_nxt = __p;
     }

   __p = __next;
 }

      _M_deallocate_buckets();
      _M_bucket_count = __bkt_count;
      _M_buckets = __new_buckets;
    }



  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    _M_rehash(size_type __bkt_count, false_type )
    {
      __buckets_ptr __new_buckets = _M_allocate_buckets(__bkt_count);
      __node_ptr __p = _M_begin();
      _M_before_begin._M_nxt = nullptr;
      std::size_t __bbegin_bkt = 0;
      std::size_t __prev_bkt = 0;
      __node_ptr __prev_p = nullptr;
      bool __check_bucket = false;

      while (__p)
 {
   __node_ptr __next = __p->_M_next();
   std::size_t __bkt
     = __hash_code_base::_M_bucket_index(*__p, __bkt_count);

   if (__prev_p && __prev_bkt == __bkt)
     {



       __p->_M_nxt = __prev_p->_M_nxt;
       __prev_p->_M_nxt = __p;






       __check_bucket = true;
     }
   else
     {
       if (__check_bucket)
  {


    if (__prev_p->_M_nxt)
      {
        std::size_t __next_bkt
   = __hash_code_base::_M_bucket_index(
     *__prev_p->_M_next(), __bkt_count);
        if (__next_bkt != __prev_bkt)
   __new_buckets[__next_bkt] = __prev_p;
      }
    __check_bucket = false;
  }

       if (!__new_buckets[__bkt])
  {
    __p->_M_nxt = _M_before_begin._M_nxt;
    _M_before_begin._M_nxt = __p;
    __new_buckets[__bkt] = &_M_before_begin;
    if (__p->_M_nxt)
      __new_buckets[__bbegin_bkt] = __p;
    __bbegin_bkt = __bkt;
  }
       else
  {
    __p->_M_nxt = __new_buckets[__bkt]->_M_nxt;
    __new_buckets[__bkt]->_M_nxt = __p;
  }
     }
   __prev_p = __p;
   __prev_bkt = __bkt;
   __p = __next;
 }

      if (__check_bucket && __prev_p->_M_nxt)
 {
   std::size_t __next_bkt
     = __hash_code_base::_M_bucket_index(*__prev_p->_M_next(),
      __bkt_count);
   if (__next_bkt != __prev_bkt)
     __new_buckets[__next_bkt] = __prev_p;
 }

      _M_deallocate_buckets();
      _M_bucket_count = __bkt_count;
      _M_buckets = __new_buckets;
    }


  template<typename, typename, typename> class _Hash_merge_helper { };




  template<typename _Hash>
    using _RequireNotAllocatorOrIntegral
      = __enable_if_t<!__or_<is_integral<_Hash>, __is_allocator<_Hash>>::value>;




}
# 34 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 2 3




namespace std
{




  template<bool _Cache>
    using __uset_traits = __detail::_Hashtable_traits<_Cache, true, true>;

  template<typename _Value,
    typename _Hash = hash<_Value>,
    typename _Pred = std::equal_to<_Value>,
      typename _Alloc = std::allocator<_Value>,
    typename _Tr = __uset_traits<__cache_default<_Value, _Hash>::value>>
    using __uset_hashtable = _Hashtable<_Value, _Value, _Alloc,
     __detail::_Identity, _Pred, _Hash,
     __detail::_Mod_range_hashing,
     __detail::_Default_ranged_hash,
     __detail::_Prime_rehash_policy, _Tr>;


  template<bool _Cache>
    using __umset_traits = __detail::_Hashtable_traits<_Cache, true, false>;

  template<typename _Value,
    typename _Hash = hash<_Value>,
    typename _Pred = std::equal_to<_Value>,
    typename _Alloc = std::allocator<_Value>,
    typename _Tr = __umset_traits<__cache_default<_Value, _Hash>::value>>
    using __umset_hashtable = _Hashtable<_Value, _Value, _Alloc,
      __detail::_Identity,
      _Pred, _Hash,
      __detail::_Mod_range_hashing,
      __detail::_Default_ranged_hash,
      __detail::_Prime_rehash_policy, _Tr>;

  template<class _Value, class _Hash, class _Pred, class _Alloc>
    class unordered_multiset;
# 100 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
  template<typename _Value,
    typename _Hash = hash<_Value>,
    typename _Pred = equal_to<_Value>,
    typename _Alloc = allocator<_Value>>
    class unordered_set
    {
      typedef __uset_hashtable<_Value, _Hash, _Pred, _Alloc> _Hashtable;
      _Hashtable _M_h;

    public:



      typedef typename _Hashtable::key_type key_type;
      typedef typename _Hashtable::value_type value_type;
      typedef typename _Hashtable::hasher hasher;
      typedef typename _Hashtable::key_equal key_equal;
      typedef typename _Hashtable::allocator_type allocator_type;




      typedef typename _Hashtable::pointer pointer;
      typedef typename _Hashtable::const_pointer const_pointer;
      typedef typename _Hashtable::reference reference;
      typedef typename _Hashtable::const_reference const_reference;
      typedef typename _Hashtable::iterator iterator;
      typedef typename _Hashtable::const_iterator const_iterator;
      typedef typename _Hashtable::local_iterator local_iterator;
      typedef typename _Hashtable::const_local_iterator const_local_iterator;
      typedef typename _Hashtable::size_type size_type;
      typedef typename _Hashtable::difference_type difference_type;



      using node_type = typename _Hashtable::node_type;
      using insert_return_type = typename _Hashtable::insert_return_type;





      unordered_set() = default;
# 151 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      explicit
      unordered_set(size_type __n,
      const hasher& __hf = hasher(),
      const key_equal& __eql = key_equal(),
      const allocator_type& __a = allocator_type())
      : _M_h(__n, __hf, __eql, __a)
      { }
# 172 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      template<typename _InputIterator>
 unordered_set(_InputIterator __first, _InputIterator __last,
        size_type __n = 0,
        const hasher& __hf = hasher(),
        const key_equal& __eql = key_equal(),
        const allocator_type& __a = allocator_type())
 : _M_h(__first, __last, __n, __hf, __eql, __a)
 { }


      unordered_set(const unordered_set&) = default;


      unordered_set(unordered_set&&) = default;





      explicit
      unordered_set(const allocator_type& __a)
      : _M_h(__a)
      { }






      unordered_set(const unordered_set& __uset,
      const allocator_type& __a)
      : _M_h(__uset._M_h, __a)
      { }






      unordered_set(unordered_set&& __uset,
      const allocator_type& __a)
 noexcept( noexcept(_Hashtable(std::move(__uset._M_h), __a)) )
      : _M_h(std::move(__uset._M_h), __a)
      { }
# 228 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      unordered_set(initializer_list<value_type> __l,
      size_type __n = 0,
      const hasher& __hf = hasher(),
      const key_equal& __eql = key_equal(),
      const allocator_type& __a = allocator_type())
      : _M_h(__l, __n, __hf, __eql, __a)
      { }

      unordered_set(size_type __n, const allocator_type& __a)
      : unordered_set(__n, hasher(), key_equal(), __a)
      { }

      unordered_set(size_type __n, const hasher& __hf,
      const allocator_type& __a)
      : unordered_set(__n, __hf, key_equal(), __a)
      { }

      template<typename _InputIterator>
 unordered_set(_InputIterator __first, _InputIterator __last,
        size_type __n,
        const allocator_type& __a)
 : unordered_set(__first, __last, __n, hasher(), key_equal(), __a)
 { }

      template<typename _InputIterator>
 unordered_set(_InputIterator __first, _InputIterator __last,
        size_type __n, const hasher& __hf,
        const allocator_type& __a)
 : unordered_set(__first, __last, __n, __hf, key_equal(), __a)
 { }

      unordered_set(initializer_list<value_type> __l,
      size_type __n,
      const allocator_type& __a)
      : unordered_set(__l, __n, hasher(), key_equal(), __a)
      { }

      unordered_set(initializer_list<value_type> __l,
      size_type __n, const hasher& __hf,
      const allocator_type& __a)
      : unordered_set(__l, __n, __hf, key_equal(), __a)
      { }


      unordered_set&
      operator=(const unordered_set&) = default;


      unordered_set&
      operator=(unordered_set&&) = default;
# 290 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      unordered_set&
      operator=(initializer_list<value_type> __l)
      {
 _M_h = __l;
 return *this;
      }


      allocator_type
      get_allocator() const noexcept
      { return _M_h.get_allocator(); }




      [[__nodiscard__]] bool
      empty() const noexcept
      { return _M_h.empty(); }


      size_type
      size() const noexcept
      { return _M_h.size(); }


      size_type
      max_size() const noexcept
      { return _M_h.max_size(); }
# 326 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      iterator
      begin() noexcept
      { return _M_h.begin(); }

      const_iterator
      begin() const noexcept
      { return _M_h.begin(); }







      iterator
      end() noexcept
      { return _M_h.end(); }

      const_iterator
      end() const noexcept
      { return _M_h.end(); }






      const_iterator
      cbegin() const noexcept
      { return _M_h.begin(); }





      const_iterator
      cend() const noexcept
      { return _M_h.end(); }
# 382 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      template<typename... _Args>
 std::pair<iterator, bool>
 emplace(_Args&&... __args)
 { return _M_h.emplace(std::forward<_Args>(__args)...); }
# 408 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 { return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...); }
# 427 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      std::pair<iterator, bool>
      insert(const value_type& __x)
      { return _M_h.insert(__x); }

      std::pair<iterator, bool>
      insert(value_type&& __x)
      { return _M_h.insert(std::move(__x)); }
# 456 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      iterator
      insert(const_iterator __hint, const value_type& __x)
      { return _M_h.insert(__hint, __x); }

      iterator
      insert(const_iterator __hint, value_type&& __x)
      { return _M_h.insert(__hint, std::move(__x)); }
# 474 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 { _M_h.insert(__first, __last); }
# 486 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      void
      insert(initializer_list<value_type> __l)
      { _M_h.insert(__l); }



      node_type
      extract(const_iterator __pos)
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__pos != end()), false)) std::__glibcxx_assert_fail(); } while (false);
 return _M_h.extract(__pos);
      }


      node_type
      extract(const key_type& __key)
      { return _M_h.extract(__key); }


      insert_return_type
      insert(node_type&& __nh)
      { return _M_h._M_reinsert_node(std::move(__nh)); }


      iterator
      insert(const_iterator, node_type&& __nh)
      { return _M_h._M_reinsert_node(std::move(__nh)).position; }
# 529 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      iterator
      erase(const_iterator __position)
      { return _M_h.erase(__position); }


      iterator
      erase(iterator __position)
      { return _M_h.erase(__position); }
# 551 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_h.erase(__x); }
# 569 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_h.erase(__first, __last); }







      void
      clear() noexcept
      { _M_h.clear(); }
# 592 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      void
      swap(unordered_set& __x)
      noexcept( noexcept(_M_h.swap(__x._M_h)) )
      { _M_h.swap(__x._M_h); }


      template<typename, typename, typename>
 friend class std::_Hash_merge_helper;

      template<typename _H2, typename _P2>
 void
 merge(unordered_set<_Value, _H2, _P2, _Alloc>& __source)
 {
   using _Merge_helper = _Hash_merge_helper<unordered_set, _H2, _P2>;
   _M_h._M_merge_unique(_Merge_helper::_S_get_table(__source));
 }

      template<typename _H2, typename _P2>
 void
 merge(unordered_set<_Value, _H2, _P2, _Alloc>&& __source)
 { merge(__source); }

      template<typename _H2, typename _P2>
 void
 merge(unordered_multiset<_Value, _H2, _P2, _Alloc>& __source)
 {
   using _Merge_helper = _Hash_merge_helper<unordered_set, _H2, _P2>;
   _M_h._M_merge_unique(_Merge_helper::_S_get_table(__source));
 }

      template<typename _H2, typename _P2>
 void
 merge(unordered_multiset<_Value, _H2, _P2, _Alloc>&& __source)
 { merge(__source); }






      hasher
      hash_function() const
      { return _M_h.hash_function(); }



      key_equal
      key_eq() const
      { return _M_h.key_eq(); }
# 656 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      iterator
      find(const key_type& __x)
      { return _M_h.find(__x); }


      template<typename _Kt>
 auto
 find(const _Kt& __k)
 -> decltype(_M_h._M_find_tr(__k))
 { return _M_h._M_find_tr(__k); }


      const_iterator
      find(const key_type& __x) const
      { return _M_h.find(__x); }


      template<typename _Kt>
 auto
 find(const _Kt& __k) const
 -> decltype(_M_h._M_find_tr(__k))
 { return _M_h._M_find_tr(__k); }
# 691 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_h.count(__x); }


      template<typename _Kt>
 auto
 count(const _Kt& __k) const
 -> decltype(_M_h._M_count_tr(__k))
 { return _M_h._M_count_tr(__k); }
# 711 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      bool
      contains(const key_type& __x) const
      { return _M_h.find(__x) != _M_h.end(); }

      template<typename _Kt>
 auto
 contains(const _Kt& __k) const
 -> decltype(_M_h._M_find_tr(__k), void(), true)
 { return _M_h._M_find_tr(__k) != _M_h.end(); }
# 732 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_h.equal_range(__x); }


      template<typename _Kt>
 auto
 equal_range(const _Kt& __k)
 -> decltype(_M_h._M_equal_range_tr(__k))
 { return _M_h._M_equal_range_tr(__k); }


      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_h.equal_range(__x); }


      template<typename _Kt>
 auto
 equal_range(const _Kt& __k) const
 -> decltype(_M_h._M_equal_range_tr(__k))
 { return _M_h._M_equal_range_tr(__k); }






      size_type
      bucket_count() const noexcept
      { return _M_h.bucket_count(); }


      size_type
      max_bucket_count() const noexcept
      { return _M_h.max_bucket_count(); }






      size_type
      bucket_size(size_type __n) const
      { return _M_h.bucket_size(__n); }






      size_type
      bucket(const key_type& __key) const
      { return _M_h.bucket(__key); }
# 794 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      local_iterator
      begin(size_type __n)
      { return _M_h.begin(__n); }

      const_local_iterator
      begin(size_type __n) const
      { return _M_h.begin(__n); }

      const_local_iterator
      cbegin(size_type __n) const
      { return _M_h.cbegin(__n); }
# 814 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      local_iterator
      end(size_type __n)
      { return _M_h.end(__n); }

      const_local_iterator
      end(size_type __n) const
      { return _M_h.end(__n); }

      const_local_iterator
      cend(size_type __n) const
      { return _M_h.cend(__n); }





      float
      load_factor() const noexcept
      { return _M_h.load_factor(); }



      float
      max_load_factor() const noexcept
      { return _M_h.max_load_factor(); }





      void
      max_load_factor(float __z)
      { _M_h.max_load_factor(__z); }
# 855 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      void
      rehash(size_type __n)
      { _M_h.rehash(__n); }
# 866 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      void
      reserve(size_type __n)
      { _M_h.reserve(__n); }

      template<typename _Value1, typename _Hash1, typename _Pred1,
        typename _Alloc1>
        friend bool
        operator==(const unordered_set<_Value1, _Hash1, _Pred1, _Alloc1>&,
     const unordered_set<_Value1, _Hash1, _Pred1, _Alloc1>&);
    };



  template<typename _InputIterator,
    typename _Hash =
      hash<typename iterator_traits<_InputIterator>::value_type>,
    typename _Pred =
      equal_to<typename iterator_traits<_InputIterator>::value_type>,
    typename _Allocator =
      allocator<typename iterator_traits<_InputIterator>::value_type>,
    typename = _RequireInputIter<_InputIterator>,
    typename = _RequireNotAllocatorOrIntegral<_Hash>,
    typename = _RequireNotAllocator<_Pred>,
    typename = _RequireAllocator<_Allocator>>
    unordered_set(_InputIterator, _InputIterator,
    unordered_set<int>::size_type = {},
    _Hash = _Hash(), _Pred = _Pred(), _Allocator = _Allocator())
    -> unordered_set<typename iterator_traits<_InputIterator>::value_type,
       _Hash, _Pred, _Allocator>;

  template<typename _Tp, typename _Hash = hash<_Tp>,
    typename _Pred = equal_to<_Tp>,
    typename _Allocator = allocator<_Tp>,
    typename = _RequireNotAllocatorOrIntegral<_Hash>,
    typename = _RequireNotAllocator<_Pred>,
    typename = _RequireAllocator<_Allocator>>
    unordered_set(initializer_list<_Tp>,
    unordered_set<int>::size_type = {},
    _Hash = _Hash(), _Pred = _Pred(), _Allocator = _Allocator())
    -> unordered_set<_Tp, _Hash, _Pred, _Allocator>;

  template<typename _InputIterator, typename _Allocator,
    typename = _RequireInputIter<_InputIterator>,
    typename = _RequireAllocator<_Allocator>>
    unordered_set(_InputIterator, _InputIterator,
    unordered_set<int>::size_type, _Allocator)
    -> unordered_set<typename iterator_traits<_InputIterator>::value_type,
       hash<
         typename iterator_traits<_InputIterator>::value_type>,
       equal_to<
         typename iterator_traits<_InputIterator>::value_type>,
       _Allocator>;

  template<typename _InputIterator, typename _Hash, typename _Allocator,
    typename = _RequireInputIter<_InputIterator>,
    typename = _RequireNotAllocatorOrIntegral<_Hash>,
    typename = _RequireAllocator<_Allocator>>
    unordered_set(_InputIterator, _InputIterator,
    unordered_set<int>::size_type,
    _Hash, _Allocator)
    -> unordered_set<typename iterator_traits<_InputIterator>::value_type,
       _Hash,
       equal_to<
         typename iterator_traits<_InputIterator>::value_type>,
       _Allocator>;

  template<typename _Tp, typename _Allocator,
    typename = _RequireAllocator<_Allocator>>
    unordered_set(initializer_list<_Tp>,
    unordered_set<int>::size_type, _Allocator)
    -> unordered_set<_Tp, hash<_Tp>, equal_to<_Tp>, _Allocator>;

  template<typename _Tp, typename _Hash, typename _Allocator,
    typename = _RequireNotAllocatorOrIntegral<_Hash>,
    typename = _RequireAllocator<_Allocator>>
    unordered_set(initializer_list<_Tp>,
    unordered_set<int>::size_type, _Hash, _Allocator)
    -> unordered_set<_Tp, _Hash, equal_to<_Tp>, _Allocator>;
# 968 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
  template<typename _Value,
    typename _Hash = hash<_Value>,
    typename _Pred = equal_to<_Value>,
    typename _Alloc = allocator<_Value>>
    class unordered_multiset
    {
      typedef __umset_hashtable<_Value, _Hash, _Pred, _Alloc> _Hashtable;
      _Hashtable _M_h;

    public:



      typedef typename _Hashtable::key_type key_type;
      typedef typename _Hashtable::value_type value_type;
      typedef typename _Hashtable::hasher hasher;
      typedef typename _Hashtable::key_equal key_equal;
      typedef typename _Hashtable::allocator_type allocator_type;




      typedef typename _Hashtable::pointer pointer;
      typedef typename _Hashtable::const_pointer const_pointer;
      typedef typename _Hashtable::reference reference;
      typedef typename _Hashtable::const_reference const_reference;
      typedef typename _Hashtable::iterator iterator;
      typedef typename _Hashtable::const_iterator const_iterator;
      typedef typename _Hashtable::local_iterator local_iterator;
      typedef typename _Hashtable::const_local_iterator const_local_iterator;
      typedef typename _Hashtable::size_type size_type;
      typedef typename _Hashtable::difference_type difference_type;



      using node_type = typename _Hashtable::node_type;





      unordered_multiset() = default;
# 1018 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      explicit
      unordered_multiset(size_type __n,
    const hasher& __hf = hasher(),
    const key_equal& __eql = key_equal(),
    const allocator_type& __a = allocator_type())
      : _M_h(__n, __hf, __eql, __a)
      { }
# 1039 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      template<typename _InputIterator>
 unordered_multiset(_InputIterator __first, _InputIterator __last,
      size_type __n = 0,
      const hasher& __hf = hasher(),
      const key_equal& __eql = key_equal(),
      const allocator_type& __a = allocator_type())
 : _M_h(__first, __last, __n, __hf, __eql, __a)
 { }


      unordered_multiset(const unordered_multiset&) = default;


      unordered_multiset(unordered_multiset&&) = default;
# 1065 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      unordered_multiset(initializer_list<value_type> __l,
    size_type __n = 0,
    const hasher& __hf = hasher(),
    const key_equal& __eql = key_equal(),
    const allocator_type& __a = allocator_type())
      : _M_h(__l, __n, __hf, __eql, __a)
      { }


      unordered_multiset&
      operator=(const unordered_multiset&) = default;


      unordered_multiset&
      operator=(unordered_multiset&&) = default;





      explicit
      unordered_multiset(const allocator_type& __a)
      : _M_h(__a)
      { }






      unordered_multiset(const unordered_multiset& __umset,
    const allocator_type& __a)
      : _M_h(__umset._M_h, __a)
      { }






      unordered_multiset(unordered_multiset&& __umset,
    const allocator_type& __a)
 noexcept( noexcept(_Hashtable(std::move(__umset._M_h), __a)) )
      : _M_h(std::move(__umset._M_h), __a)
      { }

      unordered_multiset(size_type __n, const allocator_type& __a)
      : unordered_multiset(__n, hasher(), key_equal(), __a)
      { }

      unordered_multiset(size_type __n, const hasher& __hf,
    const allocator_type& __a)
      : unordered_multiset(__n, __hf, key_equal(), __a)
      { }

      template<typename _InputIterator>
 unordered_multiset(_InputIterator __first, _InputIterator __last,
      size_type __n,
      const allocator_type& __a)
 : unordered_multiset(__first, __last, __n, hasher(), key_equal(), __a)
 { }

      template<typename _InputIterator>
 unordered_multiset(_InputIterator __first, _InputIterator __last,
      size_type __n, const hasher& __hf,
      const allocator_type& __a)
 : unordered_multiset(__first, __last, __n, __hf, key_equal(), __a)
 { }

      unordered_multiset(initializer_list<value_type> __l,
    size_type __n,
    const allocator_type& __a)
      : unordered_multiset(__l, __n, hasher(), key_equal(), __a)
      { }

      unordered_multiset(initializer_list<value_type> __l,
    size_type __n, const hasher& __hf,
    const allocator_type& __a)
      : unordered_multiset(__l, __n, __hf, key_equal(), __a)
      { }
# 1157 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      unordered_multiset&
      operator=(initializer_list<value_type> __l)
      {
 _M_h = __l;
 return *this;
      }


      allocator_type
      get_allocator() const noexcept
      { return _M_h.get_allocator(); }




      [[__nodiscard__]] bool
      empty() const noexcept
      { return _M_h.empty(); }


      size_type
      size() const noexcept
      { return _M_h.size(); }


      size_type
      max_size() const noexcept
      { return _M_h.max_size(); }
# 1193 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      iterator
      begin() noexcept
      { return _M_h.begin(); }

      const_iterator
      begin() const noexcept
      { return _M_h.begin(); }







      iterator
      end() noexcept
      { return _M_h.end(); }

      const_iterator
      end() const noexcept
      { return _M_h.end(); }






      const_iterator
      cbegin() const noexcept
      { return _M_h.begin(); }





      const_iterator
      cend() const noexcept
      { return _M_h.end(); }
# 1241 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      template<typename... _Args>
 iterator
 emplace(_Args&&... __args)
 { return _M_h.emplace(std::forward<_Args>(__args)...); }
# 1263 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 { return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...); }
# 1276 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_h.insert(__x); }

      iterator
      insert(value_type&& __x)
      { return _M_h.insert(std::move(__x)); }
# 1302 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      iterator
      insert(const_iterator __hint, const value_type& __x)
      { return _M_h.insert(__hint, __x); }

      iterator
      insert(const_iterator __hint, value_type&& __x)
      { return _M_h.insert(__hint, std::move(__x)); }
# 1319 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 { _M_h.insert(__first, __last); }
# 1331 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      void
      insert(initializer_list<value_type> __l)
      { _M_h.insert(__l); }



      node_type
      extract(const_iterator __pos)
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__pos != end()), false)) std::__glibcxx_assert_fail(); } while (false);
 return _M_h.extract(__pos);
      }


      node_type
      extract(const key_type& __key)
      { return _M_h.extract(__key); }


      iterator
      insert(node_type&& __nh)
      { return _M_h._M_reinsert_node_multi(cend(), std::move(__nh)); }


      iterator
      insert(const_iterator __hint, node_type&& __nh)
      { return _M_h._M_reinsert_node_multi(__hint, std::move(__nh)); }
# 1375 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      iterator
      erase(const_iterator __position)
      { return _M_h.erase(__position); }


      iterator
      erase(iterator __position)
      { return _M_h.erase(__position); }
# 1398 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_h.erase(__x); }
# 1418 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_h.erase(__first, __last); }
# 1429 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      void
      clear() noexcept
      { _M_h.clear(); }
# 1442 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      void
      swap(unordered_multiset& __x)
      noexcept( noexcept(_M_h.swap(__x._M_h)) )
      { _M_h.swap(__x._M_h); }


      template<typename, typename, typename>
 friend class std::_Hash_merge_helper;

      template<typename _H2, typename _P2>
 void
 merge(unordered_multiset<_Value, _H2, _P2, _Alloc>& __source)
 {
   using _Merge_helper
     = _Hash_merge_helper<unordered_multiset, _H2, _P2>;
   _M_h._M_merge_multi(_Merge_helper::_S_get_table(__source));
 }

      template<typename _H2, typename _P2>
 void
 merge(unordered_multiset<_Value, _H2, _P2, _Alloc>&& __source)
 { merge(__source); }

      template<typename _H2, typename _P2>
 void
 merge(unordered_set<_Value, _H2, _P2, _Alloc>& __source)
 {
   using _Merge_helper
     = _Hash_merge_helper<unordered_multiset, _H2, _P2>;
   _M_h._M_merge_multi(_Merge_helper::_S_get_table(__source));
 }

      template<typename _H2, typename _P2>
 void
 merge(unordered_set<_Value, _H2, _P2, _Alloc>&& __source)
 { merge(__source); }






      hasher
      hash_function() const
      { return _M_h.hash_function(); }



      key_equal
      key_eq() const
      { return _M_h.key_eq(); }
# 1508 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      iterator
      find(const key_type& __x)
      { return _M_h.find(__x); }


      template<typename _Kt>
 auto
 find(const _Kt& __x)
 -> decltype(_M_h._M_find_tr(__x))
 { return _M_h._M_find_tr(__x); }


      const_iterator
      find(const key_type& __x) const
      { return _M_h.find(__x); }


      template<typename _Kt>
 auto
 find(const _Kt& __x) const
 -> decltype(_M_h._M_find_tr(__x))
 { return _M_h._M_find_tr(__x); }
# 1539 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_h.count(__x); }


      template<typename _Kt>
 auto
 count(const _Kt& __x) const -> decltype(_M_h._M_count_tr(__x))
 { return _M_h._M_count_tr(__x); }
# 1558 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      bool
      contains(const key_type& __x) const
      { return _M_h.find(__x) != _M_h.end(); }

      template<typename _Kt>
 auto
 contains(const _Kt& __x) const
 -> decltype(_M_h._M_find_tr(__x), void(), true)
 { return _M_h._M_find_tr(__x) != _M_h.end(); }
# 1577 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_h.equal_range(__x); }


      template<typename _Kt>
 auto
 equal_range(const _Kt& __x)
 -> decltype(_M_h._M_equal_range_tr(__x))
 { return _M_h._M_equal_range_tr(__x); }


      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_h.equal_range(__x); }


      template<typename _Kt>
 auto
 equal_range(const _Kt& __x) const
 -> decltype(_M_h._M_equal_range_tr(__x))
 { return _M_h._M_equal_range_tr(__x); }






      size_type
      bucket_count() const noexcept
      { return _M_h.bucket_count(); }


      size_type
      max_bucket_count() const noexcept
      { return _M_h.max_bucket_count(); }






      size_type
      bucket_size(size_type __n) const
      { return _M_h.bucket_size(__n); }






      size_type
      bucket(const key_type& __key) const
      { return _M_h.bucket(__key); }
# 1639 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      local_iterator
      begin(size_type __n)
      { return _M_h.begin(__n); }

      const_local_iterator
      begin(size_type __n) const
      { return _M_h.begin(__n); }

      const_local_iterator
      cbegin(size_type __n) const
      { return _M_h.cbegin(__n); }
# 1659 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      local_iterator
      end(size_type __n)
      { return _M_h.end(__n); }

      const_local_iterator
      end(size_type __n) const
      { return _M_h.end(__n); }

      const_local_iterator
      cend(size_type __n) const
      { return _M_h.cend(__n); }





      float
      load_factor() const noexcept
      { return _M_h.load_factor(); }



      float
      max_load_factor() const noexcept
      { return _M_h.max_load_factor(); }





      void
      max_load_factor(float __z)
      { _M_h.max_load_factor(__z); }
# 1700 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      void
      rehash(size_type __n)
      { _M_h.rehash(__n); }
# 1711 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
      void
      reserve(size_type __n)
      { _M_h.reserve(__n); }

      template<typename _Value1, typename _Hash1, typename _Pred1,
        typename _Alloc1>
        friend bool
      operator==(const unordered_multiset<_Value1, _Hash1, _Pred1, _Alloc1>&,
   const unordered_multiset<_Value1, _Hash1, _Pred1, _Alloc1>&);
    };




  template<typename _InputIterator,
    typename _Hash =
      hash<typename iterator_traits<_InputIterator>::value_type>,
    typename _Pred =
      equal_to<typename iterator_traits<_InputIterator>::value_type>,
    typename _Allocator =
      allocator<typename iterator_traits<_InputIterator>::value_type>,
    typename = _RequireInputIter<_InputIterator>,
    typename = _RequireNotAllocatorOrIntegral<_Hash>,
    typename = _RequireNotAllocator<_Pred>,
    typename = _RequireAllocator<_Allocator>>
    unordered_multiset(_InputIterator, _InputIterator,
         unordered_multiset<int>::size_type = {},
         _Hash = _Hash(), _Pred = _Pred(),
         _Allocator = _Allocator())
    -> unordered_multiset<typename iterator_traits<_InputIterator>::value_type,
                          _Hash, _Pred, _Allocator>;

  template<typename _Tp, typename _Hash = hash<_Tp>,
    typename _Pred = equal_to<_Tp>,
    typename _Allocator = allocator<_Tp>,
    typename = _RequireNotAllocatorOrIntegral<_Hash>,
    typename = _RequireNotAllocator<_Pred>,
    typename = _RequireAllocator<_Allocator>>
    unordered_multiset(initializer_list<_Tp>,
         unordered_multiset<int>::size_type = {},
         _Hash = _Hash(), _Pred = _Pred(),
         _Allocator = _Allocator())
    -> unordered_multiset<_Tp, _Hash, _Pred, _Allocator>;

  template<typename _InputIterator, typename _Allocator,
    typename = _RequireInputIter<_InputIterator>,
    typename = _RequireAllocator<_Allocator>>
    unordered_multiset(_InputIterator, _InputIterator,
         unordered_multiset<int>::size_type, _Allocator)
    -> unordered_multiset<typename iterator_traits<_InputIterator>::value_type,
     hash<typename
          iterator_traits<_InputIterator>::value_type>,
     equal_to<typename
       iterator_traits<_InputIterator>::value_type>,
     _Allocator>;

  template<typename _InputIterator, typename _Hash, typename _Allocator,
    typename = _RequireInputIter<_InputIterator>,
    typename = _RequireNotAllocatorOrIntegral<_Hash>,
    typename = _RequireAllocator<_Allocator>>
    unordered_multiset(_InputIterator, _InputIterator,
         unordered_multiset<int>::size_type,
         _Hash, _Allocator)
    -> unordered_multiset<typename
     iterator_traits<_InputIterator>::value_type,
     _Hash,
     equal_to<
       typename
       iterator_traits<_InputIterator>::value_type>,
     _Allocator>;

  template<typename _Tp, typename _Allocator,
    typename = _RequireAllocator<_Allocator>>
    unordered_multiset(initializer_list<_Tp>,
         unordered_multiset<int>::size_type, _Allocator)
    -> unordered_multiset<_Tp, hash<_Tp>, equal_to<_Tp>, _Allocator>;

  template<typename _Tp, typename _Hash, typename _Allocator,
    typename = _RequireNotAllocatorOrIntegral<_Hash>,
    typename = _RequireAllocator<_Allocator>>
    unordered_multiset(initializer_list<_Tp>,
         unordered_multiset<int>::size_type, _Hash, _Allocator)
    -> unordered_multiset<_Tp, _Hash, equal_to<_Tp>, _Allocator>;



  template<class _Value, class _Hash, class _Pred, class _Alloc>
    inline void
    swap(unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,
  unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }

  template<class _Value, class _Hash, class _Pred, class _Alloc>
    inline void
    swap(unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,
  unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }

  template<class _Value, class _Hash, class _Pred, class _Alloc>
    inline bool
    operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,
        const unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)
    { return __x._M_h._M_equal(__y._M_h); }
# 1825 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3
  template<class _Value, class _Hash, class _Pred, class _Alloc>
    inline bool
    operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,
        const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)
    { return __x._M_h._M_equal(__y._M_h); }
# 1839 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/unordered_set.h" 3




  template<typename _Val, typename _Hash1, typename _Eq1, typename _Alloc,
    typename _Hash2, typename _Eq2>
    struct _Hash_merge_helper<
      std::unordered_set<_Val, _Hash1, _Eq1, _Alloc>, _Hash2, _Eq2>
    {
    private:
      template<typename... _Tp>
 using unordered_set = std::unordered_set<_Tp...>;
      template<typename... _Tp>
 using unordered_multiset = std::unordered_multiset<_Tp...>;

      friend unordered_set<_Val, _Hash1, _Eq1, _Alloc>;

      static auto&
      _S_get_table(unordered_set<_Val, _Hash2, _Eq2, _Alloc>& __set)
      { return __set._M_h; }

      static auto&
      _S_get_table(unordered_multiset<_Val, _Hash2, _Eq2, _Alloc>& __set)
      { return __set._M_h; }
    };


  template<typename _Val, typename _Hash1, typename _Eq1, typename _Alloc,
    typename _Hash2, typename _Eq2>
    struct _Hash_merge_helper<
      std::unordered_multiset<_Val, _Hash1, _Eq1, _Alloc>,
      _Hash2, _Eq2>
    {
    private:
      template<typename... _Tp>
 using unordered_set = std::unordered_set<_Tp...>;
      template<typename... _Tp>
 using unordered_multiset = std::unordered_multiset<_Tp...>;

      friend unordered_multiset<_Val, _Hash1, _Eq1, _Alloc>;

      static auto&
      _S_get_table(unordered_set<_Val, _Hash2, _Eq2, _Alloc>& __set)
      { return __set._M_h; }

      static auto&
      _S_get_table(unordered_multiset<_Val, _Hash2, _Eq2, _Alloc>& __set)
      { return __set._M_h; }
    };



}
# 42 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/unordered_set" 2 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/range_access.h" 1 3
# 33 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/range_access.h" 3
       
# 34 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/range_access.h" 3






namespace std
{







  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr auto
    begin(_Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr auto
    begin(const _Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr auto
    end(_Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr auto
    end(const _Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }





  template<typename _Tp, size_t _Nm>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr _Tp*
    begin(_Tp (&__arr)[_Nm]) noexcept
    { return __arr; }






  template<typename _Tp, size_t _Nm>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr _Tp*
    end(_Tp (&__arr)[_Nm]) noexcept
    { return __arr + _Nm; }



  template<typename _Tp> class valarray;

  template<typename _Tp> _Tp* begin(valarray<_Tp>&) noexcept;
  template<typename _Tp> const _Tp* begin(const valarray<_Tp>&) noexcept;
  template<typename _Tp> _Tp* end(valarray<_Tp>&) noexcept;
  template<typename _Tp> const _Tp* end(const valarray<_Tp>&) noexcept;






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    constexpr auto
    cbegin(const _Container& __cont) noexcept(noexcept(std::begin(__cont)))
      -> decltype(std::begin(__cont))
    { return std::begin(__cont); }






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    constexpr auto
    cend(const _Container& __cont) noexcept(noexcept(std::end(__cont)))
      -> decltype(std::end(__cont))
    { return std::end(__cont); }






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr auto
    rbegin(_Container& __cont) -> decltype(__cont.rbegin())
    { return __cont.rbegin(); }






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr auto
    rbegin(const _Container& __cont) -> decltype(__cont.rbegin())
    { return __cont.rbegin(); }






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr auto
    rend(_Container& __cont) -> decltype(__cont.rend())
    { return __cont.rend(); }






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr auto
    rend(const _Container& __cont) -> decltype(__cont.rend())
    { return __cont.rend(); }






  template<typename _Tp, size_t _Nm>
    [[__nodiscard__]]
    inline constexpr reverse_iterator<_Tp*>
    rbegin(_Tp (&__arr)[_Nm]) noexcept
    { return reverse_iterator<_Tp*>(__arr + _Nm); }






  template<typename _Tp, size_t _Nm>
    [[__nodiscard__]]
    inline constexpr reverse_iterator<_Tp*>
    rend(_Tp (&__arr)[_Nm]) noexcept
    { return reverse_iterator<_Tp*>(__arr); }






  template<typename _Tp>
    [[__nodiscard__]]
    inline constexpr reverse_iterator<const _Tp*>
    rbegin(initializer_list<_Tp> __il) noexcept
    { return reverse_iterator<const _Tp*>(__il.end()); }






  template<typename _Tp>
    [[__nodiscard__]]
    inline constexpr reverse_iterator<const _Tp*>
    rend(initializer_list<_Tp> __il) noexcept
    { return reverse_iterator<const _Tp*>(__il.begin()); }






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr auto
    crbegin(const _Container& __cont) -> decltype(std::rbegin(__cont))
    { return std::rbegin(__cont); }






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr auto
    crend(const _Container& __cont) -> decltype(std::rend(__cont))
    { return std::rend(__cont); }
# 259 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/range_access.h" 3
  template <typename _Container>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr auto
    size(const _Container& __cont) noexcept(noexcept(__cont.size()))
    -> decltype(__cont.size())
    { return __cont.size(); }




  template <typename _Tp, size_t _Nm>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr size_t
    size(const _Tp (&)[_Nm]) noexcept
    { return _Nm; }





  template <typename _Container>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr auto
    empty(const _Container& __cont) noexcept(noexcept(__cont.empty()))
    -> decltype(__cont.empty())
    { return __cont.empty(); }




  template <typename _Tp, size_t _Nm>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr bool
    empty(const _Tp (&)[_Nm]) noexcept
    { return false; }





  template <typename _Tp>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr bool
    empty(initializer_list<_Tp> __il) noexcept
    { return __il.size() == 0;}





  template <typename _Container>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr auto
    data(_Container& __cont) noexcept(noexcept(__cont.data()))
    -> decltype(__cont.data())
    { return __cont.data(); }





  template <typename _Container>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr auto
    data(const _Container& __cont) noexcept(noexcept(__cont.data()))
    -> decltype(__cont.data())
    { return __cont.data(); }





  template <typename _Tp, size_t _Nm>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr _Tp*
    data(_Tp (&__array)[_Nm]) noexcept
    { return __array; }





  template <typename _Tp>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr const _Tp*
    data(initializer_list<_Tp> __il) noexcept
    { return __il.begin(); }



  template<typename _Container>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr auto
    ssize(const _Container& __cont)
    noexcept(noexcept(__cont.size()))
    -> common_type_t<ptrdiff_t, make_signed_t<decltype(__cont.size())>>
    {
      using type = make_signed_t<decltype(__cont.size())>;
      return static_cast<common_type_t<ptrdiff_t, type>>(__cont.size());
    }

  template<typename _Tp, ptrdiff_t _Num>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr ptrdiff_t
    ssize(const _Tp (&)[_Num]) noexcept
    { return _Num; }


}
# 43 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/unordered_set" 2 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/erase_if.h" 1 3
# 33 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/erase_if.h" 3
       
# 34 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/erase_if.h" 3





namespace std
{


  namespace __detail
  {
    template<typename _Container, typename _UnsafeContainer,
      typename _Predicate>
      typename _Container::size_type
      __erase_nodes_if(_Container& __cont, _UnsafeContainer& __ucont,
         _Predicate __pred)
      {
 typename _Container::size_type __num = 0;
 for (auto __iter = __ucont.begin(), __last = __ucont.end();
      __iter != __last;)
   {
     if (__pred(*__iter))
       {
  __iter = __cont.erase(__iter);
  ++__num;
       }
     else
       ++__iter;
   }
 return __num;
      }
  }


}
# 44 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/unordered_set" 2 3
# 53 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/unordered_set" 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 1 3
# 47 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 3
       
# 48 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 3
# 54 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/unordered_set" 2 3


# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/memory_resource.h" 1 3
# 33 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/memory_resource.h" 3
       
# 34 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/memory_resource.h" 3




# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cstddef" 1 3
# 42 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cstddef" 3
       
# 43 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cstddef" 3







# 1 "D:/Enviroments/mingw64_msvcrt/lib/gcc/x86_64-w64-mingw32/14.2.0/include/stddef.h" 1 3 4
# 1 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/stddef.h" 1 3 4






# 1 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/crtdefs.h" 1 3 4
# 10 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/crtdefs.h" 3 4
# 1 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/corecrt.h" 1 3 4
# 10 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/corecrt.h" 3 4
# 1 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/_mingw.h" 1 3 4
# 10 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/_mingw.h" 3 4
# 1 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/_mingw_mac.h" 1 3 4
# 98 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/_mingw_mac.h" 3 4
             
# 107 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/_mingw_mac.h" 3 4
             
# 316 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/_mingw_mac.h" 3 4
       
# 395 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/_mingw_mac.h" 3 4
       
# 11 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/_mingw.h" 2 3 4
# 1 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/_mingw_secapi.h" 1 3 4
# 44 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/_mingw_secapi.h" 3 4
extern "C++" {
template <bool __test, typename __dsttype>
  struct __if_array;
template <typename __dsttype>
  struct __if_array <true, __dsttype> {
    typedef __dsttype __type;
};
}
# 12 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/_mingw.h" 2 3 4
# 282 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/_mingw.h" 3 4
# 1 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/vadefs.h" 1 3 4
# 9 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/vadefs.h" 3 4
# 1 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/_mingw.h" 1 3 4
# 661 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/_mingw.h" 3 4
# 1 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/sdks/_mingw_ddk.h" 1 3 4
# 662 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/_mingw.h" 2 3 4
# 10 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/vadefs.h" 2 3 4




#pragma pack(push,_CRT_PACKING)



extern "C" {





  typedef __builtin_va_list __gnuc_va_list;






  typedef __gnuc_va_list va_list;
# 99 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/vadefs.h" 3 4
}



#pragma pack(pop)
# 283 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/_mingw.h" 2 3 4
# 568 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/_mingw.h" 3 4
extern "C" {
# 580 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/_mingw.h" 3 4
void __attribute__((__cdecl__)) __debugbreak(void);
extern __inline__ __attribute__((__always_inline__,__gnu_inline__)) void __attribute__((__cdecl__)) __debugbreak(void)
{

  __asm__ __volatile__("int {$}3":);







}
# 601 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/_mingw.h" 3 4
void __attribute__((__cdecl__)) __attribute__ ((__noreturn__)) __fastfail(unsigned int code);
extern __inline__ __attribute__((__always_inline__,__gnu_inline__)) void __attribute__((__cdecl__)) __attribute__ ((__noreturn__)) __fastfail(unsigned int code)
{

  __asm__ __volatile__("int {$}0x29"::"c"(code));
# 615 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/_mingw.h" 3 4
  __builtin_unreachable();
}
# 641 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/_mingw.h" 3 4
const char *__mingw_get_crt_info (void);


}
# 11 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/corecrt.h" 2 3 4




#pragma pack(push,_CRT_PACKING)
# 35 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/corecrt.h" 3 4
__extension__ typedef unsigned long long size_t;
# 45 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/corecrt.h" 3 4
__extension__ typedef long long ssize_t;






typedef size_t rsize_t;
# 62 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/corecrt.h" 3 4
__extension__ typedef long long intptr_t;
# 75 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/corecrt.h" 3 4
__extension__ typedef unsigned long long uintptr_t;
# 88 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/corecrt.h" 3 4
__extension__ typedef long long ptrdiff_t;
# 106 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/corecrt.h" 3 4
typedef unsigned short wint_t;
typedef unsigned short wctype_t;





typedef int errno_t;




typedef long __time32_t;




__extension__ typedef long long __time64_t;
# 138 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/corecrt.h" 3 4
typedef __time64_t time_t;
# 430 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/corecrt.h" 3 4
struct threadlocaleinfostruct;
struct threadmbcinfostruct;
typedef struct threadlocaleinfostruct *pthreadlocinfo;
typedef struct threadmbcinfostruct *pthreadmbcinfo;
struct __lc_time_data;

typedef struct localeinfo_struct {
  pthreadlocinfo locinfo;
  pthreadmbcinfo mbcinfo;
} _locale_tstruct,*_locale_t;



typedef struct tagLC_ID {
  unsigned short wLanguage;
  unsigned short wCountry;
  unsigned short wCodePage;
} LC_ID,*LPLC_ID;




typedef struct threadlocaleinfostruct {





  int refcount;
  unsigned int lc_codepage;
  unsigned int lc_collate_cp;
  unsigned long lc_handle[6];
  LC_ID lc_id[6];
  struct {
    char *locale;
    wchar_t *wlocale;
    int *refcount;
    int *wrefcount;
  } lc_category[6];
  int lc_clike;
  int mb_cur_max;
  int *lconv_intl_refcount;
  int *lconv_num_refcount;
  int *lconv_mon_refcount;
  struct lconv *lconv;
  int *ctype1_refcount;
  unsigned short *ctype1;
  const unsigned short *pctype;
  const unsigned char *pclmap;
  const unsigned char *pcumap;
  struct __lc_time_data *lc_time_curr;

} threadlocinfo;
# 501 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/corecrt.h" 3 4
#pragma pack(pop)
# 11 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/crtdefs.h" 2 3 4
# 8 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/stddef.h" 2 3 4





extern "C" {




  __attribute__ ((__dllimport__)) extern int *__attribute__((__cdecl__)) _errno(void);

  errno_t __attribute__((__cdecl__)) _set_errno(int _Value);
  errno_t __attribute__((__cdecl__)) _get_errno(int *_Value);


  __attribute__ ((__dllimport__)) extern unsigned long __attribute__((__cdecl__)) __threadid(void);

  __attribute__ ((__dllimport__)) extern uintptr_t __attribute__((__cdecl__)) __threadhandle(void);


}
# 424 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;
# 2 "D:/Enviroments/mingw64_msvcrt/lib/gcc/x86_64-w64-mingw32/14.2.0/include/stddef.h" 2 3 4
# 51 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cstddef" 2 3


# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 1 3
# 47 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 3
       
# 48 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 3
# 54 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cstddef" 2 3

extern "C++"
{

namespace std
{

  using ::max_align_t;
}



namespace std
{


  enum class byte : unsigned char {};

  template<typename _IntegerType> struct __byte_operand { };
  template<> struct __byte_operand<bool> { using __type = byte; };
  template<> struct __byte_operand<char> { using __type = byte; };
  template<> struct __byte_operand<signed char> { using __type = byte; };
  template<> struct __byte_operand<unsigned char> { using __type = byte; };
  template<> struct __byte_operand<wchar_t> { using __type = byte; };

  template<> struct __byte_operand<char8_t> { using __type = byte; };

  template<> struct __byte_operand<char16_t> { using __type = byte; };
  template<> struct __byte_operand<char32_t> { using __type = byte; };
  template<> struct __byte_operand<short> { using __type = byte; };
  template<> struct __byte_operand<unsigned short> { using __type = byte; };
  template<> struct __byte_operand<int> { using __type = byte; };
  template<> struct __byte_operand<unsigned int> { using __type = byte; };
  template<> struct __byte_operand<long> { using __type = byte; };
  template<> struct __byte_operand<unsigned long> { using __type = byte; };
  template<> struct __byte_operand<long long> { using __type = byte; };
  template<> struct __byte_operand<unsigned long long> { using __type = byte; };

  template<> struct __byte_operand<__int128>
  { using __type = byte; };
  template<> struct __byte_operand<unsigned __int128>
  { using __type = byte; };
# 109 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cstddef" 3
  template<typename _IntegerType>
    struct __byte_operand<const _IntegerType>
    : __byte_operand<_IntegerType> { };
  template<typename _IntegerType>
    struct __byte_operand<volatile _IntegerType>
    : __byte_operand<_IntegerType> { };
  template<typename _IntegerType>
    struct __byte_operand<const volatile _IntegerType>
    : __byte_operand<_IntegerType> { };

  template<typename _IntegerType>
    using __byte_op_t = typename __byte_operand<_IntegerType>::__type;

  template<typename _IntegerType>
    [[__gnu__::__always_inline__]]
    constexpr __byte_op_t<_IntegerType>
    operator<<(byte __b, _IntegerType __shift) noexcept
    { return (byte)(unsigned char)((unsigned)__b << __shift); }

  template<typename _IntegerType>
    [[__gnu__::__always_inline__]]
    constexpr __byte_op_t<_IntegerType>
    operator>>(byte __b, _IntegerType __shift) noexcept
    { return (byte)(unsigned char)((unsigned)__b >> __shift); }

  [[__gnu__::__always_inline__]]
  constexpr byte
  operator|(byte __l, byte __r) noexcept
  { return (byte)(unsigned char)((unsigned)__l | (unsigned)__r); }

  [[__gnu__::__always_inline__]]
  constexpr byte
  operator&(byte __l, byte __r) noexcept
  { return (byte)(unsigned char)((unsigned)__l & (unsigned)__r); }

  [[__gnu__::__always_inline__]]
  constexpr byte
  operator^(byte __l, byte __r) noexcept
  { return (byte)(unsigned char)((unsigned)__l ^ (unsigned)__r); }

  [[__gnu__::__always_inline__]]
  constexpr byte
  operator~(byte __b) noexcept
  { return (byte)(unsigned char)~(unsigned)__b; }

  template<typename _IntegerType>
    [[__gnu__::__always_inline__]]
    constexpr __byte_op_t<_IntegerType>&
    operator<<=(byte& __b, _IntegerType __shift) noexcept
    { return __b = __b << __shift; }

  template<typename _IntegerType>
    [[__gnu__::__always_inline__]]
    constexpr __byte_op_t<_IntegerType>&
    operator>>=(byte& __b, _IntegerType __shift) noexcept
    { return __b = __b >> __shift; }

  [[__gnu__::__always_inline__]]
  constexpr byte&
  operator|=(byte& __l, byte __r) noexcept
  { return __l = __l | __r; }

  [[__gnu__::__always_inline__]]
  constexpr byte&
  operator&=(byte& __l, byte __r) noexcept
  { return __l = __l & __r; }

  [[__gnu__::__always_inline__]]
  constexpr byte&
  operator^=(byte& __l, byte __r) noexcept
  { return __l = __l ^ __r; }

  template<typename _IntegerType>
    [[nodiscard,__gnu__::__always_inline__]]
    constexpr _IntegerType
    to_integer(__byte_op_t<_IntegerType> __b) noexcept
    { return _IntegerType(__b); }


}

}
# 39 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/memory_resource.h" 2 3


# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/uses_allocator_args.h" 1 3
# 33 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/uses_allocator_args.h" 3
       
# 34 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/uses_allocator_args.h" 3

# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 1 3
# 47 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 3
       
# 48 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 3
# 36 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/uses_allocator_args.h" 2 3







namespace std
{


  template<typename _Tp>
    concept _Std_pair = __is_pair<remove_cv_t<_Tp>>;




  template<typename _Tp, typename _Alloc, typename... _Args>
    constexpr auto
    uses_allocator_construction_args(const _Alloc& __a,
         _Args&&... __args) noexcept
    requires (! _Std_pair<_Tp>)
    {
      if constexpr (uses_allocator_v<remove_cv_t<_Tp>, _Alloc>)
 {
   if constexpr (is_constructible_v<_Tp, allocator_arg_t,
        const _Alloc&, _Args...>)
     {
       return tuple<allocator_arg_t, const _Alloc&, _Args&&...>(
    allocator_arg, __a, std::forward<_Args>(__args)...);
     }
   else
     {
       static_assert(is_constructible_v<_Tp, _Args..., const _Alloc&>,
    "construction with an allocator must be possible"
    " if uses_allocator is true");

       return tuple<_Args&&..., const _Alloc&>(
    std::forward<_Args>(__args)..., __a);
     }
 }
      else
 {
   static_assert(is_constructible_v<_Tp, _Args...>);

   return tuple<_Args&&...>(std::forward<_Args>(__args)...);
 }
    }

  template<_Std_pair _Tp, typename _Alloc, typename _Tuple1, typename _Tuple2>
    constexpr auto
    uses_allocator_construction_args(const _Alloc& __a, piecewise_construct_t,
         _Tuple1&& __x, _Tuple2&& __y) noexcept;

  template<_Std_pair _Tp, typename _Alloc>
    constexpr auto
    uses_allocator_construction_args(const _Alloc&) noexcept;

  template<_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp>
    constexpr auto
    uses_allocator_construction_args(const _Alloc&, _Up&&, _Vp&&) noexcept;

  template<_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp>
    constexpr auto
    uses_allocator_construction_args(const _Alloc&,
         const pair<_Up, _Vp>&) noexcept;

  template<_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp>
    constexpr auto
    uses_allocator_construction_args(const _Alloc&, pair<_Up, _Vp>&&) noexcept;


  template<_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp>
    constexpr auto
    uses_allocator_construction_args(const _Alloc&,
         pair<_Up, _Vp>&) noexcept;

  template<_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp>
    constexpr auto
    uses_allocator_construction_args(const _Alloc&, const pair<_Up, _Vp>&&) noexcept;


  template<_Std_pair _Tp, typename _Alloc, typename _Tuple1, typename _Tuple2>
    constexpr auto
    uses_allocator_construction_args(const _Alloc& __a, piecewise_construct_t,
         _Tuple1&& __x, _Tuple2&& __y) noexcept
    {
      using _Tp1 = typename _Tp::first_type;
      using _Tp2 = typename _Tp::second_type;

      return std::make_tuple(piecewise_construct,
   std::apply([&__a](auto&&... __args1) {
       return std::uses_allocator_construction_args<_Tp1>(
    __a, std::forward<decltype(__args1)>(__args1)...);
   }, std::forward<_Tuple1>(__x)),
   std::apply([&__a](auto&&... __args2) {
       return std::uses_allocator_construction_args<_Tp2>(
    __a, std::forward<decltype(__args2)>(__args2)...);
   }, std::forward<_Tuple2>(__y)));
    }

  template<_Std_pair _Tp, typename _Alloc>
    constexpr auto
    uses_allocator_construction_args(const _Alloc& __a) noexcept
    {
      using _Tp1 = typename _Tp::first_type;
      using _Tp2 = typename _Tp::second_type;

      return std::make_tuple(piecewise_construct,
   std::uses_allocator_construction_args<_Tp1>(__a),
   std::uses_allocator_construction_args<_Tp2>(__a));
    }

  template<_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp>
    constexpr auto
    uses_allocator_construction_args(const _Alloc& __a, _Up&& __u, _Vp&& __v)
      noexcept
    {
      using _Tp1 = typename _Tp::first_type;
      using _Tp2 = typename _Tp::second_type;

      return std::make_tuple(piecewise_construct,
   std::uses_allocator_construction_args<_Tp1>(__a,
     std::forward<_Up>(__u)),
   std::uses_allocator_construction_args<_Tp2>(__a,
     std::forward<_Vp>(__v)));
    }

  template<_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp>
    constexpr auto
    uses_allocator_construction_args(const _Alloc& __a,
         const pair<_Up, _Vp>& __pr) noexcept
    {
      using _Tp1 = typename _Tp::first_type;
      using _Tp2 = typename _Tp::second_type;

      return std::make_tuple(piecewise_construct,
   std::uses_allocator_construction_args<_Tp1>(__a, __pr.first),
   std::uses_allocator_construction_args<_Tp2>(__a, __pr.second));
    }

  template<_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp>
    constexpr auto
    uses_allocator_construction_args(const _Alloc& __a,
         pair<_Up, _Vp>&& __pr) noexcept
    {
      using _Tp1 = typename _Tp::first_type;
      using _Tp2 = typename _Tp::second_type;




      return std::make_tuple(piecewise_construct,
   std::uses_allocator_construction_args<_Tp1>(__a,
     std::get<0>(std::move(__pr))),
   std::uses_allocator_construction_args<_Tp2>(__a,
     std::get<1>(std::move(__pr))));
    }


  template<_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp>
    constexpr auto
    uses_allocator_construction_args(const _Alloc& __a,
         pair<_Up, _Vp>& __pr) noexcept
    {
      using _Tp1 = typename _Tp::first_type;
      using _Tp2 = typename _Tp::second_type;

      return std::make_tuple(piecewise_construct,
   std::uses_allocator_construction_args<_Tp1>(__a, __pr.first),
   std::uses_allocator_construction_args<_Tp2>(__a, __pr.second));
    }

  template<_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp>
    constexpr auto
    uses_allocator_construction_args(const _Alloc& __a,
         const pair<_Up, _Vp>&& __pr) noexcept
    {
      using _Tp1 = typename _Tp::first_type;
      using _Tp2 = typename _Tp::second_type;

      return std::make_tuple(piecewise_construct,
   std::uses_allocator_construction_args<_Tp1>(__a,
     std::get<0>(std::move(__pr))),
   std::uses_allocator_construction_args<_Tp2>(__a,
     std::get<1>(std::move(__pr))));
    }


  template<typename _Tp, typename _Alloc, typename... _Args>
    constexpr _Tp
    make_obj_using_allocator(const _Alloc& __a, _Args&&... __args)
    {
      return std::make_from_tuple<_Tp>(
   std::uses_allocator_construction_args<_Tp>(__a,
     std::forward<_Args>(__args)...));
    }

  template<typename _Tp, typename _Alloc, typename... _Args>
    constexpr _Tp*
    uninitialized_construct_using_allocator(_Tp* __p, const _Alloc& __a,
         _Args&&... __args)
    {
      return std::apply([&](auto&&... __xs) {
 return std::construct_at(__p, std::forward<decltype(__xs)>(__xs)...);
      }, std::uses_allocator_construction_args<_Tp>(__a,
 std::forward<_Args>(__args)...));
    }


}
# 42 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/memory_resource.h" 2 3
# 50 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/memory_resource.h" 3
namespace std
{

namespace pmr
{






  class memory_resource
  {
    static constexpr size_t _S_max_align = alignof(max_align_t);

  public:
    memory_resource() = default;
    memory_resource(const memory_resource&) = default;
    virtual ~memory_resource();

    memory_resource& operator=(const memory_resource&) = default;

    [[nodiscard]]
    void*
    allocate(size_t __bytes, size_t __alignment = _S_max_align)
    __attribute__((__returns_nonnull__,__alloc_size__(2),__alloc_align__(3)))
    { return ::operator new(__bytes, do_allocate(__bytes, __alignment)); }

    void
    deallocate(void* __p, size_t __bytes, size_t __alignment = _S_max_align)
    __attribute__((__nonnull__))
    { return do_deallocate(__p, __bytes, __alignment); }

    [[nodiscard]]
    bool
    is_equal(const memory_resource& __other) const noexcept
    { return do_is_equal(__other); }

  private:
    virtual void*
    do_allocate(size_t __bytes, size_t __alignment) = 0;

    virtual void
    do_deallocate(void* __p, size_t __bytes, size_t __alignment) = 0;

    virtual bool
    do_is_equal(const memory_resource& __other) const noexcept = 0;
  };

  [[nodiscard]]
  inline bool
  operator==(const memory_resource& __a, const memory_resource& __b) noexcept
  { return &__a == &__b || __a.is_equal(__b); }
# 119 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/memory_resource.h" 3
  template<typename _Tp>
    class polymorphic_allocator
    {


      template<typename _Up>
 struct __not_pair { using type = void; };

      template<typename _Up1, typename _Up2>
 struct __not_pair<pair<_Up1, _Up2>> { };

    public:
      using value_type = _Tp;

      polymorphic_allocator() noexcept
      {
 extern memory_resource* get_default_resource() noexcept
   __attribute__((__returns_nonnull__));
 _M_resource = get_default_resource();
      }

      polymorphic_allocator(memory_resource* __r) noexcept
      __attribute__((__nonnull__))
      : _M_resource(__r)
      { ; }

      polymorphic_allocator(const polymorphic_allocator& __other) = default;

      template<typename _Up>
 polymorphic_allocator(const polymorphic_allocator<_Up>& __x) noexcept
 : _M_resource(__x.resource())
 { }

      polymorphic_allocator&
      operator=(const polymorphic_allocator&) = delete;

      [[nodiscard]]
      _Tp*
      allocate(size_t __n)
      __attribute__((__returns_nonnull__))
      {
 if ((__gnu_cxx::__int_traits<size_t>::__max / sizeof(_Tp)) < __n)
   std::__throw_bad_array_new_length();
 return static_cast<_Tp*>(_M_resource->allocate(__n * sizeof(_Tp),
             alignof(_Tp)));
      }

      void
      deallocate(_Tp* __p, size_t __n) noexcept
      __attribute__((__nonnull__))
      { _M_resource->deallocate(__p, __n * sizeof(_Tp), alignof(_Tp)); }


      [[nodiscard]] void*
      allocate_bytes(size_t __nbytes,
       size_t __alignment = alignof(max_align_t))
      { return _M_resource->allocate(__nbytes, __alignment); }

      void
      deallocate_bytes(void* __p, size_t __nbytes,
         size_t __alignment = alignof(max_align_t))
      { _M_resource->deallocate(__p, __nbytes, __alignment); }

      template<typename _Up>
 [[nodiscard]] _Up*
 allocate_object(size_t __n = 1)
 {
   if ((__gnu_cxx::__int_traits<size_t>::__max / sizeof(_Up)) < __n)
     std::__throw_bad_array_new_length();
   return static_cast<_Up*>(allocate_bytes(__n * sizeof(_Up),
        alignof(_Up)));
 }

      template<typename _Up>
 void
 deallocate_object(_Up* __p, size_t __n = 1)
 { deallocate_bytes(__p, __n * sizeof(_Up), alignof(_Up)); }

      template<typename _Up, typename... _CtorArgs>
 [[nodiscard]] _Up*
 new_object(_CtorArgs&&... __ctor_args)
 {
   _Up* __p = allocate_object<_Up>();
   try
     {
       construct(__p, std::forward<_CtorArgs>(__ctor_args)...);
     }
   catch(...)
     {
       deallocate_object(__p);
       throw;
     }
   return __p;
 }

      template<typename _Up>
 void
 delete_object(_Up* __p)
 {
   __p->~_Up();
   deallocate_object(__p);
 }
# 297 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/memory_resource.h" 3
      template<typename _Tp1, typename... _Args>
 __attribute__((__nonnull__))
 void
 construct(_Tp1* __p, _Args&&... __args)
 {
   std::uninitialized_construct_using_allocator(__p, *this,
       std::forward<_Args>(__args)...);
 }


      template<typename _Up>
 __attribute__ ((__deprecated__ ("use '" "allocator_traits::destroy" "' instead")))
 __attribute__((__nonnull__))
 void
 destroy(_Up* __p)
 { __p->~_Up(); }

      polymorphic_allocator
      select_on_container_copy_construction() const noexcept
      { return polymorphic_allocator(); }

      memory_resource*
      resource() const noexcept
      __attribute__((__returns_nonnull__))
      { return _M_resource; }



      [[nodiscard]]
      friend bool
      operator==(const polymorphic_allocator& __a,
   const polymorphic_allocator& __b) noexcept
      { return *__a.resource() == *__b.resource(); }
# 339 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/memory_resource.h" 3
    private:
# 366 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/memory_resource.h" 3
      memory_resource* _M_resource;
    };

  template<typename _Tp1, typename _Tp2>
    [[nodiscard]]
    inline bool
    operator==(const polymorphic_allocator<_Tp1>& __a,
        const polymorphic_allocator<_Tp2>& __b) noexcept
    { return *__a.resource() == *__b.resource(); }
# 385 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/memory_resource.h" 3
}

  template<typename _Alloc> struct allocator_traits;


  template<typename _Tp>
    struct allocator_traits<pmr::polymorphic_allocator<_Tp>>
    {

      using allocator_type = pmr::polymorphic_allocator<_Tp>;


      using value_type = _Tp;


      using pointer = _Tp*;


      using const_pointer = const _Tp*;


      using void_pointer = void*;


      using const_void_pointer = const void*;


      using difference_type = std::ptrdiff_t;


      using size_type = std::size_t;





      using propagate_on_container_copy_assignment = false_type;
      using propagate_on_container_move_assignment = false_type;
      using propagate_on_container_swap = false_type;

      static allocator_type
      select_on_container_copy_construction(const allocator_type&) noexcept
      { return allocator_type(); }



      using is_always_equal = false_type;

      template<typename _Up>
 using rebind_alloc = pmr::polymorphic_allocator<_Up>;

      template<typename _Up>
 using rebind_traits = allocator_traits<pmr::polymorphic_allocator<_Up>>;
# 446 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/memory_resource.h" 3
      [[nodiscard]] static pointer
      allocate(allocator_type& __a, size_type __n)
      { return __a.allocate(__n); }
# 461 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/memory_resource.h" 3
      [[nodiscard]] static pointer
      allocate(allocator_type& __a, size_type __n, const_void_pointer)
      { return __a.allocate(__n); }
# 473 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/memory_resource.h" 3
      static void
      deallocate(allocator_type& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 488 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/memory_resource.h" 3
      template<typename _Up, typename... _Args>
 static void
 construct(allocator_type& __a, _Up* __p, _Args&&... __args)
 { __a.construct(__p, std::forward<_Args>(__args)...); }
# 500 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/memory_resource.h" 3
      template<typename _Up>
 static constexpr void
 destroy(allocator_type&, _Up* __p)
 noexcept(is_nothrow_destructible<_Up>::value)
 { __p->~_Up(); }





      static constexpr size_type
      max_size(const allocator_type&) noexcept
      { return size_t(-1) / sizeof(value_type); }
    };


}
# 57 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/unordered_set" 2 3
namespace std
{

  namespace pmr
  {
    template<typename _Key, typename _Hash = std::hash<_Key>,
      typename _Pred = std::equal_to<_Key>>
      using unordered_set
 = std::unordered_set<_Key, _Hash, _Pred,
        polymorphic_allocator<_Key>>;
    template<typename _Key, typename _Hash = std::hash<_Key>,
      typename _Pred = std::equal_to<_Key>>
      using unordered_multiset
 = std::unordered_multiset<_Key, _Hash, _Pred,
      polymorphic_allocator<_Key>>;
  }

}



namespace std
{

  template<typename _Key, typename _Hash, typename _CPred, typename _Alloc,
    typename _Predicate>
    inline typename unordered_set<_Key, _Hash, _CPred, _Alloc>::size_type
    erase_if(unordered_set<_Key, _Hash, _CPred, _Alloc>& __cont,
      _Predicate __pred)
    {
      std::unordered_set<_Key, _Hash, _CPred, _Alloc>&
 __ucont = __cont;
      return __detail::__erase_nodes_if(__cont, __ucont, __pred);
    }

  template<typename _Key, typename _Hash, typename _CPred, typename _Alloc,
    typename _Predicate>
    inline typename unordered_multiset<_Key, _Hash, _CPred, _Alloc>::size_type
    erase_if(unordered_multiset<_Key, _Hash, _CPred, _Alloc>& __cont,
      _Predicate __pred)
    {
      std::unordered_multiset<_Key, _Hash, _CPred, _Alloc>&
 __ucont = __cont;
      return __detail::__erase_nodes_if(__cont, __ucont, __pred);
    }

}
# 3 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/src/Creepy/Input.cpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/Creepy/Input.hpp" 1
       

# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cstdint" 1 3
# 32 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cstdint" 3
       
# 33 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cstdint" 3
# 45 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cstdint" 3
# 1 "D:/Enviroments/mingw64_msvcrt/lib/gcc/x86_64-w64-mingw32/14.2.0/include/stdint.h" 1 3 4
# 9 "D:/Enviroments/mingw64_msvcrt/lib/gcc/x86_64-w64-mingw32/14.2.0/include/stdint.h" 3 4
# 1 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/stdint.h" 1 3 4
# 32 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/stdint.h" 3 4
# 1 "D:/Enviroments/mingw64_msvcrt/lib/gcc/x86_64-w64-mingw32/14.2.0/include/stddef.h" 1 3 4
# 1 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/stddef.h" 1 3 4
# 2 "D:/Enviroments/mingw64_msvcrt/lib/gcc/x86_64-w64-mingw32/14.2.0/include/stddef.h" 2 3 4
# 33 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/stdint.h" 2 3 4


typedef signed char int8_t;
typedef unsigned char uint8_t;
typedef short int16_t;
typedef unsigned short uint16_t;
typedef int int32_t;
typedef unsigned uint32_t;
__extension__ typedef long long int64_t;
__extension__ typedef unsigned long long uint64_t;


typedef signed char int_least8_t;
typedef unsigned char uint_least8_t;
typedef short int_least16_t;
typedef unsigned short uint_least16_t;
typedef int int_least32_t;
typedef unsigned uint_least32_t;
__extension__ typedef long long int_least64_t;
__extension__ typedef unsigned long long uint_least64_t;





typedef signed char int_fast8_t;
typedef unsigned char uint_fast8_t;
typedef short int_fast16_t;
typedef unsigned short uint_fast16_t;
typedef int int_fast32_t;
typedef unsigned int uint_fast32_t;
__extension__ typedef long long int_fast64_t;
__extension__ typedef unsigned long long uint_fast64_t;


__extension__ typedef long long intmax_t;
__extension__ typedef unsigned long long uintmax_t;
# 10 "D:/Enviroments/mingw64_msvcrt/lib/gcc/x86_64-w64-mingw32/14.2.0/include/stdint.h" 2 3 4
# 46 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cstdint" 2 3


namespace std
{

  using ::int8_t;
  using ::int16_t;
  using ::int32_t;
  using ::int64_t;

  using ::int_fast8_t;
  using ::int_fast16_t;
  using ::int_fast32_t;
  using ::int_fast64_t;

  using ::int_least8_t;
  using ::int_least16_t;
  using ::int_least32_t;
  using ::int_least64_t;

  using ::intmax_t;
  using ::intptr_t;

  using ::uint8_t;
  using ::uint16_t;
  using ::uint32_t;
  using ::uint64_t;

  using ::uint_fast8_t;
  using ::uint_fast16_t;
  using ::uint_fast32_t;
  using ::uint_fast64_t;

  using ::uint_least8_t;
  using ::uint_least16_t;
  using ::uint_least32_t;
  using ::uint_least64_t;

  using ::uintmax_t;
  using ::uintptr_t;
# 142 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cstdint" 3
}
# 4 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/Creepy/Input.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/glm.hpp" 1
# 104 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/glm.hpp"
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/_fixes.hpp" 1
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 1 3
# 39 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 3
       
# 40 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 3







# 1 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/math.h" 1 3
# 10 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/math.h" 3
       
# 11 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/math.h" 3




struct _exception;

#pragma pack(push,_CRT_PACKING)
# 77 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/math.h" 3
extern "C++" {
template <typename type1, typename type2> struct __mingw_types_compatible_p {
  static const bool result = false;
};

template <typename type1> struct __mingw_types_compatible_p<type1, type1> {
 static const bool result = true;
};

template <typename type1> struct __mingw_types_compatible_p<const type1, type1> {
  static const bool result = true;
};

template <typename type1> struct __mingw_types_compatible_p<type1, const type1> {
  static const bool result = true;
};
}
# 111 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/math.h" 3
extern "C" {







  typedef union __mingw_dbl_type_t {
    double x;
    unsigned long long val;
    __extension__ struct {
      unsigned int low, high;
    } lh;
  } __mingw_dbl_type_t;

  typedef union __mingw_flt_type_t {
    float x;
    unsigned int val;
  } __mingw_flt_type_t;

  typedef union __mingw_ldbl_type_t
  {
    long double x;
    __extension__ struct {
      unsigned int low, high;
      int sign_exponent : 16;
      int res1 : 16;
      int res0 : 32;
    } lh;
  } __mingw_ldbl_type_t;
# 150 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/math.h" 3
  extern double * __imp__HUGE;
# 163 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/math.h" 3
  struct _exception {
    int type;
    const char *name;
    double arg1;
    double arg2;
    double retval;
  };

  void __mingw_raise_matherr (int typ, const char *name, double a1, double a2,
         double rslt);
  void __mingw_setusermatherr (int (__attribute__((__cdecl__)) *)(struct _exception *));
  __attribute__ ((__dllimport__)) void __setusermatherr(int (__attribute__((__cdecl__)) *)(struct _exception *));



  double __attribute__((__cdecl__)) sin(double _X);
  double __attribute__((__cdecl__)) cos(double _X);
  double __attribute__((__cdecl__)) tan(double _X);
  double __attribute__((__cdecl__)) sinh(double _X);
  double __attribute__((__cdecl__)) cosh(double _X);
  double __attribute__((__cdecl__)) tanh(double _X);
  double __attribute__((__cdecl__)) asin(double _X);
  double __attribute__((__cdecl__)) acos(double _X);
  double __attribute__((__cdecl__)) atan(double _X);
  double __attribute__((__cdecl__)) atan2(double _Y,double _X);
  double __attribute__((__cdecl__)) exp(double _X);
  double __attribute__((__cdecl__)) log(double _X);
  double __attribute__((__cdecl__)) log10(double _X);
  double __attribute__((__cdecl__)) pow(double _X,double _Y);
  double __attribute__((__cdecl__)) sqrt(double _X);
  double __attribute__((__cdecl__)) ceil(double _X);
  double __attribute__((__cdecl__)) floor(double _X);


  extern float __attribute__((__cdecl__)) fabsf (float x);
  extern long double __attribute__((__cdecl__)) fabsl (long double);
  extern double __attribute__((__cdecl__)) fabs (double _X);



  inline float __attribute__((__cdecl__)) fabsf (float x)
  {

    return __builtin_fabsf (x);





  }

  inline long double __attribute__((__cdecl__)) fabsl (long double x)
  {



    long double res = 0.0l;
    __asm__ __volatile__ ("fabs;" : "=t" (res) : "0" (x));
    return res;

  }

  inline double __attribute__((__cdecl__)) fabs (double x)
  {

    return __builtin_fabs (x);





  }



  double __attribute__((__cdecl__)) ldexp(double _X,int _Y);
  double __attribute__((__cdecl__)) frexp(double _X,int *_Y);
  double __attribute__((__cdecl__)) modf(double _X,double *_Y);
  double __attribute__((__cdecl__)) fmod(double _X,double _Y);

  void __attribute__((__cdecl__)) sincos (double __x, double *p_sin, double *p_cos);
  void __attribute__((__cdecl__)) sincosl (long double __x, long double *p_sin, long double *p_cos);
  void __attribute__((__cdecl__)) sincosf (float __x, float *p_sin, float *p_cos);



  int __attribute__((__cdecl__)) abs(int _X);
  long __attribute__((__cdecl__)) labs(long _X);



  double __attribute__((__cdecl__)) atof(const char *_String);
  double __attribute__((__cdecl__)) _atof_l(const char *_String,_locale_t _Locale);
# 265 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/math.h" 3
  struct _complex {
    double x;
    double y;
  };


  double __attribute__((__cdecl__)) _cabs(struct _complex _ComplexA);
  double __attribute__((__cdecl__)) _hypot(double _X,double _Y);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _j0(double _X);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _j1(double _X);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _jn(int _X,double _Y);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _y0(double _X);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _y1(double _X);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _yn(int _X,double _Y);


  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _matherr (struct _exception *);
# 292 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/math.h" 3
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _chgsign (double _X);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _copysign (double _Number,double _Sign);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _logb (double);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _nextafter (double, double);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _scalb (double, long);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _finite (double);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fpclass (double);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isnan (double);






__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) j0 (double) ;
__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) j1 (double) ;
__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) jn (int, double) ;
__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) y0 (double) ;
__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) y1 (double) ;
__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) yn (int, double) ;

__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) chgsign (double);
# 322 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/math.h" 3
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) finite (double);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) fpclass (double);
# 367 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/math.h" 3
typedef float float_t;
typedef double double_t;
# 402 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/math.h" 3
  extern int __attribute__((__cdecl__)) __fpclassifyl (long double);
  extern int __attribute__((__cdecl__)) __fpclassifyf (float);
  extern int __attribute__((__cdecl__)) __fpclassify (double);


  inline int __attribute__((__cdecl__)) __fpclassifyl (long double x) {

    __mingw_ldbl_type_t hlp;
    unsigned int e;
    hlp.x = x;
    e = hlp.lh.sign_exponent & 0x7fff;
    if (!e)
      {
        unsigned int h = hlp.lh.high;
        if (!(hlp.lh.low | h))
          return 0x4000;
        else if (!(h & 0x80000000))
          return (0x0400 | 0x4000);
      }
    else if (e == 0x7fff)
      return (((hlp.lh.high & 0x7fffffff) | hlp.lh.low) == 0 ?
              (0x0100 | 0x0400) : 0x0100);
    return 0x0400;







  }
  inline int __attribute__((__cdecl__)) __fpclassify (double x) {

    __mingw_dbl_type_t hlp;
    unsigned int l, h;

    hlp.x = x;
    h = hlp.lh.high;
    l = hlp.lh.low | (h & 0xfffff);
    h &= 0x7ff00000;
    if ((h | l) == 0)
      return 0x4000;
    if (!h)
      return (0x0400 | 0x4000);
    if (h == 0x7ff00000)
      return (l ? 0x0100 : (0x0100 | 0x0400));
    return 0x0400;





  }
  inline int __attribute__((__cdecl__)) __fpclassifyf (float x) {

    __mingw_flt_type_t hlp;

    hlp.x = x;
    hlp.val &= 0x7fffffff;
    if (hlp.val == 0)
      return 0x4000;
    if (hlp.val < 0x800000)
      return (0x0400 | 0x4000);
    if (hlp.val >= 0x7f800000)
      return (hlp.val > 0x7f800000 ? 0x0100 : (0x0100 | 0x0400));
    return 0x0400;





  }
# 515 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/math.h" 3
  extern int __attribute__((__cdecl__)) __isnan (double);
  extern int __attribute__((__cdecl__)) __isnanf (float);
  extern int __attribute__((__cdecl__)) __isnanl (long double);


  inline int __attribute__((__cdecl__)) __isnan (double _x)
  {

    __mingw_dbl_type_t hlp;
    unsigned int l, h;

    hlp.x = _x;
    l = hlp.lh.low;
    h = hlp.lh.high & 0x7fffffff;
    h |= (l | -l) >> 31;
    h = 0x7ff00000 - h;
    return (int) h >> 31;







  }

  inline int __attribute__((__cdecl__)) __isnanf (float _x)
  {

    __mingw_flt_type_t hlp;
    unsigned int i;

    hlp.x = _x;
    i = hlp.val & 0x7fffffff;
    i = 0x7f800000 - i;
    return (int) (i >> 31);







  }

  inline int __attribute__((__cdecl__)) __isnanl (long double _x)
  {

    __mingw_ldbl_type_t ld;
    unsigned int xx, signexp;

    ld.x = _x;
    signexp = (ld.lh.sign_exponent & 0x7fff) << 1;
    xx = ld.lh.low | (ld.lh.high & 0x7fffffffu);
    signexp |= (xx | (-xx)) >> 31;
    signexp = 0xfffe - signexp;
    return (int) signexp >> 16;
# 581 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/math.h" 3
  }
# 602 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/math.h" 3
  extern int __attribute__((__cdecl__)) __signbit (double);
  extern int __attribute__((__cdecl__)) __signbitf (float);
  extern int __attribute__((__cdecl__)) __signbitl (long double);

  inline int __attribute__((__cdecl__)) __signbit (double x) {

    __mingw_dbl_type_t hlp;

    hlp.x = x;
    return ((hlp.lh.high & 0x80000000) != 0);





  }

  inline int __attribute__((__cdecl__)) __signbitf (float x) {

    __mingw_flt_type_t hlp;
    hlp.x = x;
    return ((hlp.val & 0x80000000) != 0);





  }

  inline int __attribute__((__cdecl__)) __signbitl (long double x) {

    __mingw_ldbl_type_t ld;
    ld.x = x;
    return ((ld.lh.sign_exponent & 0x8000) != 0);







  }
# 659 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/math.h" 3
  extern float __attribute__((__cdecl__)) sinf(float _X);
  extern long double __attribute__((__cdecl__)) sinl(long double);

  extern float __attribute__((__cdecl__)) cosf(float _X);
  extern long double __attribute__((__cdecl__)) cosl(long double);

  extern float __attribute__((__cdecl__)) tanf(float _X);
  extern long double __attribute__((__cdecl__)) tanl(long double);
  extern float __attribute__((__cdecl__)) asinf(float _X);
  extern long double __attribute__((__cdecl__)) asinl(long double);

  extern float __attribute__((__cdecl__)) acosf (float);
  extern long double __attribute__((__cdecl__)) acosl (long double);

  extern float __attribute__((__cdecl__)) atanf (float);
  extern long double __attribute__((__cdecl__)) atanl (long double);

  extern float __attribute__((__cdecl__)) atan2f (float, float);
  extern long double __attribute__((__cdecl__)) atan2l (long double, long double);


  extern float __attribute__((__cdecl__)) sinhf(float _X);

  inline float sinhf(float _X) { return ((float)sinh((double)_X)); }

  extern long double __attribute__((__cdecl__)) sinhl(long double);

  extern float __attribute__((__cdecl__)) coshf(float _X);

  inline float coshf(float _X) { return ((float)cosh((double)_X)); }

  extern long double __attribute__((__cdecl__)) coshl(long double);

  extern float __attribute__((__cdecl__)) tanhf(float _X);

  inline float tanhf(float _X) { return ((float)tanh((double)_X)); }

  extern long double __attribute__((__cdecl__)) tanhl(long double);



  extern double __attribute__((__cdecl__)) acosh (double);
  extern float __attribute__((__cdecl__)) acoshf (float);
  extern long double __attribute__((__cdecl__)) acoshl (long double);


  extern double __attribute__((__cdecl__)) asinh (double);
  extern float __attribute__((__cdecl__)) asinhf (float);
  extern long double __attribute__((__cdecl__)) asinhl (long double);


  extern double __attribute__((__cdecl__)) atanh (double);
  extern float __attribute__((__cdecl__)) atanhf (float);
  extern long double __attribute__((__cdecl__)) atanhl (long double);



  extern float __attribute__((__cdecl__)) expf(float _X);

  inline float expf(float _X) { return ((float)exp((double)_X)); }

  extern long double __attribute__((__cdecl__)) expl(long double);


  extern double __attribute__((__cdecl__)) exp2(double);
  extern float __attribute__((__cdecl__)) exp2f(float);
  extern long double __attribute__((__cdecl__)) exp2l(long double);



  extern double __attribute__((__cdecl__)) expm1(double);
  extern float __attribute__((__cdecl__)) expm1f(float);
  extern long double __attribute__((__cdecl__)) expm1l(long double);


  extern float frexpf(float _X,int *_Y);

  inline float frexpf(float _X,int *_Y) { return ((float)frexp((double)_X,_Y)); }

  extern long double __attribute__((__cdecl__)) frexpl(long double,int *);




  extern int __attribute__((__cdecl__)) ilogb (double);
  extern int __attribute__((__cdecl__)) ilogbf (float);
  extern int __attribute__((__cdecl__)) ilogbl (long double);


  extern float __attribute__((__cdecl__)) ldexpf(float _X,int _Y);

  inline float __attribute__((__cdecl__)) ldexpf (float x, int expn) { return (float) ldexp ((double)x, expn); }

  extern long double __attribute__((__cdecl__)) ldexpl (long double, int);


  extern float __attribute__((__cdecl__)) logf (float);
  extern long double __attribute__((__cdecl__)) logl(long double);


  extern float __attribute__((__cdecl__)) log10f (float);
  extern long double __attribute__((__cdecl__)) log10l(long double);


  extern double __attribute__((__cdecl__)) log1p(double);
  extern float __attribute__((__cdecl__)) log1pf(float);
  extern long double __attribute__((__cdecl__)) log1pl(long double);


  extern double __attribute__((__cdecl__)) log2 (double);
  extern float __attribute__((__cdecl__)) log2f (float);
  extern long double __attribute__((__cdecl__)) log2l (long double);


  extern double __attribute__((__cdecl__)) logb (double);
  extern float __attribute__((__cdecl__)) logbf (float);
  extern long double __attribute__((__cdecl__)) logbl (long double);
# 862 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/math.h" 3
  extern float __attribute__((__cdecl__)) modff (float, float*);
  extern long double __attribute__((__cdecl__)) modfl (long double, long double*);


  extern double __attribute__((__cdecl__)) scalbn (double, int);
  extern float __attribute__((__cdecl__)) scalbnf (float, int);
  extern long double __attribute__((__cdecl__)) scalbnl (long double, int);

  extern double __attribute__((__cdecl__)) scalbln (double, long);
  extern float __attribute__((__cdecl__)) scalblnf (float, long);
  extern long double __attribute__((__cdecl__)) scalblnl (long double, long);



  extern double __attribute__((__cdecl__)) cbrt (double);
  extern float __attribute__((__cdecl__)) cbrtf (float);
  extern long double __attribute__((__cdecl__)) cbrtl (long double);


  extern double __attribute__((__cdecl__)) hypot (double, double) ;
  extern float __attribute__((__cdecl__)) hypotf (float x, float y);

  inline float __attribute__((__cdecl__)) hypotf (float x, float y) { return (float) hypot ((double)x, (double)y);}

  extern long double __attribute__((__cdecl__)) hypotl (long double, long double);


  extern float __attribute__((__cdecl__)) powf(float _X,float _Y);

  inline float powf(float _X,float _Y) { return ((float)pow((double)_X,(double)_Y)); }

  extern long double __attribute__((__cdecl__)) powl (long double, long double);


  extern float __attribute__((__cdecl__)) sqrtf (float);
  extern long double sqrtl(long double);


  extern double __attribute__((__cdecl__)) erf (double);
  extern float __attribute__((__cdecl__)) erff (float);
  extern long double __attribute__((__cdecl__)) erfl (long double);


  extern double __attribute__((__cdecl__)) erfc (double);
  extern float __attribute__((__cdecl__)) erfcf (float);
  extern long double __attribute__((__cdecl__)) erfcl (long double);


  extern double __attribute__((__cdecl__)) lgamma (double);
  extern float __attribute__((__cdecl__)) lgammaf (float);
  extern long double __attribute__((__cdecl__)) lgammal (long double);

  extern int signgam;


  extern double __attribute__((__cdecl__)) tgamma (double);
  extern float __attribute__((__cdecl__)) tgammaf (float);
  extern long double __attribute__((__cdecl__)) tgammal (long double);


  extern float __attribute__((__cdecl__)) ceilf (float);
  extern long double __attribute__((__cdecl__)) ceill (long double);


  extern float __attribute__((__cdecl__)) floorf (float);
  extern long double __attribute__((__cdecl__)) floorl (long double);


  extern double __attribute__((__cdecl__)) nearbyint ( double);
  extern float __attribute__((__cdecl__)) nearbyintf (float);
  extern long double __attribute__((__cdecl__)) nearbyintl (long double);



extern double __attribute__((__cdecl__)) rint (double);
extern float __attribute__((__cdecl__)) rintf (float);
extern long double __attribute__((__cdecl__)) rintl (long double);


extern long __attribute__((__cdecl__)) lrint (double);
extern long __attribute__((__cdecl__)) lrintf (float);
extern long __attribute__((__cdecl__)) lrintl (long double);

__extension__ long long __attribute__((__cdecl__)) llrint (double);
__extension__ long long __attribute__((__cdecl__)) llrintf (float);
__extension__ long long __attribute__((__cdecl__)) llrintl (long double);
# 1029 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/math.h" 3
  extern double __attribute__((__cdecl__)) round (double);
  extern float __attribute__((__cdecl__)) roundf (float);
  extern long double __attribute__((__cdecl__)) roundl (long double);


  extern long __attribute__((__cdecl__)) lround (double);
  extern long __attribute__((__cdecl__)) lroundf (float);
  extern long __attribute__((__cdecl__)) lroundl (long double);
  __extension__ long long __attribute__((__cdecl__)) llround (double);
  __extension__ long long __attribute__((__cdecl__)) llroundf (float);
  __extension__ long long __attribute__((__cdecl__)) llroundl (long double);



  extern double __attribute__((__cdecl__)) trunc (double);
  extern float __attribute__((__cdecl__)) truncf (float);
  extern long double __attribute__((__cdecl__)) truncl (long double);


  extern float __attribute__((__cdecl__)) fmodf (float, float);
  extern long double __attribute__((__cdecl__)) fmodl (long double, long double);


  extern double __attribute__((__cdecl__)) remainder (double, double);
  extern float __attribute__((__cdecl__)) remainderf (float, float);
  extern long double __attribute__((__cdecl__)) remainderl (long double, long double);


  extern double __attribute__((__cdecl__)) remquo(double, double, int *);
  extern float __attribute__((__cdecl__)) remquof(float, float, int *);
  extern long double __attribute__((__cdecl__)) remquol(long double, long double, int *);


  extern double __attribute__((__cdecl__)) copysign (double, double);
  extern float __attribute__((__cdecl__)) copysignf (float, float);
  extern long double __attribute__((__cdecl__)) copysignl (long double, long double);



  inline double __attribute__((__cdecl__)) copysign (double x, double y)
  {
    __mingw_dbl_type_t hx, hy;
    hx.x = x; hy.x = y;
    hx.lh.high = (hx.lh.high & 0x7fffffff) | (hy.lh.high & 0x80000000);
    return hx.x;
  }
  inline float __attribute__((__cdecl__)) copysignf (float x, float y)
  {
    __mingw_flt_type_t hx, hy;
    hx.x = x; hy.x = y;
    hx.val = (hx.val & 0x7fffffff) | (hy.val & 0x80000000);
    return hx.x;
  }




  extern double __attribute__((__cdecl__)) nan(const char *tagp);
  extern float __attribute__((__cdecl__)) nanf(const char *tagp);
  extern long double __attribute__((__cdecl__)) nanl(const char *tagp);
# 1097 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/math.h" 3
  extern double __attribute__((__cdecl__)) nextafter (double, double);
  extern float __attribute__((__cdecl__)) nextafterf (float, float);
  extern long double __attribute__((__cdecl__)) nextafterl (long double, long double);


  extern double __attribute__((__cdecl__)) nexttoward (double, long double);
  extern float __attribute__((__cdecl__)) nexttowardf (float, long double);
  extern long double __attribute__((__cdecl__)) nexttowardl (long double, long double);



  extern double __attribute__((__cdecl__)) fdim (double x, double y);
  extern float __attribute__((__cdecl__)) fdimf (float x, float y);
  extern long double __attribute__((__cdecl__)) fdiml (long double x, long double y);







  extern double __attribute__((__cdecl__)) fmax (double, double);
  extern float __attribute__((__cdecl__)) fmaxf (float, float);
  extern long double __attribute__((__cdecl__)) fmaxl (long double, long double);


  extern double __attribute__((__cdecl__)) fmin (double, double);
  extern float __attribute__((__cdecl__)) fminf (float, float);
  extern long double __attribute__((__cdecl__)) fminl (long double, long double);



  extern double __attribute__((__cdecl__)) fma (double, double, double);
  extern float __attribute__((__cdecl__)) fmaf (float, float, float);
  extern long double __attribute__((__cdecl__)) fmal (long double, long double, long double);
# 1180 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/math.h" 3
   __attribute__ ((__dllimport__)) float __attribute__((__cdecl__)) _copysignf (float _Number,float _Sign);
   __attribute__ ((__dllimport__)) float __attribute__((__cdecl__)) _chgsignf (float _X);
   __attribute__ ((__dllimport__)) float __attribute__((__cdecl__)) _logbf(float _X);
   __attribute__ ((__dllimport__)) float __attribute__((__cdecl__)) _nextafterf(float _X,float _Y);
   __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _finitef(float _X);
   __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isnanf(float _X);
   __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fpclassf(float _X);



   extern long double __attribute__((__cdecl__)) _chgsignl (long double);
# 1575 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/math.h" 3
}




#pragma pack(pop)
# 48 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 2 3

# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/std_abs.h" 1 3
# 33 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/std_abs.h" 3
       
# 34 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/std_abs.h" 3




# 1 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/stdlib.h" 1 3
# 10 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/stdlib.h" 3
# 1 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/corecrt_wstdlib.h" 1 3
# 12 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/corecrt_wstdlib.h" 3
extern "C" {


  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _itow_s (int _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _itow_s(int _Val, wchar_t (&_DstBuf)[__size], int _Radix) { return _itow_s(_Val, _DstBuf, __size, _Radix); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ltow_s (long _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _ltow_s(long _Val, wchar_t (&_DstBuf)[__size], int _Radix) { return _ltow_s(_Val, _DstBuf, __size, _Radix); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ultow_s (unsigned long _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _ultow_s(unsigned long _Val, wchar_t (&_DstBuf)[__size], int _Radix) { return _ultow_s(_Val, _DstBuf, __size, _Radix); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wgetenv_s(size_t *_ReturnSize,wchar_t *_DstBuf,size_t _DstSizeInWords,const wchar_t *_VarName);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _wgetenv_s(size_t* _ReturnSize, wchar_t (&_DstBuf)[__size], const wchar_t* _VarName) { return _wgetenv_s(_ReturnSize, _DstBuf, __size, _VarName); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wdupenv_s(wchar_t **_Buffer,size_t *_BufferSizeInWords,const wchar_t *_VarName);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _i64tow_s(long long _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ui64tow_s(unsigned long long _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix);

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wmakepath_s(wchar_t *_PathResult,size_t _SizeInWords,const wchar_t *_Drive,const wchar_t *_Dir,const wchar_t *_Filename,const wchar_t *_Ext);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _wmakepath_s(wchar_t (&_PathResult)[__size], const wchar_t* _Drive, const wchar_t* _Dir, const wchar_t* _Filename, const wchar_t* _Ext) { return _wmakepath_s(_PathResult,__size,_Drive,_Dir,_Filename,_Ext); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wputenv_s(const wchar_t *_Name,const wchar_t *_Value);

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wsearchenv_s(const wchar_t *_Filename,const wchar_t *_EnvVar,wchar_t *_ResultPath,size_t _SizeInWords);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _wsearchenv_s(const wchar_t* _Filename, const wchar_t* _EnvVar, wchar_t (&_ResultPath)[__size]) { return _wsearchenv_s(_Filename, _EnvVar, _ResultPath, __size); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wsplitpath_s(const wchar_t *_FullPath,wchar_t *_Drive,size_t _DriveSizeInWords,wchar_t *_Dir,size_t _DirSizeInWords,wchar_t *_Filename,size_t _FilenameSizeInWords,wchar_t *_Ext,size_t _ExtSizeInWords);
  extern "C++" { template <size_t __drive_size, size_t __dir_size, size_t __name_size, size_t __ext_size> inline errno_t __attribute__((__cdecl__)) _wsplitpath_s(const wchar_t *_Dest, wchar_t (&__drive)[__drive_size], wchar_t (&__dir)[__dir_size], wchar_t (&__name)[__name_size], wchar_t (&__ext)[__ext_size]) { return _wsplitpath_s(_Dest, __drive, __drive_size, __dir, __dir_size, __name, __name_size, __ext, __ext_size); } }


}
# 11 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/stdlib.h" 2 3
# 1 "D:/Enviroments/mingw64_msvcrt/lib/gcc/x86_64-w64-mingw32/14.2.0/include/limits.h" 1 3 4
# 34 "D:/Enviroments/mingw64_msvcrt/lib/gcc/x86_64-w64-mingw32/14.2.0/include/limits.h" 3 4
# 1 "D:/Enviroments/mingw64_msvcrt/lib/gcc/x86_64-w64-mingw32/14.2.0/include/syslimits.h" 1 3 4






# 1 "D:/Enviroments/mingw64_msvcrt/lib/gcc/x86_64-w64-mingw32/14.2.0/include/limits.h" 1 3 4
# 210 "D:/Enviroments/mingw64_msvcrt/lib/gcc/x86_64-w64-mingw32/14.2.0/include/limits.h" 3 4
# 1 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/limits.h" 1 3 4
# 211 "D:/Enviroments/mingw64_msvcrt/lib/gcc/x86_64-w64-mingw32/14.2.0/include/limits.h" 2 3 4
# 8 "D:/Enviroments/mingw64_msvcrt/lib/gcc/x86_64-w64-mingw32/14.2.0/include/syslimits.h" 2 3 4
# 35 "D:/Enviroments/mingw64_msvcrt/lib/gcc/x86_64-w64-mingw32/14.2.0/include/limits.h" 2 3 4
# 12 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/stdlib.h" 2 3
# 26 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/stdlib.h" 3
#pragma pack(push,_CRT_PACKING)


extern "C" {
# 50 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/stdlib.h" 3
  typedef int (__attribute__((__cdecl__)) *_onexit_t)(void);
# 60 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/stdlib.h" 3
  typedef struct _div_t {
    int quot;
    int rem;
  } div_t;

  typedef struct _ldiv_t {
    long quot;
    long rem;
  } ldiv_t;





#pragma pack(4)
  typedef struct {
    unsigned char ld[10];
  } _LDOUBLE;
#pragma pack()



  typedef struct {
    double x;
  } _CRT_DOUBLE;

  typedef struct {
    float f;
  } _CRT_FLOAT;

       


  typedef struct {
    long double x;
  } _LONGDOUBLE;

       

#pragma pack(4)
  typedef struct {
    unsigned char ld12[12];
  } _LDBL12;
#pragma pack()
# 116 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/stdlib.h" 3
  extern int * __imp___mb_cur_max;




__attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) ___mb_cur_max_func(void);
# 143 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/stdlib.h" 3
  typedef void (__attribute__((__cdecl__)) *_purecall_handler)(void);

  __attribute__ ((__dllimport__)) _purecall_handler __attribute__((__cdecl__)) _set_purecall_handler(_purecall_handler _Handler);
  __attribute__ ((__dllimport__)) _purecall_handler __attribute__((__cdecl__)) _get_purecall_handler(void);

  typedef void (__attribute__((__cdecl__)) *_invalid_parameter_handler)(const wchar_t *,const wchar_t *,const wchar_t *,unsigned int,uintptr_t);
  __attribute__ ((__dllimport__)) _invalid_parameter_handler __attribute__((__cdecl__)) _set_invalid_parameter_handler(_invalid_parameter_handler _Handler);
  __attribute__ ((__dllimport__)) _invalid_parameter_handler __attribute__((__cdecl__)) _get_invalid_parameter_handler(void);
# 159 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/stdlib.h" 3
  __attribute__ ((__dllimport__)) unsigned long *__attribute__((__cdecl__)) __doserrno(void);

  errno_t __attribute__((__cdecl__)) _set_doserrno(unsigned long _Value);
  errno_t __attribute__((__cdecl__)) _get_doserrno(unsigned long *_Value);
# 173 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/stdlib.h" 3
  extern __attribute__((dllimport)) char *_sys_errlist[1];
  extern __attribute__((dllimport)) int _sys_nerr;





  __attribute__ ((__dllimport__)) char ***__attribute__((__cdecl__)) __p___argv(void);
  __attribute__ ((__dllimport__)) int *__attribute__((__cdecl__)) __p__fmode(void);
# 191 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/stdlib.h" 3
  errno_t __attribute__((__cdecl__)) _get_pgmptr(char **_Value);
  errno_t __attribute__((__cdecl__)) _get_wpgmptr(wchar_t **_Value);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _set_fmode(int _Mode);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _get_fmode(int *_PMode);
# 282 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/stdlib.h" 3
  extern int * __imp___argc;



  extern char *** __imp___argv;



  extern wchar_t *** __imp___wargv;
# 322 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/stdlib.h" 3
  extern char *** __imp__environ;




  extern wchar_t *** __imp__wenviron;






  extern char ** __imp__pgmptr;




  extern wchar_t ** __imp__wpgmptr;




  extern unsigned int * __imp__osplatform;




  extern unsigned int * __imp__osver;




  extern unsigned int * __imp__winver;




  extern unsigned int * __imp__winmajor;




  extern unsigned int * __imp__winminor;





  errno_t __attribute__((__cdecl__)) _get_osplatform(unsigned int *_Value);
  errno_t __attribute__((__cdecl__)) _get_osver(unsigned int *_Value);
  errno_t __attribute__((__cdecl__)) _get_winver(unsigned int *_Value);
  errno_t __attribute__((__cdecl__)) _get_winmajor(unsigned int *_Value);
  errno_t __attribute__((__cdecl__)) _get_winminor(unsigned int *_Value);




  extern "C++" {
    template <typename _CountofType,size_t _SizeOfArray> char (*__countof_helper( _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];

  }





  void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) exit(int _Code) __attribute__ ((__noreturn__));
  void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _exit(int _Code) __attribute__ ((__noreturn__));






  void __attribute__((__cdecl__)) _Exit(int) __attribute__ ((__noreturn__));

  inline __attribute__ ((__noreturn__)) void __attribute__((__cdecl__)) _Exit(int status)
  { _exit(status); }



       

  void __attribute__((__cdecl__)) __attribute__ ((__noreturn__)) abort(void);
       



  __attribute__ ((__dllimport__)) unsigned int __attribute__((__cdecl__)) _set_abort_behavior(unsigned int _Flags,unsigned int _Mask);







  __extension__ long long __attribute__((__cdecl__)) _abs64(long long);

  extern __inline__ __attribute__((__always_inline__,__gnu_inline__)) long long __attribute__((__cdecl__)) _abs64(long long x) {
    return __builtin_llabs(x);
  }


  int __attribute__((__cdecl__)) atexit(void (__attribute__((__cdecl__)) *)(void));
# 434 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/stdlib.h" 3
  int __attribute__((__cdecl__)) atoi(const char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoi_l(const char *_Str,_locale_t _Locale);
  long __attribute__((__cdecl__)) atol(const char *_Str);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _atol_l(const char *_Str,_locale_t _Locale);


  void *__attribute__((__cdecl__)) bsearch(const void *_Key,const void *_Base,size_t _NumOfElements,size_t _SizeOfElements,int (__attribute__((__cdecl__)) *_PtFuncCompare)(const void *,const void *));
  void __attribute__((__cdecl__)) qsort(void *_Base,size_t _NumOfElements,size_t _SizeOfElements,int (__attribute__((__cdecl__)) *_PtFuncCompare)(const void *,const void *));

  unsigned short __attribute__((__cdecl__)) _byteswap_ushort(unsigned short _Short);
  unsigned long __attribute__((__cdecl__)) _byteswap_ulong (unsigned long _Long);
  __extension__ unsigned long long __attribute__((__cdecl__)) _byteswap_uint64(unsigned long long _Int64);
  div_t __attribute__((__cdecl__)) div(int _Numerator,int _Denominator);
  char *__attribute__((__cdecl__)) getenv(const char *_VarName) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _itoa(int _Value,char *_Dest,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _i64toa(long long _Val,char *_DstBuf,int _Radix) ;
  __extension__ __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ui64toa(unsigned long long _Val,char *_DstBuf,int _Radix) ;
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _atoi64(const char *_String);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _atoi64_l(const char *_String,_locale_t _Locale);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _strtoi64(const char *_String,char **_EndPtr,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _strtoi64_l(const char *_String,char **_EndPtr,int _Radix,_locale_t _Locale);
  __extension__ __attribute__ ((__dllimport__)) unsigned long long __attribute__((__cdecl__)) _strtoui64(const char *_String,char **_EndPtr,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) unsigned long long __attribute__((__cdecl__)) _strtoui64_l(const char *_String,char **_EndPtr,int _Radix,_locale_t _Locale);
  ldiv_t __attribute__((__cdecl__)) ldiv(long _Numerator,long _Denominator);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ltoa(long _Value,char *_Dest,int _Radix) ;
  int __attribute__((__cdecl__)) mblen(const char *_Ch,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _mblen_l(const char *_Ch,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstrlen(const char *_Str);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstrlen_l(const char *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstrnlen(const char *_Str,size_t _MaxCount);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstrnlen_l(const char *_Str,size_t _MaxCount,_locale_t _Locale);
  int __attribute__((__cdecl__)) mbtowc(wchar_t * __restrict__ _DstCh,const char * __restrict__ _SrcCh,size_t _SrcSizeInBytes);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _mbtowc_l(wchar_t * __restrict__ _DstCh,const char * __restrict__ _SrcCh,size_t _SrcSizeInBytes,_locale_t _Locale);
  size_t __attribute__((__cdecl__)) mbstowcs(wchar_t * __restrict__ _Dest,const char * __restrict__ _Source,size_t _MaxCount);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstowcs_l(wchar_t * __restrict__ _Dest,const char * __restrict__ _Source,size_t _MaxCount,_locale_t _Locale);
  int __attribute__((__cdecl__)) mkstemp(char *template_name);
  int __attribute__((__cdecl__)) rand(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _set_error_mode(int _Mode);
  void __attribute__((__cdecl__)) srand(unsigned int _Seed);
# 483 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/stdlib.h" 3
inline __attribute__((__cdecl__))
double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtod(const char * __restrict__ _Str,char ** __restrict__ _EndPtr)
{
  double __attribute__((__cdecl__)) __mingw_strtod (const char * __restrict__, char ** __restrict__);
  return __mingw_strtod( _Str, _EndPtr);
}

inline __attribute__((__cdecl__))
float __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtof(const char * __restrict__ _Str,char ** __restrict__ _EndPtr)
{
  float __attribute__((__cdecl__)) __mingw_strtof (const char * __restrict__, char ** __restrict__);
  return __mingw_strtof( _Str, _EndPtr);
}






  long double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtold(const char * __restrict__ , char ** __restrict__ );


  extern double __attribute__((__cdecl__)) __attribute__ ((__nothrow__))
  __strtod (const char * __restrict__ , char ** __restrict__);







  float __attribute__((__cdecl__)) __mingw_strtof (const char * __restrict__, char ** __restrict__);
  double __attribute__((__cdecl__)) __mingw_strtod (const char * __restrict__, char ** __restrict__);
  long double __attribute__((__cdecl__)) __mingw_strtold(const char * __restrict__, char ** __restrict__);

  __attribute__ ((__dllimport__)) float __attribute__((__cdecl__)) _strtof_l(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,_locale_t _Locale);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _strtod_l(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,_locale_t _Locale);
  long __attribute__((__cdecl__)) strtol(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,int _Radix);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _strtol_l(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,int _Radix,_locale_t _Locale);
  unsigned long __attribute__((__cdecl__)) strtoul(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,int _Radix);
  __attribute__ ((__dllimport__)) unsigned long __attribute__((__cdecl__)) _strtoul_l(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,int _Radix,_locale_t _Locale);


  int __attribute__((__cdecl__)) system(const char *_Command);

  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ultoa(unsigned long _Value,char *_Dest,int _Radix) ;
  int __attribute__((__cdecl__)) wctomb(char *_MbCh,wchar_t _WCh) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wctomb_l(char *_MbCh,wchar_t _WCh,_locale_t _Locale) ;
  size_t __attribute__((__cdecl__)) wcstombs(char * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _MaxCount) ;
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _wcstombs_l(char * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _MaxCount,_locale_t _Locale) ;



  void *__attribute__((__cdecl__)) calloc(size_t _NumOfElements,size_t _SizeOfElements);
  void __attribute__((__cdecl__)) free(void *_Memory);
  void *__attribute__((__cdecl__)) malloc(size_t _Size);
  void *__attribute__((__cdecl__)) realloc(void *_Memory,size_t _NewSize);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _aligned_free(void *_Memory);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_malloc(size_t _Size,size_t _Alignment);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_offset_malloc(size_t _Size,size_t _Alignment,size_t _Offset);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_realloc(void *_Memory,size_t _Size,size_t _Alignment);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_offset_realloc(void *_Memory,size_t _Size,size_t _Alignment,size_t _Offset);
# 556 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/stdlib.h" 3
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _itow(int _Value,wchar_t *_Dest,int _Radix) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _ltow(long _Value,wchar_t *_Dest,int _Radix) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _ultow(unsigned long _Value,wchar_t *_Dest,int _Radix) ;

  double __attribute__((__cdecl__)) __mingw_wcstod(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr);
  float __attribute__((__cdecl__)) __mingw_wcstof(const wchar_t * __restrict__ nptr, wchar_t ** __restrict__ endptr);
  long double __attribute__((__cdecl__)) __mingw_wcstold(const wchar_t * __restrict__, wchar_t ** __restrict__);


  inline __attribute__((__cdecl__))
  double __attribute__((__cdecl__)) wcstod(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr){
    return __mingw_wcstod(_Str,_EndPtr);
  }
  inline __attribute__((__cdecl__))
  float __attribute__((__cdecl__)) wcstof(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr){
    return __mingw_wcstof(_Str,_EndPtr);
  }






  long double __attribute__((__cdecl__)) wcstold(const wchar_t * __restrict__, wchar_t ** __restrict__);

  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _wcstod_l(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,_locale_t _Locale);
  __attribute__ ((__dllimport__)) float __attribute__((__cdecl__)) _wcstof_l(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,_locale_t _Locale);
  long __attribute__((__cdecl__)) wcstol(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,int _Radix);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wcstol_l(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,int _Radix,_locale_t _Locale);
  unsigned long __attribute__((__cdecl__)) wcstoul(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,int _Radix);
  __attribute__ ((__dllimport__)) unsigned long __attribute__((__cdecl__)) _wcstoul_l(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,int _Radix,_locale_t _Locale);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wgetenv(const wchar_t *_VarName) ;


  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wsystem(const wchar_t *_Command);

  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _wtof(const wchar_t *_Str);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _wtof_l(const wchar_t *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wtoi(const wchar_t *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wtoi_l(const wchar_t *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wtol(const wchar_t *_Str);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wtol_l(const wchar_t *_Str,_locale_t _Locale);

  __extension__ __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _i64tow(long long _Val,wchar_t *_DstBuf,int _Radix) ;
  __extension__ __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _ui64tow(unsigned long long _Val,wchar_t *_DstBuf,int _Radix) ;
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _wtoi64(const wchar_t *_Str);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _wtoi64_l(const wchar_t *_Str,_locale_t _Locale);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _wcstoi64(const wchar_t *_Str,wchar_t **_EndPtr,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _wcstoi64_l(const wchar_t *_Str,wchar_t **_EndPtr,int _Radix,_locale_t _Locale);
  __extension__ __attribute__ ((__dllimport__)) unsigned long long __attribute__((__cdecl__)) _wcstoui64(const wchar_t *_Str,wchar_t **_EndPtr,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) unsigned long long __attribute__((__cdecl__)) _wcstoui64_l(const wchar_t *_Str ,wchar_t **_EndPtr,int _Radix,_locale_t _Locale);


  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _putenv(const char *_EnvString);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wputenv(const wchar_t *_EnvString);



  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _fullpath(char *_FullPath,const char *_Path,size_t _SizeInBytes);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ecvt(double _Val,int _NumOfDigits,int *_PtDec,int *_PtSign) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _fcvt(double _Val,int _NumOfDec,int *_PtDec,int *_PtSign) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _gcvt(double _Val,int _NumOfDigits,char *_DstBuf) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atodbl(_CRT_DOUBLE *_Result,char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoldbl(_LDOUBLE *_Result,char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoflt(_CRT_FLOAT *_Result,char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atodbl_l(_CRT_DOUBLE *_Result,char *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoldbl_l(_LDOUBLE *_Result,char *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoflt_l(_CRT_FLOAT *_Result,char *_Str,_locale_t _Locale);
# 639 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/stdlib.h" 3
unsigned long __attribute__((__cdecl__)) _lrotl(unsigned long,int);
unsigned long __attribute__((__cdecl__)) _lrotr(unsigned long,int);





  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _makepath(char *_Path,const char *_Drive,const char *_Dir,const char *_Filename,const char *_Ext);
  _onexit_t __attribute__((__cdecl__)) _onexit(_onexit_t _Func);



  void __attribute__((__cdecl__)) perror(const char *_ErrMsg);

       
       


  __extension__ unsigned long long __attribute__((__cdecl__)) _rotl64(unsigned long long _Val,int _Shift);
  __extension__ unsigned long long __attribute__((__cdecl__)) _rotr64(unsigned long long Value,int Shift);
       
       
       
       


  unsigned int __attribute__((__cdecl__)) _rotr(unsigned int _Val,int _Shift);
  unsigned int __attribute__((__cdecl__)) _rotl(unsigned int _Val,int _Shift);
       
       
  __extension__ unsigned long long __attribute__((__cdecl__)) _rotr64(unsigned long long _Val,int _Shift);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _searchenv(const char *_Filename,const char *_EnvVar,char *_ResultPath) ;
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _splitpath(const char *_FullPath,char *_Drive,char *_Dir,char *_Filename,char *_Ext) ;
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _swab(char *_Buf1,char *_Buf2,int _SizeInBytes);



  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wfullpath(wchar_t *_FullPath,const wchar_t *_Path,size_t _SizeInWords);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _wmakepath(wchar_t *_ResultPath,const wchar_t *_Drive,const wchar_t *_Dir,const wchar_t *_Filename,const wchar_t *_Ext);


  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _wperror(const wchar_t *_ErrMsg);

  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _wsearchenv(const wchar_t *_Filename,const wchar_t *_EnvVar,wchar_t *_ResultPath) ;
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _wsplitpath(const wchar_t *_FullPath,wchar_t *_Drive,wchar_t *_Dir,wchar_t *_Filename,wchar_t *_Ext) ;


  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _beep(unsigned _Frequency,unsigned _Duration) __attribute__ ((__deprecated__));

  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _seterrormode(int _Mode) __attribute__ ((__deprecated__));
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _sleep(unsigned long _Duration) __attribute__ ((__deprecated__));
# 710 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/stdlib.h" 3
  char *__attribute__((__cdecl__)) ecvt(double _Val,int _NumOfDigits,int *_PtDec,int *_PtSign) ;
  char *__attribute__((__cdecl__)) fcvt(double _Val,int _NumOfDec,int *_PtDec,int *_PtSign) ;
  char *__attribute__((__cdecl__)) gcvt(double _Val,int _NumOfDigits,char *_DstBuf) ;
  char *__attribute__((__cdecl__)) itoa(int _Val,char *_DstBuf,int _Radix) ;
  char *__attribute__((__cdecl__)) ltoa(long _Val,char *_DstBuf,int _Radix) ;
  int __attribute__((__cdecl__)) putenv(const char *_EnvString) ;



  void __attribute__((__cdecl__)) swab(char *_Buf1,char *_Buf2,int _SizeInBytes) ;


  char *__attribute__((__cdecl__)) ultoa(unsigned long _Val,char *_Dstbuf,int _Radix) ;
  _onexit_t __attribute__((__cdecl__)) onexit(_onexit_t _Func);





  typedef struct { __extension__ long long quot, rem; } lldiv_t;

  __extension__ lldiv_t __attribute__((__cdecl__)) lldiv(long long, long long);

  __extension__ long long __attribute__((__cdecl__)) llabs(long long);

  __extension__ inline long long __attribute__((__cdecl__)) llabs(long long _j) { return (_j >= 0 ? _j : -_j); }


  __extension__ long long __attribute__((__cdecl__)) strtoll(const char * __restrict__, char ** __restrict, int);
  __extension__ unsigned long long __attribute__((__cdecl__)) strtoull(const char * __restrict__, char ** __restrict__, int);


  __extension__ long long __attribute__((__cdecl__)) atoll (const char *);


  __extension__ long long __attribute__((__cdecl__)) wtoll (const wchar_t *);
  __extension__ char *__attribute__((__cdecl__)) lltoa (long long, char *, int);
  __extension__ char *__attribute__((__cdecl__)) ulltoa (unsigned long long , char *, int);
  __extension__ wchar_t *__attribute__((__cdecl__)) lltow (long long, wchar_t *, int);
  __extension__ wchar_t *__attribute__((__cdecl__)) ulltow (unsigned long long, wchar_t *, int);



  __extension__ inline char *__attribute__((__cdecl__)) lltoa (long long _n, char * _c, int _i) { return _i64toa (_n, _c, _i); }
  __extension__ inline char *__attribute__((__cdecl__)) ulltoa (unsigned long long _n, char * _c, int _i) { return _ui64toa (_n, _c, _i); }
  __extension__ inline long long __attribute__((__cdecl__)) wtoll (const wchar_t * _w) { return _wtoi64 (_w); }
  __extension__ inline wchar_t *__attribute__((__cdecl__)) lltow (long long _n, wchar_t * _w, int _i) { return _i64tow (_n, _w, _i); }
  __extension__ inline wchar_t *__attribute__((__cdecl__)) ulltow (unsigned long long _n, wchar_t * _w, int _i) { return _ui64tow (_n, _w, _i); }






}


#pragma pack(pop)

# 1 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/sec_api/stdlib_s.h" 1 3
# 9 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/sec_api/stdlib_s.h" 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/stdlib.h" 1 3
# 30 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/stdlib.h" 3
# 1 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/stdlib.h" 1 3
# 31 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/stdlib.h" 2 3
# 10 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/sec_api/stdlib_s.h" 2 3


extern "C" {


  __attribute__ ((__dllimport__)) void * __attribute__((__cdecl__)) bsearch_s(const void *_Key,const void *_Base,rsize_t _NumOfElements,rsize_t _SizeOfElements,int (__attribute__((__cdecl__)) * _PtFuncCompare)(void *, const void *, const void *), void *_Context);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _dupenv_s(char **_PBuffer,size_t *_PBufferSizeInBytes,const char *_VarName);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) getenv_s(size_t *_ReturnSize,char *_DstBuf,rsize_t _DstSize,const char *_VarName);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) getenv_s(size_t * _ReturnSize, char (&_Dest)[__size], const char * _VarName) { return getenv_s(_ReturnSize, _Dest, __size, _VarName); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _itoa_s(int _Value,char *_DstBuf,size_t _Size,int _Radix);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _itoa_s(int _Value, char (&_Dest)[__size], int _Radix) { return _itoa_s(_Value, _Dest, __size, _Radix); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _i64toa_s(long long _Val,char *_DstBuf,size_t _Size,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ui64toa_s(unsigned long long _Val,char *_DstBuf,size_t _Size,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ltoa_s(long _Val,char *_DstBuf,size_t _Size,int _Radix);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _ltoa_s(long _Value, char (&_Dest)[__size], int _Radix) { return _ltoa_s(_Value, _Dest, __size, _Radix); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) mbstowcs_s(size_t *_PtNumOfCharConverted,wchar_t *_DstBuf,size_t _SizeInWords,const char *_SrcBuf,size_t _MaxCount);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) mbstowcs_s(size_t * _PtNumOfCharConverted, wchar_t (&_Dest)[__size], const char * _Source, size_t _MaxCount) { return mbstowcs_s(_PtNumOfCharConverted, _Dest, __size, _Source, _MaxCount); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _mbstowcs_s_l(size_t *_PtNumOfCharConverted,wchar_t *_DstBuf,size_t _SizeInWords,const char *_SrcBuf,size_t _MaxCount,_locale_t _Locale);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _mbstowcs_s_l(size_t * _PtNumOfCharConverted, wchar_t (&_Dest)[__size], const char * _Source, size_t _MaxCount, _locale_t _Locale) { return _mbstowcs_s_l(_PtNumOfCharConverted, _Dest, __size, _Source, _MaxCount, _Locale); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ultoa_s(unsigned long _Val,char *_DstBuf,size_t _Size,int _Radix);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _ultoa_s(unsigned long _Value, char (&_Dest)[__size], int _Radix) { return _ultoa_s(_Value, _Dest, __size, _Radix); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wctomb_s(int *_SizeConverted,char *_MbCh,rsize_t _SizeInBytes,wchar_t _WCh);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wctomb_s_l(int *_SizeConverted,char *_MbCh,size_t _SizeInBytes,wchar_t _WCh,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcstombs_s(size_t *_PtNumOfCharConverted,char *_Dst,size_t _DstSizeInBytes,const wchar_t *_Src,size_t _MaxCountInBytes);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) wcstombs_s(size_t* _PtNumOfCharConverted, char (&_Dst)[__size], const wchar_t* _Src, size_t _MaxCountInBytes) { return wcstombs_s(_PtNumOfCharConverted, _Dst, __size, _Src, _MaxCountInBytes); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcstombs_s_l(size_t *_PtNumOfCharConverted,char *_Dst,size_t _DstSizeInBytes,const wchar_t *_Src,size_t _MaxCountInBytes,_locale_t _Locale);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _wcstombs_s_l(size_t* _PtNumOfCharConverted, char (&_Dst)[__size], const wchar_t* _Src, size_t _MaxCountInBytes, _locale_t _Locale) { return _wcstombs_s_l(_PtNumOfCharConverted, _Dst, __size, _Src, _MaxCountInBytes, _Locale); } }


  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ecvt_s(char *_DstBuf,size_t _Size,double _Val,int _NumOfDights,int *_PtDec,int *_PtSign);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _fcvt_s(char *_DstBuf,size_t _Size,double _Val,int _NumOfDec,int *_PtDec,int *_PtSign);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _gcvt_s(char *_DstBuf,size_t _Size,double _Val,int _NumOfDigits);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _makepath_s(char *_PathResult,size_t _Size,const char *_Drive,const char *_Dir,const char *_Filename,const char *_Ext);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _makepath_s(char (&_PathResult)[__size], const char* _Drive, const char* _Dir, const char* _Filename, const char* _Ext) { return _makepath_s(_PathResult,__size,_Drive,_Dir,_Filename,_Ext); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _putenv_s(const char *_Name,const char *_Value);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _searchenv_s(const char *_Filename,const char *_EnvVar,char *_ResultPath,size_t _SizeInBytes);

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _splitpath_s(const char *_FullPath,char *_Drive,size_t _DriveSize,char *_Dir,size_t _DirSize,char *_Filename,size_t _FilenameSize,char *_Ext,size_t _ExtSize);
  extern "C++" { template <size_t __drive_size, size_t __dir_size, size_t __name_size, size_t __ext_size> inline errno_t __attribute__((__cdecl__)) _splitpath_s(const char *_Dest, char (&__drive)[__drive_size], char (&__dir)[__dir_size], char (&__name)[__name_size], char (&__ext)[__ext_size]) { return _splitpath_s(_Dest, __drive, __drive_size, __dir, __dir_size, __name, __name_size, __ext, __ext_size); } }



  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) qsort_s(void *_Base,size_t _NumOfElements,size_t _SizeOfElements,int (__attribute__((__cdecl__)) *_PtFuncCompare)(void *,const void *,const void *),void *_Context);





}
# 770 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/stdlib.h" 2 3
# 1 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/malloc.h" 1 3
# 11 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/malloc.h" 3
#pragma pack(push,_CRT_PACKING)


extern "C" {
# 46 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/malloc.h" 3
  typedef struct _heapinfo {
    int *_pentry;
    size_t _size;
    int _useflag;
  } _HEAPINFO;


  extern unsigned int _amblksiz;
# 77 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/malloc.h" 3
void * __mingw_aligned_malloc (size_t _Size, size_t _Alignment);
void __mingw_aligned_free (void *_Memory);
void * __mingw_aligned_offset_realloc (void *_Memory, size_t _Size, size_t _Alignment, size_t _Offset);
void * __mingw_aligned_realloc (void *_Memory, size_t _Size, size_t _Offset);



# 1 "D:/Enviroments/mingw64_msvcrt/lib/gcc/x86_64-w64-mingw32/14.2.0/include/mm_malloc.h" 1 3 4
# 27 "D:/Enviroments/mingw64_msvcrt/lib/gcc/x86_64-w64-mingw32/14.2.0/include/mm_malloc.h" 3 4
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/stdlib.h" 1 3 4
# 28 "D:/Enviroments/mingw64_msvcrt/lib/gcc/x86_64-w64-mingw32/14.2.0/include/mm_malloc.h" 2 3 4

# 1 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/errno.h" 1 3 4
# 12 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/errno.h" 3 4
extern "C" {
# 239 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/errno.h" 3 4
}
# 30 "D:/Enviroments/mingw64_msvcrt/lib/gcc/x86_64-w64-mingw32/14.2.0/include/mm_malloc.h" 2 3 4


static __inline__ void *
_mm_malloc (size_t __size, size_t __align)
{
  void * __malloc_ptr;
  void * __aligned_ptr;


  if (__align & (__align - 1))
    {

      (*_errno()) = 22;

      return ((void *) 0);
    }

  if (__size == 0)
    return ((void *) 0);





    if (__align < 2 * sizeof (void *))
      __align = 2 * sizeof (void *);

  __malloc_ptr = malloc (__size + __align);
  if (!__malloc_ptr)
    return ((void *) 0);


  __aligned_ptr = (void *) (((size_t) __malloc_ptr + __align)
       & ~((size_t) (__align) - 1));


  ((void **) __aligned_ptr)[-1] = __malloc_ptr;

  return __aligned_ptr;
}

static __inline__ void
_mm_free (void *__aligned_ptr)
{
  if (__aligned_ptr)
    free (((void **) __aligned_ptr)[-1]);
}
# 85 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/malloc.h" 2 3





  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _resetstkoflw (void);

  __attribute__ ((__dllimport__)) unsigned long __attribute__((__cdecl__)) _set_malloc_crt_max_wait(unsigned long _NewValue);

  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _expand(void *_Memory,size_t _NewSize);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _msize(void *_Memory);






  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _get_sbh_threshold(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _set_sbh_threshold(size_t _NewValue);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _set_amblksiz(size_t _Value);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _get_amblksiz(size_t *_Value);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapadd(void *_Memory,size_t _Size);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapchk(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapmin(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapset(unsigned int _Fill);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapwalk(_HEAPINFO *_EntryInfo);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _heapused(size_t *_Used,size_t *_Commit);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _get_heap_handle(void);
# 125 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/malloc.h" 3
  static __inline void *_MarkAllocaS(void *_Ptr,unsigned int _Marker) {
    if(_Ptr) {
      *((unsigned int*)_Ptr) = _Marker;
      _Ptr = (char*)_Ptr + 16;
    }
    return _Ptr;
  }
# 144 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/malloc.h" 3
  static __inline void __attribute__((__cdecl__)) _freea(void *_Memory) {
    unsigned int _Marker;
    if(_Memory) {
      _Memory = (char*)_Memory - 16;
      _Marker = *(unsigned int *)_Memory;
      if(_Marker==0xDDDD) {
 free(_Memory);
      }





    }
  }
# 187 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/malloc.h" 3
}


#pragma pack(pop)
# 771 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/stdlib.h" 2 3
# 39 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/std_abs.h" 2 3







extern "C++"
{
namespace std
{


  using ::abs;


  inline long
  abs(long __i) { return __builtin_labs(__i); }



  inline long long
  abs(long long __x) { return __builtin_llabs (__x); }
# 70 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/std_abs.h" 3
  inline constexpr double
  abs(double __x)
  { return __builtin_fabs(__x); }

  inline constexpr float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }



  __extension__ inline constexpr __int128
  abs(__int128 __x) { return __x >= 0 ? __x : -__x; }
# 101 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/std_abs.h" 3
  constexpr _Float16
  abs(_Float16 __x)
  { return _Float16(__builtin_fabsf(__x)); }



  constexpr _Float32
  abs(_Float32 __x)
  { return __builtin_fabsf(__x); }



  constexpr _Float64
  abs(_Float64 __x)
  { return __builtin_fabs(__x); }
# 129 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/std_abs.h" 3
  constexpr __gnu_cxx::__bfloat16_t
  abs(__gnu_cxx::__bfloat16_t __x)
  { return __gnu_cxx::__bfloat16_t(__builtin_fabsf(__x)); }



  __extension__ inline constexpr
  __float128
  abs(__float128 __x)
  {






    return __builtin_signbit(__x) ? -__x : __x;

  }



}
}
# 50 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 2 3






# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 1 3
# 47 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 3
       
# 48 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 3
# 57 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 2 3
# 83 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 3
extern "C++"
{
namespace std
{


  using ::acos;


  inline constexpr float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline constexpr long double
  acos(long double __x)
  { return __builtin_acosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;


  inline constexpr float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline constexpr long double
  asin(long double __x)
  { return __builtin_asinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;


  inline constexpr float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline constexpr long double
  atan(long double __x)
  { return __builtin_atanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;


  inline constexpr float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline constexpr long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }


  using ::ceil;


  inline constexpr float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline constexpr long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;


  inline constexpr float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline constexpr long double
  cos(long double __x)
  { return __builtin_cosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;


  inline constexpr float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline constexpr long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;


  inline constexpr float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline constexpr long double
  exp(long double __x)
  { return __builtin_expl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;


  inline constexpr float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;


  inline constexpr float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline constexpr long double
  floor(long double __x)
  { return __builtin_floorl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;


  inline constexpr float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline constexpr long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }


  using ::frexp;


  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;


  inline constexpr float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline constexpr long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ldexp(_Tp __x, int __exp)
    { return __builtin_ldexp(__x, __exp); }

  using ::log;


  inline constexpr float
  log(float __x)
  { return __builtin_logf(__x); }

  inline constexpr long double
  log(long double __x)
  { return __builtin_logl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;


  inline constexpr float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline constexpr long double
  log10(long double __x)
  { return __builtin_log10l(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;


  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }


  using ::pow;


  inline constexpr float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline constexpr long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }
# 400 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 3
  using ::sin;


  inline constexpr float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline constexpr long double
  sin(long double __x)
  { return __builtin_sinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;


  inline constexpr float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline constexpr long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;


  inline constexpr float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline constexpr long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;


  inline constexpr float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline constexpr long double
  tan(long double __x)
  { return __builtin_tanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;


  inline constexpr float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline constexpr long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }


  constexpr _Float16
  acos(_Float16 __x)
  { return _Float16(__builtin_acosf(__x)); }

  constexpr _Float16
  asin(_Float16 __x)
  { return _Float16(__builtin_asinf(__x)); }

  constexpr _Float16
  atan(_Float16 __x)
  { return _Float16(__builtin_atanf(__x)); }

  constexpr _Float16
  atan2(_Float16 __y, _Float16 __x)
  { return _Float16(__builtin_atan2f(__y, __x)); }

  constexpr _Float16
  ceil(_Float16 __x)
  { return _Float16(__builtin_ceilf(__x)); }

  constexpr _Float16
  cos(_Float16 __x)
  { return _Float16(__builtin_cosf(__x)); }

  constexpr _Float16
  cosh(_Float16 __x)
  { return _Float16(__builtin_coshf(__x)); }

  constexpr _Float16
  exp(_Float16 __x)
  { return _Float16(__builtin_expf(__x)); }

  constexpr _Float16
  fabs(_Float16 __x)
  { return _Float16(__builtin_fabsf(__x)); }

  constexpr _Float16
  floor(_Float16 __x)
  { return _Float16(__builtin_floorf(__x)); }

  constexpr _Float16
  fmod(_Float16 __x, _Float16 __y)
  { return _Float16(__builtin_fmodf(__x, __y)); }

  inline _Float16
  frexp(_Float16 __x, int* __exp)
  { return _Float16(__builtin_frexpf(__x, __exp)); }

  constexpr _Float16
  ldexp(_Float16 __x, int __exp)
  { return _Float16(__builtin_ldexpf(__x, __exp)); }

  constexpr _Float16
  log(_Float16 __x)
  { return _Float16(__builtin_logf(__x)); }

  constexpr _Float16
  log10(_Float16 __x)
  { return _Float16(__builtin_log10f(__x)); }

  inline _Float16
  modf(_Float16 __x, _Float16* __iptr)
  {
    float __i, __ret = __builtin_modff(__x, &__i);
    *__iptr = _Float16(__i);
    return _Float16(__ret);
  }

  constexpr _Float16
  pow(_Float16 __x, _Float16 __y)
  { return _Float16(__builtin_powf(__x, __y)); }

  constexpr _Float16
  sin(_Float16 __x)
  { return _Float16(__builtin_sinf(__x)); }

  constexpr _Float16
  sinh(_Float16 __x)
  { return _Float16(__builtin_sinhf(__x)); }

  constexpr _Float16
  sqrt(_Float16 __x)
  { return _Float16(__builtin_sqrtf(__x)); }

  constexpr _Float16
  tan(_Float16 __x)
  { return _Float16(__builtin_tanf(__x)); }

  constexpr _Float16
  tanh(_Float16 __x)
  { return _Float16(__builtin_tanhf(__x)); }



  constexpr _Float32
  acos(_Float32 __x)
  { return __builtin_acosf(__x); }

  constexpr _Float32
  asin(_Float32 __x)
  { return __builtin_asinf(__x); }

  constexpr _Float32
  atan(_Float32 __x)
  { return __builtin_atanf(__x); }

  constexpr _Float32
  atan2(_Float32 __y, _Float32 __x)
  { return __builtin_atan2f(__y, __x); }

  constexpr _Float32
  ceil(_Float32 __x)
  { return __builtin_ceilf(__x); }

  constexpr _Float32
  cos(_Float32 __x)
  { return __builtin_cosf(__x); }

  constexpr _Float32
  cosh(_Float32 __x)
  { return __builtin_coshf(__x); }

  constexpr _Float32
  exp(_Float32 __x)
  { return __builtin_expf(__x); }

  constexpr _Float32
  fabs(_Float32 __x)
  { return __builtin_fabsf(__x); }

  constexpr _Float32
  floor(_Float32 __x)
  { return __builtin_floorf(__x); }

  constexpr _Float32
  fmod(_Float32 __x, _Float32 __y)
  { return __builtin_fmodf(__x, __y); }

  inline _Float32
  frexp(_Float32 __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  constexpr _Float32
  ldexp(_Float32 __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  constexpr _Float32
  log(_Float32 __x)
  { return __builtin_logf(__x); }

  constexpr _Float32
  log10(_Float32 __x)
  { return __builtin_log10f(__x); }

  inline _Float32
  modf(_Float32 __x, _Float32* __iptr)
  {
    float __i, __ret = __builtin_modff(__x, &__i);
    *__iptr = __i;
    return __ret;
  }

  constexpr _Float32
  pow(_Float32 __x, _Float32 __y)
  { return __builtin_powf(__x, __y); }

  constexpr _Float32
  sin(_Float32 __x)
  { return __builtin_sinf(__x); }

  constexpr _Float32
  sinh(_Float32 __x)
  { return __builtin_sinhf(__x); }

  constexpr _Float32
  sqrt(_Float32 __x)
  { return __builtin_sqrtf(__x); }

  constexpr _Float32
  tan(_Float32 __x)
  { return __builtin_tanf(__x); }

  constexpr _Float32
  tanh(_Float32 __x)
  { return __builtin_tanhf(__x); }



  constexpr _Float64
  acos(_Float64 __x)
  { return __builtin_acos(__x); }

  constexpr _Float64
  asin(_Float64 __x)
  { return __builtin_asin(__x); }

  constexpr _Float64
  atan(_Float64 __x)
  { return __builtin_atan(__x); }

  constexpr _Float64
  atan2(_Float64 __y, _Float64 __x)
  { return __builtin_atan2(__y, __x); }

  constexpr _Float64
  ceil(_Float64 __x)
  { return __builtin_ceil(__x); }

  constexpr _Float64
  cos(_Float64 __x)
  { return __builtin_cos(__x); }

  constexpr _Float64
  cosh(_Float64 __x)
  { return __builtin_cosh(__x); }

  constexpr _Float64
  exp(_Float64 __x)
  { return __builtin_exp(__x); }

  constexpr _Float64
  fabs(_Float64 __x)
  { return __builtin_fabs(__x); }

  constexpr _Float64
  floor(_Float64 __x)
  { return __builtin_floor(__x); }

  constexpr _Float64
  fmod(_Float64 __x, _Float64 __y)
  { return __builtin_fmod(__x, __y); }

  inline _Float64
  frexp(_Float64 __x, int* __exp)
  { return __builtin_frexp(__x, __exp); }

  constexpr _Float64
  ldexp(_Float64 __x, int __exp)
  { return __builtin_ldexp(__x, __exp); }

  constexpr _Float64
  log(_Float64 __x)
  { return __builtin_log(__x); }

  constexpr _Float64
  log10(_Float64 __x)
  { return __builtin_log10(__x); }

  inline _Float64
  modf(_Float64 __x, _Float64* __iptr)
  {
    double __i, __ret = __builtin_modf(__x, &__i);
    *__iptr = __i;
    return __ret;
  }

  constexpr _Float64
  pow(_Float64 __x, _Float64 __y)
  { return __builtin_pow(__x, __y); }

  constexpr _Float64
  sin(_Float64 __x)
  { return __builtin_sin(__x); }

  constexpr _Float64
  sinh(_Float64 __x)
  { return __builtin_sinh(__x); }

  constexpr _Float64
  sqrt(_Float64 __x)
  { return __builtin_sqrt(__x); }

  constexpr _Float64
  tan(_Float64 __x)
  { return __builtin_tan(__x); }

  constexpr _Float64
  tanh(_Float64 __x)
  { return __builtin_tanh(__x); }
# 960 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 3
  constexpr __gnu_cxx::__bfloat16_t
  acos(__gnu_cxx::__bfloat16_t __x)
  { return __gnu_cxx::__bfloat16_t(__builtin_acosf(__x)); }

  constexpr __gnu_cxx::__bfloat16_t
  asin(__gnu_cxx::__bfloat16_t __x)
  { return __gnu_cxx::__bfloat16_t(__builtin_asinf(__x)); }

  constexpr __gnu_cxx::__bfloat16_t
  atan(__gnu_cxx::__bfloat16_t __x)
  { return __gnu_cxx::__bfloat16_t(__builtin_atanf(__x)); }

  constexpr __gnu_cxx::__bfloat16_t
  atan2(__gnu_cxx::__bfloat16_t __y, __gnu_cxx::__bfloat16_t __x)
  { return __gnu_cxx::__bfloat16_t(__builtin_atan2f(__y, __x)); }

  constexpr __gnu_cxx::__bfloat16_t
  ceil(__gnu_cxx::__bfloat16_t __x)
  { return __gnu_cxx::__bfloat16_t(__builtin_ceilf(__x)); }

  constexpr __gnu_cxx::__bfloat16_t
  cos(__gnu_cxx::__bfloat16_t __x)
  { return __gnu_cxx::__bfloat16_t(__builtin_cosf(__x)); }

  constexpr __gnu_cxx::__bfloat16_t
  cosh(__gnu_cxx::__bfloat16_t __x)
  { return __gnu_cxx::__bfloat16_t(__builtin_coshf(__x)); }

  constexpr __gnu_cxx::__bfloat16_t
  exp(__gnu_cxx::__bfloat16_t __x)
  { return __gnu_cxx::__bfloat16_t(__builtin_expf(__x)); }

  constexpr __gnu_cxx::__bfloat16_t
  fabs(__gnu_cxx::__bfloat16_t __x)
  { return __gnu_cxx::__bfloat16_t(__builtin_fabsf(__x)); }

  constexpr __gnu_cxx::__bfloat16_t
  floor(__gnu_cxx::__bfloat16_t __x)
  { return __gnu_cxx::__bfloat16_t(__builtin_floorf(__x)); }

  constexpr __gnu_cxx::__bfloat16_t
  fmod(__gnu_cxx::__bfloat16_t __x, __gnu_cxx::__bfloat16_t __y)
  { return __gnu_cxx::__bfloat16_t(__builtin_fmodf(__x, __y)); }

  inline __gnu_cxx::__bfloat16_t
  frexp(__gnu_cxx::__bfloat16_t __x, int* __exp)
  { return __gnu_cxx::__bfloat16_t(__builtin_frexpf(__x, __exp)); }

  constexpr __gnu_cxx::__bfloat16_t
  ldexp(__gnu_cxx::__bfloat16_t __x, int __exp)
  { return __gnu_cxx::__bfloat16_t(__builtin_ldexpf(__x, __exp)); }

  constexpr __gnu_cxx::__bfloat16_t
  log(__gnu_cxx::__bfloat16_t __x)
  { return __gnu_cxx::__bfloat16_t(__builtin_logf(__x)); }

  constexpr __gnu_cxx::__bfloat16_t
  log10(__gnu_cxx::__bfloat16_t __x)
  { return __gnu_cxx::__bfloat16_t(__builtin_log10f(__x)); }

  inline __gnu_cxx::__bfloat16_t
  modf(__gnu_cxx::__bfloat16_t __x, __gnu_cxx::__bfloat16_t* __iptr)
  {
    float __i, __ret = __builtin_modff(__x, &__i);
    *__iptr = __gnu_cxx::__bfloat16_t(__i);
    return __gnu_cxx::__bfloat16_t(__ret);
  }

  constexpr __gnu_cxx::__bfloat16_t
  pow(__gnu_cxx::__bfloat16_t __x, __gnu_cxx::__bfloat16_t __y)
  { return __gnu_cxx::__bfloat16_t(__builtin_powf(__x, __y)); }

  constexpr __gnu_cxx::__bfloat16_t
  sin(__gnu_cxx::__bfloat16_t __x)
  { return __gnu_cxx::__bfloat16_t(__builtin_sinf(__x)); }

  constexpr __gnu_cxx::__bfloat16_t
  sinh(__gnu_cxx::__bfloat16_t __x)
  { return __gnu_cxx::__bfloat16_t(__builtin_sinhf(__x)); }

  constexpr __gnu_cxx::__bfloat16_t
  sqrt(__gnu_cxx::__bfloat16_t __x)
  { return __gnu_cxx::__bfloat16_t(__builtin_sqrtf(__x)); }

  constexpr __gnu_cxx::__bfloat16_t
  tan(__gnu_cxx::__bfloat16_t __x)
  { return __gnu_cxx::__bfloat16_t(__builtin_tanf(__x)); }

  constexpr __gnu_cxx::__bfloat16_t
  tanh(__gnu_cxx::__bfloat16_t __x)
  { return __gnu_cxx::__bfloat16_t(__builtin_tanhf(__x)); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmod(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmod(__type(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }
# 1100 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 3
  constexpr int
  fpclassify(float __x)
  { return __builtin_fpclassify(0x0100, (0x0100 | 0x0400), 0x0400,
    (0x0400 | 0x4000), 0x4000, __x); }

  constexpr int
  fpclassify(double __x)
  { return __builtin_fpclassify(0x0100, (0x0100 | 0x0400), 0x0400,
    (0x0400 | 0x4000), 0x4000, __x); }

  constexpr int
  fpclassify(long double __x)
  { return __builtin_fpclassify(0x0100, (0x0100 | 0x0400), 0x0400,
    (0x0400 | 0x4000), 0x4000, __x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              int>::__type
    fpclassify(_Tp __x)
    { return __x != 0 ? 0x0400 : 0x4000; }



  constexpr bool
  isfinite(float __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(double __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(long double __x)
  { return __builtin_isfinite(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isfinite(_Tp)
    { return true; }



  constexpr bool
  isinf(float __x)
  { return __builtin_isinf(__x); }





  constexpr bool
  isinf(double __x)
  { return __builtin_isinf(__x); }


  constexpr bool
  isinf(long double __x)
  { return __builtin_isinf(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isinf(_Tp)
    { return false; }



  constexpr bool
  isnan(float __x)
  { return __builtin_isnan(__x); }





  constexpr bool
  isnan(double __x)
  { return __builtin_isnan(__x); }


  constexpr bool
  isnan(long double __x)
  { return __builtin_isnan(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnan(_Tp)
    { return false; }



  constexpr bool
  isnormal(float __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(double __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(long double __x)
  { return __builtin_isnormal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnormal(_Tp __x)
    { return __x != 0 ? true : false; }




  constexpr bool
  signbit(float __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(double __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(long double __x)
  { return __builtin_signbit(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    signbit(_Tp __x)
    { return __x < 0 ? true : false; }



  constexpr bool
  isgreater(float __x, float __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(double __x, double __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(long double __x, long double __y)
  { return __builtin_isgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isgreaterequal(float __x, float __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(double __x, double __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(long double __x, long double __y)
  { return __builtin_isgreaterequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreaterequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreaterequal(__type(__x), __type(__y));
    }



  constexpr bool
  isless(float __x, float __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(double __x, double __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(long double __x, long double __y)
  { return __builtin_isless(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isless(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isless(__type(__x), __type(__y));
    }



  constexpr bool
  islessequal(float __x, float __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(double __x, double __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(long double __x, long double __y)
  { return __builtin_islessequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessequal(__type(__x), __type(__y));
    }



  constexpr bool
  islessgreater(float __x, float __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(double __x, double __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(long double __x, long double __y)
  { return __builtin_islessgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isunordered(float __x, float __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(double __x, double __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(long double __x, long double __y)
  { return __builtin_isunordered(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isunordered(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isunordered(__type(__x), __type(__y));
    }
# 1515 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 3
  constexpr int
  fpclassify(_Float16 __x)
  { return __builtin_fpclassify(0x0100, (0x0100 | 0x0400), 0x0400,
    (0x0400 | 0x4000), 0x4000, __x); }

  constexpr bool
  isfinite(_Float16 __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isinf(_Float16 __x)
  { return __builtin_isinf(__x); }

  constexpr bool
  isnan(_Float16 __x)
  { return __builtin_isnan(__x); }

  constexpr bool
  isnormal(_Float16 __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  signbit(_Float16 __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  isgreater(_Float16 __x, _Float16 __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreaterequal(_Float16 __x, _Float16 __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isless(_Float16 __x, _Float16 __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  islessequal(_Float16 __x, _Float16 __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessgreater(_Float16 __x, _Float16 __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  isunordered(_Float16 __x, _Float16 __y)
  { return __builtin_isunordered(__x, __y); }



  constexpr int
  fpclassify(_Float32 __x)
  { return __builtin_fpclassify(0x0100, (0x0100 | 0x0400), 0x0400,
    (0x0400 | 0x4000), 0x4000, __x); }

  constexpr bool
  isfinite(_Float32 __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isinf(_Float32 __x)
  { return __builtin_isinf(__x); }

  constexpr bool
  isnan(_Float32 __x)
  { return __builtin_isnan(__x); }

  constexpr bool
  isnormal(_Float32 __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  signbit(_Float32 __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  isgreater(_Float32 __x, _Float32 __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreaterequal(_Float32 __x, _Float32 __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isless(_Float32 __x, _Float32 __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  islessequal(_Float32 __x, _Float32 __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessgreater(_Float32 __x, _Float32 __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  isunordered(_Float32 __x, _Float32 __y)
  { return __builtin_isunordered(__x, __y); }



  constexpr int
  fpclassify(_Float64 __x)
  { return __builtin_fpclassify(0x0100, (0x0100 | 0x0400), 0x0400,
    (0x0400 | 0x4000), 0x4000, __x); }

  constexpr bool
  isfinite(_Float64 __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isinf(_Float64 __x)
  { return __builtin_isinf(__x); }

  constexpr bool
  isnan(_Float64 __x)
  { return __builtin_isnan(__x); }

  constexpr bool
  isnormal(_Float64 __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  signbit(_Float64 __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  isgreater(_Float64 __x, _Float64 __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreaterequal(_Float64 __x, _Float64 __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isless(_Float64 __x, _Float64 __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  islessequal(_Float64 __x, _Float64 __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessgreater(_Float64 __x, _Float64 __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  isunordered(_Float64 __x, _Float64 __y)
  { return __builtin_isunordered(__x, __y); }



  constexpr int
  fpclassify(_Float128 __x)
  { return __builtin_fpclassify(0x0100, (0x0100 | 0x0400), 0x0400,
    (0x0400 | 0x4000), 0x4000, __x); }

  constexpr bool
  isfinite(_Float128 __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isinf(_Float128 __x)
  { return __builtin_isinf(__x); }

  constexpr bool
  isnan(_Float128 __x)
  { return __builtin_isnan(__x); }

  constexpr bool
  isnormal(_Float128 __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  signbit(_Float128 __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  isgreater(_Float128 __x, _Float128 __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreaterequal(_Float128 __x, _Float128 __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isless(_Float128 __x, _Float128 __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  islessequal(_Float128 __x, _Float128 __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessgreater(_Float128 __x, _Float128 __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  isunordered(_Float128 __x, _Float128 __y)
  { return __builtin_isunordered(__x, __y); }



  constexpr int
  fpclassify(__gnu_cxx::__bfloat16_t __x)
  { return __builtin_fpclassify(0x0100, (0x0100 | 0x0400), 0x0400,
    (0x0400 | 0x4000), 0x4000, __x); }

  constexpr bool
  isfinite(__gnu_cxx::__bfloat16_t __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isinf(__gnu_cxx::__bfloat16_t __x)
  { return __builtin_isinf(__x); }

  constexpr bool
  isnan(__gnu_cxx::__bfloat16_t __x)
  { return __builtin_isnan(__x); }

  constexpr bool
  isnormal(__gnu_cxx::__bfloat16_t __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  signbit(__gnu_cxx::__bfloat16_t __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  isgreater(__gnu_cxx::__bfloat16_t __x, __gnu_cxx::__bfloat16_t __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreaterequal(__gnu_cxx::__bfloat16_t __x, __gnu_cxx::__bfloat16_t __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isless(__gnu_cxx::__bfloat16_t __x, __gnu_cxx::__bfloat16_t __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  islessequal(__gnu_cxx::__bfloat16_t __x, __gnu_cxx::__bfloat16_t __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessgreater(__gnu_cxx::__bfloat16_t __x, __gnu_cxx::__bfloat16_t __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  isunordered(__gnu_cxx::__bfloat16_t __x, __gnu_cxx::__bfloat16_t __y)
  { return __builtin_isunordered(__x, __y); }
# 1820 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 3
  using ::acosf;


  using ::acosl;



  using ::asinf;


  using ::asinl;



  using ::atanf;


  using ::atanl;



  using ::atan2f;


  using ::atan2l;



  using ::ceilf;


  using ::ceill;



  using ::cosf;


  using ::cosl;



  using ::coshf;


  using ::coshl;



  using ::expf;


  using ::expl;



  using ::fabsf;


  using ::fabsl;



  using ::floorf;


  using ::floorl;



  using ::fmodf;


  using ::fmodl;



  using ::frexpf;


  using ::frexpl;



  using ::ldexpf;


  using ::ldexpl;



  using ::logf;


  using ::logl;



  using ::log10f;


  using ::log10l;



  using ::modff;


  using ::modfl;



  using ::powf;


  using ::powl;



  using ::sinf;


  using ::sinl;



  using ::sinhf;


  using ::sinhl;



  using ::sqrtf;


  using ::sqrtl;



  using ::tanf;


  using ::tanl;



  using ::tanhf;


  using ::tanhl;
# 2085 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 3
  using ::double_t;
  using ::float_t;



  using ::acosh;
  using ::acoshf;
  using ::acoshl;

  using ::asinh;
  using ::asinhf;
  using ::asinhl;

  using ::atanh;
  using ::atanhf;
  using ::atanhl;

  using ::cbrt;
  using ::cbrtf;
  using ::cbrtl;

  using ::copysign;
  using ::copysignf;
  using ::copysignl;

  using ::erf;
  using ::erff;
  using ::erfl;

  using ::erfc;
  using ::erfcf;
  using ::erfcl;

  using ::exp2;
  using ::exp2f;
  using ::exp2l;

  using ::expm1;
  using ::expm1f;
  using ::expm1l;

  using ::fdim;
  using ::fdimf;
  using ::fdiml;

  using ::fma;
  using ::fmaf;
  using ::fmal;

  using ::fmax;
  using ::fmaxf;
  using ::fmaxl;

  using ::fmin;
  using ::fminf;
  using ::fminl;

  using ::hypot;
  using ::hypotf;
  using ::hypotl;

  using ::ilogb;
  using ::ilogbf;
  using ::ilogbl;

  using ::lgamma;
  using ::lgammaf;
  using ::lgammal;


  using ::llrint;
  using ::llrintf;
  using ::llrintl;

  using ::llround;
  using ::llroundf;
  using ::llroundl;


  using ::log1p;
  using ::log1pf;
  using ::log1pl;

  using ::log2;
  using ::log2f;
  using ::log2l;

  using ::logb;
  using ::logbf;
  using ::logbl;

  using ::lrint;
  using ::lrintf;
  using ::lrintl;

  using ::lround;
  using ::lroundf;
  using ::lroundl;

  using ::nan;
  using ::nanf;
  using ::nanl;

  using ::nearbyint;
  using ::nearbyintf;
  using ::nearbyintl;

  using ::nextafter;
  using ::nextafterf;
  using ::nextafterl;

  using ::nexttoward;
  using ::nexttowardf;
  using ::nexttowardl;

  using ::remainder;
  using ::remainderf;
  using ::remainderl;

  using ::remquo;
  using ::remquof;
  using ::remquol;

  using ::rint;
  using ::rintf;
  using ::rintl;

  using ::round;
  using ::roundf;
  using ::roundl;

  using ::scalbln;
  using ::scalblnf;
  using ::scalblnl;

  using ::scalbn;
  using ::scalbnf;
  using ::scalbnl;

  using ::tgamma;
  using ::tgammaf;
  using ::tgammal;

  using ::trunc;
  using ::truncf;
  using ::truncl;



  constexpr float
  acosh(float __x)
  { return __builtin_acoshf(__x); }

  constexpr long double
  acosh(long double __x)
  { return __builtin_acoshl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    acosh(_Tp __x)
    { return __builtin_acosh(__x); }



  constexpr float
  asinh(float __x)
  { return __builtin_asinhf(__x); }

  constexpr long double
  asinh(long double __x)
  { return __builtin_asinhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    asinh(_Tp __x)
    { return __builtin_asinh(__x); }



  constexpr float
  atanh(float __x)
  { return __builtin_atanhf(__x); }

  constexpr long double
  atanh(long double __x)
  { return __builtin_atanhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    atanh(_Tp __x)
    { return __builtin_atanh(__x); }



  constexpr float
  cbrt(float __x)
  { return __builtin_cbrtf(__x); }

  constexpr long double
  cbrt(long double __x)
  { return __builtin_cbrtl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    cbrt(_Tp __x)
    { return __builtin_cbrt(__x); }



  constexpr float
  copysign(float __x, float __y)
  { return __builtin_copysignf(__x, __y); }

  constexpr long double
  copysign(long double __x, long double __y)
  { return __builtin_copysignl(__x, __y); }



  constexpr float
  erf(float __x)
  { return __builtin_erff(__x); }

  constexpr long double
  erf(long double __x)
  { return __builtin_erfl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erf(_Tp __x)
    { return __builtin_erf(__x); }



  constexpr float
  erfc(float __x)
  { return __builtin_erfcf(__x); }

  constexpr long double
  erfc(long double __x)
  { return __builtin_erfcl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erfc(_Tp __x)
    { return __builtin_erfc(__x); }



  constexpr float
  exp2(float __x)
  { return __builtin_exp2f(__x); }

  constexpr long double
  exp2(long double __x)
  { return __builtin_exp2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    exp2(_Tp __x)
    { return __builtin_exp2(__x); }



  constexpr float
  expm1(float __x)
  { return __builtin_expm1f(__x); }

  constexpr long double
  expm1(long double __x)
  { return __builtin_expm1l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    expm1(_Tp __x)
    { return __builtin_expm1(__x); }



  constexpr float
  fdim(float __x, float __y)
  { return __builtin_fdimf(__x, __y); }

  constexpr long double
  fdim(long double __x, long double __y)
  { return __builtin_fdiml(__x, __y); }



  constexpr float
  fma(float __x, float __y, float __z)
  { return __builtin_fmaf(__x, __y, __z); }

  constexpr long double
  fma(long double __x, long double __y, long double __z)
  { return __builtin_fmal(__x, __y, __z); }



  constexpr float
  fmax(float __x, float __y)
  { return __builtin_fmaxf(__x, __y); }

  constexpr long double
  fmax(long double __x, long double __y)
  { return __builtin_fmaxl(__x, __y); }



  constexpr float
  fmin(float __x, float __y)
  { return __builtin_fminf(__x, __y); }

  constexpr long double
  fmin(long double __x, long double __y)
  { return __builtin_fminl(__x, __y); }



  constexpr float
  hypot(float __x, float __y)
  { return __builtin_hypotf(__x, __y); }

  constexpr long double
  hypot(long double __x, long double __y)
  { return __builtin_hypotl(__x, __y); }



  constexpr int
  ilogb(float __x)
  { return __builtin_ilogbf(__x); }

  constexpr int
  ilogb(long double __x)
  { return __builtin_ilogbl(__x); }



  template<typename _Tp>
    constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    int>::__type
    ilogb(_Tp __x)
    { return __builtin_ilogb(__x); }



  constexpr float
  lgamma(float __x)
  { return __builtin_lgammaf(__x); }

  constexpr long double
  lgamma(long double __x)
  { return __builtin_lgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    lgamma(_Tp __x)
    { return __builtin_lgamma(__x); }



  constexpr long long
  llrint(float __x)
  { return __builtin_llrintf(__x); }

  constexpr long long
  llrint(long double __x)
  { return __builtin_llrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llrint(_Tp __x)
    { return __builtin_llrint(__x); }



  constexpr long long
  llround(float __x)
  { return __builtin_llroundf(__x); }

  constexpr long long
  llround(long double __x)
  { return __builtin_llroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llround(_Tp __x)
    { return __builtin_llround(__x); }



  constexpr float
  log1p(float __x)
  { return __builtin_log1pf(__x); }

  constexpr long double
  log1p(long double __x)
  { return __builtin_log1pl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log1p(_Tp __x)
    { return __builtin_log1p(__x); }




  constexpr float
  log2(float __x)
  { return __builtin_log2f(__x); }

  constexpr long double
  log2(long double __x)
  { return __builtin_log2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log2(_Tp __x)
    { return __builtin_log2(__x); }



  constexpr float
  logb(float __x)
  { return __builtin_logbf(__x); }

  constexpr long double
  logb(long double __x)
  { return __builtin_logbl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    logb(_Tp __x)
    { return __builtin_logb(__x); }



  constexpr long
  lrint(float __x)
  { return __builtin_lrintf(__x); }

  constexpr long
  lrint(long double __x)
  { return __builtin_lrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lrint(_Tp __x)
    { return __builtin_lrint(__x); }



  constexpr long
  lround(float __x)
  { return __builtin_lroundf(__x); }

  constexpr long
  lround(long double __x)
  { return __builtin_lroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lround(_Tp __x)
    { return __builtin_lround(__x); }



  constexpr float
  nearbyint(float __x)
  { return __builtin_nearbyintf(__x); }

  constexpr long double
  nearbyint(long double __x)
  { return __builtin_nearbyintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nearbyint(_Tp __x)
    { return __builtin_nearbyint(__x); }



  constexpr float
  nextafter(float __x, float __y)
  { return __builtin_nextafterf(__x, __y); }

  constexpr long double
  nextafter(long double __x, long double __y)
  { return __builtin_nextafterl(__x, __y); }



  constexpr float
  nexttoward(float __x, long double __y)
  { return __builtin_nexttowardf(__x, __y); }

  constexpr long double
  nexttoward(long double __x, long double __y)
  { return __builtin_nexttowardl(__x, __y); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nexttoward(_Tp __x, long double __y)
    { return __builtin_nexttoward(__x, __y); }



  constexpr float
  remainder(float __x, float __y)
  { return __builtin_remainderf(__x, __y); }

  constexpr long double
  remainder(long double __x, long double __y)
  { return __builtin_remainderl(__x, __y); }



  inline float
  remquo(float __x, float __y, int* __pquo)
  { return __builtin_remquof(__x, __y, __pquo); }

  inline long double
  remquo(long double __x, long double __y, int* __pquo)
  { return __builtin_remquol(__x, __y, __pquo); }



  constexpr float
  rint(float __x)
  { return __builtin_rintf(__x); }

  constexpr long double
  rint(long double __x)
  { return __builtin_rintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    rint(_Tp __x)
    { return __builtin_rint(__x); }



  constexpr float
  round(float __x)
  { return __builtin_roundf(__x); }

  constexpr long double
  round(long double __x)
  { return __builtin_roundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    round(_Tp __x)
    { return __builtin_round(__x); }



  constexpr float
  scalbln(float __x, long __ex)
  { return __builtin_scalblnf(__x, __ex); }

  constexpr long double
  scalbln(long double __x, long __ex)
  { return __builtin_scalblnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbln(_Tp __x, long __ex)
    { return __builtin_scalbln(__x, __ex); }



  constexpr float
  scalbn(float __x, int __ex)
  { return __builtin_scalbnf(__x, __ex); }

  constexpr long double
  scalbn(long double __x, int __ex)
  { return __builtin_scalbnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbn(_Tp __x, int __ex)
    { return __builtin_scalbn(__x, __ex); }



  constexpr float
  tgamma(float __x)
  { return __builtin_tgammaf(__x); }

  constexpr long double
  tgamma(long double __x)
  { return __builtin_tgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    tgamma(_Tp __x)
    { return __builtin_tgamma(__x); }



  constexpr float
  trunc(float __x)
  { return __builtin_truncf(__x); }

  constexpr long double
  trunc(long double __x)
  { return __builtin_truncl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    trunc(_Tp __x)
    { return __builtin_trunc(__x); }



  constexpr _Float16
  acosh(_Float16 __x)
  { return _Float16(__builtin_acoshf(__x)); }

  constexpr _Float16
  asinh(_Float16 __x)
  { return _Float16(__builtin_asinhf(__x)); }

  constexpr _Float16
  atanh(_Float16 __x)
  { return _Float16(__builtin_atanhf(__x)); }

  constexpr _Float16
  cbrt(_Float16 __x)
  { return _Float16(__builtin_cbrtf(__x)); }

  constexpr _Float16
  copysign(_Float16 __x, _Float16 __y)
  { return __builtin_copysignf16(__x, __y); }

  constexpr _Float16
  erf(_Float16 __x)
  { return _Float16(__builtin_erff(__x)); }

  constexpr _Float16
  erfc(_Float16 __x)
  { return _Float16(__builtin_erfcf(__x)); }

  constexpr _Float16
  exp2(_Float16 __x)
  { return _Float16(__builtin_exp2f(__x)); }

  constexpr _Float16
  expm1(_Float16 __x)
  { return _Float16(__builtin_expm1f(__x)); }

  constexpr _Float16
  fdim(_Float16 __x, _Float16 __y)
  { return _Float16(__builtin_fdimf(__x, __y)); }

  constexpr _Float16
  fma(_Float16 __x, _Float16 __y, _Float16 __z)
  { return _Float16(__builtin_fmaf(__x, __y, __z)); }

  constexpr _Float16
  fmax(_Float16 __x, _Float16 __y)
  { return _Float16(__builtin_fmaxf(__x, __y)); }

  constexpr _Float16
  fmin(_Float16 __x, _Float16 __y)
  { return _Float16(__builtin_fminf(__x, __y)); }

  constexpr _Float16
  hypot(_Float16 __x, _Float16 __y)
  { return _Float16(__builtin_hypotf(__x, __y)); }

  constexpr int
  ilogb(_Float16 __x)
  { return _Float16(__builtin_ilogbf(__x)); }

  constexpr _Float16
  lgamma(_Float16 __x)
  { return _Float16(__builtin_lgammaf(__x)); }

  constexpr long long
  llrint(_Float16 __x)
  { return _Float16(__builtin_llrintf(__x)); }

  constexpr long long
  llround(_Float16 __x)
  { return _Float16(__builtin_llroundf(__x)); }

  constexpr _Float16
  log1p(_Float16 __x)
  { return _Float16(__builtin_log1pf(__x)); }


  constexpr _Float16
  log2(_Float16 __x)
  { return _Float16(__builtin_log2f(__x)); }

  constexpr _Float16
  logb(_Float16 __x)
  { return _Float16(__builtin_logbf(__x)); }

  constexpr long
  lrint(_Float16 __x)
  { return _Float16(__builtin_lrintf(__x)); }

  constexpr long
  lround(_Float16 __x)
  { return _Float16(__builtin_lroundf(__x)); }

  constexpr _Float16
  nearbyint(_Float16 __x)
  { return _Float16(__builtin_nearbyintf(__x)); }

  constexpr _Float16
  nextafter(_Float16 __x, _Float16 __y)
  {
    if (std::__is_constant_evaluated())
      return __builtin_nextafterf16(__x, __y);

    using __float16_int_type = short int;



    __float16_int_type __hx, __hy, __ix, __iy;
    __builtin_memcpy(&__hx, &__x, sizeof(__x));
    __builtin_memcpy(&__hy, &__y, sizeof(__x));
    __ix = __hx & 0x7fff;
    __iy = __hy & 0x7fff;
    if (__ix > 0x7c00 || __iy > 0x7c00)
      return __x + __y;
    if (__x == __y)
      return __y;
    if (__ix == 0)
      {
 __hy = (__hy & 0x8000) | 1;
 __builtin_memcpy(&__x, &__hy, sizeof(__x));
 __builtin_nextafterf(0.0f, 1.0f);
 return __x;
      }
    if (__hx >= 0)
      {
 if (__hx > __hy)
   --__hx;
 else
   ++__hx;
      }
    else
      {
 if (__hy >= 0 || __hx > __hy)
   --__hx;
 else
   ++__hx;
      }
    __hy = __hx & 0x7c00;
    if (__hy >= 0x7c00)
      __builtin_nextafterf(3.40282346638528859811704183484516925e+38F, __builtin_inff());
    else if (__hy < 0x0400)
      __builtin_nextafterf(1.17549435082228750796873653722224568e-38F, 0.0f);
    __builtin_memcpy(&__x, &__hx, sizeof(__x));
    return __x;
  }

  constexpr _Float16
  remainder(_Float16 __x, _Float16 __y)
  { return _Float16(__builtin_remainderf(__x, __y)); }

  inline _Float16
  remquo(_Float16 __x, _Float16 __y, int* __pquo)
  { return _Float16(__builtin_remquof(__x, __y, __pquo)); }

  constexpr _Float16
  rint(_Float16 __x)
  { return _Float16(__builtin_rintf(__x)); }

  constexpr _Float16
  round(_Float16 __x)
  { return _Float16(__builtin_roundf(__x)); }

  constexpr _Float16
  scalbln(_Float16 __x, long __ex)
  { return _Float16(__builtin_scalblnf(__x, __ex)); }

  constexpr _Float16
  scalbn(_Float16 __x, int __ex)
  { return _Float16(__builtin_scalbnf(__x, __ex)); }

  constexpr _Float16
  tgamma(_Float16 __x)
  { return _Float16(__builtin_tgammaf(__x)); }

  constexpr _Float16
  trunc(_Float16 __x)
  { return _Float16(__builtin_truncf(__x)); }



  constexpr _Float32
  acosh(_Float32 __x)
  { return __builtin_acoshf(__x); }

  constexpr _Float32
  asinh(_Float32 __x)
  { return __builtin_asinhf(__x); }

  constexpr _Float32
  atanh(_Float32 __x)
  { return __builtin_atanhf(__x); }

  constexpr _Float32
  cbrt(_Float32 __x)
  { return __builtin_cbrtf(__x); }

  constexpr _Float32
  copysign(_Float32 __x, _Float32 __y)
  { return __builtin_copysignf(__x, __y); }

  constexpr _Float32
  erf(_Float32 __x)
  { return __builtin_erff(__x); }

  constexpr _Float32
  erfc(_Float32 __x)
  { return __builtin_erfcf(__x); }

  constexpr _Float32
  exp2(_Float32 __x)
  { return __builtin_exp2f(__x); }

  constexpr _Float32
  expm1(_Float32 __x)
  { return __builtin_expm1f(__x); }

  constexpr _Float32
  fdim(_Float32 __x, _Float32 __y)
  { return __builtin_fdimf(__x, __y); }

  constexpr _Float32
  fma(_Float32 __x, _Float32 __y, _Float32 __z)
  { return __builtin_fmaf(__x, __y, __z); }

  constexpr _Float32
  fmax(_Float32 __x, _Float32 __y)
  { return __builtin_fmaxf(__x, __y); }

  constexpr _Float32
  fmin(_Float32 __x, _Float32 __y)
  { return __builtin_fminf(__x, __y); }

  constexpr _Float32
  hypot(_Float32 __x, _Float32 __y)
  { return __builtin_hypotf(__x, __y); }

  constexpr int
  ilogb(_Float32 __x)
  { return __builtin_ilogbf(__x); }

  constexpr _Float32
  lgamma(_Float32 __x)
  { return __builtin_lgammaf(__x); }

  constexpr long long
  llrint(_Float32 __x)
  { return __builtin_llrintf(__x); }

  constexpr long long
  llround(_Float32 __x)
  { return __builtin_llroundf(__x); }

  constexpr _Float32
  log1p(_Float32 __x)
  { return __builtin_log1pf(__x); }


  constexpr _Float32
  log2(_Float32 __x)
  { return __builtin_log2f(__x); }

  constexpr _Float32
  logb(_Float32 __x)
  { return __builtin_logbf(__x); }

  constexpr long
  lrint(_Float32 __x)
  { return __builtin_lrintf(__x); }

  constexpr long
  lround(_Float32 __x)
  { return __builtin_lroundf(__x); }

  constexpr _Float32
  nearbyint(_Float32 __x)
  { return __builtin_nearbyintf(__x); }

  constexpr _Float32
  nextafter(_Float32 __x, _Float32 __y)
  { return __builtin_nextafterf(__x, __y); }

  constexpr _Float32
  remainder(_Float32 __x, _Float32 __y)
  { return __builtin_remainderf(__x, __y); }

  inline _Float32
  remquo(_Float32 __x, _Float32 __y, int* __pquo)
  { return __builtin_remquof(__x, __y, __pquo); }

  constexpr _Float32
  rint(_Float32 __x)
  { return __builtin_rintf(__x); }

  constexpr _Float32
  round(_Float32 __x)
  { return __builtin_roundf(__x); }

  constexpr _Float32
  scalbln(_Float32 __x, long __ex)
  { return __builtin_scalblnf(__x, __ex); }

  constexpr _Float32
  scalbn(_Float32 __x, int __ex)
  { return __builtin_scalbnf(__x, __ex); }

  constexpr _Float32
  tgamma(_Float32 __x)
  { return __builtin_tgammaf(__x); }

  constexpr _Float32
  trunc(_Float32 __x)
  { return __builtin_truncf(__x); }



  constexpr _Float64
  acosh(_Float64 __x)
  { return __builtin_acosh(__x); }

  constexpr _Float64
  asinh(_Float64 __x)
  { return __builtin_asinh(__x); }

  constexpr _Float64
  atanh(_Float64 __x)
  { return __builtin_atanh(__x); }

  constexpr _Float64
  cbrt(_Float64 __x)
  { return __builtin_cbrt(__x); }

  constexpr _Float64
  copysign(_Float64 __x, _Float64 __y)
  { return __builtin_copysign(__x, __y); }

  constexpr _Float64
  erf(_Float64 __x)
  { return __builtin_erf(__x); }

  constexpr _Float64
  erfc(_Float64 __x)
  { return __builtin_erfc(__x); }

  constexpr _Float64
  exp2(_Float64 __x)
  { return __builtin_exp2(__x); }

  constexpr _Float64
  expm1(_Float64 __x)
  { return __builtin_expm1(__x); }

  constexpr _Float64
  fdim(_Float64 __x, _Float64 __y)
  { return __builtin_fdim(__x, __y); }

  constexpr _Float64
  fma(_Float64 __x, _Float64 __y, _Float64 __z)
  { return __builtin_fma(__x, __y, __z); }

  constexpr _Float64
  fmax(_Float64 __x, _Float64 __y)
  { return __builtin_fmax(__x, __y); }

  constexpr _Float64
  fmin(_Float64 __x, _Float64 __y)
  { return __builtin_fmin(__x, __y); }

  constexpr _Float64
  hypot(_Float64 __x, _Float64 __y)
  { return __builtin_hypot(__x, __y); }

  constexpr int
  ilogb(_Float64 __x)
  { return __builtin_ilogb(__x); }

  constexpr _Float64
  lgamma(_Float64 __x)
  { return __builtin_lgamma(__x); }

  constexpr long long
  llrint(_Float64 __x)
  { return __builtin_llrint(__x); }

  constexpr long long
  llround(_Float64 __x)
  { return __builtin_llround(__x); }

  constexpr _Float64
  log1p(_Float64 __x)
  { return __builtin_log1p(__x); }


  constexpr _Float64
  log2(_Float64 __x)
  { return __builtin_log2(__x); }

  constexpr _Float64
  logb(_Float64 __x)
  { return __builtin_logb(__x); }

  constexpr long
  lrint(_Float64 __x)
  { return __builtin_lrint(__x); }

  constexpr long
  lround(_Float64 __x)
  { return __builtin_lround(__x); }

  constexpr _Float64
  nearbyint(_Float64 __x)
  { return __builtin_nearbyint(__x); }

  constexpr _Float64
  nextafter(_Float64 __x, _Float64 __y)
  { return __builtin_nextafter(__x, __y); }

  constexpr _Float64
  remainder(_Float64 __x, _Float64 __y)
  { return __builtin_remainder(__x, __y); }

  inline _Float64
  remquo(_Float64 __x, _Float64 __y, int* __pquo)
  { return __builtin_remquo(__x, __y, __pquo); }

  constexpr _Float64
  rint(_Float64 __x)
  { return __builtin_rint(__x); }

  constexpr _Float64
  round(_Float64 __x)
  { return __builtin_round(__x); }

  constexpr _Float64
  scalbln(_Float64 __x, long __ex)
  { return __builtin_scalbln(__x, __ex); }

  constexpr _Float64
  scalbn(_Float64 __x, int __ex)
  { return __builtin_scalbn(__x, __ex); }

  constexpr _Float64
  tgamma(_Float64 __x)
  { return __builtin_tgamma(__x); }

  constexpr _Float64
  trunc(_Float64 __x)
  { return __builtin_trunc(__x); }
# 3494 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 3
  constexpr __gnu_cxx::__bfloat16_t
  acosh(__gnu_cxx::__bfloat16_t __x)
  { return __gnu_cxx::__bfloat16_t(__builtin_acoshf(__x)); }

  constexpr __gnu_cxx::__bfloat16_t
  asinh(__gnu_cxx::__bfloat16_t __x)
  { return __gnu_cxx::__bfloat16_t(__builtin_asinhf(__x)); }

  constexpr __gnu_cxx::__bfloat16_t
  atanh(__gnu_cxx::__bfloat16_t __x)
  { return __gnu_cxx::__bfloat16_t(__builtin_atanhf(__x)); }

  constexpr __gnu_cxx::__bfloat16_t
  cbrt(__gnu_cxx::__bfloat16_t __x)
  { return __gnu_cxx::__bfloat16_t(__builtin_cbrtf(__x)); }

  constexpr __gnu_cxx::__bfloat16_t
  copysign(__gnu_cxx::__bfloat16_t __x, __gnu_cxx::__bfloat16_t __y)
  { return __gnu_cxx::__bfloat16_t(__builtin_copysignf(__x, __y)); }

  constexpr __gnu_cxx::__bfloat16_t
  erf(__gnu_cxx::__bfloat16_t __x)
  { return __gnu_cxx::__bfloat16_t(__builtin_erff(__x)); }

  constexpr __gnu_cxx::__bfloat16_t
  erfc(__gnu_cxx::__bfloat16_t __x)
  { return __gnu_cxx::__bfloat16_t(__builtin_erfcf(__x)); }

  constexpr __gnu_cxx::__bfloat16_t
  exp2(__gnu_cxx::__bfloat16_t __x)
  { return __gnu_cxx::__bfloat16_t(__builtin_exp2f(__x)); }

  constexpr __gnu_cxx::__bfloat16_t
  expm1(__gnu_cxx::__bfloat16_t __x)
  { return __gnu_cxx::__bfloat16_t(__builtin_expm1f(__x)); }

  constexpr __gnu_cxx::__bfloat16_t
  fdim(__gnu_cxx::__bfloat16_t __x, __gnu_cxx::__bfloat16_t __y)
  { return __gnu_cxx::__bfloat16_t(__builtin_fdimf(__x, __y)); }

  constexpr __gnu_cxx::__bfloat16_t
  fma(__gnu_cxx::__bfloat16_t __x, __gnu_cxx::__bfloat16_t __y, __gnu_cxx::__bfloat16_t __z)
  { return __gnu_cxx::__bfloat16_t(__builtin_fmaf(__x, __y, __z)); }

  constexpr __gnu_cxx::__bfloat16_t
  fmax(__gnu_cxx::__bfloat16_t __x, __gnu_cxx::__bfloat16_t __y)
  { return __gnu_cxx::__bfloat16_t(__builtin_fmaxf(__x, __y)); }

  constexpr __gnu_cxx::__bfloat16_t
  fmin(__gnu_cxx::__bfloat16_t __x, __gnu_cxx::__bfloat16_t __y)
  { return __gnu_cxx::__bfloat16_t(__builtin_fminf(__x, __y)); }

  constexpr __gnu_cxx::__bfloat16_t
  hypot(__gnu_cxx::__bfloat16_t __x, __gnu_cxx::__bfloat16_t __y)
  { return __gnu_cxx::__bfloat16_t(__builtin_hypotf(__x, __y)); }

  constexpr int
  ilogb(__gnu_cxx::__bfloat16_t __x)
  { return __gnu_cxx::__bfloat16_t(__builtin_ilogbf(__x)); }

  constexpr __gnu_cxx::__bfloat16_t
  lgamma(__gnu_cxx::__bfloat16_t __x)
  { return __gnu_cxx::__bfloat16_t(__builtin_lgammaf(__x)); }

  constexpr long long
  llrint(__gnu_cxx::__bfloat16_t __x)
  { return __gnu_cxx::__bfloat16_t(__builtin_llrintf(__x)); }

  constexpr long long
  llround(__gnu_cxx::__bfloat16_t __x)
  { return __gnu_cxx::__bfloat16_t(__builtin_llroundf(__x)); }

  constexpr __gnu_cxx::__bfloat16_t
  log1p(__gnu_cxx::__bfloat16_t __x)
  { return __gnu_cxx::__bfloat16_t(__builtin_log1pf(__x)); }


  constexpr __gnu_cxx::__bfloat16_t
  log2(__gnu_cxx::__bfloat16_t __x)
  { return __gnu_cxx::__bfloat16_t(__builtin_log2f(__x)); }

  constexpr __gnu_cxx::__bfloat16_t
  logb(__gnu_cxx::__bfloat16_t __x)
  { return __gnu_cxx::__bfloat16_t(__builtin_logbf(__x)); }

  constexpr long
  lrint(__gnu_cxx::__bfloat16_t __x)
  { return __gnu_cxx::__bfloat16_t(__builtin_lrintf(__x)); }

  constexpr long
  lround(__gnu_cxx::__bfloat16_t __x)
  { return __gnu_cxx::__bfloat16_t(__builtin_lroundf(__x)); }

  constexpr __gnu_cxx::__bfloat16_t
  nearbyint(__gnu_cxx::__bfloat16_t __x)
  { return __gnu_cxx::__bfloat16_t(__builtin_nearbyintf(__x)); }

  constexpr __gnu_cxx::__bfloat16_t
  nextafter(__gnu_cxx::__bfloat16_t __x, __gnu_cxx::__bfloat16_t __y)
  {
    if (std::__is_constant_evaluated())
      return __builtin_nextafterf16b(__x, __y);

    using __bfloat16_int_type = short int;



    __bfloat16_int_type __hx, __hy, __ix, __iy;
    __builtin_memcpy(&__hx, &__x, sizeof(__x));
    __builtin_memcpy(&__hy, &__y, sizeof(__x));
    __ix = __hx & 0x7fff;
    __iy = __hy & 0x7fff;
    if (__ix > 0x7f80 || __iy > 0x7f80)
      return __x + __y;
    if (__x == __y)
      return __y;
    if (__ix == 0)
      {
 __hy = (__hy & 0x8000) | 1;
 __builtin_memcpy(&__x, &__hy, sizeof(__x));
 __builtin_nextafterf(0.0f, 1.0f);
 return __x;
      }
    if (__hx >= 0)
      {
 if (__hx > __hy)
   --__hx;
 else
   ++__hx;
      }
    else
      {
 if (__hy >= 0 || __hx > __hy)
   --__hx;
 else
   ++__hx;
      }
    __hy = __hx & 0x7f80;
    if (__hy >= 0x7f80)
      __builtin_nextafterf(3.40282346638528859811704183484516925e+38F, __builtin_inff());
    else if (__hy < 0x0080)
      __builtin_nextafterf(1.17549435082228750796873653722224568e-38F, 0.0f);
    __builtin_memcpy(&__x, &__hx, sizeof(__x));
    return __x;
  }

  constexpr __gnu_cxx::__bfloat16_t
  remainder(__gnu_cxx::__bfloat16_t __x, __gnu_cxx::__bfloat16_t __y)
  { return __gnu_cxx::__bfloat16_t(__builtin_remainderf(__x, __y)); }

  inline __gnu_cxx::__bfloat16_t
  remquo(__gnu_cxx::__bfloat16_t __x, __gnu_cxx::__bfloat16_t __y, int* __pquo)
  { return __gnu_cxx::__bfloat16_t(__builtin_remquof(__x, __y, __pquo)); }

  constexpr __gnu_cxx::__bfloat16_t
  rint(__gnu_cxx::__bfloat16_t __x)
  { return __gnu_cxx::__bfloat16_t(__builtin_rintf(__x)); }

  constexpr __gnu_cxx::__bfloat16_t
  round(__gnu_cxx::__bfloat16_t __x)
  { return __gnu_cxx::__bfloat16_t(__builtin_roundf(__x)); }

  constexpr __gnu_cxx::__bfloat16_t
  scalbln(__gnu_cxx::__bfloat16_t __x, long __ex)
  { return __gnu_cxx::__bfloat16_t(__builtin_scalblnf(__x, __ex)); }

  constexpr __gnu_cxx::__bfloat16_t
  scalbn(__gnu_cxx::__bfloat16_t __x, int __ex)
  { return __gnu_cxx::__bfloat16_t(__builtin_scalbnf(__x, __ex)); }

  constexpr __gnu_cxx::__bfloat16_t
  tgamma(__gnu_cxx::__bfloat16_t __x)
  { return __gnu_cxx::__bfloat16_t(__builtin_tgammaf(__x)); }

  constexpr __gnu_cxx::__bfloat16_t
  trunc(__gnu_cxx::__bfloat16_t __x)
  { return __gnu_cxx::__bfloat16_t(__builtin_truncf(__x)); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    copysign(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return copysign(__type(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fdim(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fdim(__type(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmax(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmax(__type(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmin(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmin(__type(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    hypot(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return hypot(__type(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    nextafter(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return nextafter(__type(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remainder(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remainder(__type(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remquo(_Tp __x, _Up __y, int* __pquo)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remquo(__type(__x), __type(__y), __pquo);
    }

  template<typename _Tp, typename _Up, typename _Vp>
    constexpr typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
    fma(_Tp __x, _Up __y, _Vp __z)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
      return fma(__type(__x), __type(__y), __type(__z));
    }







  template<typename _Tp>
    inline _Tp
    __hypot3(_Tp __x, _Tp __y, _Tp __z)
    {
      __x = std::abs(__x);
      __y = std::abs(__y);
      __z = std::abs(__z);
      if (_Tp __a = __x < __y ? __y < __z ? __z : __y : __x < __z ? __z : __x)
 return __a * std::sqrt((__x / __a) * (__x / __a)
          + (__y / __a) * (__y / __a)
          + (__z / __a) * (__z / __a));
      else
 return {};
    }

  inline float
  hypot(float __x, float __y, float __z)
  { return std::__hypot3<float>(__x, __y, __z); }

  inline double
  hypot(double __x, double __y, double __z)
  { return std::__hypot3<double>(__x, __y, __z); }

  inline long double
  hypot(long double __x, long double __y, long double __z)
  { return std::__hypot3<long double>(__x, __y, __z); }

  template<typename _Tp, typename _Up, typename _Vp>
    __gnu_cxx::__promoted_t<_Tp, _Up, _Vp>
    hypot(_Tp __x, _Up __y, _Vp __z)
    {
      using __type = __gnu_cxx::__promoted_t<_Tp, _Up, _Vp>;
      return std::__hypot3<__type>(__x, __y, __z);
    }


  inline _Float16
  hypot(_Float16 __x, _Float16 __y, _Float16 __z)
  { return std::__hypot3<_Float16>(__x, __y, __z); }



  inline _Float32
  hypot(_Float32 __x, _Float32 __y, _Float32 __z)
  { return std::__hypot3<_Float32>(__x, __y, __z); }



  inline _Float64
  hypot(_Float64 __x, _Float64 __y, _Float64 __z)
  { return std::__hypot3<_Float64>(__x, __y, __z); }
# 3814 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 3
  inline __gnu_cxx::__bfloat16_t
  hypot(__gnu_cxx::__bfloat16_t __x, __gnu_cxx::__bfloat16_t __y, __gnu_cxx::__bfloat16_t __z)
  { return std::__hypot3<__gnu_cxx::__bfloat16_t>(__x, __y, __z); }






  template<typename _Fp>
    constexpr _Fp
    __lerp(_Fp __a, _Fp __b, _Fp __t) noexcept
    {
      if ((__a <= 0 && __b >= 0) || (__a >= 0 && __b <= 0))
 return __t * __b + (1 - __t) * __a;

      if (__t == 1)
 return __b;



      const _Fp __x = __a + __t * (__b - __a);
      return (__t > 1) == (__b > __a)
 ? (__b < __x ? __x : __b)
 : (__b > __x ? __x : __b);
    }

  constexpr float
  lerp(float __a, float __b, float __t) noexcept
  { return std::__lerp(__a, __b, __t); }

  constexpr double
  lerp(double __a, double __b, double __t) noexcept
  { return std::__lerp(__a, __b, __t); }

  constexpr long double
  lerp(long double __a, long double __b, long double __t) noexcept
  { return std::__lerp(__a, __b, __t); }

  template<typename _Tp, typename _Up, typename _Vp>
    constexpr __gnu_cxx::__promoted_t<_Tp, _Up, _Vp>
    lerp(_Tp __x, _Up __y, _Vp __z) noexcept
    {
      using __type = __gnu_cxx::__promoted_t<_Tp, _Up, _Vp>;
      return std::__lerp<__type>(__x, __y, __z);
    }


  inline _Float16
  lerp(_Float16 __x, _Float16 __y, _Float16 __z) noexcept
  { return std::__lerp<_Float16>(__x, __y, __z); }



  inline _Float32
  lerp(_Float32 __x, _Float32 __y, _Float32 __z) noexcept
  { return std::__lerp<_Float32>(__x, __y, __z); }



  inline _Float64
  lerp(_Float64 __x, _Float64 __y, _Float64 __z) noexcept
  { return std::__lerp<_Float64>(__x, __y, __z); }
# 3888 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 3
  inline __gnu_cxx::__bfloat16_t
  lerp(__gnu_cxx::__bfloat16_t __x, __gnu_cxx::__bfloat16_t __y, __gnu_cxx::__bfloat16_t __z) noexcept
  { return std::__lerp<__gnu_cxx::__bfloat16_t>(__x, __y, __z); }




}


# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 1 3
# 37 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 1 3
# 47 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 3
       
# 48 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 3
# 38 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 2 3






# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/limits" 1 3
# 40 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/limits" 3
       
# 41 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/limits" 3
# 158 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/limits" 3
namespace std
{







  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 202 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/limits" 3
  struct __numeric_limits_base
  {


    static constexpr bool is_specialized = false;




    static constexpr int digits = 0;


    static constexpr int digits10 = 0;




    static constexpr int max_digits10 = 0;



    static constexpr bool is_signed = false;


    static constexpr bool is_integer = false;




    static constexpr bool is_exact = false;



    static constexpr int radix = 0;



    static constexpr int min_exponent = 0;



    static constexpr int min_exponent10 = 0;




    static constexpr int max_exponent = 0;



    static constexpr int max_exponent10 = 0;


    static constexpr bool has_infinity = false;



    static constexpr bool has_quiet_NaN = false;



    static constexpr bool has_signaling_NaN = false;


    static constexpr float_denorm_style has_denorm = denorm_absent;



    static constexpr bool has_denorm_loss = false;



    static constexpr bool is_iec559 = false;




    static constexpr bool is_bounded = false;
# 288 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/limits" 3
    static constexpr bool is_modulo = false;


    static constexpr bool traps = false;


    static constexpr bool tinyness_before = false;




    static constexpr float_round_style round_style =
          round_toward_zero;
  };
# 311 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static constexpr _Tp
      min() noexcept { return _Tp(); }


      static constexpr _Tp
      max() noexcept { return _Tp(); }




      static constexpr _Tp
      lowest() noexcept { return _Tp(); }




      static constexpr _Tp
      epsilon() noexcept { return _Tp(); }


      static constexpr _Tp
      round_error() noexcept { return _Tp(); }


      static constexpr _Tp
      infinity() noexcept { return _Tp(); }



      static constexpr _Tp
      quiet_NaN() noexcept { return _Tp(); }



      static constexpr _Tp
      signaling_NaN() noexcept { return _Tp(); }




      static constexpr _Tp
      denorm_min() noexcept { return _Tp(); }
    };




  template<typename _Tp>
    struct numeric_limits<const _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<volatile _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<const volatile _Tp>
    : public numeric_limits<_Tp> { };
# 383 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/limits" 3
  template<>
    struct numeric_limits<bool>
    {
      static constexpr bool is_specialized = true;

      static constexpr bool
      min() noexcept { return false; }

      static constexpr bool
      max() noexcept { return true; }


      static constexpr bool
      lowest() noexcept { return min(); }

      static constexpr int digits = 1;
      static constexpr int digits10 = 0;

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr bool
      epsilon() noexcept { return false; }

      static constexpr bool
      round_error() noexcept { return false; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr bool
      infinity() noexcept { return false; }

      static constexpr bool
      quiet_NaN() noexcept { return false; }

      static constexpr bool
      signaling_NaN() noexcept { return false; }

      static constexpr bool
      denorm_min() noexcept { return false; }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;




      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static constexpr bool is_specialized = true;

      static constexpr char
      min() noexcept { return (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0) - 1 : (char)0); }

      static constexpr char
      max() noexcept { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }


      static constexpr char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((char)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char
      epsilon() noexcept { return 0; }

      static constexpr char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr
      char infinity() noexcept { return char(); }

      static constexpr char
      quiet_NaN() noexcept { return char(); }

      static constexpr char
      signaling_NaN() noexcept { return char(); }

      static constexpr char
      denorm_min() noexcept { return static_cast<char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static constexpr bool is_specialized = true;

      static constexpr signed char
      min() noexcept { return -0x7f - 1; }

      static constexpr signed char
      max() noexcept { return 0x7f; }


      static constexpr signed char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr signed char
      epsilon() noexcept { return 0; }

      static constexpr signed char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr signed char
      infinity() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      quiet_NaN() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      signaling_NaN() noexcept
      { return static_cast<signed char>(0); }

      static constexpr signed char
      denorm_min() noexcept
      { return static_cast<signed char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned char
      min() noexcept { return 0; }

      static constexpr unsigned char
      max() noexcept { return 0x7f * 2U + 1; }


      static constexpr unsigned char
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned char
      epsilon() noexcept { return 0; }

      static constexpr unsigned char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned char
      infinity() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      quiet_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      signaling_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      denorm_min() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr wchar_t
      min() noexcept { return (((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0) - 1 : (wchar_t)0); }

      static constexpr wchar_t
      max() noexcept { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }


      static constexpr wchar_t
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((wchar_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr wchar_t
      epsilon() noexcept { return 0; }

      static constexpr wchar_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr wchar_t
      infinity() noexcept { return wchar_t(); }

      static constexpr wchar_t
      quiet_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      signaling_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      denorm_min() noexcept { return wchar_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };



  template<>
    struct numeric_limits<char8_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char8_t
      min() noexcept { return (((char8_t)(-1) < 0) ? -(((char8_t)(-1) < 0) ? (((((char8_t)1 << ((sizeof(char8_t) * 8 - ((char8_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char8_t)0) - 1 : (char8_t)0); }

      static constexpr char8_t
      max() noexcept { return (((char8_t)(-1) < 0) ? (((((char8_t)1 << ((sizeof(char8_t) * 8 - ((char8_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char8_t)0); }

      static constexpr char8_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char8_t) * 8 - ((char8_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char8_t) * 8 - ((char8_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char8_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char8_t
      epsilon() noexcept { return 0; }

      static constexpr char8_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
 = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char8_t
      infinity() noexcept { return char8_t(); }

      static constexpr char8_t
      quiet_NaN() noexcept { return char8_t(); }

      static constexpr char8_t
      signaling_NaN() noexcept { return char8_t(); }

      static constexpr char8_t
      denorm_min() noexcept { return char8_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
 = round_toward_zero;
    };




  template<>
    struct numeric_limits<char16_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char16_t
      min() noexcept { return (((char16_t)(-1) < 0) ? -(((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0) - 1 : (char16_t)0); }

      static constexpr char16_t
      max() noexcept { return (((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0); }

      static constexpr char16_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char16_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char16_t
      epsilon() noexcept { return 0; }

      static constexpr char16_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char16_t
      infinity() noexcept { return char16_t(); }

      static constexpr char16_t
      quiet_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      signaling_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      denorm_min() noexcept { return char16_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char32_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char32_t
      min() noexcept { return (((char32_t)(-1) < 0) ? -(((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0) - 1 : (char32_t)0); }

      static constexpr char32_t
      max() noexcept { return (((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0); }

      static constexpr char32_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char32_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char32_t
      epsilon() noexcept { return 0; }

      static constexpr char32_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char32_t
      infinity() noexcept { return char32_t(); }

      static constexpr char32_t
      quiet_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      signaling_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      denorm_min() noexcept { return char32_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };



  template<>
    struct numeric_limits<short>
    {
      static constexpr bool is_specialized = true;

      static constexpr short
      min() noexcept { return -0x7fff - 1; }

      static constexpr short
      max() noexcept { return 0x7fff; }


      static constexpr short
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static constexpr int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr short
      epsilon() noexcept { return 0; }

      static constexpr short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr short
      infinity() noexcept { return short(); }

      static constexpr short
      quiet_NaN() noexcept { return short(); }

      static constexpr short
      signaling_NaN() noexcept { return short(); }

      static constexpr short
      denorm_min() noexcept { return short(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned short
      min() noexcept { return 0; }

      static constexpr unsigned short
      max() noexcept { return 0x7fff * 2U + 1; }


      static constexpr unsigned short
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned short
      epsilon() noexcept { return 0; }

      static constexpr unsigned short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned short
      infinity() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      quiet_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      signaling_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      denorm_min() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static constexpr bool is_specialized = true;

      static constexpr int
      min() noexcept { return -0x7fffffff - 1; }

      static constexpr int
      max() noexcept { return 0x7fffffff; }


      static constexpr int
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static constexpr int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr int
      epsilon() noexcept { return 0; }

      static constexpr int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr int
      infinity() noexcept { return static_cast<int>(0); }

      static constexpr int
      quiet_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      signaling_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      denorm_min() noexcept { return static_cast<int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned int
      min() noexcept { return 0; }

      static constexpr unsigned int
      max() noexcept { return 0x7fffffff * 2U + 1; }


      static constexpr unsigned int
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned int
      epsilon() noexcept { return 0; }

      static constexpr unsigned int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned int
      infinity() noexcept { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      quiet_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      signaling_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      denorm_min() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long
      min() noexcept { return -0x7fffffffL - 1; }

      static constexpr long
      max() noexcept { return 0x7fffffffL; }


      static constexpr long
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static constexpr int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long
      epsilon() noexcept { return 0; }

      static constexpr long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long
      infinity() noexcept { return static_cast<long>(0); }

      static constexpr long
      quiet_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      signaling_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      denorm_min() noexcept { return static_cast<long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long
      min() noexcept { return 0; }

      static constexpr unsigned long
      max() noexcept { return 0x7fffffffL * 2UL + 1; }


      static constexpr unsigned long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long
      infinity() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      quiet_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      signaling_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      denorm_min() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long long
      min() noexcept { return -0x7fffffffffffffffLL - 1; }

      static constexpr long long
      max() noexcept { return 0x7fffffffffffffffLL; }


      static constexpr long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long long
      epsilon() noexcept { return 0; }

      static constexpr long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long long
      infinity() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      quiet_NaN() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      signaling_NaN() noexcept
      { return static_cast<long long>(0); }

      static constexpr long long
      denorm_min() noexcept { return static_cast<long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long long
      min() noexcept { return 0; }

      static constexpr unsigned long long
      max() noexcept { return 0x7fffffffffffffffLL * 2ULL + 1; }


      static constexpr unsigned long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long long
      infinity() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      quiet_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      signaling_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      denorm_min() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };
# 1637 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/limits" 3
  __extension__ template<> struct numeric_limits<__int128> { static constexpr bool is_specialized = true; static constexpr __int128 min() noexcept { return (((__int128)(-1) < 0) ? -(((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0) - 1 : (__int128)0); } static constexpr __int128 max() noexcept { return (((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0); } static constexpr int digits = 128 - 1; static constexpr int digits10 = (128 - 1) * 643L / 2136; static constexpr bool is_signed = true; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr __int128 epsilon() noexcept { return 0; } static constexpr __int128 round_error() noexcept { return 0; } static constexpr __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr __int128 infinity() noexcept { return static_cast<__int128>(0); } static constexpr __int128 quiet_NaN() noexcept { return static_cast<__int128>(0); } static constexpr __int128 signaling_NaN() noexcept { return static_cast<__int128>(0); } static constexpr __int128 denorm_min() noexcept { return static_cast<__int128>(0); } static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = false; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; }; __extension__ template<> struct numeric_limits<unsigned __int128> { static constexpr bool is_specialized = true; static constexpr unsigned __int128 min() noexcept { return 0; } static constexpr unsigned __int128 max() noexcept { return (((unsigned __int128)(-1) < 0) ? (((((unsigned __int128)1 << ((128 - ((unsigned __int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(unsigned __int128)0); } static constexpr unsigned __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int digits = 128; static constexpr int digits10 = 128 * 643L / 2136; static constexpr bool is_signed = false; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr unsigned __int128 epsilon() noexcept { return 0; } static constexpr unsigned __int128 round_error() noexcept { return 0; } static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr unsigned __int128 infinity() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 quiet_NaN() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 signaling_NaN() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 denorm_min() noexcept { return static_cast<unsigned __int128>(0); } static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = true; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; };
# 1669 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/limits" 3
  template<>
    struct numeric_limits<float>
    {
      static constexpr bool is_specialized = true;

      static constexpr float
      min() noexcept { return 1.17549435082228750796873653722224568e-38F; }

      static constexpr float
      max() noexcept { return 3.40282346638528859811704183484516925e+38F; }


      static constexpr float
      lowest() noexcept { return -3.40282346638528859811704183484516925e+38F; }


      static constexpr int digits = 24;
      static constexpr int digits10 = 6;

      static constexpr int max_digits10
  = (2 + (24) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr float
      epsilon() noexcept { return 1.19209289550781250000000000000000000e-7F; }

      static constexpr float
      round_error() noexcept { return 0.5F; }

      static constexpr int min_exponent = (-125);
      static constexpr int min_exponent10 = (-37);
      static constexpr int max_exponent = 128;
      static constexpr int max_exponent10 = 38;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
       = false;

      static constexpr float
      infinity() noexcept { return __builtin_huge_valf(); }

      static constexpr float
      quiet_NaN() noexcept { return __builtin_nanf(""); }

      static constexpr float
      signaling_NaN() noexcept { return __builtin_nansf(""); }

      static constexpr float
      denorm_min() noexcept { return 1.40129846432481707092372958328991613e-45F; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static constexpr bool is_specialized = true;

      static constexpr double
      min() noexcept { return double(2.22507385850720138309023271733240406e-308L); }

      static constexpr double
      max() noexcept { return double(1.79769313486231570814527423731704357e+308L); }


      static constexpr double
      lowest() noexcept { return -double(1.79769313486231570814527423731704357e+308L); }


      static constexpr int digits = 53;
      static constexpr int digits10 = 15;

      static constexpr int max_digits10
  = (2 + (53) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr double
      epsilon() noexcept { return double(2.22044604925031308084726333618164062e-16L); }

      static constexpr double
      round_error() noexcept { return 0.5; }

      static constexpr int min_exponent = (-1021);
      static constexpr int min_exponent10 = (-307);
      static constexpr int max_exponent = 1024;
      static constexpr int max_exponent10 = 308;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
        = false;

      static constexpr double
      infinity() noexcept { return __builtin_huge_val(); }

      static constexpr double
      quiet_NaN() noexcept { return __builtin_nan(""); }

      static constexpr double
      signaling_NaN() noexcept { return __builtin_nans(""); }

      static constexpr double
      denorm_min() noexcept { return double(4.94065645841246544176568792868221372e-324L); }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static constexpr bool is_specialized = true;

      static constexpr long double
      min() noexcept { return 3.36210314311209350626267781732175260e-4932L; }

      static constexpr long double
      max() noexcept { return 1.18973149535723176502126385303097021e+4932L; }


      static constexpr long double
      lowest() noexcept { return -1.18973149535723176502126385303097021e+4932L; }


      static constexpr int digits = 64;
      static constexpr int digits10 = 18;

      static constexpr int max_digits10
  = (2 + (64) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr long double
      epsilon() noexcept { return 1.08420217248550443400745280086994171e-19L; }

      static constexpr long double
      round_error() noexcept { return 0.5L; }

      static constexpr int min_exponent = (-16381);
      static constexpr int min_exponent10 = (-4931);
      static constexpr int max_exponent = 16384;
      static constexpr int max_exponent10 = 4932;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
 = false;

      static constexpr long double
      infinity() noexcept { return __builtin_huge_vall(); }

      static constexpr long double
      quiet_NaN() noexcept { return __builtin_nanl(""); }

      static constexpr long double
      signaling_NaN() noexcept { return __builtin_nansl(""); }

      static constexpr long double
      denorm_min() noexcept { return 3.64519953188247460252840593361941982e-4951L; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before =
      false;
      static constexpr float_round_style round_style =
            round_to_nearest;
    };
# 1986 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/limits" 3
__extension__ template<> struct numeric_limits<_Float16> { static constexpr bool is_specialized = true; static constexpr _Float16 min() noexcept { return 6.10351562500000000000000000000000000e-5F16; } static constexpr _Float16 max() noexcept { return 6.55040000000000000000000000000000000e+4F16; } static constexpr _Float16 lowest() noexcept { return -6.55040000000000000000000000000000000e+4F16; } static constexpr int digits = 11; static constexpr int digits10 = 3; static constexpr int max_digits10 = (2 + (11) * 643L / 2136); static constexpr bool is_signed = true; static constexpr bool is_integer = false; static constexpr bool is_exact = false; static constexpr int radix = 2; static constexpr _Float16 epsilon() noexcept { return 9.76562500000000000000000000000000000e-4F16; } static constexpr _Float16 round_error() noexcept { return 0.5F16; } static constexpr int min_exponent = (-13); static constexpr int min_exponent10 = (-4); static constexpr int max_exponent = 16; static constexpr int max_exponent10 = 4; static constexpr bool has_infinity = 1; static constexpr bool has_quiet_NaN = 1; static constexpr bool has_signaling_NaN = has_quiet_NaN; static constexpr float_denorm_style has_denorm = bool(1) ? denorm_present : denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr _Float16 infinity() noexcept { return __builtin_huge_valf16(); } static constexpr _Float16 quiet_NaN() noexcept { return __builtin_nanf16(""); } static constexpr _Float16 signaling_NaN() noexcept { return __builtin_nansf16(""); } static constexpr _Float16 denorm_min() noexcept { return 5.96046447753906250000000000000000000e-8F16; } static constexpr bool is_iec559 = has_infinity && has_quiet_NaN && has_denorm == denorm_present; static constexpr bool is_bounded = true; static constexpr bool is_modulo = false; static constexpr bool traps = false; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_to_nearest; };


__extension__ template<> struct numeric_limits<_Float32> { static constexpr bool is_specialized = true; static constexpr _Float32 min() noexcept { return 1.17549435082228750796873653722224568e-38F32; } static constexpr _Float32 max() noexcept { return 3.40282346638528859811704183484516925e+38F32; } static constexpr _Float32 lowest() noexcept { return -3.40282346638528859811704183484516925e+38F32; } static constexpr int digits = 24; static constexpr int digits10 = 6; static constexpr int max_digits10 = (2 + (24) * 643L / 2136); static constexpr bool is_signed = true; static constexpr bool is_integer = false; static constexpr bool is_exact = false; static constexpr int radix = 2; static constexpr _Float32 epsilon() noexcept { return 1.19209289550781250000000000000000000e-7F32; } static constexpr _Float32 round_error() noexcept { return 0.5F32; } static constexpr int min_exponent = (-125); static constexpr int min_exponent10 = (-37); static constexpr int max_exponent = 128; static constexpr int max_exponent10 = 38; static constexpr bool has_infinity = 1; static constexpr bool has_quiet_NaN = 1; static constexpr bool has_signaling_NaN = has_quiet_NaN; static constexpr float_denorm_style has_denorm = bool(1) ? denorm_present : denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr _Float32 infinity() noexcept { return __builtin_huge_valf32(); } static constexpr _Float32 quiet_NaN() noexcept { return __builtin_nanf32(""); } static constexpr _Float32 signaling_NaN() noexcept { return __builtin_nansf32(""); } static constexpr _Float32 denorm_min() noexcept { return 1.40129846432481707092372958328991613e-45F32; } static constexpr bool is_iec559 = has_infinity && has_quiet_NaN && has_denorm == denorm_present; static constexpr bool is_bounded = true; static constexpr bool is_modulo = false; static constexpr bool traps = false; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_to_nearest; };


__extension__ template<> struct numeric_limits<_Float64> { static constexpr bool is_specialized = true; static constexpr _Float64 min() noexcept { return 2.22507385850720138309023271733240406e-308F64; } static constexpr _Float64 max() noexcept { return 1.79769313486231570814527423731704357e+308F64; } static constexpr _Float64 lowest() noexcept { return -1.79769313486231570814527423731704357e+308F64; } static constexpr int digits = 53; static constexpr int digits10 = 15; static constexpr int max_digits10 = (2 + (53) * 643L / 2136); static constexpr bool is_signed = true; static constexpr bool is_integer = false; static constexpr bool is_exact = false; static constexpr int radix = 2; static constexpr _Float64 epsilon() noexcept { return 2.22044604925031308084726333618164062e-16F64; } static constexpr _Float64 round_error() noexcept { return 0.5F64; } static constexpr int min_exponent = (-1021); static constexpr int min_exponent10 = (-307); static constexpr int max_exponent = 1024; static constexpr int max_exponent10 = 308; static constexpr bool has_infinity = 1; static constexpr bool has_quiet_NaN = 1; static constexpr bool has_signaling_NaN = has_quiet_NaN; static constexpr float_denorm_style has_denorm = bool(1) ? denorm_present : denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr _Float64 infinity() noexcept { return __builtin_huge_valf64(); } static constexpr _Float64 quiet_NaN() noexcept { return __builtin_nanf64(""); } static constexpr _Float64 signaling_NaN() noexcept { return __builtin_nansf64(""); } static constexpr _Float64 denorm_min() noexcept { return 4.94065645841246544176568792868221372e-324F64; } static constexpr bool is_iec559 = has_infinity && has_quiet_NaN && has_denorm == denorm_present; static constexpr bool is_bounded = true; static constexpr bool is_modulo = false; static constexpr bool traps = false; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_to_nearest; };


__extension__ template<> struct numeric_limits<_Float128> { static constexpr bool is_specialized = true; static constexpr _Float128 min() noexcept { return 3.36210314311209350626267781732175260e-4932F128; } static constexpr _Float128 max() noexcept { return 1.18973149535723176508575932662800702e+4932F128; } static constexpr _Float128 lowest() noexcept { return -1.18973149535723176508575932662800702e+4932F128; } static constexpr int digits = 113; static constexpr int digits10 = 33; static constexpr int max_digits10 = (2 + (113) * 643L / 2136); static constexpr bool is_signed = true; static constexpr bool is_integer = false; static constexpr bool is_exact = false; static constexpr int radix = 2; static constexpr _Float128 epsilon() noexcept { return 1.92592994438723585305597794258492732e-34F128; } static constexpr _Float128 round_error() noexcept { return 0.5F128; } static constexpr int min_exponent = (-16381); static constexpr int min_exponent10 = (-4931); static constexpr int max_exponent = 16384; static constexpr int max_exponent10 = 4932; static constexpr bool has_infinity = 1; static constexpr bool has_quiet_NaN = 1; static constexpr bool has_signaling_NaN = has_quiet_NaN; static constexpr float_denorm_style has_denorm = bool(1) ? denorm_present : denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr _Float128 infinity() noexcept { return __builtin_huge_valf128(); } static constexpr _Float128 quiet_NaN() noexcept { return __builtin_nanf128(""); } static constexpr _Float128 signaling_NaN() noexcept { return __builtin_nansf128(""); } static constexpr _Float128 denorm_min() noexcept { return 6.47517511943802511092443895822764655e-4966F128; } static constexpr bool is_iec559 = has_infinity && has_quiet_NaN && has_denorm == denorm_present; static constexpr bool is_bounded = true; static constexpr bool is_modulo = false; static constexpr bool traps = false; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_to_nearest; };
# 2006 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/limits" 3
  __extension__
  template<>
    struct numeric_limits<__gnu_cxx::__bfloat16_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr __gnu_cxx::__bfloat16_t
      min() noexcept
      { return 1.17549435082228750796873653722224568e-38BF16; }

      static constexpr __gnu_cxx::__bfloat16_t
      max() noexcept
      { return 3.38953138925153547590470800371487867e+38BF16; }

      static constexpr __gnu_cxx::__bfloat16_t
      lowest() noexcept
      { return -3.38953138925153547590470800371487867e+38BF16; }

      static constexpr int digits = 8;
      static constexpr int digits10 = 2;

      static constexpr int max_digits10
 = (2 + (8) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr __gnu_cxx::__bfloat16_t
      epsilon() noexcept
      { return 7.81250000000000000000000000000000000e-3BF16; }

      static constexpr __gnu_cxx::__bfloat16_t
      round_error() noexcept { return 0.5BF16; }

      static constexpr int min_exponent = (-125);
      static constexpr int min_exponent10 = (-37);
      static constexpr int max_exponent = 128;
      static constexpr int max_exponent10 = 38;

      static constexpr bool has_infinity
 = 1;
      static constexpr bool has_quiet_NaN
 = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr __gnu_cxx::__bfloat16_t
      infinity() noexcept
      { return __gnu_cxx::__bfloat16_t(__builtin_huge_valf()); }

      static constexpr __gnu_cxx::__bfloat16_t
      quiet_NaN() noexcept
      { return __gnu_cxx::__bfloat16_t(__builtin_nanf("")); }

      static constexpr __gnu_cxx::__bfloat16_t
      signaling_NaN() noexcept
      { return __builtin_nansf16b(""); }

      static constexpr __gnu_cxx::__bfloat16_t
      denorm_min() noexcept
      { return 9.18354961579912115600575419704879436e-41BF16; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
 = round_to_nearest;
    };





  __extension__
  template<>
    struct numeric_limits<__float128>
    {
      static constexpr bool is_specialized = true;

      static constexpr __float128
      min() noexcept
      {




 return __extension__ 0x1.0p-16382Q;

      }

      static constexpr __float128
      max() noexcept
      {







 return __extension__ 0x1.ffffffffffffffffffffffffffffp+16383Q;

      }

      static constexpr __float128
      lowest() noexcept
      { return -max(); }

      static constexpr int digits = 113;
      static constexpr int digits10 = 33;

      static constexpr int max_digits10 = 35;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr __float128
      epsilon() noexcept
      { return double(1.9259299443872359e-34); }

      static constexpr __float128
      round_error() noexcept { return 0.5; }

      static constexpr int min_exponent = -16381;
      static constexpr int min_exponent10 = -4931;
      static constexpr int max_exponent = 16384;
      static constexpr int max_exponent10 = 4932;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;


      static constexpr bool has_signaling_NaN = true;



      static constexpr float_denorm_style has_denorm
 = denorm_present;
      static constexpr bool has_denorm_loss = false;

      static constexpr __float128
      infinity() noexcept
      { return __builtin_huge_val(); }

      static constexpr __float128
      quiet_NaN() noexcept
      { return __builtin_nan(""); }

      static constexpr __float128
      signaling_NaN() noexcept
      {

 return __builtin_nansq("");





      }

      static constexpr __float128
      denorm_min() noexcept
      {




 return __extension__ 0x1.0p-16494Q;

      }

      static constexpr bool is_iec559 = has_signaling_NaN;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
 = round_to_nearest;
# 2218 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/limits" 3
    };




}
# 45 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 2 3


# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/gamma.tcc" 1 3
# 49 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/gamma.tcc" 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/special_function_util.h" 1 3
# 39 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/special_function_util.h" 3
namespace std
{

# 50 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/special_function_util.h" 3
  namespace __detail
  {



    template<typename _Tp>
    struct __floating_point_constant
    {
      static const _Tp __value;
    };



    template<typename _Tp>
      struct __numeric_constants
      {

        static _Tp __pi() throw()
        { return static_cast<_Tp>(3.1415926535897932384626433832795029L); }

        static _Tp __pi_2() throw()
        { return static_cast<_Tp>(1.5707963267948966192313216916397514L); }

        static _Tp __pi_3() throw()
        { return static_cast<_Tp>(1.0471975511965977461542144610931676L); }

        static _Tp __pi_4() throw()
        { return static_cast<_Tp>(0.7853981633974483096156608458198757L); }

        static _Tp __1_pi() throw()
        { return static_cast<_Tp>(0.3183098861837906715377675267450287L); }

        static _Tp __2_sqrtpi() throw()
        { return static_cast<_Tp>(1.1283791670955125738961589031215452L); }

        static _Tp __sqrt2() throw()
        { return static_cast<_Tp>(1.4142135623730950488016887242096981L); }

        static _Tp __sqrt3() throw()
        { return static_cast<_Tp>(1.7320508075688772935274463415058723L); }

        static _Tp __sqrtpio2() throw()
        { return static_cast<_Tp>(1.2533141373155002512078826424055226L); }

        static _Tp __sqrt1_2() throw()
        { return static_cast<_Tp>(0.7071067811865475244008443621048490L); }

        static _Tp __lnpi() throw()
        { return static_cast<_Tp>(1.1447298858494001741434273513530587L); }

        static _Tp __gamma_e() throw()
        { return static_cast<_Tp>(0.5772156649015328606065120900824024L); }

        static _Tp __euler() throw()
        { return static_cast<_Tp>(2.7182818284590452353602874713526625L); }
      };
# 114 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/special_function_util.h" 3
    template<typename _Tp>
    inline bool __isnan(_Tp __x)
    { return std::isnan(__x); }
# 133 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/special_function_util.h" 3
  }





}
# 50 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/gamma.tcc" 2 3

namespace std
{

# 65 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/gamma.tcc" 3
  namespace __detail
  {
# 76 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/gamma.tcc" 3
    template <typename _Tp>
    _Tp
    __bernoulli_series(unsigned int __n)
    {

      static const _Tp __num[28] = {
        _Tp(1UL), -_Tp(1UL) / _Tp(2UL),
        _Tp(1UL) / _Tp(6UL), _Tp(0UL),
        -_Tp(1UL) / _Tp(30UL), _Tp(0UL),
        _Tp(1UL) / _Tp(42UL), _Tp(0UL),
        -_Tp(1UL) / _Tp(30UL), _Tp(0UL),
        _Tp(5UL) / _Tp(66UL), _Tp(0UL),
        -_Tp(691UL) / _Tp(2730UL), _Tp(0UL),
        _Tp(7UL) / _Tp(6UL), _Tp(0UL),
        -_Tp(3617UL) / _Tp(510UL), _Tp(0UL),
        _Tp(43867UL) / _Tp(798UL), _Tp(0UL),
        -_Tp(174611) / _Tp(330UL), _Tp(0UL),
        _Tp(854513UL) / _Tp(138UL), _Tp(0UL),
        -_Tp(236364091UL) / _Tp(2730UL), _Tp(0UL),
        _Tp(8553103UL) / _Tp(6UL), _Tp(0UL)
      };

      if (__n == 0)
        return _Tp(1);

      if (__n == 1)
        return -_Tp(1) / _Tp(2);


      if (__n % 2 == 1)
        return _Tp(0);


      if (__n < 28)
        return __num[__n];


      _Tp __fact = _Tp(1);
      if ((__n / 2) % 2 == 0)
        __fact *= _Tp(-1);
      for (unsigned int __k = 1; __k <= __n; ++__k)
        __fact *= __k / (_Tp(2) * __numeric_constants<_Tp>::__pi());
      __fact *= _Tp(2);

      _Tp __sum = _Tp(0);
      for (unsigned int __i = 1; __i < 1000; ++__i)
        {
          _Tp __term = std::pow(_Tp(__i), -_Tp(__n));
          if (__term < std::numeric_limits<_Tp>::epsilon())
            break;
          __sum += __term;
        }

      return __fact * __sum;
    }
# 139 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    inline _Tp
    __bernoulli(int __n)
    { return __bernoulli_series<_Tp>(__n); }
# 153 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __log_gamma_bernoulli(_Tp __x)
    {
      _Tp __lg = (__x - _Tp(0.5L)) * std::log(__x) - __x
               + _Tp(0.5L) * std::log(_Tp(2)
               * __numeric_constants<_Tp>::__pi());

      const _Tp __xx = __x * __x;
      _Tp __help = _Tp(1) / __x;
      for ( unsigned int __i = 1; __i < 20; ++__i )
        {
          const _Tp __2i = _Tp(2 * __i);
          __help /= __2i * (__2i - _Tp(1)) * __xx;
          __lg += __bernoulli<_Tp>(2 * __i) * __help;
        }

      return __lg;
    }
# 181 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __log_gamma_lanczos(_Tp __x)
    {
      const _Tp __xm1 = __x - _Tp(1);

      static const _Tp __lanczos_cheb_7[9] = {
       _Tp( 0.99999999999980993227684700473478L),
       _Tp( 676.520368121885098567009190444019L),
       _Tp(-1259.13921672240287047156078755283L),
       _Tp( 771.3234287776530788486528258894L),
       _Tp(-176.61502916214059906584551354L),
       _Tp( 12.507343278686904814458936853L),
       _Tp(-0.13857109526572011689554707L),
       _Tp( 9.984369578019570859563e-6L),
       _Tp( 1.50563273514931155834e-7L)
      };

      static const _Tp __LOGROOT2PI
          = _Tp(0.9189385332046727417803297364056176L);

      _Tp __sum = __lanczos_cheb_7[0];
      for(unsigned int __k = 1; __k < 9; ++__k)
        __sum += __lanczos_cheb_7[__k] / (__xm1 + __k);

      const _Tp __term1 = (__xm1 + _Tp(0.5L))
                        * std::log((__xm1 + _Tp(7.5L))
                       / __numeric_constants<_Tp>::__euler());
      const _Tp __term2 = __LOGROOT2PI + std::log(__sum);
      const _Tp __result = __term1 + (__term2 - _Tp(7));

      return __result;
    }
# 225 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __log_gamma(_Tp __x)
    {
      if (__x > _Tp(0.5L))
        return __log_gamma_lanczos(__x);
      else
        {
          const _Tp __sin_fact
                 = std::abs(std::sin(__numeric_constants<_Tp>::__pi() * __x));
          if (__sin_fact == _Tp(0))
            std::__throw_domain_error(("Argument is nonpositive integer " "in __log_gamma")
                                                           );
          return __numeric_constants<_Tp>::__lnpi()
                     - std::log(__sin_fact)
                     - __log_gamma_lanczos(_Tp(1) - __x);
        }
    }
# 252 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __log_gamma_sign(_Tp __x)
    {
      if (__x > _Tp(0))
        return _Tp(1);
      else
        {
          const _Tp __sin_fact
                  = std::sin(__numeric_constants<_Tp>::__pi() * __x);
          if (__sin_fact > _Tp(0))
            return (1);
          else if (__sin_fact < _Tp(0))
            return -_Tp(1);
          else
            return _Tp(0);
        }
    }
# 283 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __log_bincoef(unsigned int __n, unsigned int __k)
    {

      static const _Tp __max_bincoeff
                      = std::numeric_limits<_Tp>::max_exponent10
                      * std::log(_Tp(10)) - _Tp(1);

      _Tp __coeff = ::std::lgamma(_Tp(1 + __n))
                  - ::std::lgamma(_Tp(1 + __k))
                  - ::std::lgamma(_Tp(1 + __n - __k));





    }
# 314 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __bincoef(unsigned int __n, unsigned int __k)
    {

      static const _Tp __max_bincoeff
                      = std::numeric_limits<_Tp>::max_exponent10
                      * std::log(_Tp(10)) - _Tp(1);

      const _Tp __log_coeff = __log_bincoef<_Tp>(__n, __k);
      if (__log_coeff > __max_bincoeff)
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return std::exp(__log_coeff);
    }
# 337 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    inline _Tp
    __gamma(_Tp __x)
    { return std::exp(__log_gamma(__x)); }
# 356 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __psi_series(_Tp __x)
    {
      _Tp __sum = -__numeric_constants<_Tp>::__gamma_e() - _Tp(1) / __x;
      const unsigned int __max_iter = 100000;
      for (unsigned int __k = 1; __k < __max_iter; ++__k)
        {
          const _Tp __term = __x / (__k * (__k + __x));
          __sum += __term;
          if (std::abs(__term / __sum) < std::numeric_limits<_Tp>::epsilon())
            break;
        }
      return __sum;
    }
# 386 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __psi_asymp(_Tp __x)
    {
      _Tp __sum = std::log(__x) - _Tp(0.5L) / __x;
      const _Tp __xx = __x * __x;
      _Tp __xp = __xx;
      const unsigned int __max_iter = 100;
      for (unsigned int __k = 1; __k < __max_iter; ++__k)
        {
          const _Tp __term = __bernoulli<_Tp>(2 * __k) / (2 * __k * __xp);
          __sum -= __term;
          if (std::abs(__term / __sum) < std::numeric_limits<_Tp>::epsilon())
            break;
          __xp *= __xx;
        }
      return __sum;
    }
# 417 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __psi(_Tp __x)
    {
      const int __n = static_cast<int>(__x + 0.5L);
      const _Tp __eps = _Tp(4) * std::numeric_limits<_Tp>::epsilon();
      if (__n <= 0 && std::abs(__x - _Tp(__n)) < __eps)
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x < _Tp(0))
        {
          const _Tp __pi = __numeric_constants<_Tp>::__pi();
          return __psi(_Tp(1) - __x)
               - __pi * std::cos(__pi * __x) / std::sin(__pi * __x);
        }
      else if (__x > _Tp(100))
        return __psi_asymp(__x);
      else
        return __psi_series(__x);
    }
# 446 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __psi(unsigned int __n, _Tp __x)
    {
      if (__x <= _Tp(0))
        std::__throw_domain_error(("Argument out of range " "in __psi")
                                                 );
      else if (__n == 0)
        return __psi(__x);
      else
        {
          const _Tp __hzeta = __hurwitz_zeta(_Tp(__n + 1), __x);

          const _Tp __ln_nfact = ::std::lgamma(_Tp(__n + 1));



          _Tp __result = std::exp(__ln_nfact) * __hzeta;
          if (__n % 2 == 1)
            __result = -__result;
          return __result;
        }
    }
  }






}
# 48 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 2 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/bessel_function.tcc" 1 3
# 55 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/bessel_function.tcc" 3
namespace std
{

# 71 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/bessel_function.tcc" 3
  namespace __detail
  {
# 98 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    void
    __gamma_temme(_Tp __mu,
                  _Tp & __gam1, _Tp & __gam2, _Tp & __gampl, _Tp & __gammi)
    {

      __gampl = _Tp(1) / ::std::tgamma(_Tp(1) + __mu);
      __gammi = _Tp(1) / ::std::tgamma(_Tp(1) - __mu);





      if (std::abs(__mu) < std::numeric_limits<_Tp>::epsilon())
        __gam1 = -_Tp(__numeric_constants<_Tp>::__gamma_e());
      else
        __gam1 = (__gammi - __gampl) / (_Tp(2) * __mu);

      __gam2 = (__gammi + __gampl) / (_Tp(2));

      return;
    }
# 136 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    void
    __bessel_jn(_Tp __nu, _Tp __x,
                _Tp & __Jnu, _Tp & __Nnu, _Tp & __Jpnu, _Tp & __Npnu)
    {
      if (__x == _Tp(0))
        {
          if (__nu == _Tp(0))
            {
              __Jnu = _Tp(1);
              __Jpnu = _Tp(0);
            }
          else if (__nu == _Tp(1))
            {
              __Jnu = _Tp(0);
              __Jpnu = _Tp(0.5L);
            }
          else
            {
              __Jnu = _Tp(0);
              __Jpnu = _Tp(0);
            }
          __Nnu = -std::numeric_limits<_Tp>::infinity();
          __Npnu = std::numeric_limits<_Tp>::infinity();
          return;
        }

      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();




      const _Tp __fp_min = std::sqrt(std::numeric_limits<_Tp>::min());
      const int __max_iter = 15000;
      const _Tp __x_min = _Tp(2);

      const int __nl = (__x < __x_min
                    ? static_cast<int>(__nu + _Tp(0.5L))
                    : std::max(0, static_cast<int>(__nu - __x + _Tp(1.5L))));

      const _Tp __mu = __nu - __nl;
      const _Tp __mu2 = __mu * __mu;
      const _Tp __xi = _Tp(1) / __x;
      const _Tp __xi2 = _Tp(2) * __xi;
      _Tp __w = __xi2 / __numeric_constants<_Tp>::__pi();
      int __isign = 1;
      _Tp __h = __nu * __xi;
      if (__h < __fp_min)
        __h = __fp_min;
      _Tp __b = __xi2 * __nu;
      _Tp __d = _Tp(0);
      _Tp __c = __h;
      int __i;
      for (__i = 1; __i <= __max_iter; ++__i)
        {
          __b += __xi2;
          __d = __b - __d;
          if (std::abs(__d) < __fp_min)
            __d = __fp_min;
          __c = __b - _Tp(1) / __c;
          if (std::abs(__c) < __fp_min)
            __c = __fp_min;
          __d = _Tp(1) / __d;
          const _Tp __del = __c * __d;
          __h *= __del;
          if (__d < _Tp(0))
            __isign = -__isign;
          if (std::abs(__del - _Tp(1)) < __eps)
            break;
        }
      if (__i > __max_iter)
        std::__throw_runtime_error(("Argument x too large in __bessel_jn; " "try asymptotic expansion.")
                                                                   );
      _Tp __Jnul = __isign * __fp_min;
      _Tp __Jpnul = __h * __Jnul;
      _Tp __Jnul1 = __Jnul;
      _Tp __Jpnu1 = __Jpnul;
      _Tp __fact = __nu * __xi;
      for ( int __l = __nl; __l >= 1; --__l )
        {
          const _Tp __Jnutemp = __fact * __Jnul + __Jpnul;
          __fact -= __xi;
          __Jpnul = __fact * __Jnutemp - __Jnul;
          __Jnul = __Jnutemp;
        }
      if (__Jnul == _Tp(0))
        __Jnul = __eps;
      _Tp __f= __Jpnul / __Jnul;
      _Tp __Nmu, __Nnu1, __Npmu, __Jmu;
      if (__x < __x_min)
        {
          const _Tp __x2 = __x / _Tp(2);
          const _Tp __pimu = __numeric_constants<_Tp>::__pi() * __mu;
          _Tp __fact = (std::abs(__pimu) < __eps
                      ? _Tp(1) : __pimu / std::sin(__pimu));
          _Tp __d = -std::log(__x2);
          _Tp __e = __mu * __d;
          _Tp __fact2 = (std::abs(__e) < __eps
                       ? _Tp(1) : std::sinh(__e) / __e);
          _Tp __gam1, __gam2, __gampl, __gammi;
          __gamma_temme(__mu, __gam1, __gam2, __gampl, __gammi);
          _Tp __ff = (_Tp(2) / __numeric_constants<_Tp>::__pi())
                   * __fact * (__gam1 * std::cosh(__e) + __gam2 * __fact2 * __d);
          __e = std::exp(__e);
          _Tp __p = __e / (__numeric_constants<_Tp>::__pi() * __gampl);
          _Tp __q = _Tp(1) / (__e * __numeric_constants<_Tp>::__pi() * __gammi);
          const _Tp __pimu2 = __pimu / _Tp(2);
          _Tp __fact3 = (std::abs(__pimu2) < __eps
                       ? _Tp(1) : std::sin(__pimu2) / __pimu2 );
          _Tp __r = __numeric_constants<_Tp>::__pi() * __pimu2 * __fact3 * __fact3;
          _Tp __c = _Tp(1);
          __d = -__x2 * __x2;
          _Tp __sum = __ff + __r * __q;
          _Tp __sum1 = __p;
          for (__i = 1; __i <= __max_iter; ++__i)
            {
              __ff = (__i * __ff + __p + __q) / (__i * __i - __mu2);
              __c *= __d / _Tp(__i);
              __p /= _Tp(__i) - __mu;
              __q /= _Tp(__i) + __mu;
              const _Tp __del = __c * (__ff + __r * __q);
              __sum += __del;
              const _Tp __del1 = __c * __p - __i * __del;
              __sum1 += __del1;
              if ( std::abs(__del) < __eps * (_Tp(1) + std::abs(__sum)) )
                break;
            }
          if ( __i > __max_iter )
            std::__throw_runtime_error(("Bessel y series failed to converge " "in __bessel_jn.")
                                                             );
          __Nmu = -__sum;
          __Nnu1 = -__sum1 * __xi2;
          __Npmu = __mu * __xi * __Nmu - __Nnu1;
          __Jmu = __w / (__Npmu - __f * __Nmu);
        }
      else
        {
          _Tp __a = _Tp(0.25L) - __mu2;
          _Tp __q = _Tp(1);
          _Tp __p = -__xi / _Tp(2);
          _Tp __br = _Tp(2) * __x;
          _Tp __bi = _Tp(2);
          _Tp __fact = __a * __xi / (__p * __p + __q * __q);
          _Tp __cr = __br + __q * __fact;
          _Tp __ci = __bi + __p * __fact;
          _Tp __den = __br * __br + __bi * __bi;
          _Tp __dr = __br / __den;
          _Tp __di = -__bi / __den;
          _Tp __dlr = __cr * __dr - __ci * __di;
          _Tp __dli = __cr * __di + __ci * __dr;
          _Tp __temp = __p * __dlr - __q * __dli;
          __q = __p * __dli + __q * __dlr;
          __p = __temp;
          int __i;
          for (__i = 2; __i <= __max_iter; ++__i)
            {
              __a += _Tp(2 * (__i - 1));
              __bi += _Tp(2);
              __dr = __a * __dr + __br;
              __di = __a * __di + __bi;
              if (std::abs(__dr) + std::abs(__di) < __fp_min)
                __dr = __fp_min;
              __fact = __a / (__cr * __cr + __ci * __ci);
              __cr = __br + __cr * __fact;
              __ci = __bi - __ci * __fact;
              if (std::abs(__cr) + std::abs(__ci) < __fp_min)
                __cr = __fp_min;
              __den = __dr * __dr + __di * __di;
              __dr /= __den;
              __di /= -__den;
              __dlr = __cr * __dr - __ci * __di;
              __dli = __cr * __di + __ci * __dr;
              __temp = __p * __dlr - __q * __dli;
              __q = __p * __dli + __q * __dlr;
              __p = __temp;
              if (std::abs(__dlr - _Tp(1)) + std::abs(__dli) < __eps)
                break;
          }
          if (__i > __max_iter)
            std::__throw_runtime_error(("Lentz's method failed " "in __bessel_jn.")
                                                             );
          const _Tp __gam = (__p - __f) / __q;
          __Jmu = std::sqrt(__w / ((__p - __f) * __gam + __q));

          __Jmu = ::std::copysign(__Jmu, __Jnul);




          __Nmu = __gam * __Jmu;
          __Npmu = (__p + __q / __gam) * __Nmu;
          __Nnu1 = __mu * __xi * __Nmu - __Npmu;
      }
      __fact = __Jmu / __Jnul;
      __Jnu = __fact * __Jnul1;
      __Jpnu = __fact * __Jpnu1;
      for (__i = 1; __i <= __nl; ++__i)
        {
          const _Tp __Nnutemp = (__mu + __i) * __xi2 * __Nnu1 - __Nmu;
          __Nmu = __Nnu1;
          __Nnu1 = __Nnutemp;
        }
      __Nnu = __Nmu;
      __Npnu = __nu * __xi * __Nmu - __Nnu1;

      return;
    }
# 361 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    void
    __cyl_bessel_jn_asymp(_Tp __nu, _Tp __x, _Tp & __Jnu, _Tp & __Nnu)
    {
      const _Tp __mu = _Tp(4) * __nu * __nu;
      const _Tp __8x = _Tp(8) * __x;

      _Tp __P = _Tp(0);
      _Tp __Q = _Tp(0);

      _Tp __k = _Tp(0);
      _Tp __term = _Tp(1);

      int __epsP = 0;
      int __epsQ = 0;

      _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      do
        {
          __term *= (__k == 0
                     ? _Tp(1)
                     : -(__mu - (2 * __k - 1) * (2 * __k - 1)) / (__k * __8x));

          __epsP = std::abs(__term) < __eps * std::abs(__P);
          __P += __term;

          __k++;

          __term *= (__mu - (2 * __k - 1) * (2 * __k - 1)) / (__k * __8x);
          __epsQ = std::abs(__term) < __eps * std::abs(__Q);
          __Q += __term;

          if (__epsP && __epsQ && __k > (__nu / 2.))
            break;

          __k++;
        }
      while (__k < 1000);

      const _Tp __chi = __x - (__nu + _Tp(0.5L))
                             * __numeric_constants<_Tp>::__pi_2();

      const _Tp __c = std::cos(__chi);
      const _Tp __s = std::sin(__chi);

      const _Tp __coef = std::sqrt(_Tp(2)
                             / (__numeric_constants<_Tp>::__pi() * __x));

      __Jnu = __coef * (__c * __P - __s * __Q);
      __Nnu = __coef * (__s * __P + __c * __Q);

      return;
    }
# 444 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    _Tp
    __cyl_bessel_ij_series(_Tp __nu, _Tp __x, _Tp __sgn,
                           unsigned int __max_iter)
    {
      if (__x == _Tp(0))
 return __nu == _Tp(0) ? _Tp(1) : _Tp(0);

      const _Tp __x2 = __x / _Tp(2);
      _Tp __fact = __nu * std::log(__x2);

      __fact -= ::std::lgamma(__nu + _Tp(1));



      __fact = std::exp(__fact);
      const _Tp __xx4 = __sgn * __x2 * __x2;
      _Tp __Jn = _Tp(1);
      _Tp __term = _Tp(1);

      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          __term *= __xx4 / (_Tp(__i) * (__nu + _Tp(__i)));
          __Jn += __term;
          if (std::abs(__term / __Jn) < std::numeric_limits<_Tp>::epsilon())
            break;
        }

      return __fact * __Jn;
    }
# 490 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/bessel_function.tcc" 3
    template<typename _Tp>
    _Tp
    __cyl_bessel_j(_Tp __nu, _Tp __x)
    {
      if (__nu < _Tp(0) || __x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __cyl_bessel_j.")
                                                           );
      else if (__isnan(__nu) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x * __x < _Tp(10) * (__nu + _Tp(1)))
        return __cyl_bessel_ij_series(__nu, __x, -_Tp(1), 200);
      else if (__x > _Tp(1000))
        {
          _Tp __J_nu, __N_nu;
          __cyl_bessel_jn_asymp(__nu, __x, __J_nu, __N_nu);
          return __J_nu;
        }
      else
        {
          _Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
          __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
          return __J_nu;
        }
    }
# 532 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/bessel_function.tcc" 3
    template<typename _Tp>
    _Tp
    __cyl_neumann_n(_Tp __nu, _Tp __x)
    {
      if (__nu < _Tp(0) || __x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __cyl_neumann_n.")
                                                            );
      else if (__isnan(__nu) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x > _Tp(1000))
        {
          _Tp __J_nu, __N_nu;
          __cyl_bessel_jn_asymp(__nu, __x, __J_nu, __N_nu);
          return __N_nu;
        }
      else
        {
          _Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
          __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
          return __N_nu;
        }
    }
# 569 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    void
    __sph_bessel_jn(unsigned int __n, _Tp __x,
                    _Tp & __j_n, _Tp & __n_n, _Tp & __jp_n, _Tp & __np_n)
    {
      const _Tp __nu = _Tp(__n) + _Tp(0.5L);

      _Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
      __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);

      const _Tp __factor = __numeric_constants<_Tp>::__sqrtpio2()
                         / std::sqrt(__x);

      __j_n = __factor * __J_nu;
      __n_n = __factor * __N_nu;
      __jp_n = __factor * __Jp_nu - __j_n / (_Tp(2) * __x);
      __np_n = __factor * __Np_nu - __n_n / (_Tp(2) * __x);

      return;
    }
# 604 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    _Tp
    __sph_bessel(unsigned int __n, _Tp __x)
    {
      if (__x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __sph_bessel.")
                                                         );
      else if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x == _Tp(0))
        {
          if (__n == 0)
            return _Tp(1);
          else
            return _Tp(0);
        }
      else
        {
          _Tp __j_n, __n_n, __jp_n, __np_n;
          __sph_bessel_jn(__n, __x, __j_n, __n_n, __jp_n, __np_n);
          return __j_n;
        }
    }
# 642 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    _Tp
    __sph_neumann(unsigned int __n, _Tp __x)
    {
      if (__x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __sph_neumann.")
                                                          );
      else if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x == _Tp(0))
        return -std::numeric_limits<_Tp>::infinity();
      else
        {
          _Tp __j_n, __n_n, __jp_n, __np_n;
          __sph_bessel_jn(__n, __x, __j_n, __n_n, __jp_n, __np_n);
          return __n_n;
        }
    }
  }






}
# 49 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 2 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/beta_function.tcc" 1 3
# 49 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/beta_function.tcc" 3
namespace std
{

# 65 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/beta_function.tcc" 3
  namespace __detail
  {
# 79 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/beta_function.tcc" 3
    template<typename _Tp>
    _Tp
    __beta_gamma(_Tp __x, _Tp __y)
    {

      _Tp __bet;

      if (__x > __y)
        {
          __bet = ::std::tgamma(__x)
                / ::std::tgamma(__x + __y);
          __bet *= ::std::tgamma(__y);
        }
      else
        {
          __bet = ::std::tgamma(__y)
                / ::std::tgamma(__x + __y);
          __bet *= ::std::tgamma(__x);
        }
# 111 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/beta_function.tcc" 3
      return __bet;
    }
# 127 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/beta_function.tcc" 3
    template<typename _Tp>
    _Tp
    __beta_lgamma(_Tp __x, _Tp __y)
    {

      _Tp __bet = ::std::lgamma(__x)
                + ::std::lgamma(__y)
                - ::std::lgamma(__x + __y);





      __bet = std::exp(__bet);
      return __bet;
    }
# 158 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/beta_function.tcc" 3
    template<typename _Tp>
    _Tp
    __beta_product(_Tp __x, _Tp __y)
    {

      _Tp __bet = (__x + __y) / (__x * __y);

      unsigned int __max_iter = 1000000;
      for (unsigned int __k = 1; __k < __max_iter; ++__k)
        {
          _Tp __term = (_Tp(1) + (__x + __y) / __k)
                     / ((_Tp(1) + __x / __k) * (_Tp(1) + __y / __k));
          __bet *= __term;
        }

      return __bet;
    }
# 189 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/beta_function.tcc" 3
    template<typename _Tp>
    inline _Tp
    __beta(_Tp __x, _Tp __y)
    {
      if (__isnan(__x) || __isnan(__y))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return __beta_lgamma(__x, __y);
    }
  }






}
# 50 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 2 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/ell_integral.tcc" 1 3
# 45 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/ell_integral.tcc" 3
namespace std
{

# 59 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/ell_integral.tcc" 3
  namespace __detail
  {
# 76 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_rf(_Tp __x, _Tp __y, _Tp __z)
    {
      const _Tp __min = std::numeric_limits<_Tp>::min();
      const _Tp __lolim = _Tp(5) * __min;

      if (__x < _Tp(0) || __y < _Tp(0) || __z < _Tp(0))
        std::__throw_domain_error(("Argument less than zero " "in __ellint_rf.")
                                                        );
      else if (__x + __y < __lolim || __x + __z < __lolim
            || __y + __z < __lolim)
        std::__throw_domain_error(("Argument too small in __ellint_rf"));
      else
        {
          const _Tp __c0 = _Tp(1) / _Tp(4);
          const _Tp __c1 = _Tp(1) / _Tp(24);
          const _Tp __c2 = _Tp(1) / _Tp(10);
          const _Tp __c3 = _Tp(3) / _Tp(44);
          const _Tp __c4 = _Tp(1) / _Tp(14);

          _Tp __xn = __x;
          _Tp __yn = __y;
          _Tp __zn = __z;

          const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
          const _Tp __errtol = std::pow(__eps, _Tp(1) / _Tp(6));
          _Tp __mu;
          _Tp __xndev, __yndev, __zndev;

          const unsigned int __max_iter = 100;
          for (unsigned int __iter = 0; __iter < __max_iter; ++__iter)
            {
              __mu = (__xn + __yn + __zn) / _Tp(3);
              __xndev = 2 - (__mu + __xn) / __mu;
              __yndev = 2 - (__mu + __yn) / __mu;
              __zndev = 2 - (__mu + __zn) / __mu;
              _Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
              __epsilon = std::max(__epsilon, std::abs(__zndev));
              if (__epsilon < __errtol)
                break;
              const _Tp __xnroot = std::sqrt(__xn);
              const _Tp __ynroot = std::sqrt(__yn);
              const _Tp __znroot = std::sqrt(__zn);
              const _Tp __lambda = __xnroot * (__ynroot + __znroot)
                                 + __ynroot * __znroot;
              __xn = __c0 * (__xn + __lambda);
              __yn = __c0 * (__yn + __lambda);
              __zn = __c0 * (__zn + __lambda);
            }

          const _Tp __e2 = __xndev * __yndev - __zndev * __zndev;
          const _Tp __e3 = __xndev * __yndev * __zndev;
          const _Tp __s = _Tp(1) + (__c1 * __e2 - __c2 - __c3 * __e3) * __e2
                   + __c4 * __e3;

          return __s / std::sqrt(__mu);
        }
    }
# 153 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __comp_ellint_1_series(_Tp __k)
    {

      const _Tp __kk = __k * __k;

      _Tp __term = __kk / _Tp(4);
      _Tp __sum = _Tp(1) + __term;

      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 2; __i < __max_iter; ++__i)
        {
          __term *= (2 * __i - 1) * __kk / (2 * __i);
          if (__term < std::numeric_limits<_Tp>::epsilon())
            break;
          __sum += __term;
        }

      return __numeric_constants<_Tp>::__pi_2() * __sum;
    }
# 191 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __comp_ellint_1(_Tp __k)
    {

      if (__isnan(__k))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) >= _Tp(1))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return __ellint_rf(_Tp(0), _Tp(1) - __k * __k, _Tp(1));
    }
# 219 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_1(_Tp __k, _Tp __phi)
    {

      if (__isnan(__k) || __isnan(__phi))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __ellint_1."));
      else
        {

          const int __n = std::floor(__phi / __numeric_constants<_Tp>::__pi()
                                   + _Tp(0.5L));
          const _Tp __phi_red = __phi
                              - __n * __numeric_constants<_Tp>::__pi();

          const _Tp __s = std::sin(__phi_red);
          const _Tp __c = std::cos(__phi_red);

          const _Tp __F = __s
                        * __ellint_rf(__c * __c,
                                _Tp(1) - __k * __k * __s * __s, _Tp(1));

          if (__n == 0)
            return __F;
          else
            return __F + _Tp(2) * __n * __comp_ellint_1(__k);
        }
    }
# 266 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __comp_ellint_2_series(_Tp __k)
    {

      const _Tp __kk = __k * __k;

      _Tp __term = __kk;
      _Tp __sum = __term;

      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 2; __i < __max_iter; ++__i)
        {
          const _Tp __i2m = 2 * __i - 1;
          const _Tp __i2 = 2 * __i;
          __term *= __i2m * __i2m * __kk / (__i2 * __i2);
          if (__term < std::numeric_limits<_Tp>::epsilon())
            break;
          __sum += __term / __i2m;
        }

      return __numeric_constants<_Tp>::__pi_2() * (_Tp(1) - __sum);
    }
# 314 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_rd(_Tp __x, _Tp __y, _Tp __z)
    {
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __errtol = std::pow(__eps / _Tp(8), _Tp(1) / _Tp(6));
      const _Tp __max = std::numeric_limits<_Tp>::max();
      const _Tp __lolim = _Tp(2) / std::pow(__max, _Tp(2) / _Tp(3));

      if (__x < _Tp(0) || __y < _Tp(0))
        std::__throw_domain_error(("Argument less than zero " "in __ellint_rd.")
                                                        );
      else if (__x + __y < __lolim || __z < __lolim)
        std::__throw_domain_error(("Argument too small " "in __ellint_rd.")
                                                        );
      else
        {
          const _Tp __c0 = _Tp(1) / _Tp(4);
          const _Tp __c1 = _Tp(3) / _Tp(14);
          const _Tp __c2 = _Tp(1) / _Tp(6);
          const _Tp __c3 = _Tp(9) / _Tp(22);
          const _Tp __c4 = _Tp(3) / _Tp(26);

          _Tp __xn = __x;
          _Tp __yn = __y;
          _Tp __zn = __z;
          _Tp __sigma = _Tp(0);
          _Tp __power4 = _Tp(1);

          _Tp __mu;
          _Tp __xndev, __yndev, __zndev;

          const unsigned int __max_iter = 100;
          for (unsigned int __iter = 0; __iter < __max_iter; ++__iter)
            {
              __mu = (__xn + __yn + _Tp(3) * __zn) / _Tp(5);
              __xndev = (__mu - __xn) / __mu;
              __yndev = (__mu - __yn) / __mu;
              __zndev = (__mu - __zn) / __mu;
              _Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
              __epsilon = std::max(__epsilon, std::abs(__zndev));
              if (__epsilon < __errtol)
                break;
              _Tp __xnroot = std::sqrt(__xn);
              _Tp __ynroot = std::sqrt(__yn);
              _Tp __znroot = std::sqrt(__zn);
              _Tp __lambda = __xnroot * (__ynroot + __znroot)
                           + __ynroot * __znroot;
              __sigma += __power4 / (__znroot * (__zn + __lambda));
              __power4 *= __c0;
              __xn = __c0 * (__xn + __lambda);
              __yn = __c0 * (__yn + __lambda);
              __zn = __c0 * (__zn + __lambda);
            }

          _Tp __ea = __xndev * __yndev;
          _Tp __eb = __zndev * __zndev;
          _Tp __ec = __ea - __eb;
          _Tp __ed = __ea - _Tp(6) * __eb;
          _Tp __ef = __ed + __ec + __ec;
          _Tp __s1 = __ed * (-__c1 + __c3 * __ed
                                   / _Tp(3) - _Tp(3) * __c4 * __zndev * __ef
                                   / _Tp(2));
          _Tp __s2 = __zndev
                   * (__c2 * __ef
                    + __zndev * (-__c3 * __ec - __zndev * __c4 - __ea));

          return _Tp(3) * __sigma + __power4 * (_Tp(1) + __s1 + __s2)
                                        / (__mu * std::sqrt(__mu));
        }
    }
# 399 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __comp_ellint_2(_Tp __k)
    {

      if (__isnan(__k))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) == 1)
        return _Tp(1);
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __comp_ellint_2."));
      else
        {
          const _Tp __kk = __k * __k;

          return __ellint_rf(_Tp(0), _Tp(1) - __kk, _Tp(1))
               - __kk * __ellint_rd(_Tp(0), _Tp(1) - __kk, _Tp(1)) / _Tp(3);
        }
    }
# 433 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_2(_Tp __k, _Tp __phi)
    {

      if (__isnan(__k) || __isnan(__phi))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __ellint_2."));
      else
        {

          const int __n = std::floor(__phi / __numeric_constants<_Tp>::__pi()
                                   + _Tp(0.5L));
          const _Tp __phi_red = __phi
                              - __n * __numeric_constants<_Tp>::__pi();

          const _Tp __kk = __k * __k;
          const _Tp __s = std::sin(__phi_red);
          const _Tp __ss = __s * __s;
          const _Tp __sss = __ss * __s;
          const _Tp __c = std::cos(__phi_red);
          const _Tp __cc = __c * __c;

          const _Tp __E = __s
                        * __ellint_rf(__cc, _Tp(1) - __kk * __ss, _Tp(1))
                        - __kk * __sss
                        * __ellint_rd(__cc, _Tp(1) - __kk * __ss, _Tp(1))
                        / _Tp(3);

          if (__n == 0)
            return __E;
          else
            return __E + _Tp(2) * __n * __comp_ellint_2(__k);
        }
    }
# 492 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_rc(_Tp __x, _Tp __y)
    {
      const _Tp __min = std::numeric_limits<_Tp>::min();
      const _Tp __lolim = _Tp(5) * __min;

      if (__x < _Tp(0) || __y < _Tp(0) || __x + __y < __lolim)
        std::__throw_domain_error(("Argument less than zero " "in __ellint_rc.")
                                                        );
      else
        {
          const _Tp __c0 = _Tp(1) / _Tp(4);
          const _Tp __c1 = _Tp(1) / _Tp(7);
          const _Tp __c2 = _Tp(9) / _Tp(22);
          const _Tp __c3 = _Tp(3) / _Tp(10);
          const _Tp __c4 = _Tp(3) / _Tp(8);

          _Tp __xn = __x;
          _Tp __yn = __y;

          const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
          const _Tp __errtol = std::pow(__eps / _Tp(30), _Tp(1) / _Tp(6));
          _Tp __mu;
          _Tp __sn;

          const unsigned int __max_iter = 100;
          for (unsigned int __iter = 0; __iter < __max_iter; ++__iter)
            {
              __mu = (__xn + _Tp(2) * __yn) / _Tp(3);
              __sn = (__yn + __mu) / __mu - _Tp(2);
              if (std::abs(__sn) < __errtol)
                break;
              const _Tp __lambda = _Tp(2) * std::sqrt(__xn) * std::sqrt(__yn)
                             + __yn;
              __xn = __c0 * (__xn + __lambda);
              __yn = __c0 * (__yn + __lambda);
            }

          _Tp __s = __sn * __sn
                  * (__c3 + __sn*(__c1 + __sn * (__c4 + __sn * __c2)));

          return (_Tp(1) + __s) / std::sqrt(__mu);
        }
    }
# 561 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_rj(_Tp __x, _Tp __y, _Tp __z, _Tp __p)
    {
      const _Tp __min = std::numeric_limits<_Tp>::min();
      const _Tp __lolim = std::pow(_Tp(5) * __min, _Tp(1)/_Tp(3));

      if (__x < _Tp(0) || __y < _Tp(0) || __z < _Tp(0))
        std::__throw_domain_error(("Argument less than zero " "in __ellint_rj.")
                                                        );
      else if (__x + __y < __lolim || __x + __z < __lolim
            || __y + __z < __lolim || __p < __lolim)
        std::__throw_domain_error(("Argument too small " "in __ellint_rj")
                                                       );
      else
        {
          const _Tp __c0 = _Tp(1) / _Tp(4);
          const _Tp __c1 = _Tp(3) / _Tp(14);
          const _Tp __c2 = _Tp(1) / _Tp(3);
          const _Tp __c3 = _Tp(3) / _Tp(22);
          const _Tp __c4 = _Tp(3) / _Tp(26);

          _Tp __xn = __x;
          _Tp __yn = __y;
          _Tp __zn = __z;
          _Tp __pn = __p;
          _Tp __sigma = _Tp(0);
          _Tp __power4 = _Tp(1);

          const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
          const _Tp __errtol = std::pow(__eps / _Tp(8), _Tp(1) / _Tp(6));

          _Tp __mu;
          _Tp __xndev, __yndev, __zndev, __pndev;

          const unsigned int __max_iter = 100;
          for (unsigned int __iter = 0; __iter < __max_iter; ++__iter)
            {
              __mu = (__xn + __yn + __zn + _Tp(2) * __pn) / _Tp(5);
              __xndev = (__mu - __xn) / __mu;
              __yndev = (__mu - __yn) / __mu;
              __zndev = (__mu - __zn) / __mu;
              __pndev = (__mu - __pn) / __mu;
              _Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
              __epsilon = std::max(__epsilon, std::abs(__zndev));
              __epsilon = std::max(__epsilon, std::abs(__pndev));
              if (__epsilon < __errtol)
                break;
              const _Tp __xnroot = std::sqrt(__xn);
              const _Tp __ynroot = std::sqrt(__yn);
              const _Tp __znroot = std::sqrt(__zn);
              const _Tp __lambda = __xnroot * (__ynroot + __znroot)
                                 + __ynroot * __znroot;
              const _Tp __alpha1 = __pn * (__xnroot + __ynroot + __znroot)
                                + __xnroot * __ynroot * __znroot;
              const _Tp __alpha2 = __alpha1 * __alpha1;
              const _Tp __beta = __pn * (__pn + __lambda)
                                      * (__pn + __lambda);
              __sigma += __power4 * __ellint_rc(__alpha2, __beta);
              __power4 *= __c0;
              __xn = __c0 * (__xn + __lambda);
              __yn = __c0 * (__yn + __lambda);
              __zn = __c0 * (__zn + __lambda);
              __pn = __c0 * (__pn + __lambda);
            }

          _Tp __ea = __xndev * (__yndev + __zndev) + __yndev * __zndev;
          _Tp __eb = __xndev * __yndev * __zndev;
          _Tp __ec = __pndev * __pndev;
          _Tp __e2 = __ea - _Tp(3) * __ec;
          _Tp __e3 = __eb + _Tp(2) * __pndev * (__ea - __ec);
          _Tp __s1 = _Tp(1) + __e2 * (-__c1 + _Tp(3) * __c3 * __e2 / _Tp(4)
                            - _Tp(3) * __c4 * __e3 / _Tp(2));
          _Tp __s2 = __eb * (__c2 / _Tp(2)
                   + __pndev * (-__c3 - __c3 + __pndev * __c4));
          _Tp __s3 = __pndev * __ea * (__c2 - __pndev * __c3)
                   - __c2 * __pndev * __ec;

          return _Tp(3) * __sigma + __power4 * (__s1 + __s2 + __s3)
                                             / (__mu * std::sqrt(__mu));
        }
    }
# 661 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __comp_ellint_3(_Tp __k, _Tp __nu)
    {

      if (__isnan(__k) || __isnan(__nu))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__nu == _Tp(1))
        return std::numeric_limits<_Tp>::infinity();
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __comp_ellint_3."));
      else
        {
          const _Tp __kk = __k * __k;

          return __ellint_rf(_Tp(0), _Tp(1) - __kk, _Tp(1))
               + __nu
               * __ellint_rj(_Tp(0), _Tp(1) - __kk, _Tp(1), _Tp(1) - __nu)
               / _Tp(3);
        }
    }
# 701 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_3(_Tp __k, _Tp __nu, _Tp __phi)
    {

      if (__isnan(__k) || __isnan(__nu) || __isnan(__phi))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __ellint_3."));
      else
        {

          const int __n = std::floor(__phi / __numeric_constants<_Tp>::__pi()
                                   + _Tp(0.5L));
          const _Tp __phi_red = __phi
                              - __n * __numeric_constants<_Tp>::__pi();

          const _Tp __kk = __k * __k;
          const _Tp __s = std::sin(__phi_red);
          const _Tp __ss = __s * __s;
          const _Tp __sss = __ss * __s;
          const _Tp __c = std::cos(__phi_red);
          const _Tp __cc = __c * __c;

          const _Tp __Pi = __s
                         * __ellint_rf(__cc, _Tp(1) - __kk * __ss, _Tp(1))
                         + __nu * __sss
                         * __ellint_rj(__cc, _Tp(1) - __kk * __ss, _Tp(1),
                                       _Tp(1) - __nu * __ss) / _Tp(3);

          if (__n == 0)
            return __Pi;
          else
            return __Pi + _Tp(2) * __n * __comp_ellint_3(__k, __nu);
        }
    }
  }





}
# 51 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 2 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/exp_integral.tcc" 1 3
# 50 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/exp_integral.tcc" 3
namespace std
{

# 64 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/exp_integral.tcc" 3
  namespace __detail
  {
    template<typename _Tp> _Tp __expint_E1(_Tp);
# 81 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_E1_series(_Tp __x)
    {
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      _Tp __term = _Tp(1);
      _Tp __esum = _Tp(0);
      _Tp __osum = _Tp(0);
      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          __term *= - __x / __i;
          if (std::abs(__term) < __eps)
            break;
          if (__term >= _Tp(0))
            __esum += __term / __i;
          else
            __osum += __term / __i;
        }

      return - __esum - __osum
             - __numeric_constants<_Tp>::__gamma_e() - std::log(__x);
    }
# 118 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_E1_asymp(_Tp __x)
    {
      _Tp __term = _Tp(1);
      _Tp __esum = _Tp(1);
      _Tp __osum = _Tp(0);
      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          _Tp __prev = __term;
          __term *= - __i / __x;
          if (std::abs(__term) > std::abs(__prev))
            break;
          if (__term >= _Tp(0))
            __esum += __term;
          else
            __osum += __term;
        }

      return std::exp(- __x) * (__esum + __osum) / __x;
    }
# 155 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_En_series(unsigned int __n, _Tp __x)
    {
      const unsigned int __max_iter = 1000;
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const int __nm1 = __n - 1;
      _Tp __ans = (__nm1 != 0
                ? _Tp(1) / __nm1 : -std::log(__x)
                                   - __numeric_constants<_Tp>::__gamma_e());
      _Tp __fact = _Tp(1);
      for (int __i = 1; __i <= __max_iter; ++__i)
        {
          __fact *= -__x / _Tp(__i);
          _Tp __del;
          if ( __i != __nm1 )
            __del = -__fact / _Tp(__i - __nm1);
          else
            {
              _Tp __psi = -__numeric_constants<_Tp>::gamma_e();
              for (int __ii = 1; __ii <= __nm1; ++__ii)
                __psi += _Tp(1) / _Tp(__ii);
              __del = __fact * (__psi - std::log(__x));
            }
          __ans += __del;
          if (std::abs(__del) < __eps * std::abs(__ans))
            return __ans;
        }
      std::__throw_runtime_error(("Series summation failed " "in __expint_En_series.")
                                                              );
    }
# 201 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_En_cont_frac(unsigned int __n, _Tp __x)
    {
      const unsigned int __max_iter = 1000;
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __fp_min = std::numeric_limits<_Tp>::min();
      const int __nm1 = __n - 1;
      _Tp __b = __x + _Tp(__n);
      _Tp __c = _Tp(1) / __fp_min;
      _Tp __d = _Tp(1) / __b;
      _Tp __h = __d;
      for ( unsigned int __i = 1; __i <= __max_iter; ++__i )
        {
          _Tp __a = -_Tp(__i * (__nm1 + __i));
          __b += _Tp(2);
          __d = _Tp(1) / (__a * __d + __b);
          __c = __b + __a / __c;
          const _Tp __del = __c * __d;
          __h *= __del;
          if (std::abs(__del - _Tp(1)) < __eps)
            {
              const _Tp __ans = __h * std::exp(-__x);
              return __ans;
            }
        }
      std::__throw_runtime_error(("Continued fraction failed " "in __expint_En_cont_frac.")
                                                                 );
    }
# 246 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_En_recursion(unsigned int __n, _Tp __x)
    {
      _Tp __En;
      _Tp __E1 = __expint_E1(__x);
      if (__x < _Tp(__n))
        {

          __En = __E1;
          for (unsigned int __j = 2; __j < __n; ++__j)
            __En = (std::exp(-__x) - __x * __En) / _Tp(__j - 1);
        }
      else
        {

          __En = _Tp(1);
          const int __N = __n + 20;
          _Tp __save = _Tp(0);
          for (int __j = __N; __j > 0; --__j)
            {
              __En = (std::exp(-__x) - __j * __En) / __x;
              if (__j == __n)
                __save = __En;
            }
            _Tp __norm = __En / __E1;
            __En /= __norm;
        }

      return __En;
    }
# 290 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_Ei_series(_Tp __x)
    {
      _Tp __term = _Tp(1);
      _Tp __sum = _Tp(0);
      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          __term *= __x / __i;
          __sum += __term / __i;
          if (__term < std::numeric_limits<_Tp>::epsilon() * __sum)
            break;
        }

      return __numeric_constants<_Tp>::__gamma_e() + __sum + std::log(__x);
    }
# 321 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_Ei_asymp(_Tp __x)
    {
      _Tp __term = _Tp(1);
      _Tp __sum = _Tp(1);
      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          _Tp __prev = __term;
          __term *= __i / __x;
          if (__term < std::numeric_limits<_Tp>::epsilon())
            break;
          if (__term >= __prev)
            break;
          __sum += __term;
        }

      return std::exp(__x) * __sum / __x;
    }
# 354 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_Ei(_Tp __x)
    {
      if (__x < _Tp(0))
        return -__expint_E1(-__x);
      else if (__x < -std::log(std::numeric_limits<_Tp>::epsilon()))
        return __expint_Ei_series(__x);
      else
        return __expint_Ei_asymp(__x);
    }
# 378 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_E1(_Tp __x)
    {
      if (__x < _Tp(0))
        return -__expint_Ei(-__x);
      else if (__x < _Tp(1))
        return __expint_E1_series(__x);
      else if (__x < _Tp(100))
        return __expint_En_cont_frac(1, __x);
      else
        return __expint_E1_asymp(__x);
    }
# 408 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_asymp(unsigned int __n, _Tp __x)
    {
      _Tp __term = _Tp(1);
      _Tp __sum = _Tp(1);
      for (unsigned int __i = 1; __i <= __n; ++__i)
        {
          _Tp __prev = __term;
          __term *= -(__n - __i + 1) / __x;
          if (std::abs(__term) > std::abs(__prev))
            break;
          __sum += __term;
        }

      return std::exp(-__x) * __sum / __x;
    }
# 442 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_large_n(unsigned int __n, _Tp __x)
    {
      const _Tp __xpn = __x + __n;
      const _Tp __xpn2 = __xpn * __xpn;
      _Tp __term = _Tp(1);
      _Tp __sum = _Tp(1);
      for (unsigned int __i = 1; __i <= __n; ++__i)
        {
          _Tp __prev = __term;
          __term *= (__n - 2 * (__i - 1) * __x) / __xpn2;
          if (std::abs(__term) < std::numeric_limits<_Tp>::epsilon())
            break;
          __sum += __term;
        }

      return std::exp(-__x) * __sum / __xpn;
    }
# 476 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint(unsigned int __n, _Tp __x)
    {

      if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__n <= 1 && __x == _Tp(0))
        return std::numeric_limits<_Tp>::infinity();
      else
        {
          _Tp __E0 = std::exp(__x) / __x;
          if (__n == 0)
            return __E0;

          _Tp __E1 = __expint_E1(__x);
          if (__n == 1)
            return __E1;

          if (__x == _Tp(0))
            return _Tp(1) / static_cast<_Tp>(__n - 1);

          _Tp __En = __expint_En_recursion(__n, __x);

          return __En;
        }
    }
# 516 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    inline _Tp
    __expint(_Tp __x)
    {
      if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return __expint_Ei(__x);
    }
  }





}
# 52 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 2 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/hypergeometric.tcc" 1 3
# 44 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/hypergeometric.tcc" 3
namespace std
{

# 60 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/hypergeometric.tcc" 3
  namespace __detail
  {
# 83 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __conf_hyperg_series(_Tp __a, _Tp __c, _Tp __x)
    {
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      _Tp __term = _Tp(1);
      _Tp __Fac = _Tp(1);
      const unsigned int __max_iter = 100000;
      unsigned int __i;
      for (__i = 0; __i < __max_iter; ++__i)
        {
          __term *= (__a + _Tp(__i)) * __x
                  / ((__c + _Tp(__i)) * _Tp(1 + __i));
          if (std::abs(__term) < __eps)
            {
              break;
            }
          __Fac += __term;
        }
      if (__i == __max_iter)
        std::__throw_runtime_error(("Series failed to converge " "in __conf_hyperg_series.")
                                                                  );

      return __Fac;
    }
# 120 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __conf_hyperg_luke(_Tp __a, _Tp __c, _Tp __xin)
    {
      const _Tp __big = std::pow(std::numeric_limits<_Tp>::max(), _Tp(0.16L));
      const int __nmax = 20000;
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __x = -__xin;
      const _Tp __x3 = __x * __x * __x;
      const _Tp __t0 = __a / __c;
      const _Tp __t1 = (__a + _Tp(1)) / (_Tp(2) * __c);
      const _Tp __t2 = (__a + _Tp(2)) / (_Tp(2) * (__c + _Tp(1)));
      _Tp __F = _Tp(1);
      _Tp __prec;

      _Tp __Bnm3 = _Tp(1);
      _Tp __Bnm2 = _Tp(1) + __t1 * __x;
      _Tp __Bnm1 = _Tp(1) + __t2 * __x * (_Tp(1) + __t1 / _Tp(3) * __x);

      _Tp __Anm3 = _Tp(1);
      _Tp __Anm2 = __Bnm2 - __t0 * __x;
      _Tp __Anm1 = __Bnm1 - __t0 * (_Tp(1) + __t2 * __x) * __x
                 + __t0 * __t1 * (__c / (__c + _Tp(1))) * __x * __x;

      int __n = 3;
      while(1)
        {
          _Tp __npam1 = _Tp(__n - 1) + __a;
          _Tp __npcm1 = _Tp(__n - 1) + __c;
          _Tp __npam2 = _Tp(__n - 2) + __a;
          _Tp __npcm2 = _Tp(__n - 2) + __c;
          _Tp __tnm1 = _Tp(2 * __n - 1);
          _Tp __tnm3 = _Tp(2 * __n - 3);
          _Tp __tnm5 = _Tp(2 * __n - 5);
          _Tp __F1 = (_Tp(__n - 2) - __a) / (_Tp(2) * __tnm3 * __npcm1);
          _Tp __F2 = (_Tp(__n) + __a) * __npam1
                   / (_Tp(4) * __tnm1 * __tnm3 * __npcm2 * __npcm1);
          _Tp __F3 = -__npam2 * __npam1 * (_Tp(__n - 2) - __a)
                   / (_Tp(8) * __tnm3 * __tnm3 * __tnm5
                   * (_Tp(__n - 3) + __c) * __npcm2 * __npcm1);
          _Tp __E = -__npam1 * (_Tp(__n - 1) - __c)
                   / (_Tp(2) * __tnm3 * __npcm2 * __npcm1);

          _Tp __An = (_Tp(1) + __F1 * __x) * __Anm1
                   + (__E + __F2 * __x) * __x * __Anm2 + __F3 * __x3 * __Anm3;
          _Tp __Bn = (_Tp(1) + __F1 * __x) * __Bnm1
                   + (__E + __F2 * __x) * __x * __Bnm2 + __F3 * __x3 * __Bnm3;
          _Tp __r = __An / __Bn;

          __prec = std::abs((__F - __r) / __F);
          __F = __r;

          if (__prec < __eps || __n > __nmax)
            break;

          if (std::abs(__An) > __big || std::abs(__Bn) > __big)
            {
              __An /= __big;
              __Bn /= __big;
              __Anm1 /= __big;
              __Bnm1 /= __big;
              __Anm2 /= __big;
              __Bnm2 /= __big;
              __Anm3 /= __big;
              __Bnm3 /= __big;
            }
          else if (std::abs(__An) < _Tp(1) / __big
                || std::abs(__Bn) < _Tp(1) / __big)
            {
              __An *= __big;
              __Bn *= __big;
              __Anm1 *= __big;
              __Bnm1 *= __big;
              __Anm2 *= __big;
              __Bnm2 *= __big;
              __Anm3 *= __big;
              __Bnm3 *= __big;
            }

          ++__n;
          __Bnm3 = __Bnm2;
          __Bnm2 = __Bnm1;
          __Bnm1 = __Bn;
          __Anm3 = __Anm2;
          __Anm2 = __Anm1;
          __Anm1 = __An;
        }

      if (__n >= __nmax)
        std::__throw_runtime_error(("Iteration failed to converge " "in __conf_hyperg_luke.")
                                                                );

      return __F;
    }
# 227 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __conf_hyperg(_Tp __a, _Tp __c, _Tp __x)
    {

      const _Tp __c_nint = ::std::nearbyint(__c);



      if (__isnan(__a) || __isnan(__c) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__c_nint == __c && __c_nint <= 0)
        return std::numeric_limits<_Tp>::infinity();
      else if (__a == _Tp(0))
        return _Tp(1);
      else if (__c == __a)
        return std::exp(__x);
      else if (__x < _Tp(0))
        return __conf_hyperg_luke(__a, __c, __x);
      else
        return __conf_hyperg_series(__a, __c, __x);
    }
# 271 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __hyperg_series(_Tp __a, _Tp __b, _Tp __c, _Tp __x)
    {
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      _Tp __term = _Tp(1);
      _Tp __Fabc = _Tp(1);
      const unsigned int __max_iter = 100000;
      unsigned int __i;
      for (__i = 0; __i < __max_iter; ++__i)
        {
          __term *= (__a + _Tp(__i)) * (__b + _Tp(__i)) * __x
                  / ((__c + _Tp(__i)) * _Tp(1 + __i));
          if (std::abs(__term) < __eps)
            {
              break;
            }
          __Fabc += __term;
        }
      if (__i == __max_iter)
        std::__throw_runtime_error(("Series failed to converge " "in __hyperg_series.")
                                                             );

      return __Fabc;
    }







    template<typename _Tp>
    _Tp
    __hyperg_luke(_Tp __a, _Tp __b, _Tp __c, _Tp __xin)
    {
      const _Tp __big = std::pow(std::numeric_limits<_Tp>::max(), _Tp(0.16L));
      const int __nmax = 20000;
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __x = -__xin;
      const _Tp __x3 = __x * __x * __x;
      const _Tp __t0 = __a * __b / __c;
      const _Tp __t1 = (__a + _Tp(1)) * (__b + _Tp(1)) / (_Tp(2) * __c);
      const _Tp __t2 = (__a + _Tp(2)) * (__b + _Tp(2))
                     / (_Tp(2) * (__c + _Tp(1)));

      _Tp __F = _Tp(1);

      _Tp __Bnm3 = _Tp(1);
      _Tp __Bnm2 = _Tp(1) + __t1 * __x;
      _Tp __Bnm1 = _Tp(1) + __t2 * __x * (_Tp(1) + __t1 / _Tp(3) * __x);

      _Tp __Anm3 = _Tp(1);
      _Tp __Anm2 = __Bnm2 - __t0 * __x;
      _Tp __Anm1 = __Bnm1 - __t0 * (_Tp(1) + __t2 * __x) * __x
                 + __t0 * __t1 * (__c / (__c + _Tp(1))) * __x * __x;

      int __n = 3;
      while (1)
        {
          const _Tp __npam1 = _Tp(__n - 1) + __a;
          const _Tp __npbm1 = _Tp(__n - 1) + __b;
          const _Tp __npcm1 = _Tp(__n - 1) + __c;
          const _Tp __npam2 = _Tp(__n - 2) + __a;
          const _Tp __npbm2 = _Tp(__n - 2) + __b;
          const _Tp __npcm2 = _Tp(__n - 2) + __c;
          const _Tp __tnm1 = _Tp(2 * __n - 1);
          const _Tp __tnm3 = _Tp(2 * __n - 3);
          const _Tp __tnm5 = _Tp(2 * __n - 5);
          const _Tp __n2 = __n * __n;
          const _Tp __F1 = (_Tp(3) * __n2 + (__a + __b - _Tp(6)) * __n
                         + _Tp(2) - __a * __b - _Tp(2) * (__a + __b))
                         / (_Tp(2) * __tnm3 * __npcm1);
          const _Tp __F2 = -(_Tp(3) * __n2 - (__a + __b + _Tp(6)) * __n
                         + _Tp(2) - __a * __b) * __npam1 * __npbm1
                         / (_Tp(4) * __tnm1 * __tnm3 * __npcm2 * __npcm1);
          const _Tp __F3 = (__npam2 * __npam1 * __npbm2 * __npbm1
                         * (_Tp(__n - 2) - __a) * (_Tp(__n - 2) - __b))
                         / (_Tp(8) * __tnm3 * __tnm3 * __tnm5
                         * (_Tp(__n - 3) + __c) * __npcm2 * __npcm1);
          const _Tp __E = -__npam1 * __npbm1 * (_Tp(__n - 1) - __c)
                         / (_Tp(2) * __tnm3 * __npcm2 * __npcm1);

          _Tp __An = (_Tp(1) + __F1 * __x) * __Anm1
                   + (__E + __F2 * __x) * __x * __Anm2 + __F3 * __x3 * __Anm3;
          _Tp __Bn = (_Tp(1) + __F1 * __x) * __Bnm1
                   + (__E + __F2 * __x) * __x * __Bnm2 + __F3 * __x3 * __Bnm3;
          const _Tp __r = __An / __Bn;

          const _Tp __prec = std::abs((__F - __r) / __F);
          __F = __r;

          if (__prec < __eps || __n > __nmax)
            break;

          if (std::abs(__An) > __big || std::abs(__Bn) > __big)
            {
              __An /= __big;
              __Bn /= __big;
              __Anm1 /= __big;
              __Bnm1 /= __big;
              __Anm2 /= __big;
              __Bnm2 /= __big;
              __Anm3 /= __big;
              __Bnm3 /= __big;
            }
          else if (std::abs(__An) < _Tp(1) / __big
                || std::abs(__Bn) < _Tp(1) / __big)
            {
              __An *= __big;
              __Bn *= __big;
              __Anm1 *= __big;
              __Bnm1 *= __big;
              __Anm2 *= __big;
              __Bnm2 *= __big;
              __Anm3 *= __big;
              __Bnm3 *= __big;
            }

          ++__n;
          __Bnm3 = __Bnm2;
          __Bnm2 = __Bnm1;
          __Bnm1 = __Bn;
          __Anm3 = __Anm2;
          __Anm2 = __Anm1;
          __Anm1 = __An;
        }

      if (__n >= __nmax)
        std::__throw_runtime_error(("Iteration failed to converge " "in __hyperg_luke.")
                                                           );

      return __F;
    }
# 438 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __hyperg_reflect(_Tp __a, _Tp __b, _Tp __c, _Tp __x)
    {
      const _Tp __d = __c - __a - __b;
      const int __intd = std::floor(__d + _Tp(0.5L));
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __toler = _Tp(1000) * __eps;
      const _Tp __log_max = std::log(std::numeric_limits<_Tp>::max());
      const bool __d_integer = (std::abs(__d - __intd) < __toler);

      if (__d_integer)
        {
          const _Tp __ln_omx = std::log(_Tp(1) - __x);
          const _Tp __ad = std::abs(__d);
          _Tp __F1, __F2;

          _Tp __d1, __d2;
          if (__d >= _Tp(0))
            {
              __d1 = __d;
              __d2 = _Tp(0);
            }
          else
            {
              __d1 = _Tp(0);
              __d2 = __d;
            }

          const _Tp __lng_c = __log_gamma(__c);


          if (__ad < __eps)
            {

              __F1 = _Tp(0);
            }
          else
            {

              bool __ok_d1 = true;
              _Tp __lng_ad, __lng_ad1, __lng_bd1;
              try
                {
                  __lng_ad = __log_gamma(__ad);
                  __lng_ad1 = __log_gamma(__a + __d1);
                  __lng_bd1 = __log_gamma(__b + __d1);
                }
              catch(...)
                {
                  __ok_d1 = false;
                }

              if (__ok_d1)
                {



                  _Tp __sum1 = _Tp(1);
                  _Tp __term = _Tp(1);
                  _Tp __ln_pre1 = __lng_ad + __lng_c + __d2 * __ln_omx
                                - __lng_ad1 - __lng_bd1;



                  for (int __i = 1; __i < __ad; ++__i)
                    {
                      const int __j = __i - 1;
                      __term *= (__a + __d2 + __j) * (__b + __d2 + __j)
                              / (_Tp(1) + __d2 + __j) / __i * (_Tp(1) - __x);
                      __sum1 += __term;
                    }

                  if (__ln_pre1 > __log_max)
                    std::__throw_runtime_error(("Overflow of gamma functions" " in __hyperg_luke.")
                                                                        );
                  else
                    __F1 = std::exp(__ln_pre1) * __sum1;
                }
              else
                {


                  __F1 = _Tp(0);
                }
            }


          bool __ok_d2 = true;
          _Tp __lng_ad2, __lng_bd2;
          try
            {
              __lng_ad2 = __log_gamma(__a + __d2);
              __lng_bd2 = __log_gamma(__b + __d2);
            }
          catch(...)
            {
              __ok_d2 = false;
            }

          if (__ok_d2)
            {


              const int __maxiter = 2000;
              const _Tp __psi_1 = -__numeric_constants<_Tp>::__gamma_e();
              const _Tp __psi_1pd = __psi(_Tp(1) + __ad);
              const _Tp __psi_apd1 = __psi(__a + __d1);
              const _Tp __psi_bpd1 = __psi(__b + __d1);

              _Tp __psi_term = __psi_1 + __psi_1pd - __psi_apd1
                             - __psi_bpd1 - __ln_omx;
              _Tp __fact = _Tp(1);
              _Tp __sum2 = __psi_term;
              _Tp __ln_pre2 = __lng_c + __d1 * __ln_omx
                            - __lng_ad2 - __lng_bd2;


              int __j;
              for (__j = 1; __j < __maxiter; ++__j)
                {


                  const _Tp __term1 = _Tp(1) / _Tp(__j)
                                    + _Tp(1) / (__ad + __j);
                  const _Tp __term2 = _Tp(1) / (__a + __d1 + _Tp(__j - 1))
                                    + _Tp(1) / (__b + __d1 + _Tp(__j - 1));
                  __psi_term += __term1 - __term2;
                  __fact *= (__a + __d1 + _Tp(__j - 1))
                          * (__b + __d1 + _Tp(__j - 1))
                          / ((__ad + __j) * __j) * (_Tp(1) - __x);
                  const _Tp __delta = __fact * __psi_term;
                  __sum2 += __delta;
                  if (std::abs(__delta) < __eps * std::abs(__sum2))
                    break;
                }
              if (__j == __maxiter)
                std::__throw_runtime_error(("Sum F2 failed to converge " "in __hyperg_reflect")
                                                                     );

              if (__sum2 == _Tp(0))
                __F2 = _Tp(0);
              else
                __F2 = std::exp(__ln_pre2) * __sum2;
            }
          else
            {


              __F2 = _Tp(0);
            }

          const _Tp __sgn_2 = (__intd % 2 == 1 ? -_Tp(1) : _Tp(1));
          const _Tp __F = __F1 + __sgn_2 * __F2;

          return __F;
        }
      else
        {




          bool __ok1 = true;
          _Tp __sgn_g1ca = _Tp(0), __ln_g1ca = _Tp(0);
          _Tp __sgn_g1cb = _Tp(0), __ln_g1cb = _Tp(0);
          try
            {
              __sgn_g1ca = __log_gamma_sign(__c - __a);
              __ln_g1ca = __log_gamma(__c - __a);
              __sgn_g1cb = __log_gamma_sign(__c - __b);
              __ln_g1cb = __log_gamma(__c - __b);
            }
          catch(...)
            {
              __ok1 = false;
            }

          bool __ok2 = true;
          _Tp __sgn_g2a = _Tp(0), __ln_g2a = _Tp(0);
          _Tp __sgn_g2b = _Tp(0), __ln_g2b = _Tp(0);
          try
            {
              __sgn_g2a = __log_gamma_sign(__a);
              __ln_g2a = __log_gamma(__a);
              __sgn_g2b = __log_gamma_sign(__b);
              __ln_g2b = __log_gamma(__b);
            }
          catch(...)
            {
              __ok2 = false;
            }

          const _Tp __sgn_gc = __log_gamma_sign(__c);
          const _Tp __ln_gc = __log_gamma(__c);
          const _Tp __sgn_gd = __log_gamma_sign(__d);
          const _Tp __ln_gd = __log_gamma(__d);
          const _Tp __sgn_gmd = __log_gamma_sign(-__d);
          const _Tp __ln_gmd = __log_gamma(-__d);

          const _Tp __sgn1 = __sgn_gc * __sgn_gd * __sgn_g1ca * __sgn_g1cb;
          const _Tp __sgn2 = __sgn_gc * __sgn_gmd * __sgn_g2a * __sgn_g2b;

          _Tp __pre1, __pre2;
          if (__ok1 && __ok2)
            {
              _Tp __ln_pre1 = __ln_gc + __ln_gd - __ln_g1ca - __ln_g1cb;
              _Tp __ln_pre2 = __ln_gc + __ln_gmd - __ln_g2a - __ln_g2b
                            + __d * std::log(_Tp(1) - __x);
              if (__ln_pre1 < __log_max && __ln_pre2 < __log_max)
                {
                  __pre1 = std::exp(__ln_pre1);
                  __pre2 = std::exp(__ln_pre2);
                  __pre1 *= __sgn1;
                  __pre2 *= __sgn2;
                }
              else
                {
                  std::__throw_runtime_error(("Overflow of gamma functions " "in __hyperg_reflect")
                                                                       );
                }
            }
          else if (__ok1 && !__ok2)
            {
              _Tp __ln_pre1 = __ln_gc + __ln_gd - __ln_g1ca - __ln_g1cb;
              if (__ln_pre1 < __log_max)
                {
                  __pre1 = std::exp(__ln_pre1);
                  __pre1 *= __sgn1;
                  __pre2 = _Tp(0);
                }
              else
                {
                  std::__throw_runtime_error(("Overflow of gamma functions " "in __hyperg_reflect")
                                                                       );
                }
            }
          else if (!__ok1 && __ok2)
            {
              _Tp __ln_pre2 = __ln_gc + __ln_gmd - __ln_g2a - __ln_g2b
                            + __d * std::log(_Tp(1) - __x);
              if (__ln_pre2 < __log_max)
                {
                  __pre1 = _Tp(0);
                  __pre2 = std::exp(__ln_pre2);
                  __pre2 *= __sgn2;
                }
              else
                {
                  std::__throw_runtime_error(("Overflow of gamma functions " "in __hyperg_reflect")
                                                                       );
                }
            }
          else
            {
              __pre1 = _Tp(0);
              __pre2 = _Tp(0);
              std::__throw_runtime_error(("Underflow of gamma functions " "in __hyperg_reflect")
                                                                   );
            }

          const _Tp __F1 = __hyperg_series(__a, __b, _Tp(1) - __d,
                                           _Tp(1) - __x);
          const _Tp __F2 = __hyperg_series(__c - __a, __c - __b, _Tp(1) + __d,
                                           _Tp(1) - __x);

          const _Tp __F = __pre1 * __F1 + __pre2 * __F2;

          return __F;
        }
    }
# 728 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __hyperg(_Tp __a, _Tp __b, _Tp __c, _Tp __x)
    {

      const _Tp __a_nint = ::std::nearbyint(__a);
      const _Tp __b_nint = ::std::nearbyint(__b);
      const _Tp __c_nint = ::std::nearbyint(__c);





      const _Tp __toler = _Tp(1000) * std::numeric_limits<_Tp>::epsilon();
      if (std::abs(__x) >= _Tp(1))
        std::__throw_domain_error(("Argument outside unit circle " "in __hyperg.")
                                                     );
      else if (__isnan(__a) || __isnan(__b)
            || __isnan(__c) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__c_nint == __c && __c_nint <= _Tp(0))
        return std::numeric_limits<_Tp>::infinity();
      else if (std::abs(__c - __b) < __toler || std::abs(__c - __a) < __toler)
        return std::pow(_Tp(1) - __x, __c - __a - __b);
      else if (__a >= _Tp(0) && __b >= _Tp(0) && __c >= _Tp(0)
            && __x >= _Tp(0) && __x < _Tp(0.995L))
        return __hyperg_series(__a, __b, __c, __x);
      else if (std::abs(__a) < _Tp(10) && std::abs(__b) < _Tp(10))
        {


          if (__a < _Tp(0) && std::abs(__a - __a_nint) < __toler)
            return __hyperg_series(__a_nint, __b, __c, __x);
          else if (__b < _Tp(0) && std::abs(__b - __b_nint) < __toler)
            return __hyperg_series(__a, __b_nint, __c, __x);
          else if (__x < -_Tp(0.25L))
            return __hyperg_luke(__a, __b, __c, __x);
          else if (__x < _Tp(0.5L))
            return __hyperg_series(__a, __b, __c, __x);
          else
            if (std::abs(__c) > _Tp(10))
              return __hyperg_series(__a, __b, __c, __x);
            else
              return __hyperg_reflect(__a, __b, __c, __x);
        }
      else
        return __hyperg_luke(__a, __b, __c, __x);
    }
  }






}
# 53 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 2 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/legendre_function.tcc" 1 3
# 49 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/legendre_function.tcc" 3
namespace std
{

# 65 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/legendre_function.tcc" 3
  namespace __detail
  {
# 80 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/legendre_function.tcc" 3
    template<typename _Tp>
    _Tp
    __poly_legendre_p(unsigned int __l, _Tp __x)
    {

      if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x == +_Tp(1))
        return +_Tp(1);
      else if (__x == -_Tp(1))
        return (__l % 2 == 1 ? -_Tp(1) : +_Tp(1));
      else
        {
          _Tp __p_lm2 = _Tp(1);
          if (__l == 0)
            return __p_lm2;

          _Tp __p_lm1 = __x;
          if (__l == 1)
            return __p_lm1;

          _Tp __p_l = 0;
          for (unsigned int __ll = 2; __ll <= __l; ++__ll)
            {


              __p_l = _Tp(2) * __x * __p_lm1 - __p_lm2
                    - (__x * __p_lm1 - __p_lm2) / _Tp(__ll);
              __p_lm2 = __p_lm1;
              __p_lm1 = __p_l;
            }

          return __p_l;
        }
    }
# 136 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/legendre_function.tcc" 3
    template<typename _Tp>
    _Tp
    __assoc_legendre_p(unsigned int __l, unsigned int __m, _Tp __x,
         _Tp __phase = _Tp(+1))
    {

      if (__m > __l)
        return _Tp(0);
      else if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__m == 0)
        return __poly_legendre_p(__l, __x);
      else
        {
          _Tp __p_mm = _Tp(1);
          if (__m > 0)
            {


              _Tp __root = std::sqrt(_Tp(1) - __x) * std::sqrt(_Tp(1) + __x);
              _Tp __fact = _Tp(1);
              for (unsigned int __i = 1; __i <= __m; ++__i)
                {
                  __p_mm *= __phase * __fact * __root;
                  __fact += _Tp(2);
                }
            }
          if (__l == __m)
            return __p_mm;

          _Tp __p_mp1m = _Tp(2 * __m + 1) * __x * __p_mm;
          if (__l == __m + 1)
            return __p_mp1m;

          _Tp __p_lm2m = __p_mm;
          _Tp __P_lm1m = __p_mp1m;
          _Tp __p_lm = _Tp(0);
          for (unsigned int __j = __m + 2; __j <= __l; ++__j)
            {
              __p_lm = (_Tp(2 * __j - 1) * __x * __P_lm1m
                      - _Tp(__j + __m - 1) * __p_lm2m) / _Tp(__j - __m);
              __p_lm2m = __P_lm1m;
              __P_lm1m = __p_lm;
            }

          return __p_lm;
        }
    }
# 214 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/legendre_function.tcc" 3
    template <typename _Tp>
    _Tp
    __sph_legendre(unsigned int __l, unsigned int __m, _Tp __theta)
    {
      if (__isnan(__theta))
        return std::numeric_limits<_Tp>::quiet_NaN();

      const _Tp __x = std::cos(__theta);

      if (__m > __l)
        return _Tp(0);
      else if (__m == 0)
        {
          _Tp __P = __poly_legendre_p(__l, __x);
          _Tp __fact = std::sqrt(_Tp(2 * __l + 1)
                     / (_Tp(4) * __numeric_constants<_Tp>::__pi()));
          __P *= __fact;
          return __P;
        }
      else if (__x == _Tp(1) || __x == -_Tp(1))
        {

          return _Tp(0);
        }
      else
        {





          const _Tp __sgn = ( __m % 2 == 1 ? -_Tp(1) : _Tp(1));
          const _Tp __y_mp1m_factor = __x * std::sqrt(_Tp(2 * __m + 3));

          const _Tp __lncirc = ::std::log1p(-__x * __x);





          const _Tp __lnpoch = ::std::lgamma(_Tp(__m + _Tp(0.5L)))
                             - ::std::lgamma(_Tp(__m));




          const _Tp __lnpre_val =
                    -_Tp(0.25L) * __numeric_constants<_Tp>::__lnpi()
                    + _Tp(0.5L) * (__lnpoch + __m * __lncirc);
          const _Tp __sr = std::sqrt((_Tp(2) + _Tp(1) / __m)
                         / (_Tp(4) * __numeric_constants<_Tp>::__pi()));
          _Tp __y_mm = __sgn * __sr * std::exp(__lnpre_val);
          _Tp __y_mp1m = __y_mp1m_factor * __y_mm;

          if (__l == __m)
            return __y_mm;
          else if (__l == __m + 1)
            return __y_mp1m;
          else
            {
              _Tp __y_lm = _Tp(0);


              for (unsigned int __ll = __m + 2; __ll <= __l; ++__ll)
                {
                  const _Tp __rat1 = _Tp(__ll - __m) / _Tp(__ll + __m);
                  const _Tp __rat2 = _Tp(__ll - __m - 1) / _Tp(__ll + __m - 1);
                  const _Tp __fact1 = std::sqrt(__rat1 * _Tp(2 * __ll + 1)
                                                       * _Tp(2 * __ll - 1));
                  const _Tp __fact2 = std::sqrt(__rat1 * __rat2 * _Tp(2 * __ll + 1)
                                                                / _Tp(2 * __ll - 3));
                  __y_lm = (__x * __y_mp1m * __fact1
                         - (__ll + __m - 1) * __y_mm * __fact2) / _Tp(__ll - __m);
                  __y_mm = __y_mp1m;
                  __y_mp1m = __y_lm;
                }

              return __y_lm;
            }
        }
    }
  }






}
# 54 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 2 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/modified_bessel_func.tcc" 1 3
# 51 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/modified_bessel_func.tcc" 3
namespace std
{

# 65 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/modified_bessel_func.tcc" 3
  namespace __detail
  {
# 83 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/modified_bessel_func.tcc" 3
    template <typename _Tp>
    void
    __bessel_ik(_Tp __nu, _Tp __x,
                _Tp & __Inu, _Tp & __Knu, _Tp & __Ipnu, _Tp & __Kpnu)
    {
      if (__x == _Tp(0))
        {
          if (__nu == _Tp(0))
            {
              __Inu = _Tp(1);
              __Ipnu = _Tp(0);
            }
          else if (__nu == _Tp(1))
            {
              __Inu = _Tp(0);
              __Ipnu = _Tp(0.5L);
            }
          else
            {
              __Inu = _Tp(0);
              __Ipnu = _Tp(0);
            }
          __Knu = std::numeric_limits<_Tp>::infinity();
          __Kpnu = -std::numeric_limits<_Tp>::infinity();
          return;
        }

      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __fp_min = _Tp(10) * std::numeric_limits<_Tp>::epsilon();
      const int __max_iter = 15000;
      const _Tp __x_min = _Tp(2);

      const int __nl = static_cast<int>(__nu + _Tp(0.5L));

      const _Tp __mu = __nu - __nl;
      const _Tp __mu2 = __mu * __mu;
      const _Tp __xi = _Tp(1) / __x;
      const _Tp __xi2 = _Tp(2) * __xi;
      _Tp __h = __nu * __xi;
      if ( __h < __fp_min )
        __h = __fp_min;
      _Tp __b = __xi2 * __nu;
      _Tp __d = _Tp(0);
      _Tp __c = __h;
      int __i;
      for ( __i = 1; __i <= __max_iter; ++__i )
        {
          __b += __xi2;
          __d = _Tp(1) / (__b + __d);
          __c = __b + _Tp(1) / __c;
          const _Tp __del = __c * __d;
          __h *= __del;
          if (std::abs(__del - _Tp(1)) < __eps)
            break;
        }
      if (__i > __max_iter)
        std::__throw_runtime_error(("Argument x too large " "in __bessel_ik; " "try asymptotic expansion.")

                                                                   );
      _Tp __Inul = __fp_min;
      _Tp __Ipnul = __h * __Inul;
      _Tp __Inul1 = __Inul;
      _Tp __Ipnu1 = __Ipnul;
      _Tp __fact = __nu * __xi;
      for (int __l = __nl; __l >= 1; --__l)
        {
          const _Tp __Inutemp = __fact * __Inul + __Ipnul;
          __fact -= __xi;
          __Ipnul = __fact * __Inutemp + __Inul;
          __Inul = __Inutemp;
        }
      _Tp __f = __Ipnul / __Inul;
      _Tp __Kmu, __Knu1;
      if (__x < __x_min)
        {
          const _Tp __x2 = __x / _Tp(2);
          const _Tp __pimu = __numeric_constants<_Tp>::__pi() * __mu;
          const _Tp __fact = (std::abs(__pimu) < __eps
                            ? _Tp(1) : __pimu / std::sin(__pimu));
          _Tp __d = -std::log(__x2);
          _Tp __e = __mu * __d;
          const _Tp __fact2 = (std::abs(__e) < __eps
                            ? _Tp(1) : std::sinh(__e) / __e);
          _Tp __gam1, __gam2, __gampl, __gammi;
          __gamma_temme(__mu, __gam1, __gam2, __gampl, __gammi);
          _Tp __ff = __fact
                   * (__gam1 * std::cosh(__e) + __gam2 * __fact2 * __d);
          _Tp __sum = __ff;
          __e = std::exp(__e);
          _Tp __p = __e / (_Tp(2) * __gampl);
          _Tp __q = _Tp(1) / (_Tp(2) * __e * __gammi);
          _Tp __c = _Tp(1);
          __d = __x2 * __x2;
          _Tp __sum1 = __p;
          int __i;
          for (__i = 1; __i <= __max_iter; ++__i)
            {
              __ff = (__i * __ff + __p + __q) / (__i * __i - __mu2);
              __c *= __d / __i;
              __p /= __i - __mu;
              __q /= __i + __mu;
              const _Tp __del = __c * __ff;
              __sum += __del;
              const _Tp __del1 = __c * (__p - __i * __ff);
              __sum1 += __del1;
              if (std::abs(__del) < __eps * std::abs(__sum))
                break;
            }
          if (__i > __max_iter)
            std::__throw_runtime_error(("Bessel k series failed to converge " "in __bessel_ik.")
                                                             );
          __Kmu = __sum;
          __Knu1 = __sum1 * __xi2;
        }
      else
        {
          _Tp __b = _Tp(2) * (_Tp(1) + __x);
          _Tp __d = _Tp(1) / __b;
          _Tp __delh = __d;
          _Tp __h = __delh;
          _Tp __q1 = _Tp(0);
          _Tp __q2 = _Tp(1);
          _Tp __a1 = _Tp(0.25L) - __mu2;
          _Tp __q = __c = __a1;
          _Tp __a = -__a1;
          _Tp __s = _Tp(1) + __q * __delh;
          int __i;
          for (__i = 2; __i <= __max_iter; ++__i)
            {
              __a -= 2 * (__i - 1);
              __c = -__a * __c / __i;
              const _Tp __qnew = (__q1 - __b * __q2) / __a;
              __q1 = __q2;
              __q2 = __qnew;
              __q += __c * __qnew;
              __b += _Tp(2);
              __d = _Tp(1) / (__b + __a * __d);
              __delh = (__b * __d - _Tp(1)) * __delh;
              __h += __delh;
              const _Tp __dels = __q * __delh;
              __s += __dels;
              if ( std::abs(__dels / __s) < __eps )
                break;
            }
          if (__i > __max_iter)
            std::__throw_runtime_error(("Steed's method failed " "in __bessel_ik.")
                                                             );
          __h = __a1 * __h;
          __Kmu = std::sqrt(__numeric_constants<_Tp>::__pi() / (_Tp(2) * __x))
                * std::exp(-__x) / __s;
          __Knu1 = __Kmu * (__mu + __x + _Tp(0.5L) - __h) * __xi;
        }

      _Tp __Kpmu = __mu * __xi * __Kmu - __Knu1;
      _Tp __Inumu = __xi / (__f * __Kmu - __Kpmu);
      __Inu = __Inumu * __Inul1 / __Inul;
      __Ipnu = __Inumu * __Ipnu1 / __Inul;
      for ( __i = 1; __i <= __nl; ++__i )
        {
          const _Tp __Knutemp = (__mu + __i) * __xi2 * __Knu1 + __Kmu;
          __Kmu = __Knu1;
          __Knu1 = __Knutemp;
        }
      __Knu = __Kmu;
      __Kpnu = __nu * __xi * __Kmu - __Knu1;

      return;
    }
# 267 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/modified_bessel_func.tcc" 3
    template<typename _Tp>
    _Tp
    __cyl_bessel_i(_Tp __nu, _Tp __x)
    {
      if (__nu < _Tp(0) || __x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __cyl_bessel_i.")
                                                           );
      else if (__isnan(__nu) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x * __x < _Tp(10) * (__nu + _Tp(1)))
        return __cyl_bessel_ij_series(__nu, __x, +_Tp(1), 200);
      else
        {
          _Tp __I_nu, __K_nu, __Ip_nu, __Kp_nu;
          __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
          return __I_nu;
        }
    }
# 303 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/modified_bessel_func.tcc" 3
    template<typename _Tp>
    _Tp
    __cyl_bessel_k(_Tp __nu, _Tp __x)
    {
      if (__nu < _Tp(0) || __x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __cyl_bessel_k.")
                                                           );
      else if (__isnan(__nu) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        {
          _Tp __I_nu, __K_nu, __Ip_nu, __Kp_nu;
          __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
          return __K_nu;
        }
    }
# 337 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/modified_bessel_func.tcc" 3
    template <typename _Tp>
    void
    __sph_bessel_ik(unsigned int __n, _Tp __x,
                    _Tp & __i_n, _Tp & __k_n, _Tp & __ip_n, _Tp & __kp_n)
    {
      const _Tp __nu = _Tp(__n) + _Tp(0.5L);

      _Tp __I_nu, __Ip_nu, __K_nu, __Kp_nu;
      __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);

      const _Tp __factor = __numeric_constants<_Tp>::__sqrtpio2()
                         / std::sqrt(__x);

      __i_n = __factor * __I_nu;
      __k_n = __factor * __K_nu;
      __ip_n = __factor * __Ip_nu - __i_n / (_Tp(2) * __x);
      __kp_n = __factor * __Kp_nu - __k_n / (_Tp(2) * __x);

      return;
    }
# 373 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/modified_bessel_func.tcc" 3
    template <typename _Tp>
    void
    __airy(_Tp __x, _Tp & __Ai, _Tp & __Bi, _Tp & __Aip, _Tp & __Bip)
    {
      const _Tp __absx = std::abs(__x);
      const _Tp __rootx = std::sqrt(__absx);
      const _Tp __z = _Tp(2) * __absx * __rootx / _Tp(3);
      const _Tp _S_inf = std::numeric_limits<_Tp>::infinity();

      if (__isnan(__x))
        __Bip = __Aip = __Bi = __Ai = std::numeric_limits<_Tp>::quiet_NaN();
      else if (__z == _S_inf)
        {
   __Aip = __Ai = _Tp(0);
   __Bip = __Bi = _S_inf;
 }
      else if (__z == -_S_inf)
 __Bip = __Aip = __Bi = __Ai = _Tp(0);
      else if (__x > _Tp(0))
        {
          _Tp __I_nu, __Ip_nu, __K_nu, __Kp_nu;

          __bessel_ik(_Tp(1) / _Tp(3), __z, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
          __Ai = __rootx * __K_nu
               / (__numeric_constants<_Tp>::__sqrt3()
                * __numeric_constants<_Tp>::__pi());
          __Bi = __rootx * (__K_nu / __numeric_constants<_Tp>::__pi()
                 + _Tp(2) * __I_nu / __numeric_constants<_Tp>::__sqrt3());

          __bessel_ik(_Tp(2) / _Tp(3), __z, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
          __Aip = -__x * __K_nu
                / (__numeric_constants<_Tp>::__sqrt3()
                 * __numeric_constants<_Tp>::__pi());
          __Bip = __x * (__K_nu / __numeric_constants<_Tp>::__pi()
                      + _Tp(2) * __I_nu
                      / __numeric_constants<_Tp>::__sqrt3());
        }
      else if (__x < _Tp(0))
        {
          _Tp __J_nu, __Jp_nu, __N_nu, __Np_nu;

          __bessel_jn(_Tp(1) / _Tp(3), __z, __J_nu, __N_nu, __Jp_nu, __Np_nu);
          __Ai = __rootx * (__J_nu
                    - __N_nu / __numeric_constants<_Tp>::__sqrt3()) / _Tp(2);
          __Bi = -__rootx * (__N_nu
                    + __J_nu / __numeric_constants<_Tp>::__sqrt3()) / _Tp(2);

          __bessel_jn(_Tp(2) / _Tp(3), __z, __J_nu, __N_nu, __Jp_nu, __Np_nu);
          __Aip = __absx * (__N_nu / __numeric_constants<_Tp>::__sqrt3()
                          + __J_nu) / _Tp(2);
          __Bip = __absx * (__J_nu / __numeric_constants<_Tp>::__sqrt3()
                          - __N_nu) / _Tp(2);
        }
      else
        {



          __Ai = _Tp(0.35502805388781723926L);
          __Bi = __Ai * __numeric_constants<_Tp>::__sqrt3();




          __Aip = -_Tp(0.25881940379280679840L);
          __Bip = -__Aip * __numeric_constants<_Tp>::__sqrt3();
        }

      return;
    }
  }





}
# 55 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 2 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/poly_hermite.tcc" 1 3
# 42 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/poly_hermite.tcc" 3
namespace std
{

# 56 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/poly_hermite.tcc" 3
  namespace __detail
  {
# 72 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/poly_hermite.tcc" 3
    template<typename _Tp>
    _Tp
    __poly_hermite_recursion(unsigned int __n, _Tp __x)
    {

      _Tp __H_0 = 1;
      if (__n == 0)
        return __H_0;


      _Tp __H_1 = 2 * __x;
      if (__n == 1)
        return __H_1;


      _Tp __H_n, __H_nm1, __H_nm2;
      unsigned int __i;
      for (__H_nm2 = __H_0, __H_nm1 = __H_1, __i = 2; __i <= __n; ++__i)
        {
          __H_n = 2 * (__x * __H_nm1 - (__i - 1) * __H_nm2);
          __H_nm2 = __H_nm1;
          __H_nm1 = __H_n;
        }

      return __H_n;
    }
# 114 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/poly_hermite.tcc" 3
    template<typename _Tp>
    inline _Tp
    __poly_hermite(unsigned int __n, _Tp __x)
    {
      if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return __poly_hermite_recursion(__n, __x);
    }
  }





}
# 56 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 2 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/poly_laguerre.tcc" 1 3
# 44 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/poly_laguerre.tcc" 3
namespace std
{

# 60 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/poly_laguerre.tcc" 3
  namespace __detail
  {
# 75 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/poly_laguerre.tcc" 3
    template<typename _Tpa, typename _Tp>
    _Tp
    __poly_laguerre_large_n(unsigned __n, _Tpa __alpha1, _Tp __x)
    {
      const _Tp __a = -_Tp(__n);
      const _Tp __b = _Tp(__alpha1) + _Tp(1);
      const _Tp __eta = _Tp(2) * __b - _Tp(4) * __a;
      const _Tp __cos2th = __x / __eta;
      const _Tp __sin2th = _Tp(1) - __cos2th;
      const _Tp __th = std::acos(std::sqrt(__cos2th));
      const _Tp __pre_h = __numeric_constants<_Tp>::__pi_2()
                        * __numeric_constants<_Tp>::__pi_2()
                        * __eta * __eta * __cos2th * __sin2th;


      const _Tp __lg_b = ::std::lgamma(_Tp(__n) + __b);
      const _Tp __lnfact = ::std::lgamma(_Tp(__n + 1));





      _Tp __pre_term1 = _Tp(0.5L) * (_Tp(1) - __b)
                      * std::log(_Tp(0.25L) * __x * __eta);
      _Tp __pre_term2 = _Tp(0.25L) * std::log(__pre_h);
      _Tp __lnpre = __lg_b - __lnfact + _Tp(0.5L) * __x
                      + __pre_term1 - __pre_term2;
      _Tp __ser_term1 = std::sin(__a * __numeric_constants<_Tp>::__pi());
      _Tp __ser_term2 = std::sin(_Tp(0.25L) * __eta
                              * (_Tp(2) * __th
                               - std::sin(_Tp(2) * __th))
                               + __numeric_constants<_Tp>::__pi_4());
      _Tp __ser = __ser_term1 + __ser_term2;

      return std::exp(__lnpre) * __ser;
    }
# 129 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/poly_laguerre.tcc" 3
    template<typename _Tpa, typename _Tp>
    _Tp
    __poly_laguerre_hyperg(unsigned int __n, _Tpa __alpha1, _Tp __x)
    {
      const _Tp __b = _Tp(__alpha1) + _Tp(1);
      const _Tp __mx = -__x;
      const _Tp __tc_sgn = (__x < _Tp(0) ? _Tp(1)
                         : ((__n % 2 == 1) ? -_Tp(1) : _Tp(1)));

      _Tp __tc = _Tp(1);
      const _Tp __ax = std::abs(__x);
      for (unsigned int __k = 1; __k <= __n; ++__k)
        __tc *= (__ax / __k);

      _Tp __term = __tc * __tc_sgn;
      _Tp __sum = __term;
      for (int __k = int(__n) - 1; __k >= 0; --__k)
        {
          __term *= ((__b + _Tp(__k)) / _Tp(int(__n) - __k))
                  * _Tp(__k + 1) / __mx;
          __sum += __term;
        }

      return __sum;
    }
# 185 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/poly_laguerre.tcc" 3
    template<typename _Tpa, typename _Tp>
    _Tp
    __poly_laguerre_recursion(unsigned int __n, _Tpa __alpha1, _Tp __x)
    {

      _Tp __l_0 = _Tp(1);
      if (__n == 0)
        return __l_0;


      _Tp __l_1 = -__x + _Tp(1) + _Tp(__alpha1);
      if (__n == 1)
        return __l_1;


      _Tp __l_n2 = __l_0;
      _Tp __l_n1 = __l_1;
      _Tp __l_n = _Tp(0);
      for (unsigned int __nn = 2; __nn <= __n; ++__nn)
        {
            __l_n = (_Tp(2 * __nn - 1) + _Tp(__alpha1) - __x)
                  * __l_n1 / _Tp(__nn)
                  - (_Tp(__nn - 1) + _Tp(__alpha1)) * __l_n2 / _Tp(__nn);
            __l_n2 = __l_n1;
            __l_n1 = __l_n;
        }

      return __l_n;
    }
# 244 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/poly_laguerre.tcc" 3
    template<typename _Tpa, typename _Tp>
    _Tp
    __poly_laguerre(unsigned int __n, _Tpa __alpha1, _Tp __x)
    {
      if (__x < _Tp(0))
        std::__throw_domain_error(("Negative argument " "in __poly_laguerre.")
                                                            );

      else if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__n == 0)
        return _Tp(1);
      else if (__n == 1)
        return _Tp(1) + _Tp(__alpha1) - __x;
      else if (__x == _Tp(0))
        {
          _Tp __prod = _Tp(__alpha1) + _Tp(1);
          for (unsigned int __k = 2; __k <= __n; ++__k)
            __prod *= (_Tp(__alpha1) + _Tp(__k)) / _Tp(__k);
          return __prod;
        }
      else if (__n > 10000000 && _Tp(__alpha1) > -_Tp(1)
            && __x < _Tp(2) * (_Tp(__alpha1) + _Tp(1)) + _Tp(4 * __n))
        return __poly_laguerre_large_n(__n, __alpha1, __x);
      else if (_Tp(__alpha1) >= _Tp(0)
           || (__x > _Tp(0) && _Tp(__alpha1) < -_Tp(__n + 1)))
        return __poly_laguerre_recursion(__n, __alpha1, __x);
      else
        return __poly_laguerre_hyperg(__n, __alpha1, __x);
    }
# 296 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/poly_laguerre.tcc" 3
    template<typename _Tp>
    inline _Tp
    __assoc_laguerre(unsigned int __n, unsigned int __m, _Tp __x)
    { return __poly_laguerre<unsigned int, _Tp>(__n, __m, __x); }
# 316 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/poly_laguerre.tcc" 3
    template<typename _Tp>
    inline _Tp
    __laguerre(unsigned int __n, _Tp __x)
    { return __poly_laguerre<unsigned int, _Tp>(__n, 0, __x); }
  }






}
# 57 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 2 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/riemann_zeta.tcc" 1 3
# 47 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/riemann_zeta.tcc" 3
namespace std
{

# 63 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/riemann_zeta.tcc" 3
  namespace __detail
  {
# 78 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __riemann_zeta_sum(_Tp __s)
    {

      if (__s < _Tp(1))
        std::__throw_domain_error(("Bad argument in zeta sum."));

      const unsigned int max_iter = 10000;
      _Tp __zeta = _Tp(0);
      for (unsigned int __k = 1; __k < max_iter; ++__k)
        {
          _Tp __term = std::pow(static_cast<_Tp>(__k), -__s);
          if (__term < std::numeric_limits<_Tp>::epsilon())
            {
              break;
            }
          __zeta += __term;
        }

      return __zeta;
    }
# 115 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __riemann_zeta_alt(_Tp __s)
    {
      _Tp __sgn = _Tp(1);
      _Tp __zeta = _Tp(0);
      for (unsigned int __i = 1; __i < 10000000; ++__i)
        {
          _Tp __term = __sgn / std::pow(__i, __s);
          if (std::abs(__term) < std::numeric_limits<_Tp>::epsilon())
            break;
          __zeta += __term;
          __sgn *= _Tp(-1);
        }
      __zeta /= _Tp(1) - std::pow(_Tp(2), _Tp(1) - __s);

      return __zeta;
    }
# 157 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __riemann_zeta_glob(_Tp __s)
    {
      _Tp __zeta = _Tp(0);

      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      const _Tp __max_bincoeff = std::numeric_limits<_Tp>::max_exponent10
                               * std::log(_Tp(10)) - _Tp(1);



      if (__s < _Tp(0))
        {

          if (::std::fmod(__s,_Tp(2)) == _Tp(0))
            return _Tp(0);
          else

            {
              _Tp __zeta = __riemann_zeta_glob(_Tp(1) - __s);
              __zeta *= std::pow(_Tp(2)
                     * __numeric_constants<_Tp>::__pi(), __s)
                     * std::sin(__numeric_constants<_Tp>::__pi_2() * __s)

                     * std::exp(::std::lgamma(_Tp(1) - __s))



                     / __numeric_constants<_Tp>::__pi();
              return __zeta;
            }
        }

      _Tp __num = _Tp(0.5L);
      const unsigned int __maxit = 10000;
      for (unsigned int __i = 0; __i < __maxit; ++__i)
        {
          bool __punt = false;
          _Tp __sgn = _Tp(1);
          _Tp __term = _Tp(0);
          for (unsigned int __j = 0; __j <= __i; ++__j)
            {

              _Tp __bincoeff = ::std::lgamma(_Tp(1 + __i))
                              - ::std::lgamma(_Tp(1 + __j))
                              - ::std::lgamma(_Tp(1 + __i - __j));





              if (__bincoeff > __max_bincoeff)
                {

                  __punt = true;
                  break;
                }
              __bincoeff = std::exp(__bincoeff);
              __term += __sgn * __bincoeff * std::pow(_Tp(1 + __j), -__s);
              __sgn *= _Tp(-1);
            }
          if (__punt)
            break;
          __term *= __num;
          __zeta += __term;
          if (std::abs(__term/__zeta) < __eps)
            break;
          __num *= _Tp(0.5L);
        }

      __zeta /= _Tp(1) - std::pow(_Tp(2), _Tp(1) - __s);

      return __zeta;
    }
# 252 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __riemann_zeta_product(_Tp __s)
    {
      static const _Tp __prime[] = {
        _Tp(2), _Tp(3), _Tp(5), _Tp(7), _Tp(11), _Tp(13), _Tp(17), _Tp(19),
        _Tp(23), _Tp(29), _Tp(31), _Tp(37), _Tp(41), _Tp(43), _Tp(47),
        _Tp(53), _Tp(59), _Tp(61), _Tp(67), _Tp(71), _Tp(73), _Tp(79),
        _Tp(83), _Tp(89), _Tp(97), _Tp(101), _Tp(103), _Tp(107), _Tp(109)
      };
      static const unsigned int __num_primes = sizeof(__prime) / sizeof(_Tp);

      _Tp __zeta = _Tp(1);
      for (unsigned int __i = 0; __i < __num_primes; ++__i)
        {
          const _Tp __fact = _Tp(1) - std::pow(__prime[__i], -__s);
          __zeta *= __fact;
          if (_Tp(1) - __fact < std::numeric_limits<_Tp>::epsilon())
            break;
        }

      __zeta = _Tp(1) / __zeta;

      return __zeta;
    }
# 293 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __riemann_zeta(_Tp __s)
    {
      if (__isnan(__s))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__s == _Tp(1))
        return std::numeric_limits<_Tp>::infinity();
      else if (__s < -_Tp(19))
        {
          _Tp __zeta = __riemann_zeta_product(_Tp(1) - __s);
          __zeta *= std::pow(_Tp(2) * __numeric_constants<_Tp>::__pi(), __s)
                 * std::sin(__numeric_constants<_Tp>::__pi_2() * __s)

                 * std::exp(::std::lgamma(_Tp(1) - __s))



                 / __numeric_constants<_Tp>::__pi();
          return __zeta;
        }
      else if (__s < _Tp(20))
        {

          bool __glob = true;
          if (__glob)
            return __riemann_zeta_glob(__s);
          else
            {
              if (__s > _Tp(1))
                return __riemann_zeta_sum(__s);
              else
                {
                  _Tp __zeta = std::pow(_Tp(2)
                                * __numeric_constants<_Tp>::__pi(), __s)
                         * std::sin(__numeric_constants<_Tp>::__pi_2() * __s)

                             * ::std::tgamma(_Tp(1) - __s)



                             * __riemann_zeta_sum(_Tp(1) - __s);
                  return __zeta;
                }
            }
        }
      else
        return __riemann_zeta_product(__s);
    }
# 365 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __hurwitz_zeta_glob(_Tp __a, _Tp __s)
    {
      _Tp __zeta = _Tp(0);

      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      const _Tp __max_bincoeff = std::numeric_limits<_Tp>::max_exponent10
                               * std::log(_Tp(10)) - _Tp(1);

      const unsigned int __maxit = 10000;
      for (unsigned int __i = 0; __i < __maxit; ++__i)
        {
          bool __punt = false;
          _Tp __sgn = _Tp(1);
          _Tp __term = _Tp(0);
          for (unsigned int __j = 0; __j <= __i; ++__j)
            {

              _Tp __bincoeff = ::std::lgamma(_Tp(1 + __i))
                              - ::std::lgamma(_Tp(1 + __j))
                              - ::std::lgamma(_Tp(1 + __i - __j));





              if (__bincoeff > __max_bincoeff)
                {

                  __punt = true;
                  break;
                }
              __bincoeff = std::exp(__bincoeff);
              __term += __sgn * __bincoeff * std::pow(_Tp(__a + __j), -__s);
              __sgn *= _Tp(-1);
            }
          if (__punt)
            break;
          __term /= _Tp(__i + 1);
          if (std::abs(__term / __zeta) < __eps)
            break;
          __zeta += __term;
        }

      __zeta /= __s - _Tp(1);

      return __zeta;
    }
# 430 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    inline _Tp
    __hurwitz_zeta(_Tp __a, _Tp __s)
    { return __hurwitz_zeta_glob(__a, __s); }
  }






}
# 58 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 2 3

namespace std
{

# 203 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  inline float
  assoc_laguerref(unsigned int __n, unsigned int __m, float __x)
  { return __detail::__assoc_laguerre<float>(__n, __m, __x); }







  inline long double
  assoc_laguerrel(unsigned int __n, unsigned int __m, long double __x)
  { return __detail::__assoc_laguerre<long double>(__n, __m, __x); }
# 248 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    assoc_laguerre(unsigned int __n, unsigned int __m, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__assoc_laguerre<__type>(__n, __m, __x);
    }
# 264 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  inline float
  assoc_legendref(unsigned int __l, unsigned int __m, float __x)
  { return __detail::__assoc_legendre_p<float>(__l, __m, __x); }






  inline long double
  assoc_legendrel(unsigned int __l, unsigned int __m, long double __x)
  { return __detail::__assoc_legendre_p<long double>(__l, __m, __x); }
# 294 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    assoc_legendre(unsigned int __l, unsigned int __m, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__assoc_legendre_p<__type>(__l, __m, __x);
    }
# 309 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  inline float
  betaf(float __a, float __b)
  { return __detail::__beta<float>(__a, __b); }







  inline long double
  betal(long double __a, long double __b)
  { return __detail::__beta<long double>(__a, __b); }
# 339 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  template<typename _Tpa, typename _Tpb>
    inline typename __gnu_cxx::__promote_2<_Tpa, _Tpb>::__type
    beta(_Tpa __a, _Tpb __b)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpa, _Tpb>::__type __type;
      return __detail::__beta<__type>(__a, __b);
    }
# 355 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  inline float
  comp_ellint_1f(float __k)
  { return __detail::__comp_ellint_1<float>(__k); }







  inline long double
  comp_ellint_1l(long double __k)
  { return __detail::__comp_ellint_1<long double>(__k); }
# 387 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    comp_ellint_1(_Tp __k)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__comp_ellint_1<__type>(__k);
    }
# 403 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  inline float
  comp_ellint_2f(float __k)
  { return __detail::__comp_ellint_2<float>(__k); }







  inline long double
  comp_ellint_2l(long double __k)
  { return __detail::__comp_ellint_2<long double>(__k); }
# 434 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    comp_ellint_2(_Tp __k)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__comp_ellint_2<__type>(__k);
    }
# 450 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  inline float
  comp_ellint_3f(float __k, float __nu)
  { return __detail::__comp_ellint_3<float>(__k, __nu); }







  inline long double
  comp_ellint_3l(long double __k, long double __nu)
  { return __detail::__comp_ellint_3<long double>(__k, __nu); }
# 485 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  template<typename _Tp, typename _Tpn>
    inline typename __gnu_cxx::__promote_2<_Tp, _Tpn>::__type
    comp_ellint_3(_Tp __k, _Tpn __nu)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Tpn>::__type __type;
      return __detail::__comp_ellint_3<__type>(__k, __nu);
    }
# 501 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  inline float
  cyl_bessel_if(float __nu, float __x)
  { return __detail::__cyl_bessel_i<float>(__nu, __x); }







  inline long double
  cyl_bessel_il(long double __nu, long double __x)
  { return __detail::__cyl_bessel_i<long double>(__nu, __x); }
# 531 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  template<typename _Tpnu, typename _Tp>
    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
    cyl_bessel_i(_Tpnu __nu, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
      return __detail::__cyl_bessel_i<__type>(__nu, __x);
    }
# 547 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  inline float
  cyl_bessel_jf(float __nu, float __x)
  { return __detail::__cyl_bessel_j<float>(__nu, __x); }







  inline long double
  cyl_bessel_jl(long double __nu, long double __x)
  { return __detail::__cyl_bessel_j<long double>(__nu, __x); }
# 577 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  template<typename _Tpnu, typename _Tp>
    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
    cyl_bessel_j(_Tpnu __nu, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
      return __detail::__cyl_bessel_j<__type>(__nu, __x);
    }
# 593 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  inline float
  cyl_bessel_kf(float __nu, float __x)
  { return __detail::__cyl_bessel_k<float>(__nu, __x); }







  inline long double
  cyl_bessel_kl(long double __nu, long double __x)
  { return __detail::__cyl_bessel_k<long double>(__nu, __x); }
# 629 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  template<typename _Tpnu, typename _Tp>
    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
    cyl_bessel_k(_Tpnu __nu, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
      return __detail::__cyl_bessel_k<__type>(__nu, __x);
    }
# 645 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  inline float
  cyl_neumannf(float __nu, float __x)
  { return __detail::__cyl_neumann_n<float>(__nu, __x); }







  inline long double
  cyl_neumannl(long double __nu, long double __x)
  { return __detail::__cyl_neumann_n<long double>(__nu, __x); }
# 677 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  template<typename _Tpnu, typename _Tp>
    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
    cyl_neumann(_Tpnu __nu, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
      return __detail::__cyl_neumann_n<__type>(__nu, __x);
    }
# 693 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  inline float
  ellint_1f(float __k, float __phi)
  { return __detail::__ellint_1<float>(__k, __phi); }







  inline long double
  ellint_1l(long double __k, long double __phi)
  { return __detail::__ellint_1<long double>(__k, __phi); }
# 725 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  template<typename _Tp, typename _Tpp>
    inline typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type
    ellint_1(_Tp __k, _Tpp __phi)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type __type;
      return __detail::__ellint_1<__type>(__k, __phi);
    }
# 741 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  inline float
  ellint_2f(float __k, float __phi)
  { return __detail::__ellint_2<float>(__k, __phi); }







  inline long double
  ellint_2l(long double __k, long double __phi)
  { return __detail::__ellint_2<long double>(__k, __phi); }
# 773 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  template<typename _Tp, typename _Tpp>
    inline typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type
    ellint_2(_Tp __k, _Tpp __phi)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type __type;
      return __detail::__ellint_2<__type>(__k, __phi);
    }
# 789 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  inline float
  ellint_3f(float __k, float __nu, float __phi)
  { return __detail::__ellint_3<float>(__k, __nu, __phi); }







  inline long double
  ellint_3l(long double __k, long double __nu, long double __phi)
  { return __detail::__ellint_3<long double>(__k, __nu, __phi); }
# 826 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  template<typename _Tp, typename _Tpn, typename _Tpp>
    inline typename __gnu_cxx::__promote_3<_Tp, _Tpn, _Tpp>::__type
    ellint_3(_Tp __k, _Tpn __nu, _Tpp __phi)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Tpn, _Tpp>::__type __type;
      return __detail::__ellint_3<__type>(__k, __nu, __phi);
    }
# 841 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  inline float
  expintf(float __x)
  { return __detail::__expint<float>(__x); }







  inline long double
  expintl(long double __x)
  { return __detail::__expint<long double>(__x); }
# 866 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    expint(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__expint<__type>(__x);
    }
# 882 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  inline float
  hermitef(unsigned int __n, float __x)
  { return __detail::__poly_hermite<float>(__n, __x); }







  inline long double
  hermitel(unsigned int __n, long double __x)
  { return __detail::__poly_hermite<long double>(__n, __x); }
# 914 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    hermite(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__poly_hermite<__type>(__n, __x);
    }
# 930 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  inline float
  laguerref(unsigned int __n, float __x)
  { return __detail::__laguerre<float>(__n, __x); }







  inline long double
  laguerrel(unsigned int __n, long double __x)
  { return __detail::__laguerre<long double>(__n, __x); }
# 958 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    laguerre(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__laguerre<__type>(__n, __x);
    }
# 974 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  inline float
  legendref(unsigned int __l, float __x)
  { return __detail::__poly_legendre_p<float>(__l, __x); }







  inline long double
  legendrel(unsigned int __l, long double __x)
  { return __detail::__poly_legendre_p<long double>(__l, __x); }
# 1003 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    legendre(unsigned int __l, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__poly_legendre_p<__type>(__l, __x);
    }
# 1019 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  inline float
  riemann_zetaf(float __s)
  { return __detail::__riemann_zeta<float>(__s); }







  inline long double
  riemann_zetal(long double __s)
  { return __detail::__riemann_zeta<long double>(__s); }
# 1054 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    riemann_zeta(_Tp __s)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__riemann_zeta<__type>(__s);
    }
# 1070 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  inline float
  sph_besself(unsigned int __n, float __x)
  { return __detail::__sph_bessel<float>(__n, __x); }







  inline long double
  sph_bessell(unsigned int __n, long double __x)
  { return __detail::__sph_bessel<long double>(__n, __x); }
# 1098 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    sph_bessel(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__sph_bessel<__type>(__n, __x);
    }
# 1114 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  inline float
  sph_legendref(unsigned int __l, unsigned int __m, float __theta)
  { return __detail::__sph_legendre<float>(__l, __m, __theta); }
# 1125 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  inline long double
  sph_legendrel(unsigned int __l, unsigned int __m, long double __theta)
  { return __detail::__sph_legendre<long double>(__l, __m, __theta); }
# 1145 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    sph_legendre(unsigned int __l, unsigned int __m, _Tp __theta)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__sph_legendre<__type>(__l, __m, __theta);
    }
# 1161 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  inline float
  sph_neumannf(unsigned int __n, float __x)
  { return __detail::__sph_neumann<float>(__n, __x); }







  inline long double
  sph_neumannl(unsigned int __n, long double __x)
  { return __detail::__sph_neumann<long double>(__n, __x); }
# 1189 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    sph_neumann(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__sph_neumann<__type>(__n, __x);
    }




}


namespace __gnu_cxx
{

# 1216 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  inline float
  airy_aif(float __x)
  {
    float __Ai, __Bi, __Aip, __Bip;
    std::__detail::__airy<float>(__x, __Ai, __Bi, __Aip, __Bip);
    return __Ai;
  }




  inline long double
  airy_ail(long double __x)
  {
    long double __Ai, __Bi, __Aip, __Bip;
    std::__detail::__airy<long double>(__x, __Ai, __Bi, __Aip, __Bip);
    return __Ai;
  }




  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    airy_ai(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      __type __Ai, __Bi, __Aip, __Bip;
      std::__detail::__airy<__type>(__x, __Ai, __Bi, __Aip, __Bip);
      return __Ai;
    }




  inline float
  airy_bif(float __x)
  {
    float __Ai, __Bi, __Aip, __Bip;
    std::__detail::__airy<float>(__x, __Ai, __Bi, __Aip, __Bip);
    return __Bi;
  }




  inline long double
  airy_bil(long double __x)
  {
    long double __Ai, __Bi, __Aip, __Bip;
    std::__detail::__airy<long double>(__x, __Ai, __Bi, __Aip, __Bip);
    return __Bi;
  }




  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    airy_bi(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      __type __Ai, __Bi, __Aip, __Bip;
      std::__detail::__airy<__type>(__x, __Ai, __Bi, __Aip, __Bip);
      return __Bi;
    }
# 1292 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  inline float
  conf_hypergf(float __a, float __c, float __x)
  { return std::__detail::__conf_hyperg<float>(__a, __c, __x); }
# 1303 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  inline long double
  conf_hypergl(long double __a, long double __c, long double __x)
  { return std::__detail::__conf_hyperg<long double>(__a, __c, __x); }
# 1323 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  template<typename _Tpa, typename _Tpc, typename _Tp>
    inline typename __gnu_cxx::__promote_3<_Tpa, _Tpc, _Tp>::__type
    conf_hyperg(_Tpa __a, _Tpc __c, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_3<_Tpa, _Tpc, _Tp>::__type __type;
      return std::__detail::__conf_hyperg<__type>(__a, __c, __x);
    }
# 1340 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  inline float
  hypergf(float __a, float __b, float __c, float __x)
  { return std::__detail::__hyperg<float>(__a, __b, __c, __x); }
# 1351 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  inline long double
  hypergl(long double __a, long double __b, long double __c, long double __x)
  { return std::__detail::__hyperg<long double>(__a, __b, __c, __x); }
# 1372 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/specfun.h" 3
  template<typename _Tpa, typename _Tpb, typename _Tpc, typename _Tp>
    inline typename __gnu_cxx::__promote_4<_Tpa, _Tpb, _Tpc, _Tp>::__type
    hyperg(_Tpa __a, _Tpb __b, _Tpc __c, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_4<_Tpa, _Tpb, _Tpc, _Tp>
  ::__type __type;
      return std::__detail::__hyperg<__type>(__a, __b, __c, __x);
    }



}
# 3899 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 2 3


}
# 2 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/_fixes.hpp" 2
# 105 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/glm.hpp" 2

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/setup.hpp" 1


# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cassert" 1 3
# 41 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cassert" 3
       
# 42 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cassert" 3


# 1 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/assert.h" 1 3
# 17 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/assert.h" 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/stdlib.h" 1 3
# 36 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/stdlib.h" 3
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cstdlib" 1 3
# 39 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cstdlib" 3
       
# 40 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cstdlib" 3
# 125 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cstdlib" 3
extern "C++"
{
namespace std
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;



  using ::atexit;





  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;





  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;



  inline ldiv_t
  div(long __i, long __j) noexcept { return ldiv(__i, __j); }




}
# 199 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cstdlib" 3
namespace __gnu_cxx
{



  using ::lldiv_t;





  using ::_Exit;



  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 231 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}
# 275 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cstdlib" 3
}
# 37 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/stdlib.h" 2 3

using std::abort;
using std::atexit;
using std::exit;
# 49 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/stdlib.h" 3
  using std::_Exit;




using std::div_t;
using std::ldiv_t;

using std::abs;
using std::atof;
using std::atoi;
using std::atol;
using std::bsearch;
using std::calloc;
using std::div;
using std::free;
using std::getenv;
using std::labs;
using std::ldiv;
using std::malloc;

using std::mblen;
using std::mbstowcs;
using std::mbtowc;

using std::qsort;
using std::rand;
using std::realloc;
using std::srand;
using std::strtod;
using std::strtol;
using std::strtoul;
using std::system;

using std::wcstombs;
using std::wctomb;
# 18 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/assert.h" 2 3



extern "C" {


__attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) __attribute__ ((__noreturn__)) _wassert(const wchar_t *_Message,const wchar_t *_File,unsigned _Line);
__attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) __attribute__ ((__noreturn__)) _assert (const char *_Message, const char *_File, unsigned _Line);


}
# 45 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cassert" 2 3
# 4 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/setup.hpp" 2
# 43 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/setup.hpp"
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/simd/platform.h" 1
       
# 44 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/setup.hpp" 2
# 632 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/setup.hpp"

# 632 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/setup.hpp"
namespace glm
{
 using std::size_t;



  typedef int length_t;

}







 namespace glm
 {
  template<typename T, std::size_t N>
  constexpr std::size_t countof(T const (&)[N])
  {
   return N;
  }
 }
# 670 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/setup.hpp"
namespace glm{
namespace detail
{
 template<typename T>
 struct is_int
 {
  enum test {value = 0};
 };

 template<>
 struct is_int<unsigned int>
 {
  enum test {value = ~0};
 };

 template<>
 struct is_int<signed int>
 {
  enum test {value = ~0};
 };
}

 typedef unsigned int uint;
}
# 702 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/setup.hpp"
namespace glm{
namespace detail
{

  typedef std::uint64_t uint64;
  typedef std::int64_t int64;
# 726 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/setup.hpp"
}
}







namespace glm{
namespace detail
{
 using std::make_unsigned;
}
}
# 107 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/glm.hpp" 2

       

# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 1 3
# 39 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 3
       
# 40 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 3
# 111 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/glm.hpp" 2
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/climits" 1 3
# 39 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/climits" 3
       
# 40 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/climits" 3


# 1 "D:/Enviroments/mingw64_msvcrt/lib/gcc/x86_64-w64-mingw32/14.2.0/include/limits.h" 1 3 4
# 43 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/climits" 2 3
# 112 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/glm.hpp" 2
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cfloat" 1 3
# 39 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cfloat" 3
       
# 40 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cfloat" 3


# 1 "D:/Enviroments/mingw64_msvcrt/lib/gcc/x86_64-w64-mingw32/14.2.0/include/float.h" 1 3 4
# 632 "D:/Enviroments/mingw64_msvcrt/lib/gcc/x86_64-w64-mingw32/14.2.0/include/float.h" 3 4
# 1 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/float.h" 1 3 4
# 255 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/float.h" 3 4

# 255 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/float.h" 3 4
extern "C" {





__attribute__ ((__dllimport__)) unsigned int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _controlfp (unsigned int _NewValue, unsigned int _Mask) ;
__attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _controlfp_s(unsigned int *_CurrentState, unsigned int _NewValue, unsigned int _Mask);
__attribute__ ((__dllimport__)) unsigned int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _control87 (unsigned int _NewValue, unsigned int _Mask);


__attribute__ ((__dllimport__)) unsigned int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _clearfp (void);
__attribute__ ((__dllimport__)) unsigned int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _statusfp (void);
# 281 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/float.h" 3 4
void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fpreset (void);

void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fpreset (void);



__attribute__ ((__dllimport__)) int * __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __fpecode(void);
# 312 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/float.h" 3 4
}
# 633 "D:/Enviroments/mingw64_msvcrt/lib/gcc/x86_64-w64-mingw32/14.2.0/include/float.h" 2 3 4
# 43 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cfloat" 2 3
# 113 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/glm.hpp" 2

# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cassert" 1 3
# 41 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cassert" 3
       
# 42 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cassert" 3


# 1 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/assert.h" 1 3
# 45 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cassert" 2 3
# 115 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/glm.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/fwd.hpp" 1
       

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/qualifier.hpp" 1
       

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/setup.hpp" 1
# 4 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/qualifier.hpp" 2


# 5 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/qualifier.hpp"
namespace glm
{

 enum qualifier
 {
  packed_highp,
  packed_mediump,
  packed_lowp,
# 21 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/qualifier.hpp"
  highp = packed_highp,
  mediump = packed_mediump,
  lowp = packed_lowp,
  packed = packed_highp,




   defaultp = highp

 };

 typedef qualifier precision;

 template<length_t L, typename T, qualifier Q = defaultp> struct vec;
 template<length_t C, length_t R, typename T, qualifier Q = defaultp> struct mat;
 template<typename T, qualifier Q = defaultp> struct qua;


  template <typename T, qualifier Q = defaultp> using tvec1 = vec<1, T, Q>;
  template <typename T, qualifier Q = defaultp> using tvec2 = vec<2, T, Q>;
  template <typename T, qualifier Q = defaultp> using tvec3 = vec<3, T, Q>;
  template <typename T, qualifier Q = defaultp> using tvec4 = vec<4, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat2x2 = mat<2, 2, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat2x3 = mat<2, 3, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat2x4 = mat<2, 4, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat3x2 = mat<3, 2, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat3x3 = mat<3, 3, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat3x4 = mat<3, 4, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat4x2 = mat<4, 2, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat4x3 = mat<4, 3, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat4x4 = mat<4, 4, T, Q>;
  template <typename T, qualifier Q = defaultp> using tquat = qua<T, Q>;


namespace detail
{
 template<glm::qualifier P>
 struct is_aligned
 {
  static const bool value = false;
 };
# 84 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/qualifier.hpp"
 template<length_t L, typename T, bool is_aligned>
 struct storage
 {
  typedef struct type {
   T data[L];
  } type;
 };


  template<length_t L, typename T>
  struct storage<L, T, true>
  {
   typedef struct alignas(L * sizeof(T)) type {
    T data[L];
   } type;
  };

  template<typename T>
  struct storage<3, T, true>
  {
   typedef struct alignas(4 * sizeof(T)) type {
    T data[4];
   } type;
  };
# 189 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/qualifier.hpp"
 enum genTypeEnum
 {
  GENTYPE_VEC,
  GENTYPE_MAT,
  GENTYPE_QUAT
 };

 template <typename genType>
 struct genTypeTrait
 {};

 template <length_t C, length_t R, typename T>
 struct genTypeTrait<mat<C, R, T> >
 {
  static const genTypeEnum GENTYPE = GENTYPE_MAT;
 };

 template<typename genType, genTypeEnum type>
 struct init_gentype
 {
 };

 template<typename genType>
 struct init_gentype<genType, GENTYPE_QUAT>
 {
  inline constexpr static genType identity()
  {
   return genType(1, 0, 0, 0);
  }
 };

 template<typename genType>
 struct init_gentype<genType, GENTYPE_MAT>
 {
  inline constexpr static genType identity()
  {
   return genType(1);
  }
 };
}
}
# 4 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/fwd.hpp" 2

namespace glm
{

 typedef std::int8_t int8;
 typedef std::int16_t int16;
 typedef std::int32_t int32;
 typedef std::int64_t int64;

 typedef std::uint8_t uint8;
 typedef std::uint16_t uint16;
 typedef std::uint32_t uint32;
 typedef std::uint64_t uint64;
# 31 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/fwd.hpp"
 typedef int8 lowp_i8;
 typedef int8 mediump_i8;
 typedef int8 highp_i8;
 typedef int8 i8;

 typedef int8 lowp_int8;
 typedef int8 mediump_int8;
 typedef int8 highp_int8;

 typedef int8 lowp_int8_t;
 typedef int8 mediump_int8_t;
 typedef int8 highp_int8_t;
 typedef int8 int8_t;

 typedef int16 lowp_i16;
 typedef int16 mediump_i16;
 typedef int16 highp_i16;
 typedef int16 i16;

 typedef int16 lowp_int16;
 typedef int16 mediump_int16;
 typedef int16 highp_int16;

 typedef int16 lowp_int16_t;
 typedef int16 mediump_int16_t;
 typedef int16 highp_int16_t;
 typedef int16 int16_t;

 typedef int32 lowp_i32;
 typedef int32 mediump_i32;
 typedef int32 highp_i32;
 typedef int32 i32;

 typedef int32 lowp_int32;
 typedef int32 mediump_int32;
 typedef int32 highp_int32;

 typedef int32 lowp_int32_t;
 typedef int32 mediump_int32_t;
 typedef int32 highp_int32_t;
 typedef int32 int32_t;

 typedef int64 lowp_i64;
 typedef int64 mediump_i64;
 typedef int64 highp_i64;
 typedef int64 i64;

 typedef int64 lowp_int64;
 typedef int64 mediump_int64;
 typedef int64 highp_int64;

 typedef int64 lowp_int64_t;
 typedef int64 mediump_int64_t;
 typedef int64 highp_int64_t;
 typedef int64 int64_t;



 typedef unsigned int uint;

 typedef uint8 lowp_u8;
 typedef uint8 mediump_u8;
 typedef uint8 highp_u8;
 typedef uint8 u8;

 typedef uint8 lowp_uint8;
 typedef uint8 mediump_uint8;
 typedef uint8 highp_uint8;

 typedef uint8 lowp_uint8_t;
 typedef uint8 mediump_uint8_t;
 typedef uint8 highp_uint8_t;
 typedef uint8 uint8_t;

 typedef uint16 lowp_u16;
 typedef uint16 mediump_u16;
 typedef uint16 highp_u16;
 typedef uint16 u16;

 typedef uint16 lowp_uint16;
 typedef uint16 mediump_uint16;
 typedef uint16 highp_uint16;

 typedef uint16 lowp_uint16_t;
 typedef uint16 mediump_uint16_t;
 typedef uint16 highp_uint16_t;
 typedef uint16 uint16_t;

 typedef uint32 lowp_u32;
 typedef uint32 mediump_u32;
 typedef uint32 highp_u32;
 typedef uint32 u32;

 typedef uint32 lowp_uint32;
 typedef uint32 mediump_uint32;
 typedef uint32 highp_uint32;

 typedef uint32 lowp_uint32_t;
 typedef uint32 mediump_uint32_t;
 typedef uint32 highp_uint32_t;
 typedef uint32 uint32_t;

 typedef uint64 lowp_u64;
 typedef uint64 mediump_u64;
 typedef uint64 highp_u64;
 typedef uint64 u64;

 typedef uint64 lowp_uint64;
 typedef uint64 mediump_uint64;
 typedef uint64 highp_uint64;

 typedef uint64 lowp_uint64_t;
 typedef uint64 mediump_uint64_t;
 typedef uint64 highp_uint64_t;
 typedef uint64 uint64_t;



 typedef float lowp_f32;
 typedef float mediump_f32;
 typedef float highp_f32;
 typedef float f32;

 typedef float lowp_float32;
 typedef float mediump_float32;
 typedef float highp_float32;
 typedef float float32;

 typedef float lowp_float32_t;
 typedef float mediump_float32_t;
 typedef float highp_float32_t;
 typedef float float32_t;


 typedef double lowp_f64;
 typedef double mediump_f64;
 typedef double highp_f64;
 typedef double f64;

 typedef double lowp_float64;
 typedef double mediump_float64;
 typedef double highp_float64;
 typedef double float64;

 typedef double lowp_float64_t;
 typedef double mediump_float64_t;
 typedef double highp_float64_t;
 typedef double float64_t;



 typedef vec<1, bool, lowp> lowp_bvec1;
 typedef vec<2, bool, lowp> lowp_bvec2;
 typedef vec<3, bool, lowp> lowp_bvec3;
 typedef vec<4, bool, lowp> lowp_bvec4;

 typedef vec<1, bool, mediump> mediump_bvec1;
 typedef vec<2, bool, mediump> mediump_bvec2;
 typedef vec<3, bool, mediump> mediump_bvec3;
 typedef vec<4, bool, mediump> mediump_bvec4;

 typedef vec<1, bool, highp> highp_bvec1;
 typedef vec<2, bool, highp> highp_bvec2;
 typedef vec<3, bool, highp> highp_bvec3;
 typedef vec<4, bool, highp> highp_bvec4;

 typedef vec<1, bool, defaultp> bvec1;
 typedef vec<2, bool, defaultp> bvec2;
 typedef vec<3, bool, defaultp> bvec3;
 typedef vec<4, bool, defaultp> bvec4;



 typedef vec<1, int, lowp> lowp_ivec1;
 typedef vec<2, int, lowp> lowp_ivec2;
 typedef vec<3, int, lowp> lowp_ivec3;
 typedef vec<4, int, lowp> lowp_ivec4;

 typedef vec<1, int, mediump> mediump_ivec1;
 typedef vec<2, int, mediump> mediump_ivec2;
 typedef vec<3, int, mediump> mediump_ivec3;
 typedef vec<4, int, mediump> mediump_ivec4;

 typedef vec<1, int, highp> highp_ivec1;
 typedef vec<2, int, highp> highp_ivec2;
 typedef vec<3, int, highp> highp_ivec3;
 typedef vec<4, int, highp> highp_ivec4;

 typedef vec<1, int, defaultp> ivec1;
 typedef vec<2, int, defaultp> ivec2;
 typedef vec<3, int, defaultp> ivec3;
 typedef vec<4, int, defaultp> ivec4;

 typedef vec<1, i8, lowp> lowp_i8vec1;
 typedef vec<2, i8, lowp> lowp_i8vec2;
 typedef vec<3, i8, lowp> lowp_i8vec3;
 typedef vec<4, i8, lowp> lowp_i8vec4;

 typedef vec<1, i8, mediump> mediump_i8vec1;
 typedef vec<2, i8, mediump> mediump_i8vec2;
 typedef vec<3, i8, mediump> mediump_i8vec3;
 typedef vec<4, i8, mediump> mediump_i8vec4;

 typedef vec<1, i8, highp> highp_i8vec1;
 typedef vec<2, i8, highp> highp_i8vec2;
 typedef vec<3, i8, highp> highp_i8vec3;
 typedef vec<4, i8, highp> highp_i8vec4;

 typedef vec<1, i8, defaultp> i8vec1;
 typedef vec<2, i8, defaultp> i8vec2;
 typedef vec<3, i8, defaultp> i8vec3;
 typedef vec<4, i8, defaultp> i8vec4;

 typedef vec<1, i16, lowp> lowp_i16vec1;
 typedef vec<2, i16, lowp> lowp_i16vec2;
 typedef vec<3, i16, lowp> lowp_i16vec3;
 typedef vec<4, i16, lowp> lowp_i16vec4;

 typedef vec<1, i16, mediump> mediump_i16vec1;
 typedef vec<2, i16, mediump> mediump_i16vec2;
 typedef vec<3, i16, mediump> mediump_i16vec3;
 typedef vec<4, i16, mediump> mediump_i16vec4;

 typedef vec<1, i16, highp> highp_i16vec1;
 typedef vec<2, i16, highp> highp_i16vec2;
 typedef vec<3, i16, highp> highp_i16vec3;
 typedef vec<4, i16, highp> highp_i16vec4;

 typedef vec<1, i16, defaultp> i16vec1;
 typedef vec<2, i16, defaultp> i16vec2;
 typedef vec<3, i16, defaultp> i16vec3;
 typedef vec<4, i16, defaultp> i16vec4;

 typedef vec<1, i32, lowp> lowp_i32vec1;
 typedef vec<2, i32, lowp> lowp_i32vec2;
 typedef vec<3, i32, lowp> lowp_i32vec3;
 typedef vec<4, i32, lowp> lowp_i32vec4;

 typedef vec<1, i32, mediump> mediump_i32vec1;
 typedef vec<2, i32, mediump> mediump_i32vec2;
 typedef vec<3, i32, mediump> mediump_i32vec3;
 typedef vec<4, i32, mediump> mediump_i32vec4;

 typedef vec<1, i32, highp> highp_i32vec1;
 typedef vec<2, i32, highp> highp_i32vec2;
 typedef vec<3, i32, highp> highp_i32vec3;
 typedef vec<4, i32, highp> highp_i32vec4;

 typedef vec<1, i32, defaultp> i32vec1;
 typedef vec<2, i32, defaultp> i32vec2;
 typedef vec<3, i32, defaultp> i32vec3;
 typedef vec<4, i32, defaultp> i32vec4;

 typedef vec<1, i64, lowp> lowp_i64vec1;
 typedef vec<2, i64, lowp> lowp_i64vec2;
 typedef vec<3, i64, lowp> lowp_i64vec3;
 typedef vec<4, i64, lowp> lowp_i64vec4;

 typedef vec<1, i64, mediump> mediump_i64vec1;
 typedef vec<2, i64, mediump> mediump_i64vec2;
 typedef vec<3, i64, mediump> mediump_i64vec3;
 typedef vec<4, i64, mediump> mediump_i64vec4;

 typedef vec<1, i64, highp> highp_i64vec1;
 typedef vec<2, i64, highp> highp_i64vec2;
 typedef vec<3, i64, highp> highp_i64vec3;
 typedef vec<4, i64, highp> highp_i64vec4;

 typedef vec<1, i64, defaultp> i64vec1;
 typedef vec<2, i64, defaultp> i64vec2;
 typedef vec<3, i64, defaultp> i64vec3;
 typedef vec<4, i64, defaultp> i64vec4;



 typedef vec<1, uint, lowp> lowp_uvec1;
 typedef vec<2, uint, lowp> lowp_uvec2;
 typedef vec<3, uint, lowp> lowp_uvec3;
 typedef vec<4, uint, lowp> lowp_uvec4;

 typedef vec<1, uint, mediump> mediump_uvec1;
 typedef vec<2, uint, mediump> mediump_uvec2;
 typedef vec<3, uint, mediump> mediump_uvec3;
 typedef vec<4, uint, mediump> mediump_uvec4;

 typedef vec<1, uint, highp> highp_uvec1;
 typedef vec<2, uint, highp> highp_uvec2;
 typedef vec<3, uint, highp> highp_uvec3;
 typedef vec<4, uint, highp> highp_uvec4;

 typedef vec<1, uint, defaultp> uvec1;
 typedef vec<2, uint, defaultp> uvec2;
 typedef vec<3, uint, defaultp> uvec3;
 typedef vec<4, uint, defaultp> uvec4;

 typedef vec<1, u8, lowp> lowp_u8vec1;
 typedef vec<2, u8, lowp> lowp_u8vec2;
 typedef vec<3, u8, lowp> lowp_u8vec3;
 typedef vec<4, u8, lowp> lowp_u8vec4;

 typedef vec<1, u8, mediump> mediump_u8vec1;
 typedef vec<2, u8, mediump> mediump_u8vec2;
 typedef vec<3, u8, mediump> mediump_u8vec3;
 typedef vec<4, u8, mediump> mediump_u8vec4;

 typedef vec<1, u8, highp> highp_u8vec1;
 typedef vec<2, u8, highp> highp_u8vec2;
 typedef vec<3, u8, highp> highp_u8vec3;
 typedef vec<4, u8, highp> highp_u8vec4;

 typedef vec<1, u8, defaultp> u8vec1;
 typedef vec<2, u8, defaultp> u8vec2;
 typedef vec<3, u8, defaultp> u8vec3;
 typedef vec<4, u8, defaultp> u8vec4;

 typedef vec<1, u16, lowp> lowp_u16vec1;
 typedef vec<2, u16, lowp> lowp_u16vec2;
 typedef vec<3, u16, lowp> lowp_u16vec3;
 typedef vec<4, u16, lowp> lowp_u16vec4;

 typedef vec<1, u16, mediump> mediump_u16vec1;
 typedef vec<2, u16, mediump> mediump_u16vec2;
 typedef vec<3, u16, mediump> mediump_u16vec3;
 typedef vec<4, u16, mediump> mediump_u16vec4;

 typedef vec<1, u16, highp> highp_u16vec1;
 typedef vec<2, u16, highp> highp_u16vec2;
 typedef vec<3, u16, highp> highp_u16vec3;
 typedef vec<4, u16, highp> highp_u16vec4;

 typedef vec<1, u16, defaultp> u16vec1;
 typedef vec<2, u16, defaultp> u16vec2;
 typedef vec<3, u16, defaultp> u16vec3;
 typedef vec<4, u16, defaultp> u16vec4;

 typedef vec<1, u32, lowp> lowp_u32vec1;
 typedef vec<2, u32, lowp> lowp_u32vec2;
 typedef vec<3, u32, lowp> lowp_u32vec3;
 typedef vec<4, u32, lowp> lowp_u32vec4;

 typedef vec<1, u32, mediump> mediump_u32vec1;
 typedef vec<2, u32, mediump> mediump_u32vec2;
 typedef vec<3, u32, mediump> mediump_u32vec3;
 typedef vec<4, u32, mediump> mediump_u32vec4;

 typedef vec<1, u32, highp> highp_u32vec1;
 typedef vec<2, u32, highp> highp_u32vec2;
 typedef vec<3, u32, highp> highp_u32vec3;
 typedef vec<4, u32, highp> highp_u32vec4;

 typedef vec<1, u32, defaultp> u32vec1;
 typedef vec<2, u32, defaultp> u32vec2;
 typedef vec<3, u32, defaultp> u32vec3;
 typedef vec<4, u32, defaultp> u32vec4;

 typedef vec<1, u64, lowp> lowp_u64vec1;
 typedef vec<2, u64, lowp> lowp_u64vec2;
 typedef vec<3, u64, lowp> lowp_u64vec3;
 typedef vec<4, u64, lowp> lowp_u64vec4;

 typedef vec<1, u64, mediump> mediump_u64vec1;
 typedef vec<2, u64, mediump> mediump_u64vec2;
 typedef vec<3, u64, mediump> mediump_u64vec3;
 typedef vec<4, u64, mediump> mediump_u64vec4;

 typedef vec<1, u64, highp> highp_u64vec1;
 typedef vec<2, u64, highp> highp_u64vec2;
 typedef vec<3, u64, highp> highp_u64vec3;
 typedef vec<4, u64, highp> highp_u64vec4;

 typedef vec<1, u64, defaultp> u64vec1;
 typedef vec<2, u64, defaultp> u64vec2;
 typedef vec<3, u64, defaultp> u64vec3;
 typedef vec<4, u64, defaultp> u64vec4;



 typedef vec<1, float, lowp> lowp_vec1;
 typedef vec<2, float, lowp> lowp_vec2;
 typedef vec<3, float, lowp> lowp_vec3;
 typedef vec<4, float, lowp> lowp_vec4;

 typedef vec<1, float, mediump> mediump_vec1;
 typedef vec<2, float, mediump> mediump_vec2;
 typedef vec<3, float, mediump> mediump_vec3;
 typedef vec<4, float, mediump> mediump_vec4;

 typedef vec<1, float, highp> highp_vec1;
 typedef vec<2, float, highp> highp_vec2;
 typedef vec<3, float, highp> highp_vec3;
 typedef vec<4, float, highp> highp_vec4;

 typedef vec<1, float, defaultp> vec1;
 typedef vec<2, float, defaultp> vec2;
 typedef vec<3, float, defaultp> vec3;
 typedef vec<4, float, defaultp> vec4;

 typedef vec<1, float, lowp> lowp_fvec1;
 typedef vec<2, float, lowp> lowp_fvec2;
 typedef vec<3, float, lowp> lowp_fvec3;
 typedef vec<4, float, lowp> lowp_fvec4;

 typedef vec<1, float, mediump> mediump_fvec1;
 typedef vec<2, float, mediump> mediump_fvec2;
 typedef vec<3, float, mediump> mediump_fvec3;
 typedef vec<4, float, mediump> mediump_fvec4;

 typedef vec<1, float, highp> highp_fvec1;
 typedef vec<2, float, highp> highp_fvec2;
 typedef vec<3, float, highp> highp_fvec3;
 typedef vec<4, float, highp> highp_fvec4;

 typedef vec<1, f32, defaultp> fvec1;
 typedef vec<2, f32, defaultp> fvec2;
 typedef vec<3, f32, defaultp> fvec3;
 typedef vec<4, f32, defaultp> fvec4;

 typedef vec<1, f32, lowp> lowp_f32vec1;
 typedef vec<2, f32, lowp> lowp_f32vec2;
 typedef vec<3, f32, lowp> lowp_f32vec3;
 typedef vec<4, f32, lowp> lowp_f32vec4;

 typedef vec<1, f32, mediump> mediump_f32vec1;
 typedef vec<2, f32, mediump> mediump_f32vec2;
 typedef vec<3, f32, mediump> mediump_f32vec3;
 typedef vec<4, f32, mediump> mediump_f32vec4;

 typedef vec<1, f32, highp> highp_f32vec1;
 typedef vec<2, f32, highp> highp_f32vec2;
 typedef vec<3, f32, highp> highp_f32vec3;
 typedef vec<4, f32, highp> highp_f32vec4;

 typedef vec<1, f32, defaultp> f32vec1;
 typedef vec<2, f32, defaultp> f32vec2;
 typedef vec<3, f32, defaultp> f32vec3;
 typedef vec<4, f32, defaultp> f32vec4;

 typedef vec<1, f64, lowp> lowp_dvec1;
 typedef vec<2, f64, lowp> lowp_dvec2;
 typedef vec<3, f64, lowp> lowp_dvec3;
 typedef vec<4, f64, lowp> lowp_dvec4;

 typedef vec<1, f64, mediump> mediump_dvec1;
 typedef vec<2, f64, mediump> mediump_dvec2;
 typedef vec<3, f64, mediump> mediump_dvec3;
 typedef vec<4, f64, mediump> mediump_dvec4;

 typedef vec<1, f64, highp> highp_dvec1;
 typedef vec<2, f64, highp> highp_dvec2;
 typedef vec<3, f64, highp> highp_dvec3;
 typedef vec<4, f64, highp> highp_dvec4;

 typedef vec<1, f64, defaultp> dvec1;
 typedef vec<2, f64, defaultp> dvec2;
 typedef vec<3, f64, defaultp> dvec3;
 typedef vec<4, f64, defaultp> dvec4;

 typedef vec<1, f64, lowp> lowp_f64vec1;
 typedef vec<2, f64, lowp> lowp_f64vec2;
 typedef vec<3, f64, lowp> lowp_f64vec3;
 typedef vec<4, f64, lowp> lowp_f64vec4;

 typedef vec<1, f64, mediump> mediump_f64vec1;
 typedef vec<2, f64, mediump> mediump_f64vec2;
 typedef vec<3, f64, mediump> mediump_f64vec3;
 typedef vec<4, f64, mediump> mediump_f64vec4;

 typedef vec<1, f64, highp> highp_f64vec1;
 typedef vec<2, f64, highp> highp_f64vec2;
 typedef vec<3, f64, highp> highp_f64vec3;
 typedef vec<4, f64, highp> highp_f64vec4;

 typedef vec<1, f64, defaultp> f64vec1;
 typedef vec<2, f64, defaultp> f64vec2;
 typedef vec<3, f64, defaultp> f64vec3;
 typedef vec<4, f64, defaultp> f64vec4;



 typedef mat<2, 2, f32, lowp> lowp_mat2;
 typedef mat<3, 3, f32, lowp> lowp_mat3;
 typedef mat<4, 4, f32, lowp> lowp_mat4;

 typedef mat<2, 2, f32, mediump> mediump_mat2;
 typedef mat<3, 3, f32, mediump> mediump_mat3;
 typedef mat<4, 4, f32, mediump> mediump_mat4;

 typedef mat<2, 2, f32, highp> highp_mat2;
 typedef mat<3, 3, f32, highp> highp_mat3;
 typedef mat<4, 4, f32, highp> highp_mat4;

 typedef mat<2, 2, f32, defaultp> mat2;
 typedef mat<3, 3, f32, defaultp> mat3;
 typedef mat<4, 4, f32, defaultp> mat4;

 typedef mat<2, 2, f32, lowp> lowp_fmat2;
 typedef mat<3, 3, f32, lowp> lowp_fmat3;
 typedef mat<4, 4, f32, lowp> lowp_fmat4;

 typedef mat<2, 2, f32, mediump> mediump_fmat2;
 typedef mat<3, 3, f32, mediump> mediump_fmat3;
 typedef mat<4, 4, f32, mediump> mediump_fmat4;

 typedef mat<2, 2, f32, highp> highp_fmat2;
 typedef mat<3, 3, f32, highp> highp_fmat3;
 typedef mat<4, 4, f32, highp> highp_fmat4;

 typedef mat<2, 2, f32, defaultp> fmat2;
 typedef mat<3, 3, f32, defaultp> fmat3;
 typedef mat<4, 4, f32, defaultp> fmat4;

 typedef mat<2, 2, f32, lowp> lowp_f32mat2;
 typedef mat<3, 3, f32, lowp> lowp_f32mat3;
 typedef mat<4, 4, f32, lowp> lowp_f32mat4;

 typedef mat<2, 2, f32, mediump> mediump_f32mat2;
 typedef mat<3, 3, f32, mediump> mediump_f32mat3;
 typedef mat<4, 4, f32, mediump> mediump_f32mat4;

 typedef mat<2, 2, f32, highp> highp_f32mat2;
 typedef mat<3, 3, f32, highp> highp_f32mat3;
 typedef mat<4, 4, f32, highp> highp_f32mat4;

 typedef mat<2, 2, f32, defaultp> f32mat2;
 typedef mat<3, 3, f32, defaultp> f32mat3;
 typedef mat<4, 4, f32, defaultp> f32mat4;

 typedef mat<2, 2, f64, lowp> lowp_dmat2;
 typedef mat<3, 3, f64, lowp> lowp_dmat3;
 typedef mat<4, 4, f64, lowp> lowp_dmat4;

 typedef mat<2, 2, f64, mediump> mediump_dmat2;
 typedef mat<3, 3, f64, mediump> mediump_dmat3;
 typedef mat<4, 4, f64, mediump> mediump_dmat4;

 typedef mat<2, 2, f64, highp> highp_dmat2;
 typedef mat<3, 3, f64, highp> highp_dmat3;
 typedef mat<4, 4, f64, highp> highp_dmat4;

 typedef mat<2, 2, f64, defaultp> dmat2;
 typedef mat<3, 3, f64, defaultp> dmat3;
 typedef mat<4, 4, f64, defaultp> dmat4;

 typedef mat<2, 2, f64, lowp> lowp_f64mat2;
 typedef mat<3, 3, f64, lowp> lowp_f64mat3;
 typedef mat<4, 4, f64, lowp> lowp_f64mat4;

 typedef mat<2, 2, f64, mediump> mediump_f64mat2;
 typedef mat<3, 3, f64, mediump> mediump_f64mat3;
 typedef mat<4, 4, f64, mediump> mediump_f64mat4;

 typedef mat<2, 2, f64, highp> highp_f64mat2;
 typedef mat<3, 3, f64, highp> highp_f64mat3;
 typedef mat<4, 4, f64, highp> highp_f64mat4;

 typedef mat<2, 2, f64, defaultp> f64mat2;
 typedef mat<3, 3, f64, defaultp> f64mat3;
 typedef mat<4, 4, f64, defaultp> f64mat4;



 typedef mat<2, 2, f32, lowp> lowp_mat2x2;
 typedef mat<2, 3, f32, lowp> lowp_mat2x3;
 typedef mat<2, 4, f32, lowp> lowp_mat2x4;
 typedef mat<3, 2, f32, lowp> lowp_mat3x2;
 typedef mat<3, 3, f32, lowp> lowp_mat3x3;
 typedef mat<3, 4, f32, lowp> lowp_mat3x4;
 typedef mat<4, 2, f32, lowp> lowp_mat4x2;
 typedef mat<4, 3, f32, lowp> lowp_mat4x3;
 typedef mat<4, 4, f32, lowp> lowp_mat4x4;

 typedef mat<2, 2, f32, mediump> mediump_mat2x2;
 typedef mat<2, 3, f32, mediump> mediump_mat2x3;
 typedef mat<2, 4, f32, mediump> mediump_mat2x4;
 typedef mat<3, 2, f32, mediump> mediump_mat3x2;
 typedef mat<3, 3, f32, mediump> mediump_mat3x3;
 typedef mat<3, 4, f32, mediump> mediump_mat3x4;
 typedef mat<4, 2, f32, mediump> mediump_mat4x2;
 typedef mat<4, 3, f32, mediump> mediump_mat4x3;
 typedef mat<4, 4, f32, mediump> mediump_mat4x4;

 typedef mat<2, 2, f32, highp> highp_mat2x2;
 typedef mat<2, 3, f32, highp> highp_mat2x3;
 typedef mat<2, 4, f32, highp> highp_mat2x4;
 typedef mat<3, 2, f32, highp> highp_mat3x2;
 typedef mat<3, 3, f32, highp> highp_mat3x3;
 typedef mat<3, 4, f32, highp> highp_mat3x4;
 typedef mat<4, 2, f32, highp> highp_mat4x2;
 typedef mat<4, 3, f32, highp> highp_mat4x3;
 typedef mat<4, 4, f32, highp> highp_mat4x4;

 typedef mat<2, 2, f32, defaultp> mat2x2;
 typedef mat<2, 3, f32, defaultp> mat2x3;
 typedef mat<2, 4, f32, defaultp> mat2x4;
 typedef mat<3, 2, f32, defaultp> mat3x2;
 typedef mat<3, 3, f32, defaultp> mat3x3;
 typedef mat<3, 4, f32, defaultp> mat3x4;
 typedef mat<4, 2, f32, defaultp> mat4x2;
 typedef mat<4, 3, f32, defaultp> mat4x3;
 typedef mat<4, 4, f32, defaultp> mat4x4;

 typedef mat<2, 2, f32, lowp> lowp_fmat2x2;
 typedef mat<2, 3, f32, lowp> lowp_fmat2x3;
 typedef mat<2, 4, f32, lowp> lowp_fmat2x4;
 typedef mat<3, 2, f32, lowp> lowp_fmat3x2;
 typedef mat<3, 3, f32, lowp> lowp_fmat3x3;
 typedef mat<3, 4, f32, lowp> lowp_fmat3x4;
 typedef mat<4, 2, f32, lowp> lowp_fmat4x2;
 typedef mat<4, 3, f32, lowp> lowp_fmat4x3;
 typedef mat<4, 4, f32, lowp> lowp_fmat4x4;

 typedef mat<2, 2, f32, mediump> mediump_fmat2x2;
 typedef mat<2, 3, f32, mediump> mediump_fmat2x3;
 typedef mat<2, 4, f32, mediump> mediump_fmat2x4;
 typedef mat<3, 2, f32, mediump> mediump_fmat3x2;
 typedef mat<3, 3, f32, mediump> mediump_fmat3x3;
 typedef mat<3, 4, f32, mediump> mediump_fmat3x4;
 typedef mat<4, 2, f32, mediump> mediump_fmat4x2;
 typedef mat<4, 3, f32, mediump> mediump_fmat4x3;
 typedef mat<4, 4, f32, mediump> mediump_fmat4x4;

 typedef mat<2, 2, f32, highp> highp_fmat2x2;
 typedef mat<2, 3, f32, highp> highp_fmat2x3;
 typedef mat<2, 4, f32, highp> highp_fmat2x4;
 typedef mat<3, 2, f32, highp> highp_fmat3x2;
 typedef mat<3, 3, f32, highp> highp_fmat3x3;
 typedef mat<3, 4, f32, highp> highp_fmat3x4;
 typedef mat<4, 2, f32, highp> highp_fmat4x2;
 typedef mat<4, 3, f32, highp> highp_fmat4x3;
 typedef mat<4, 4, f32, highp> highp_fmat4x4;

 typedef mat<2, 2, f32, defaultp> fmat2x2;
 typedef mat<2, 3, f32, defaultp> fmat2x3;
 typedef mat<2, 4, f32, defaultp> fmat2x4;
 typedef mat<3, 2, f32, defaultp> fmat3x2;
 typedef mat<3, 3, f32, defaultp> fmat3x3;
 typedef mat<3, 4, f32, defaultp> fmat3x4;
 typedef mat<4, 2, f32, defaultp> fmat4x2;
 typedef mat<4, 3, f32, defaultp> fmat4x3;
 typedef mat<4, 4, f32, defaultp> fmat4x4;

 typedef mat<2, 2, f32, lowp> lowp_f32mat2x2;
 typedef mat<2, 3, f32, lowp> lowp_f32mat2x3;
 typedef mat<2, 4, f32, lowp> lowp_f32mat2x4;
 typedef mat<3, 2, f32, lowp> lowp_f32mat3x2;
 typedef mat<3, 3, f32, lowp> lowp_f32mat3x3;
 typedef mat<3, 4, f32, lowp> lowp_f32mat3x4;
 typedef mat<4, 2, f32, lowp> lowp_f32mat4x2;
 typedef mat<4, 3, f32, lowp> lowp_f32mat4x3;
 typedef mat<4, 4, f32, lowp> lowp_f32mat4x4;

 typedef mat<2, 2, f32, mediump> mediump_f32mat2x2;
 typedef mat<2, 3, f32, mediump> mediump_f32mat2x3;
 typedef mat<2, 4, f32, mediump> mediump_f32mat2x4;
 typedef mat<3, 2, f32, mediump> mediump_f32mat3x2;
 typedef mat<3, 3, f32, mediump> mediump_f32mat3x3;
 typedef mat<3, 4, f32, mediump> mediump_f32mat3x4;
 typedef mat<4, 2, f32, mediump> mediump_f32mat4x2;
 typedef mat<4, 3, f32, mediump> mediump_f32mat4x3;
 typedef mat<4, 4, f32, mediump> mediump_f32mat4x4;

 typedef mat<2, 2, f32, highp> highp_f32mat2x2;
 typedef mat<2, 3, f32, highp> highp_f32mat2x3;
 typedef mat<2, 4, f32, highp> highp_f32mat2x4;
 typedef mat<3, 2, f32, highp> highp_f32mat3x2;
 typedef mat<3, 3, f32, highp> highp_f32mat3x3;
 typedef mat<3, 4, f32, highp> highp_f32mat3x4;
 typedef mat<4, 2, f32, highp> highp_f32mat4x2;
 typedef mat<4, 3, f32, highp> highp_f32mat4x3;
 typedef mat<4, 4, f32, highp> highp_f32mat4x4;

 typedef mat<2, 2, f32, defaultp> f32mat2x2;
 typedef mat<2, 3, f32, defaultp> f32mat2x3;
 typedef mat<2, 4, f32, defaultp> f32mat2x4;
 typedef mat<3, 2, f32, defaultp> f32mat3x2;
 typedef mat<3, 3, f32, defaultp> f32mat3x3;
 typedef mat<3, 4, f32, defaultp> f32mat3x4;
 typedef mat<4, 2, f32, defaultp> f32mat4x2;
 typedef mat<4, 3, f32, defaultp> f32mat4x3;
 typedef mat<4, 4, f32, defaultp> f32mat4x4;

 typedef mat<2, 2, double, lowp> lowp_dmat2x2;
 typedef mat<2, 3, double, lowp> lowp_dmat2x3;
 typedef mat<2, 4, double, lowp> lowp_dmat2x4;
 typedef mat<3, 2, double, lowp> lowp_dmat3x2;
 typedef mat<3, 3, double, lowp> lowp_dmat3x3;
 typedef mat<3, 4, double, lowp> lowp_dmat3x4;
 typedef mat<4, 2, double, lowp> lowp_dmat4x2;
 typedef mat<4, 3, double, lowp> lowp_dmat4x3;
 typedef mat<4, 4, double, lowp> lowp_dmat4x4;

 typedef mat<2, 2, double, mediump> mediump_dmat2x2;
 typedef mat<2, 3, double, mediump> mediump_dmat2x3;
 typedef mat<2, 4, double, mediump> mediump_dmat2x4;
 typedef mat<3, 2, double, mediump> mediump_dmat3x2;
 typedef mat<3, 3, double, mediump> mediump_dmat3x3;
 typedef mat<3, 4, double, mediump> mediump_dmat3x4;
 typedef mat<4, 2, double, mediump> mediump_dmat4x2;
 typedef mat<4, 3, double, mediump> mediump_dmat4x3;
 typedef mat<4, 4, double, mediump> mediump_dmat4x4;

 typedef mat<2, 2, double, highp> highp_dmat2x2;
 typedef mat<2, 3, double, highp> highp_dmat2x3;
 typedef mat<2, 4, double, highp> highp_dmat2x4;
 typedef mat<3, 2, double, highp> highp_dmat3x2;
 typedef mat<3, 3, double, highp> highp_dmat3x3;
 typedef mat<3, 4, double, highp> highp_dmat3x4;
 typedef mat<4, 2, double, highp> highp_dmat4x2;
 typedef mat<4, 3, double, highp> highp_dmat4x3;
 typedef mat<4, 4, double, highp> highp_dmat4x4;

 typedef mat<2, 2, double, defaultp> dmat2x2;
 typedef mat<2, 3, double, defaultp> dmat2x3;
 typedef mat<2, 4, double, defaultp> dmat2x4;
 typedef mat<3, 2, double, defaultp> dmat3x2;
 typedef mat<3, 3, double, defaultp> dmat3x3;
 typedef mat<3, 4, double, defaultp> dmat3x4;
 typedef mat<4, 2, double, defaultp> dmat4x2;
 typedef mat<4, 3, double, defaultp> dmat4x3;
 typedef mat<4, 4, double, defaultp> dmat4x4;

 typedef mat<2, 2, f64, lowp> lowp_f64mat2x2;
 typedef mat<2, 3, f64, lowp> lowp_f64mat2x3;
 typedef mat<2, 4, f64, lowp> lowp_f64mat2x4;
 typedef mat<3, 2, f64, lowp> lowp_f64mat3x2;
 typedef mat<3, 3, f64, lowp> lowp_f64mat3x3;
 typedef mat<3, 4, f64, lowp> lowp_f64mat3x4;
 typedef mat<4, 2, f64, lowp> lowp_f64mat4x2;
 typedef mat<4, 3, f64, lowp> lowp_f64mat4x3;
 typedef mat<4, 4, f64, lowp> lowp_f64mat4x4;

 typedef mat<2, 2, f64, mediump> mediump_f64mat2x2;
 typedef mat<2, 3, f64, mediump> mediump_f64mat2x3;
 typedef mat<2, 4, f64, mediump> mediump_f64mat2x4;
 typedef mat<3, 2, f64, mediump> mediump_f64mat3x2;
 typedef mat<3, 3, f64, mediump> mediump_f64mat3x3;
 typedef mat<3, 4, f64, mediump> mediump_f64mat3x4;
 typedef mat<4, 2, f64, mediump> mediump_f64mat4x2;
 typedef mat<4, 3, f64, mediump> mediump_f64mat4x3;
 typedef mat<4, 4, f64, mediump> mediump_f64mat4x4;

 typedef mat<2, 2, f64, highp> highp_f64mat2x2;
 typedef mat<2, 3, f64, highp> highp_f64mat2x3;
 typedef mat<2, 4, f64, highp> highp_f64mat2x4;
 typedef mat<3, 2, f64, highp> highp_f64mat3x2;
 typedef mat<3, 3, f64, highp> highp_f64mat3x3;
 typedef mat<3, 4, f64, highp> highp_f64mat3x4;
 typedef mat<4, 2, f64, highp> highp_f64mat4x2;
 typedef mat<4, 3, f64, highp> highp_f64mat4x3;
 typedef mat<4, 4, f64, highp> highp_f64mat4x4;

 typedef mat<2, 2, f64, defaultp> f64mat2x2;
 typedef mat<2, 3, f64, defaultp> f64mat2x3;
 typedef mat<2, 4, f64, defaultp> f64mat2x4;
 typedef mat<3, 2, f64, defaultp> f64mat3x2;
 typedef mat<3, 3, f64, defaultp> f64mat3x3;
 typedef mat<3, 4, f64, defaultp> f64mat3x4;
 typedef mat<4, 2, f64, defaultp> f64mat4x2;
 typedef mat<4, 3, f64, defaultp> f64mat4x3;
 typedef mat<4, 4, f64, defaultp> f64mat4x4;



 typedef mat<2, 2, int, lowp> lowp_imat2x2;
 typedef mat<2, 3, int, lowp> lowp_imat2x3;
 typedef mat<2, 4, int, lowp> lowp_imat2x4;
 typedef mat<3, 2, int, lowp> lowp_imat3x2;
 typedef mat<3, 3, int, lowp> lowp_imat3x3;
 typedef mat<3, 4, int, lowp> lowp_imat3x4;
 typedef mat<4, 2, int, lowp> lowp_imat4x2;
 typedef mat<4, 3, int, lowp> lowp_imat4x3;
 typedef mat<4, 4, int, lowp> lowp_imat4x4;

 typedef mat<2, 2, int, mediump> mediump_imat2x2;
 typedef mat<2, 3, int, mediump> mediump_imat2x3;
 typedef mat<2, 4, int, mediump> mediump_imat2x4;
 typedef mat<3, 2, int, mediump> mediump_imat3x2;
 typedef mat<3, 3, int, mediump> mediump_imat3x3;
 typedef mat<3, 4, int, mediump> mediump_imat3x4;
 typedef mat<4, 2, int, mediump> mediump_imat4x2;
 typedef mat<4, 3, int, mediump> mediump_imat4x3;
 typedef mat<4, 4, int, mediump> mediump_imat4x4;

 typedef mat<2, 2, int, highp> highp_imat2x2;
 typedef mat<2, 3, int, highp> highp_imat2x3;
 typedef mat<2, 4, int, highp> highp_imat2x4;
 typedef mat<3, 2, int, highp> highp_imat3x2;
 typedef mat<3, 3, int, highp> highp_imat3x3;
 typedef mat<3, 4, int, highp> highp_imat3x4;
 typedef mat<4, 2, int, highp> highp_imat4x2;
 typedef mat<4, 3, int, highp> highp_imat4x3;
 typedef mat<4, 4, int, highp> highp_imat4x4;

 typedef mat<2, 2, int, defaultp> imat2x2;
 typedef mat<2, 3, int, defaultp> imat2x3;
 typedef mat<2, 4, int, defaultp> imat2x4;
 typedef mat<3, 2, int, defaultp> imat3x2;
 typedef mat<3, 3, int, defaultp> imat3x3;
 typedef mat<3, 4, int, defaultp> imat3x4;
 typedef mat<4, 2, int, defaultp> imat4x2;
 typedef mat<4, 3, int, defaultp> imat4x3;
 typedef mat<4, 4, int, defaultp> imat4x4;


 typedef mat<2, 2, int8, lowp> lowp_i8mat2x2;
 typedef mat<2, 3, int8, lowp> lowp_i8mat2x3;
 typedef mat<2, 4, int8, lowp> lowp_i8mat2x4;
 typedef mat<3, 2, int8, lowp> lowp_i8mat3x2;
 typedef mat<3, 3, int8, lowp> lowp_i8mat3x3;
 typedef mat<3, 4, int8, lowp> lowp_i8mat3x4;
 typedef mat<4, 2, int8, lowp> lowp_i8mat4x2;
 typedef mat<4, 3, int8, lowp> lowp_i8mat4x3;
 typedef mat<4, 4, int8, lowp> lowp_i8mat4x4;

 typedef mat<2, 2, int8, mediump> mediump_i8mat2x2;
 typedef mat<2, 3, int8, mediump> mediump_i8mat2x3;
 typedef mat<2, 4, int8, mediump> mediump_i8mat2x4;
 typedef mat<3, 2, int8, mediump> mediump_i8mat3x2;
 typedef mat<3, 3, int8, mediump> mediump_i8mat3x3;
 typedef mat<3, 4, int8, mediump> mediump_i8mat3x4;
 typedef mat<4, 2, int8, mediump> mediump_i8mat4x2;
 typedef mat<4, 3, int8, mediump> mediump_i8mat4x3;
 typedef mat<4, 4, int8, mediump> mediump_i8mat4x4;

 typedef mat<2, 2, int8, highp> highp_i8mat2x2;
 typedef mat<2, 3, int8, highp> highp_i8mat2x3;
 typedef mat<2, 4, int8, highp> highp_i8mat2x4;
 typedef mat<3, 2, int8, highp> highp_i8mat3x2;
 typedef mat<3, 3, int8, highp> highp_i8mat3x3;
 typedef mat<3, 4, int8, highp> highp_i8mat3x4;
 typedef mat<4, 2, int8, highp> highp_i8mat4x2;
 typedef mat<4, 3, int8, highp> highp_i8mat4x3;
 typedef mat<4, 4, int8, highp> highp_i8mat4x4;

 typedef mat<2, 2, int8, defaultp> i8mat2x2;
 typedef mat<2, 3, int8, defaultp> i8mat2x3;
 typedef mat<2, 4, int8, defaultp> i8mat2x4;
 typedef mat<3, 2, int8, defaultp> i8mat3x2;
 typedef mat<3, 3, int8, defaultp> i8mat3x3;
 typedef mat<3, 4, int8, defaultp> i8mat3x4;
 typedef mat<4, 2, int8, defaultp> i8mat4x2;
 typedef mat<4, 3, int8, defaultp> i8mat4x3;
 typedef mat<4, 4, int8, defaultp> i8mat4x4;


 typedef mat<2, 2, int16, lowp> lowp_i16mat2x2;
 typedef mat<2, 3, int16, lowp> lowp_i16mat2x3;
 typedef mat<2, 4, int16, lowp> lowp_i16mat2x4;
 typedef mat<3, 2, int16, lowp> lowp_i16mat3x2;
 typedef mat<3, 3, int16, lowp> lowp_i16mat3x3;
 typedef mat<3, 4, int16, lowp> lowp_i16mat3x4;
 typedef mat<4, 2, int16, lowp> lowp_i16mat4x2;
 typedef mat<4, 3, int16, lowp> lowp_i16mat4x3;
 typedef mat<4, 4, int16, lowp> lowp_i16mat4x4;

 typedef mat<2, 2, int16, mediump> mediump_i16mat2x2;
 typedef mat<2, 3, int16, mediump> mediump_i16mat2x3;
 typedef mat<2, 4, int16, mediump> mediump_i16mat2x4;
 typedef mat<3, 2, int16, mediump> mediump_i16mat3x2;
 typedef mat<3, 3, int16, mediump> mediump_i16mat3x3;
 typedef mat<3, 4, int16, mediump> mediump_i16mat3x4;
 typedef mat<4, 2, int16, mediump> mediump_i16mat4x2;
 typedef mat<4, 3, int16, mediump> mediump_i16mat4x3;
 typedef mat<4, 4, int16, mediump> mediump_i16mat4x4;

 typedef mat<2, 2, int16, highp> highp_i16mat2x2;
 typedef mat<2, 3, int16, highp> highp_i16mat2x3;
 typedef mat<2, 4, int16, highp> highp_i16mat2x4;
 typedef mat<3, 2, int16, highp> highp_i16mat3x2;
 typedef mat<3, 3, int16, highp> highp_i16mat3x3;
 typedef mat<3, 4, int16, highp> highp_i16mat3x4;
 typedef mat<4, 2, int16, highp> highp_i16mat4x2;
 typedef mat<4, 3, int16, highp> highp_i16mat4x3;
 typedef mat<4, 4, int16, highp> highp_i16mat4x4;

 typedef mat<2, 2, int16, defaultp> i16mat2x2;
 typedef mat<2, 3, int16, defaultp> i16mat2x3;
 typedef mat<2, 4, int16, defaultp> i16mat2x4;
 typedef mat<3, 2, int16, defaultp> i16mat3x2;
 typedef mat<3, 3, int16, defaultp> i16mat3x3;
 typedef mat<3, 4, int16, defaultp> i16mat3x4;
 typedef mat<4, 2, int16, defaultp> i16mat4x2;
 typedef mat<4, 3, int16, defaultp> i16mat4x3;
 typedef mat<4, 4, int16, defaultp> i16mat4x4;


 typedef mat<2, 2, int32, lowp> lowp_i32mat2x2;
 typedef mat<2, 3, int32, lowp> lowp_i32mat2x3;
 typedef mat<2, 4, int32, lowp> lowp_i32mat2x4;
 typedef mat<3, 2, int32, lowp> lowp_i32mat3x2;
 typedef mat<3, 3, int32, lowp> lowp_i32mat3x3;
 typedef mat<3, 4, int32, lowp> lowp_i32mat3x4;
 typedef mat<4, 2, int32, lowp> lowp_i32mat4x2;
 typedef mat<4, 3, int32, lowp> lowp_i32mat4x3;
 typedef mat<4, 4, int32, lowp> lowp_i32mat4x4;

 typedef mat<2, 2, int32, mediump> mediump_i32mat2x2;
 typedef mat<2, 3, int32, mediump> mediump_i32mat2x3;
 typedef mat<2, 4, int32, mediump> mediump_i32mat2x4;
 typedef mat<3, 2, int32, mediump> mediump_i32mat3x2;
 typedef mat<3, 3, int32, mediump> mediump_i32mat3x3;
 typedef mat<3, 4, int32, mediump> mediump_i32mat3x4;
 typedef mat<4, 2, int32, mediump> mediump_i32mat4x2;
 typedef mat<4, 3, int32, mediump> mediump_i32mat4x3;
 typedef mat<4, 4, int32, mediump> mediump_i32mat4x4;

 typedef mat<2, 2, int32, highp> highp_i32mat2x2;
 typedef mat<2, 3, int32, highp> highp_i32mat2x3;
 typedef mat<2, 4, int32, highp> highp_i32mat2x4;
 typedef mat<3, 2, int32, highp> highp_i32mat3x2;
 typedef mat<3, 3, int32, highp> highp_i32mat3x3;
 typedef mat<3, 4, int32, highp> highp_i32mat3x4;
 typedef mat<4, 2, int32, highp> highp_i32mat4x2;
 typedef mat<4, 3, int32, highp> highp_i32mat4x3;
 typedef mat<4, 4, int32, highp> highp_i32mat4x4;

 typedef mat<2, 2, int32, defaultp> i32mat2x2;
 typedef mat<2, 3, int32, defaultp> i32mat2x3;
 typedef mat<2, 4, int32, defaultp> i32mat2x4;
 typedef mat<3, 2, int32, defaultp> i32mat3x2;
 typedef mat<3, 3, int32, defaultp> i32mat3x3;
 typedef mat<3, 4, int32, defaultp> i32mat3x4;
 typedef mat<4, 2, int32, defaultp> i32mat4x2;
 typedef mat<4, 3, int32, defaultp> i32mat4x3;
 typedef mat<4, 4, int32, defaultp> i32mat4x4;


 typedef mat<2, 2, int64, lowp> lowp_i64mat2x2;
 typedef mat<2, 3, int64, lowp> lowp_i64mat2x3;
 typedef mat<2, 4, int64, lowp> lowp_i64mat2x4;
 typedef mat<3, 2, int64, lowp> lowp_i64mat3x2;
 typedef mat<3, 3, int64, lowp> lowp_i64mat3x3;
 typedef mat<3, 4, int64, lowp> lowp_i64mat3x4;
 typedef mat<4, 2, int64, lowp> lowp_i64mat4x2;
 typedef mat<4, 3, int64, lowp> lowp_i64mat4x3;
 typedef mat<4, 4, int64, lowp> lowp_i64mat4x4;

 typedef mat<2, 2, int64, mediump> mediump_i64mat2x2;
 typedef mat<2, 3, int64, mediump> mediump_i64mat2x3;
 typedef mat<2, 4, int64, mediump> mediump_i64mat2x4;
 typedef mat<3, 2, int64, mediump> mediump_i64mat3x2;
 typedef mat<3, 3, int64, mediump> mediump_i64mat3x3;
 typedef mat<3, 4, int64, mediump> mediump_i64mat3x4;
 typedef mat<4, 2, int64, mediump> mediump_i64mat4x2;
 typedef mat<4, 3, int64, mediump> mediump_i64mat4x3;
 typedef mat<4, 4, int64, mediump> mediump_i64mat4x4;

 typedef mat<2, 2, int64, highp> highp_i64mat2x2;
 typedef mat<2, 3, int64, highp> highp_i64mat2x3;
 typedef mat<2, 4, int64, highp> highp_i64mat2x4;
 typedef mat<3, 2, int64, highp> highp_i64mat3x2;
 typedef mat<3, 3, int64, highp> highp_i64mat3x3;
 typedef mat<3, 4, int64, highp> highp_i64mat3x4;
 typedef mat<4, 2, int64, highp> highp_i64mat4x2;
 typedef mat<4, 3, int64, highp> highp_i64mat4x3;
 typedef mat<4, 4, int64, highp> highp_i64mat4x4;

 typedef mat<2, 2, int64, defaultp> i64mat2x2;
 typedef mat<2, 3, int64, defaultp> i64mat2x3;
 typedef mat<2, 4, int64, defaultp> i64mat2x4;
 typedef mat<3, 2, int64, defaultp> i64mat3x2;
 typedef mat<3, 3, int64, defaultp> i64mat3x3;
 typedef mat<3, 4, int64, defaultp> i64mat3x4;
 typedef mat<4, 2, int64, defaultp> i64mat4x2;
 typedef mat<4, 3, int64, defaultp> i64mat4x3;
 typedef mat<4, 4, int64, defaultp> i64mat4x4;




 typedef mat<2, 2, uint, lowp> lowp_umat2x2;
 typedef mat<2, 3, uint, lowp> lowp_umat2x3;
 typedef mat<2, 4, uint, lowp> lowp_umat2x4;
 typedef mat<3, 2, uint, lowp> lowp_umat3x2;
 typedef mat<3, 3, uint, lowp> lowp_umat3x3;
 typedef mat<3, 4, uint, lowp> lowp_umat3x4;
 typedef mat<4, 2, uint, lowp> lowp_umat4x2;
 typedef mat<4, 3, uint, lowp> lowp_umat4x3;
 typedef mat<4, 4, uint, lowp> lowp_umat4x4;

 typedef mat<2, 2, uint, mediump> mediump_umat2x2;
 typedef mat<2, 3, uint, mediump> mediump_umat2x3;
 typedef mat<2, 4, uint, mediump> mediump_umat2x4;
 typedef mat<3, 2, uint, mediump> mediump_umat3x2;
 typedef mat<3, 3, uint, mediump> mediump_umat3x3;
 typedef mat<3, 4, uint, mediump> mediump_umat3x4;
 typedef mat<4, 2, uint, mediump> mediump_umat4x2;
 typedef mat<4, 3, uint, mediump> mediump_umat4x3;
 typedef mat<4, 4, uint, mediump> mediump_umat4x4;

 typedef mat<2, 2, uint, highp> highp_umat2x2;
 typedef mat<2, 3, uint, highp> highp_umat2x3;
 typedef mat<2, 4, uint, highp> highp_umat2x4;
 typedef mat<3, 2, uint, highp> highp_umat3x2;
 typedef mat<3, 3, uint, highp> highp_umat3x3;
 typedef mat<3, 4, uint, highp> highp_umat3x4;
 typedef mat<4, 2, uint, highp> highp_umat4x2;
 typedef mat<4, 3, uint, highp> highp_umat4x3;
 typedef mat<4, 4, uint, highp> highp_umat4x4;

 typedef mat<2, 2, uint, defaultp> umat2x2;
 typedef mat<2, 3, uint, defaultp> umat2x3;
 typedef mat<2, 4, uint, defaultp> umat2x4;
 typedef mat<3, 2, uint, defaultp> umat3x2;
 typedef mat<3, 3, uint, defaultp> umat3x3;
 typedef mat<3, 4, uint, defaultp> umat3x4;
 typedef mat<4, 2, uint, defaultp> umat4x2;
 typedef mat<4, 3, uint, defaultp> umat4x3;
 typedef mat<4, 4, uint, defaultp> umat4x4;


 typedef mat<2, 2, uint8, lowp> lowp_u8mat2x2;
 typedef mat<2, 3, uint8, lowp> lowp_u8mat2x3;
 typedef mat<2, 4, uint8, lowp> lowp_u8mat2x4;
 typedef mat<3, 2, uint8, lowp> lowp_u8mat3x2;
 typedef mat<3, 3, uint8, lowp> lowp_u8mat3x3;
 typedef mat<3, 4, uint8, lowp> lowp_u8mat3x4;
 typedef mat<4, 2, uint8, lowp> lowp_u8mat4x2;
 typedef mat<4, 3, uint8, lowp> lowp_u8mat4x3;
 typedef mat<4, 4, uint8, lowp> lowp_u8mat4x4;

 typedef mat<2, 2, uint8, mediump> mediump_u8mat2x2;
 typedef mat<2, 3, uint8, mediump> mediump_u8mat2x3;
 typedef mat<2, 4, uint8, mediump> mediump_u8mat2x4;
 typedef mat<3, 2, uint8, mediump> mediump_u8mat3x2;
 typedef mat<3, 3, uint8, mediump> mediump_u8mat3x3;
 typedef mat<3, 4, uint8, mediump> mediump_u8mat3x4;
 typedef mat<4, 2, uint8, mediump> mediump_u8mat4x2;
 typedef mat<4, 3, uint8, mediump> mediump_u8mat4x3;
 typedef mat<4, 4, uint8, mediump> mediump_u8mat4x4;

 typedef mat<2, 2, uint8, highp> highp_u8mat2x2;
 typedef mat<2, 3, uint8, highp> highp_u8mat2x3;
 typedef mat<2, 4, uint8, highp> highp_u8mat2x4;
 typedef mat<3, 2, uint8, highp> highp_u8mat3x2;
 typedef mat<3, 3, uint8, highp> highp_u8mat3x3;
 typedef mat<3, 4, uint8, highp> highp_u8mat3x4;
 typedef mat<4, 2, uint8, highp> highp_u8mat4x2;
 typedef mat<4, 3, uint8, highp> highp_u8mat4x3;
 typedef mat<4, 4, uint8, highp> highp_u8mat4x4;

 typedef mat<2, 2, uint8, defaultp> u8mat2x2;
 typedef mat<2, 3, uint8, defaultp> u8mat2x3;
 typedef mat<2, 4, uint8, defaultp> u8mat2x4;
 typedef mat<3, 2, uint8, defaultp> u8mat3x2;
 typedef mat<3, 3, uint8, defaultp> u8mat3x3;
 typedef mat<3, 4, uint8, defaultp> u8mat3x4;
 typedef mat<4, 2, uint8, defaultp> u8mat4x2;
 typedef mat<4, 3, uint8, defaultp> u8mat4x3;
 typedef mat<4, 4, uint8, defaultp> u8mat4x4;


 typedef mat<2, 2, uint16, lowp> lowp_u16mat2x2;
 typedef mat<2, 3, uint16, lowp> lowp_u16mat2x3;
 typedef mat<2, 4, uint16, lowp> lowp_u16mat2x4;
 typedef mat<3, 2, uint16, lowp> lowp_u16mat3x2;
 typedef mat<3, 3, uint16, lowp> lowp_u16mat3x3;
 typedef mat<3, 4, uint16, lowp> lowp_u16mat3x4;
 typedef mat<4, 2, uint16, lowp> lowp_u16mat4x2;
 typedef mat<4, 3, uint16, lowp> lowp_u16mat4x3;
 typedef mat<4, 4, uint16, lowp> lowp_u16mat4x4;

 typedef mat<2, 2, uint16, mediump> mediump_u16mat2x2;
 typedef mat<2, 3, uint16, mediump> mediump_u16mat2x3;
 typedef mat<2, 4, uint16, mediump> mediump_u16mat2x4;
 typedef mat<3, 2, uint16, mediump> mediump_u16mat3x2;
 typedef mat<3, 3, uint16, mediump> mediump_u16mat3x3;
 typedef mat<3, 4, uint16, mediump> mediump_u16mat3x4;
 typedef mat<4, 2, uint16, mediump> mediump_u16mat4x2;
 typedef mat<4, 3, uint16, mediump> mediump_u16mat4x3;
 typedef mat<4, 4, uint16, mediump> mediump_u16mat4x4;

 typedef mat<2, 2, uint16, highp> highp_u16mat2x2;
 typedef mat<2, 3, uint16, highp> highp_u16mat2x3;
 typedef mat<2, 4, uint16, highp> highp_u16mat2x4;
 typedef mat<3, 2, uint16, highp> highp_u16mat3x2;
 typedef mat<3, 3, uint16, highp> highp_u16mat3x3;
 typedef mat<3, 4, uint16, highp> highp_u16mat3x4;
 typedef mat<4, 2, uint16, highp> highp_u16mat4x2;
 typedef mat<4, 3, uint16, highp> highp_u16mat4x3;
 typedef mat<4, 4, uint16, highp> highp_u16mat4x4;

 typedef mat<2, 2, uint16, defaultp> u16mat2x2;
 typedef mat<2, 3, uint16, defaultp> u16mat2x3;
 typedef mat<2, 4, uint16, defaultp> u16mat2x4;
 typedef mat<3, 2, uint16, defaultp> u16mat3x2;
 typedef mat<3, 3, uint16, defaultp> u16mat3x3;
 typedef mat<3, 4, uint16, defaultp> u16mat3x4;
 typedef mat<4, 2, uint16, defaultp> u16mat4x2;
 typedef mat<4, 3, uint16, defaultp> u16mat4x3;
 typedef mat<4, 4, uint16, defaultp> u16mat4x4;


 typedef mat<2, 2, uint32, lowp> lowp_u32mat2x2;
 typedef mat<2, 3, uint32, lowp> lowp_u32mat2x3;
 typedef mat<2, 4, uint32, lowp> lowp_u32mat2x4;
 typedef mat<3, 2, uint32, lowp> lowp_u32mat3x2;
 typedef mat<3, 3, uint32, lowp> lowp_u32mat3x3;
 typedef mat<3, 4, uint32, lowp> lowp_u32mat3x4;
 typedef mat<4, 2, uint32, lowp> lowp_u32mat4x2;
 typedef mat<4, 3, uint32, lowp> lowp_u32mat4x3;
 typedef mat<4, 4, uint32, lowp> lowp_u32mat4x4;

 typedef mat<2, 2, uint32, mediump> mediump_u32mat2x2;
 typedef mat<2, 3, uint32, mediump> mediump_u32mat2x3;
 typedef mat<2, 4, uint32, mediump> mediump_u32mat2x4;
 typedef mat<3, 2, uint32, mediump> mediump_u32mat3x2;
 typedef mat<3, 3, uint32, mediump> mediump_u32mat3x3;
 typedef mat<3, 4, uint32, mediump> mediump_u32mat3x4;
 typedef mat<4, 2, uint32, mediump> mediump_u32mat4x2;
 typedef mat<4, 3, uint32, mediump> mediump_u32mat4x3;
 typedef mat<4, 4, uint32, mediump> mediump_u32mat4x4;

 typedef mat<2, 2, uint32, highp> highp_u32mat2x2;
 typedef mat<2, 3, uint32, highp> highp_u32mat2x3;
 typedef mat<2, 4, uint32, highp> highp_u32mat2x4;
 typedef mat<3, 2, uint32, highp> highp_u32mat3x2;
 typedef mat<3, 3, uint32, highp> highp_u32mat3x3;
 typedef mat<3, 4, uint32, highp> highp_u32mat3x4;
 typedef mat<4, 2, uint32, highp> highp_u32mat4x2;
 typedef mat<4, 3, uint32, highp> highp_u32mat4x3;
 typedef mat<4, 4, uint32, highp> highp_u32mat4x4;

 typedef mat<2, 2, uint32, defaultp> u32mat2x2;
 typedef mat<2, 3, uint32, defaultp> u32mat2x3;
 typedef mat<2, 4, uint32, defaultp> u32mat2x4;
 typedef mat<3, 2, uint32, defaultp> u32mat3x2;
 typedef mat<3, 3, uint32, defaultp> u32mat3x3;
 typedef mat<3, 4, uint32, defaultp> u32mat3x4;
 typedef mat<4, 2, uint32, defaultp> u32mat4x2;
 typedef mat<4, 3, uint32, defaultp> u32mat4x3;
 typedef mat<4, 4, uint32, defaultp> u32mat4x4;


 typedef mat<2, 2, uint64, lowp> lowp_u64mat2x2;
 typedef mat<2, 3, uint64, lowp> lowp_u64mat2x3;
 typedef mat<2, 4, uint64, lowp> lowp_u64mat2x4;
 typedef mat<3, 2, uint64, lowp> lowp_u64mat3x2;
 typedef mat<3, 3, uint64, lowp> lowp_u64mat3x3;
 typedef mat<3, 4, uint64, lowp> lowp_u64mat3x4;
 typedef mat<4, 2, uint64, lowp> lowp_u64mat4x2;
 typedef mat<4, 3, uint64, lowp> lowp_u64mat4x3;
 typedef mat<4, 4, uint64, lowp> lowp_u64mat4x4;

 typedef mat<2, 2, uint64, mediump> mediump_u64mat2x2;
 typedef mat<2, 3, uint64, mediump> mediump_u64mat2x3;
 typedef mat<2, 4, uint64, mediump> mediump_u64mat2x4;
 typedef mat<3, 2, uint64, mediump> mediump_u64mat3x2;
 typedef mat<3, 3, uint64, mediump> mediump_u64mat3x3;
 typedef mat<3, 4, uint64, mediump> mediump_u64mat3x4;
 typedef mat<4, 2, uint64, mediump> mediump_u64mat4x2;
 typedef mat<4, 3, uint64, mediump> mediump_u64mat4x3;
 typedef mat<4, 4, uint64, mediump> mediump_u64mat4x4;

 typedef mat<2, 2, uint64, highp> highp_u64mat2x2;
 typedef mat<2, 3, uint64, highp> highp_u64mat2x3;
 typedef mat<2, 4, uint64, highp> highp_u64mat2x4;
 typedef mat<3, 2, uint64, highp> highp_u64mat3x2;
 typedef mat<3, 3, uint64, highp> highp_u64mat3x3;
 typedef mat<3, 4, uint64, highp> highp_u64mat3x4;
 typedef mat<4, 2, uint64, highp> highp_u64mat4x2;
 typedef mat<4, 3, uint64, highp> highp_u64mat4x3;
 typedef mat<4, 4, uint64, highp> highp_u64mat4x4;

 typedef mat<2, 2, uint64, defaultp> u64mat2x2;
 typedef mat<2, 3, uint64, defaultp> u64mat2x3;
 typedef mat<2, 4, uint64, defaultp> u64mat2x4;
 typedef mat<3, 2, uint64, defaultp> u64mat3x2;
 typedef mat<3, 3, uint64, defaultp> u64mat3x3;
 typedef mat<3, 4, uint64, defaultp> u64mat3x4;
 typedef mat<4, 2, uint64, defaultp> u64mat4x2;
 typedef mat<4, 3, uint64, defaultp> u64mat4x3;
 typedef mat<4, 4, uint64, defaultp> u64mat4x4;



 typedef qua<float, lowp> lowp_quat;
 typedef qua<float, mediump> mediump_quat;
 typedef qua<float, highp> highp_quat;
 typedef qua<float, defaultp> quat;

 typedef qua<float, lowp> lowp_fquat;
 typedef qua<float, mediump> mediump_fquat;
 typedef qua<float, highp> highp_fquat;
 typedef qua<float, defaultp> fquat;

 typedef qua<f32, lowp> lowp_f32quat;
 typedef qua<f32, mediump> mediump_f32quat;
 typedef qua<f32, highp> highp_f32quat;
 typedef qua<f32, defaultp> f32quat;

 typedef qua<double, lowp> lowp_dquat;
 typedef qua<double, mediump> mediump_dquat;
 typedef qua<double, highp> highp_dquat;
 typedef qua<double, defaultp> dquat;

 typedef qua<f64, lowp> lowp_f64quat;
 typedef qua<f64, mediump> mediump_f64quat;
 typedef qua<f64, highp> highp_f64quat;
 typedef qua<f64, defaultp> f64quat;
}
# 116 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/glm.hpp" 2

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vec2.hpp" 1



       
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_bool2.hpp" 1



       
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec2.hpp" 1



       
# 14 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec2.hpp"
namespace glm
{
 template<typename T, qualifier Q>
 struct vec<2, T, Q>
 {


  typedef T value_type;
  typedef vec<2, T, Q> type;
  typedef vec<2, bool, Q> bool_type;





#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpedantic"
# 68 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec2.hpp"
   union {T x, r, s;};
   union {T y, g, t;};
# 80 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec2.hpp"
#pragma GCC diagnostic pop
# 89 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec2.hpp"
  typedef length_t length_type;
  [[nodiscard]] static constexpr length_type length(){return 2;}

  [[nodiscard]] constexpr T& operator[](length_type i);
  [[nodiscard]] constexpr T const& operator[](length_type i) const;



  constexpr vec() = default;
  constexpr vec(vec const& v) = default;
  template<qualifier P>
  constexpr vec(vec<2, T, P> const& v);



  constexpr explicit vec(T scalar);
  constexpr vec(T x, T y);



  template<typename U, qualifier P>
  constexpr explicit vec(vec<1, U, P> const& v);


  template<typename A, typename B>
  constexpr vec(A x, B y);
  template<typename A, typename B>
  constexpr vec(vec<1, A, Q> const& x, B y);
  template<typename A, typename B>
  constexpr vec(A x, vec<1, B, Q> const& y);
  template<typename A, typename B>
  constexpr vec(vec<1, A, Q> const& x, vec<1, B, Q> const& y);




  template<typename U, qualifier P>
  constexpr vec(vec<3, U, P> const& v);

  template<typename U, qualifier P>
  constexpr vec(vec<4, U, P> const& v);


  template<typename U, qualifier P>
  constexpr vec(vec<2, U, P> const& v);
# 146 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec2.hpp"
  constexpr vec<2, T, Q> & operator=(vec const& v) = default;

  template<typename U>
  constexpr vec<2, T, Q> & operator=(vec<2, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator+=(U scalar);
  template<typename U>
  constexpr vec<2, T, Q> & operator+=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator+=(vec<2, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator-=(U scalar);
  template<typename U>
  constexpr vec<2, T, Q> & operator-=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator-=(vec<2, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator*=(U scalar);
  template<typename U>
  constexpr vec<2, T, Q> & operator*=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator*=(vec<2, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator/=(U scalar);
  template<typename U>
  constexpr vec<2, T, Q> & operator/=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator/=(vec<2, U, Q> const& v);



  constexpr vec<2, T, Q> & operator++();
  constexpr vec<2, T, Q> & operator--();
  [[nodiscard]] constexpr vec<2, T, Q> operator++(int);
  [[nodiscard]] constexpr vec<2, T, Q> operator--(int);



  template<typename U>
  constexpr vec<2, T, Q> & operator%=(U scalar);
  template<typename U>
  constexpr vec<2, T, Q> & operator%=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator%=(vec<2, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator&=(U scalar);
  template<typename U>
  constexpr vec<2, T, Q> & operator&=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator&=(vec<2, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator|=(U scalar);
  template<typename U>
  constexpr vec<2, T, Q> & operator|=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator|=(vec<2, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator^=(U scalar);
  template<typename U>
  constexpr vec<2, T, Q> & operator^=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator^=(vec<2, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator<<=(U scalar);
  template<typename U>
  constexpr vec<2, T, Q> & operator<<=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator<<=(vec<2, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator>>=(U scalar);
  template<typename U>
  constexpr vec<2, T, Q> & operator>>=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator>>=(vec<2, U, Q> const& v);
 };



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator+(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator+(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator-(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator-(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator*(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator*(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator*(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator*(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator*(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator/(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator/(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator/(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator/(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator/(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator%(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator%(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator%(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator%(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator%(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator&(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator&(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator&(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator&(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator&(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator|(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator|(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator|(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator|(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator|(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator^(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator^(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator^(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator^(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator^(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator<<(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator<<(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator<<(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator<<(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator<<(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator>>(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator>>(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator>>(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator>>(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator>>(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator~(vec<2, T, Q> const& v);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<qualifier Q>
 [[nodiscard]] constexpr vec<2, bool, Q> operator&&(vec<2, bool, Q> const& v1, vec<2, bool, Q> const& v2);

 template<qualifier Q>
 [[nodiscard]] constexpr vec<2, bool, Q> operator||(vec<2, bool, Q> const& v1, vec<2, bool, Q> const& v2);
}


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec2.inl" 1


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/compute_vector_relational.hpp" 1
       


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/setup.hpp" 1
# 5 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/compute_vector_relational.hpp" 2


namespace glm{
namespace detail
{
 template <typename T, bool isFloat>
 struct compute_equal
 {
  inline constexpr static bool call(T a, T b)
  {
   return a == b;
  }
 };
# 29 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/compute_vector_relational.hpp"
}
}
# 4 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec2.inl" 2

namespace glm
{
# 25 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec2.inl"
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr vec<2, T, Q>::vec(vec<2, T, P> const& v)
  : x(v.x), y(v.y)
 {}



 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q>::vec(T scalar)
  : x(scalar), y(scalar)
 {}

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q>::vec(T _x, T _y)
  : x(_x), y(_y)
 {}



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr vec<2, T, Q>::vec(vec<1, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B>
 inline constexpr vec<2, T, Q>::vec(A _x, B _y)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B>
 inline constexpr vec<2, T, Q>::vec(vec<1, A, Q> const& _x, B _y)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B>
 inline constexpr vec<2, T, Q>::vec(A _x, vec<1, B, Q> const& _y)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B>
 inline constexpr vec<2, T, Q>::vec(vec<1, A, Q> const& _x, vec<1, B, Q> const& _y)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
 {}



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr vec<2, T, Q>::vec(vec<2, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr vec<2, T, Q>::vec(vec<3, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr vec<2, T, Q>::vec(vec<4, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
 {}



 template<typename T, qualifier Q>
 inline constexpr T & vec<2, T, Q>::operator[](typename vec<2, T, Q>::length_type i)
 {
  (
# 108 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec2.inl" 3
 ((void)0)
# 108 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec2.inl"
 );
  switch(i)
  {
  default:
  case 0:
   return x;
  case 1:
   return y;
  }
 }

 template<typename T, qualifier Q>
 inline constexpr T const& vec<2, T, Q>::operator[](typename vec<2, T, Q>::length_type i) const
 {
  (
# 122 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec2.inl" 3
 ((void)0)
# 122 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec2.inl"
 );
  switch(i)
  {
  default:
  case 0:
   return x;
  case 1:
   return y;
  }
 }
# 145 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec2.inl"
 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator=(vec<2, U, Q> const& v)
 {
  this->x = static_cast<T>(v.x);
  this->y = static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator+=(U scalar)
 {
  this->x += static_cast<T>(scalar);
  this->y += static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator+=(vec<1, U, Q> const& v)
 {
  this->x += static_cast<T>(v.x);
  this->y += static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator+=(vec<2, U, Q> const& v)
 {
  this->x += static_cast<T>(v.x);
  this->y += static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator-=(U scalar)
 {
  this->x -= static_cast<T>(scalar);
  this->y -= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator-=(vec<1, U, Q> const& v)
 {
  this->x -= static_cast<T>(v.x);
  this->y -= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator-=(vec<2, U, Q> const& v)
 {
  this->x -= static_cast<T>(v.x);
  this->y -= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator*=(U scalar)
 {
  this->x *= static_cast<T>(scalar);
  this->y *= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator*=(vec<1, U, Q> const& v)
 {
  this->x *= static_cast<T>(v.x);
  this->y *= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator*=(vec<2, U, Q> const& v)
 {
  this->x *= static_cast<T>(v.x);
  this->y *= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator/=(U scalar)
 {
  this->x /= static_cast<T>(scalar);
  this->y /= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator/=(vec<1, U, Q> const& v)
 {
  this->x /= static_cast<T>(v.x);
  this->y /= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator/=(vec<2, U, Q> const& v)
 {
  this->x /= static_cast<T>(v.x);
  this->y /= static_cast<T>(v.y);
  return *this;
 }



 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator++()
 {
  ++this->x;
  ++this->y;
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator--()
 {
  --this->x;
  --this->y;
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> vec<2, T, Q>::operator++(int)
 {
  vec<2, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> vec<2, T, Q>::operator--(int)
 {
  vec<2, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator%=(U scalar)
 {
  this->x %= static_cast<T>(scalar);
  this->y %= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator%=(vec<1, U, Q> const& v)
 {
  this->x %= static_cast<T>(v.x);
  this->y %= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator%=(vec<2, U, Q> const& v)
 {
  this->x %= static_cast<T>(v.x);
  this->y %= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator&=(U scalar)
 {
  this->x &= static_cast<T>(scalar);
  this->y &= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator&=(vec<1, U, Q> const& v)
 {
  this->x &= static_cast<T>(v.x);
  this->y &= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator&=(vec<2, U, Q> const& v)
 {
  this->x &= static_cast<T>(v.x);
  this->y &= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator|=(U scalar)
 {
  this->x |= static_cast<T>(scalar);
  this->y |= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator|=(vec<1, U, Q> const& v)
 {
  this->x |= static_cast<T>(v.x);
  this->y |= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator|=(vec<2, U, Q> const& v)
 {
  this->x |= static_cast<T>(v.x);
  this->y |= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator^=(U scalar)
 {
  this->x ^= static_cast<T>(scalar);
  this->y ^= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator^=(vec<1, U, Q> const& v)
 {
  this->x ^= static_cast<T>(v.x);
  this->y ^= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator^=(vec<2, U, Q> const& v)
 {
  this->x ^= static_cast<T>(v.x);
  this->y ^= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator<<=(U scalar)
 {
  this->x <<= static_cast<T>(scalar);
  this->y <<= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator<<=(vec<1, U, Q> const& v)
 {
  this->x <<= static_cast<T>(v.x);
  this->y <<= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator<<=(vec<2, U, Q> const& v)
 {
  this->x <<= static_cast<T>(v.x);
  this->y <<= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator>>=(U scalar)
 {
  this->x >>= static_cast<T>(scalar);
  this->y >>= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator>>=(vec<1, U, Q> const& v)
 {
  this->x >>= static_cast<T>(v.x);
  this->y >>= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator>>=(vec<2, U, Q> const& v)
 {
  this->x >>= static_cast<T>(v.x);
  this->y >>= static_cast<T>(v.y);
  return *this;
 }



 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v)
 {
  return v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   -v.x,
   -v.y);
 }



 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x + scalar,
   v.y + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x + v2.x,
   v1.y + v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator+(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar + v.x,
   scalar + v.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator+(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x + v2.x,
   v1.x + v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x + v2.x,
   v1.y + v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x - scalar,
   v.y - scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x - v2.x,
   v1.y - v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator-(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar - v.x,
   scalar - v.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator-(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x - v2.x,
   v1.x - v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x - v2.x,
   v1.y - v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator*(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x * scalar,
   v.y * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator*(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x * v2.x,
   v1.y * v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator*(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar * v.x,
   scalar * v.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator*(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x * v2.x,
   v1.x * v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator*(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x * v2.x,
   v1.y * v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator/(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x / scalar,
   v.y / scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator/(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x / v2.x,
   v1.y / v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator/(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar / v.x,
   scalar / v.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator/(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x / v2.x,
   v1.x / v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator/(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x / v2.x,
   v1.y / v2.y);
 }



 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator%(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x % scalar,
   v.y % scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator%(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x % v2.x,
   v1.y % v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator%(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar % v.x,
   scalar % v.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator%(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x % v2.x,
   v1.x % v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator%(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x % v2.x,
   v1.y % v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator&(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x & scalar,
   v.y & scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator&(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x & v2.x,
   v1.y & v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator&(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar & v.x,
   scalar & v.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator&(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x & v2.x,
   v1.x & v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator&(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x & v2.x,
   v1.y & v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator|(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x | scalar,
   v.y | scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator|(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x | v2.x,
   v1.y | v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator|(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar | v.x,
   scalar | v.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator|(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x | v2.x,
   v1.x | v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator|(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x | v2.x,
   v1.y | v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator^(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x ^ scalar,
   v.y ^ scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator^(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x ^ v2.x,
   v1.y ^ v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator^(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar ^ v.x,
   scalar ^ v.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator^(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x ^ v2.x,
   v1.x ^ v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator^(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x ^ v2.x,
   v1.y ^ v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator<<(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x << scalar,
   v.y << scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator<<(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x << v2.x,
   v1.y << v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator<<(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar << v.x,
   scalar << v.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator<<(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x << v2.x,
   v1.x << v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator<<(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x << v2.x,
   v1.y << v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator>>(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x >> scalar,
   v.y >> scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator>>(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x >> v2.x,
   v1.y >> v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator>>(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar >> v.x,
   scalar >> v.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator>>(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x >> v2.x,
   v1.x >> v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator>>(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x >> v2.x,
   v1.y >> v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator~(vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   ~v.x,
   ~v.y);
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return
   detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.x, v2.x) &&
   detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.y, v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return !(v1 == v2);
 }

 template<qualifier Q>
 inline constexpr vec<2, bool, Q> operator&&(vec<2, bool, Q> const& v1, vec<2, bool, Q> const& v2)
 {
  return vec<2, bool, Q>(v1.x && v2.x, v1.y && v2.y);
 }

 template<qualifier Q>
 inline constexpr vec<2, bool, Q> operator||(vec<2, bool, Q> const& v1, vec<2, bool, Q> const& v2)
 {
  return vec<2, bool, Q>(v1.x || v2.x, v1.y || v2.y);
 }
}
# 402 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec2.hpp" 2
# 6 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_bool2.hpp" 2

namespace glm
{






 typedef vec<2, bool, defaultp> bvec2;


}
# 6 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vec2.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_bool2_precision.hpp" 1



       


namespace glm
{







 typedef vec<2, bool, highp> highp_bvec2;





 typedef vec<2, bool, mediump> mediump_bvec2;





 typedef vec<2, bool, lowp> lowp_bvec2;


}
# 7 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vec2.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_float2.hpp" 1



       


namespace glm
{






 typedef vec<2, float, defaultp> vec2;


}
# 8 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vec2.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_float2_precision.hpp" 1



       


namespace glm
{







 typedef vec<2, float, highp> highp_vec2;





 typedef vec<2, float, mediump> mediump_vec2;





 typedef vec<2, float, lowp> lowp_vec2;


}
# 9 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vec2.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_double2.hpp" 1



       


namespace glm
{






 typedef vec<2, double, defaultp> dvec2;


}
# 10 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vec2.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_double2_precision.hpp" 1



       


namespace glm
{







 typedef vec<2, double, highp> highp_dvec2;





 typedef vec<2, double, mediump> mediump_dvec2;





 typedef vec<2, double, lowp> lowp_dvec2;


}
# 11 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vec2.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_int2.hpp" 1



       


namespace glm
{






 typedef vec<2, int, defaultp> ivec2;


}
# 12 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vec2.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_int2_sized.hpp" 1
# 14 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_int2_sized.hpp"
       


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_int_sized.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_int_sized.hpp"
       

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/setup.hpp" 1
# 16 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_int_sized.hpp" 2





namespace glm{
namespace detail
{

  typedef std::int8_t int8;
  typedef std::int16_t int16;
  typedef std::int32_t int32;






 template<>
 struct is_int<int8>
 {
  enum test {value = ~0};
 };

 template<>
 struct is_int<int16>
 {
  enum test {value = ~0};
 };

 template<>
 struct is_int<int64>
 {
  enum test {value = ~0};
 };
}






 typedef detail::int8 int8;


 typedef detail::int16 int16;


 typedef detail::int32 int32;


 typedef detail::int64 int64;


}
# 18 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_int2_sized.hpp" 2





namespace glm
{






 typedef vec<2, int8, defaultp> i8vec2;




 typedef vec<2, int16, defaultp> i16vec2;




 typedef vec<2, int32, defaultp> i32vec2;




 typedef vec<2, int64, defaultp> i64vec2;


}
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vec2.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_uint2.hpp" 1



       


namespace glm
{






 typedef vec<2, unsigned int, defaultp> uvec2;


}
# 14 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vec2.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_uint2_sized.hpp" 1
# 14 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_uint2_sized.hpp"
       


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_uint_sized.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_uint_sized.hpp"
       

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/setup.hpp" 1
# 16 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_uint_sized.hpp" 2





namespace glm{
namespace detail
{

  typedef std::uint8_t uint8;
  typedef std::uint16_t uint16;
  typedef std::uint32_t uint32;






 template<>
 struct is_int<uint8>
 {
  enum test {value = ~0};
 };

 template<>
 struct is_int<uint16>
 {
  enum test {value = ~0};
 };

 template<>
 struct is_int<uint64>
 {
  enum test {value = ~0};
 };
}






 typedef detail::uint8 uint8;


 typedef detail::uint16 uint16;


 typedef detail::uint32 uint32;


 typedef detail::uint64 uint64;


}
# 18 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_uint2_sized.hpp" 2





namespace glm
{






 typedef vec<2, uint8, defaultp> u8vec2;




 typedef vec<2, uint16, defaultp> u16vec2;




 typedef vec<2, uint32, defaultp> u32vec2;




 typedef vec<2, uint64, defaultp> u64vec2;


}
# 15 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vec2.hpp" 2
# 118 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/glm.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vec3.hpp" 1



       
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_bool3.hpp" 1



       
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec3.hpp" 1



       
# 14 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec3.hpp"
namespace glm
{
 template<typename T, qualifier Q>
 struct vec<3, T, Q>
 {


  typedef T value_type;
  typedef vec<3, T, Q> type;
  typedef vec<3, bool, Q> bool_type;





#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpedantic"
# 72 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec3.hpp"
   union { T x, r, s; };
   union { T y, g, t; };
   union { T z, b, p; };
# 85 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec3.hpp"
#pragma GCC diagnostic pop
# 94 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec3.hpp"
  typedef length_t length_type;
  [[nodiscard]] static constexpr length_type length(){return 3;}

  [[nodiscard]] constexpr T & operator[](length_type i);
  [[nodiscard]] constexpr T const& operator[](length_type i) const;



  constexpr vec() = default;
  constexpr vec(vec const& v) = default;
  template<qualifier P>
  constexpr vec(vec<3, T, P> const& v);



  constexpr explicit vec(T scalar);
  constexpr vec(T a, T b, T c);



  template<typename U, qualifier P>
  constexpr explicit vec(vec<1, U, P> const& v);


  template<typename X, typename Y, typename Z>
  constexpr vec(X x, Y y, Z z);
  template<typename X, typename Y, typename Z>
  constexpr vec(vec<1, X, Q> const& _x, Y _y, Z _z);
  template<typename X, typename Y, typename Z>
  constexpr vec(X _x, vec<1, Y, Q> const& _y, Z _z);
  template<typename X, typename Y, typename Z>
  constexpr vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z);
  template<typename X, typename Y, typename Z>
  constexpr vec(X _x, Y _y, vec<1, Z, Q> const& _z);
  template<typename X, typename Y, typename Z>
  constexpr vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z);
  template<typename X, typename Y, typename Z>
  constexpr vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z);
  template<typename X, typename Y, typename Z>
  constexpr vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z);




  template<typename A, typename B, qualifier P>
  constexpr vec(vec<2, A, P> const& _xy, B _z);

  template<typename A, typename B, qualifier P>
  constexpr vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z);

  template<typename A, typename B, qualifier P>
  constexpr vec(A _x, vec<2, B, P> const& _yz);

  template<typename A, typename B, qualifier P>
  constexpr vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz);

  template<typename U, qualifier P>
  constexpr vec(vec<4, U, P> const& v);


  template<typename U, qualifier P>
  constexpr vec(vec<3, U, P> const& v);
# 180 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec3.hpp"
  constexpr vec<3, T, Q>& operator=(vec<3, T, Q> const& v) = default;

  template<typename U>
  constexpr vec<3, T, Q> & operator=(vec<3, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator+=(U scalar);
  template<typename U>
  constexpr vec<3, T, Q> & operator+=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator+=(vec<3, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator-=(U scalar);
  template<typename U>
  constexpr vec<3, T, Q> & operator-=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator-=(vec<3, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator*=(U scalar);
  template<typename U>
  constexpr vec<3, T, Q> & operator*=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator*=(vec<3, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator/=(U scalar);
  template<typename U>
  constexpr vec<3, T, Q> & operator/=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator/=(vec<3, U, Q> const& v);



  constexpr vec<3, T, Q> & operator++();
  constexpr vec<3, T, Q> & operator--();
  [[nodiscard]] constexpr vec<3, T, Q> operator++(int);
  [[nodiscard]] constexpr vec<3, T, Q> operator--(int);



  template<typename U>
  constexpr vec<3, T, Q> & operator%=(U scalar);
  template<typename U>
  constexpr vec<3, T, Q> & operator%=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator%=(vec<3, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator&=(U scalar);
  template<typename U>
  constexpr vec<3, T, Q> & operator&=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator&=(vec<3, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator|=(U scalar);
  template<typename U>
  constexpr vec<3, T, Q> & operator|=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator|=(vec<3, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator^=(U scalar);
  template<typename U>
  constexpr vec<3, T, Q> & operator^=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator^=(vec<3, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator<<=(U scalar);
  template<typename U>
  constexpr vec<3, T, Q> & operator<<=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator<<=(vec<3, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator>>=(U scalar);
  template<typename U>
  constexpr vec<3, T, Q> & operator>>=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator>>=(vec<3, U, Q> const& v);
 };



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator+(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator+(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator-(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator-(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator*(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator*(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator/(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator/(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator/(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator/(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator/(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator%(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator%(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator%(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator%(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator%(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator&(vec<3, T, Q> const& v1, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator&(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator&(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator&(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator&(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator|(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator|(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator|(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator|(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator|(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator^(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator^(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator^(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator^(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator^(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator<<(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator<<(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator<<(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator<<(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator<<(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator>>(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator>>(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator>>(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator>>(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator>>(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator~(vec<3, T, Q> const& v);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<qualifier Q>
 [[nodiscard]] constexpr vec<3, bool, Q> operator&&(vec<3, bool, Q> const& v1, vec<3, bool, Q> const& v2);

 template<qualifier Q>
 [[nodiscard]] constexpr vec<3, bool, Q> operator||(vec<3, bool, Q> const& v1, vec<3, bool, Q> const& v2);
}


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec3.inl" 1




namespace glm
{
# 25 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec3.inl"
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr vec<3, T, Q>::vec(vec<3, T, P> const& v)
  : x(v.x), y(v.y), z(v.z)
 {}



 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q>::vec(T scalar)
  : x(scalar), y(scalar), z(scalar)
 {}

 template <typename T, qualifier Q>
 inline constexpr vec<3, T, Q>::vec(T _x, T _y, T _z)
  : x(_x), y(_y), z(_z)
 {}



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr vec<3, T, Q>::vec(vec<1, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.x))
  , z(static_cast<T>(v.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z>
 inline constexpr vec<3, T, Q>::vec(X _x, Y _y, Z _z)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z>
 inline constexpr vec<3, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, Z _z)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z>
 inline constexpr vec<3, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, Z _z)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z>
 inline constexpr vec<3, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z>
 inline constexpr vec<3, T, Q>::vec(X _x, Y _y, vec<1, Z, Q> const& _z)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z>
 inline constexpr vec<3, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z>
 inline constexpr vec<3, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z>
 inline constexpr vec<3, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z.x))
 {}



 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline constexpr vec<3, T, Q>::vec(vec<2, A, P> const& _xy, B _z)
  : x(static_cast<T>(_xy.x))
  , y(static_cast<T>(_xy.y))
  , z(static_cast<T>(_z))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline constexpr vec<3, T, Q>::vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z)
  : x(static_cast<T>(_xy.x))
  , y(static_cast<T>(_xy.y))
  , z(static_cast<T>(_z.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline constexpr vec<3, T, Q>::vec(A _x, vec<2, B, P> const& _yz)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_yz.x))
  , z(static_cast<T>(_yz.y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline constexpr vec<3, T, Q>::vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_yz.x))
  , z(static_cast<T>(_yz.y))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr vec<3, T, Q>::vec(vec<3, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
  , z(static_cast<T>(v.z))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr vec<3, T, Q>::vec(vec<4, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
  , z(static_cast<T>(v.z))
 {}



 template<typename T, qualifier Q>
 inline constexpr T & vec<3, T, Q>::operator[](typename vec<3, T, Q>::length_type i)
 {
  (
# 172 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec3.inl" 3
 ((void)0)
# 172 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec3.inl"
 );
  switch(i)
  {
  default:
   case 0:
  return x;
   case 1:
  return y;
   case 2:
  return z;
  }
 }

 template<typename T, qualifier Q>
 inline constexpr T const& vec<3, T, Q>::operator[](typename vec<3, T, Q>::length_type i) const
 {
  (
# 188 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec3.inl" 3
 ((void)0)
# 188 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec3.inl"
 );
  switch(i)
  {
  default:
  case 0:
   return x;
  case 1:
   return y;
  case 2:
   return z;
  }
 }
# 214 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec3.inl"
 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q>& vec<3, T, Q>::operator=(vec<3, U, Q> const& v)
 {
  this->x = static_cast<T>(v.x);
  this->y = static_cast<T>(v.y);
  this->z = static_cast<T>(v.z);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator+=(U scalar)
 {
  this->x += static_cast<T>(scalar);
  this->y += static_cast<T>(scalar);
  this->z += static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator+=(vec<1, U, Q> const& v)
 {
  this->x += static_cast<T>(v.x);
  this->y += static_cast<T>(v.x);
  this->z += static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator+=(vec<3, U, Q> const& v)
 {
  this->x += static_cast<T>(v.x);
  this->y += static_cast<T>(v.y);
  this->z += static_cast<T>(v.z);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator-=(U scalar)
 {
  this->x -= static_cast<T>(scalar);
  this->y -= static_cast<T>(scalar);
  this->z -= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator-=(vec<1, U, Q> const& v)
 {
  this->x -= static_cast<T>(v.x);
  this->y -= static_cast<T>(v.x);
  this->z -= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator-=(vec<3, U, Q> const& v)
 {
  this->x -= static_cast<T>(v.x);
  this->y -= static_cast<T>(v.y);
  this->z -= static_cast<T>(v.z);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator*=(U scalar)
 {
  this->x *= static_cast<T>(scalar);
  this->y *= static_cast<T>(scalar);
  this->z *= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator*=(vec<1, U, Q> const& v)
 {
  this->x *= static_cast<T>(v.x);
  this->y *= static_cast<T>(v.x);
  this->z *= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator*=(vec<3, U, Q> const& v)
 {
  this->x *= static_cast<T>(v.x);
  this->y *= static_cast<T>(v.y);
  this->z *= static_cast<T>(v.z);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator/=(U v)
 {
  this->x /= static_cast<T>(v);
  this->y /= static_cast<T>(v);
  this->z /= static_cast<T>(v);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator/=(vec<1, U, Q> const& v)
 {
  this->x /= static_cast<T>(v.x);
  this->y /= static_cast<T>(v.x);
  this->z /= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator/=(vec<3, U, Q> const& v)
 {
  this->x /= static_cast<T>(v.x);
  this->y /= static_cast<T>(v.y);
  this->z /= static_cast<T>(v.z);
  return *this;
 }



 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator++()
 {
  ++this->x;
  ++this->y;
  ++this->z;
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator--()
 {
  --this->x;
  --this->y;
  --this->z;
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> vec<3, T, Q>::operator++(int)
 {
  vec<3, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> vec<3, T, Q>::operator--(int)
 {
  vec<3, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator%=(U scalar)
 {
  this->x %= scalar;
  this->y %= scalar;
  this->z %= scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator%=(vec<1, U, Q> const& v)
 {
  this->x %= v.x;
  this->y %= v.x;
  this->z %= v.x;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator%=(vec<3, U, Q> const& v)
 {
  this->x %= v.x;
  this->y %= v.y;
  this->z %= v.z;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator&=(U scalar)
 {
  this->x &= scalar;
  this->y &= scalar;
  this->z &= scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator&=(vec<1, U, Q> const& v)
 {
  this->x &= v.x;
  this->y &= v.x;
  this->z &= v.x;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator&=(vec<3, U, Q> const& v)
 {
  this->x &= v.x;
  this->y &= v.y;
  this->z &= v.z;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator|=(U scalar)
 {
  this->x |= scalar;
  this->y |= scalar;
  this->z |= scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator|=(vec<1, U, Q> const& v)
 {
  this->x |= v.x;
  this->y |= v.x;
  this->z |= v.x;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator|=(vec<3, U, Q> const& v)
 {
  this->x |= v.x;
  this->y |= v.y;
  this->z |= v.z;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator^=(U scalar)
 {
  this->x ^= scalar;
  this->y ^= scalar;
  this->z ^= scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator^=(vec<1, U, Q> const& v)
 {
  this->x ^= v.x;
  this->y ^= v.x;
  this->z ^= v.x;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator^=(vec<3, U, Q> const& v)
 {
  this->x ^= v.x;
  this->y ^= v.y;
  this->z ^= v.z;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator<<=(U scalar)
 {
  this->x <<= scalar;
  this->y <<= scalar;
  this->z <<= scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator<<=(vec<1, U, Q> const& v)
 {
  this->x <<= static_cast<T>(v.x);
  this->y <<= static_cast<T>(v.x);
  this->z <<= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator<<=(vec<3, U, Q> const& v)
 {
  this->x <<= static_cast<T>(v.x);
  this->y <<= static_cast<T>(v.y);
  this->z <<= static_cast<T>(v.z);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator>>=(U scalar)
 {
  this->x >>= static_cast<T>(scalar);
  this->y >>= static_cast<T>(scalar);
  this->z >>= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator>>=(vec<1, U, Q> const& v)
 {
  this->x >>= static_cast<T>(v.x);
  this->y >>= static_cast<T>(v.x);
  this->z >>= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator>>=(vec<3, U, Q> const& v)
 {
  this->x >>= static_cast<T>(v.x);
  this->y >>= static_cast<T>(v.y);
  this->z >>= static_cast<T>(v.z);
  return *this;
 }



 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v)
 {
  return v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   -v.x,
   -v.y,
   -v.z);
 }



 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x + scalar,
   v.y + scalar,
   v.z + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x + scalar.x,
   v.y + scalar.x,
   v.z + scalar.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator+(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar + v.x,
   scalar + v.y,
   scalar + v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator+(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x + v.x,
   scalar.x + v.y,
   scalar.x + v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x + v2.x,
   v1.y + v2.y,
   v1.z + v2.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x - scalar,
   v.y - scalar,
   v.z - scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x - scalar.x,
   v.y - scalar.x,
   v.z - scalar.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator-(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar - v.x,
   scalar - v.y,
   scalar - v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator-(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x - v.x,
   scalar.x - v.y,
   scalar.x - v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x - v2.x,
   v1.y - v2.y,
   v1.z - v2.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x * scalar,
   v.y * scalar,
   v.z * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x * scalar.x,
   v.y * scalar.x,
   v.z * scalar.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator*(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar * v.x,
   scalar * v.y,
   scalar * v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator*(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x * v.x,
   scalar.x * v.y,
   scalar.x * v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x * v2.x,
   v1.y * v2.y,
   v1.z * v2.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator/(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x / scalar,
   v.y / scalar,
   v.z / scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator/(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x / scalar.x,
   v.y / scalar.x,
   v.z / scalar.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator/(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar / v.x,
   scalar / v.y,
   scalar / v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator/(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x / v.x,
   scalar.x / v.y,
   scalar.x / v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator/(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x / v2.x,
   v1.y / v2.y,
   v1.z / v2.z);
 }



 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator%(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x % scalar,
   v.y % scalar,
   v.z % scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator%(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x % scalar.x,
   v.y % scalar.x,
   v.z % scalar.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator%(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar % v.x,
   scalar % v.y,
   scalar % v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator%(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x % v.x,
   scalar.x % v.y,
   scalar.x % v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator%(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x % v2.x,
   v1.y % v2.y,
   v1.z % v2.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator&(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x & scalar,
   v.y & scalar,
   v.z & scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator&(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x & scalar.x,
   v.y & scalar.x,
   v.z & scalar.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator&(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar & v.x,
   scalar & v.y,
   scalar & v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator&(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x & v.x,
   scalar.x & v.y,
   scalar.x & v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator&(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x & v2.x,
   v1.y & v2.y,
   v1.z & v2.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator|(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x | scalar,
   v.y | scalar,
   v.z | scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator|(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x | scalar.x,
   v.y | scalar.x,
   v.z | scalar.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator|(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar | v.x,
   scalar | v.y,
   scalar | v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator|(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x | v.x,
   scalar.x | v.y,
   scalar.x | v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator|(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x | v2.x,
   v1.y | v2.y,
   v1.z | v2.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator^(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x ^ scalar,
   v.y ^ scalar,
   v.z ^ scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator^(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x ^ scalar.x,
   v.y ^ scalar.x,
   v.z ^ scalar.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator^(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar ^ v.x,
   scalar ^ v.y,
   scalar ^ v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator^(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x ^ v.x,
   scalar.x ^ v.y,
   scalar.x ^ v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator^(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x ^ v2.x,
   v1.y ^ v2.y,
   v1.z ^ v2.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator<<(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x << scalar,
   v.y << scalar,
   v.z << scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator<<(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x << scalar.x,
   v.y << scalar.x,
   v.z << scalar.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator<<(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar << v.x,
   scalar << v.y,
   scalar << v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator<<(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x << v.x,
   scalar.x << v.y,
   scalar.x << v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator<<(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x << v2.x,
   v1.y << v2.y,
   v1.z << v2.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator>>(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x >> scalar,
   v.y >> scalar,
   v.z >> scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator>>(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x >> scalar.x,
   v.y >> scalar.x,
   v.z >> scalar.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator>>(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar >> v.x,
   scalar >> v.y,
   scalar >> v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator>>(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x >> v.x,
   scalar.x >> v.y,
   scalar.x >> v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator>>(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x >> v2.x,
   v1.y >> v2.y,
   v1.z >> v2.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator~(vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   ~v.x,
   ~v.y,
   ~v.z);
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return
   detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.x, v2.x) &&
   detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.y, v2.y) &&
   detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.z, v2.z);
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return !(v1 == v2);
 }

 template<qualifier Q>
 inline constexpr vec<3, bool, Q> operator&&(vec<3, bool, Q> const& v1, vec<3, bool, Q> const& v2)
 {
  return vec<3, bool, Q>(v1.x && v2.x, v1.y && v2.y, v1.z && v2.z);
 }

 template<qualifier Q>
 inline constexpr vec<3, bool, Q> operator||(vec<3, bool, Q> const& v1, vec<3, bool, Q> const& v2)
 {
  return vec<3, bool, Q>(v1.x || v2.x, v1.y || v2.y, v1.z || v2.z);
 }
}
# 436 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec3.hpp" 2
# 6 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_bool3.hpp" 2

namespace glm
{






 typedef vec<3, bool, defaultp> bvec3;


}
# 6 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vec3.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_bool3_precision.hpp" 1



       


namespace glm
{







 typedef vec<3, bool, highp> highp_bvec3;





 typedef vec<3, bool, mediump> mediump_bvec3;





 typedef vec<3, bool, lowp> lowp_bvec3;


}
# 7 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vec3.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_float3.hpp" 1



       


namespace glm
{






 typedef vec<3, float, defaultp> vec3;


}
# 8 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vec3.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_float3_precision.hpp" 1



       


namespace glm
{







 typedef vec<3, float, highp> highp_vec3;





 typedef vec<3, float, mediump> mediump_vec3;





 typedef vec<3, float, lowp> lowp_vec3;


}
# 9 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vec3.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_double3.hpp" 1



       


namespace glm
{






 typedef vec<3, double, defaultp> dvec3;


}
# 10 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vec3.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_double3_precision.hpp" 1



       


namespace glm
{
# 17 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_double3_precision.hpp"
 typedef vec<3, double, highp> highp_dvec3;






 typedef vec<3, double, mediump> mediump_dvec3;






 typedef vec<3, double, lowp> lowp_dvec3;


}
# 11 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vec3.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_int3.hpp" 1



       


namespace glm
{






 typedef vec<3, int, defaultp> ivec3;


}
# 12 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vec3.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_int3_sized.hpp" 1
# 14 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_int3_sized.hpp"
       
# 23 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_int3_sized.hpp"
namespace glm
{






 typedef vec<3, int8, defaultp> i8vec3;




 typedef vec<3, int16, defaultp> i16vec3;




 typedef vec<3, int32, defaultp> i32vec3;




 typedef vec<3, int64, defaultp> i64vec3;


}
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vec3.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_uint3.hpp" 1



       


namespace glm
{






 typedef vec<3, unsigned int, defaultp> uvec3;


}
# 14 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vec3.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_uint3_sized.hpp" 1
# 14 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_uint3_sized.hpp"
       
# 23 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_uint3_sized.hpp"
namespace glm
{






 typedef vec<3, uint8, defaultp> u8vec3;




 typedef vec<3, uint16, defaultp> u16vec3;




 typedef vec<3, uint32, defaultp> u32vec3;




 typedef vec<3, uint64, defaultp> u64vec3;


}
# 15 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vec3.hpp" 2
# 119 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/glm.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vec4.hpp" 1



       
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_bool4.hpp" 1



       
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec4.hpp" 1



       
# 14 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec4.hpp"
namespace glm
{
 template<typename T, qualifier Q>
 struct vec<4, T, Q>
 {


  typedef T value_type;
  typedef vec<4, T, Q> type;
  typedef vec<4, bool, Q> bool_type;





#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpedantic"
# 68 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec4.hpp"
   union { T x, r, s; };
   union { T y, g, t; };
   union { T z, b, p; };
   union { T w, a, q; };
# 82 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec4.hpp"
#pragma GCC diagnostic pop







  typedef length_t length_type;


  [[nodiscard]] static constexpr length_type length(){return 4;}

  [[nodiscard]] constexpr T & operator[](length_type i);
  [[nodiscard]] constexpr T const& operator[](length_type i) const;



  constexpr vec() = default;
  constexpr vec(vec<4, T, Q> const& v) = default;
  template<qualifier P>
  constexpr vec(vec<4, T, P> const& v);



  constexpr explicit vec(T scalar);
  constexpr vec(T x, T y, T z, T w);



  template<typename U, qualifier P>
  constexpr explicit vec(vec<1, U, P> const& v);


  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(X _x, Y _y, Z _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(vec<1, X, Q> const& _x, Y _y, Z _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(X _x, vec<1, Y, Q> const& _y, Z _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(X _x, Y _y, vec<1, Z, Q> const& _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(vec<1, X, Q> const& _x, Y _y, Z _z, vec<1, W, Q> const& _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(X _x, vec<1, Y, Q> const& _y, Z _z, vec<1, W, Q> const& _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z, vec<1, W, Q> const& _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(X _x, Y _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w);




  template<typename A, typename B, typename C, qualifier P>
  constexpr vec(vec<2, A, P> const& _xy, B _z, C _w);

  template<typename A, typename B, typename C, qualifier P>
  constexpr vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z, C _w);

  template<typename A, typename B, typename C, qualifier P>
  constexpr vec(vec<2, A, P> const& _xy, B _z, vec<1, C, P> const& _w);

  template<typename A, typename B, typename C, qualifier P>
  constexpr vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z, vec<1, C, P> const& _w);

  template<typename A, typename B, typename C, qualifier P>
  constexpr vec(A _x, vec<2, B, P> const& _yz, C _w);

  template<typename A, typename B, typename C, qualifier P>
  constexpr vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz, C _w);

  template<typename A, typename B, typename C, qualifier P>
  constexpr vec(A _x, vec<2, B, P> const& _yz, vec<1, C, P> const& _w);

  template<typename A, typename B, typename C, qualifier P>
  constexpr vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz, vec<1, C, P> const& _w);

  template<typename A, typename B, typename C, qualifier P>
  constexpr vec(A _x, B _y, vec<2, C, P> const& _zw);

  template<typename A, typename B, typename C, qualifier P>
  constexpr vec(vec<1, A, P> const& _x, B _y, vec<2, C, P> const& _zw);

  template<typename A, typename B, typename C, qualifier P>
  constexpr vec(A _x, vec<1, B, P> const& _y, vec<2, C, P> const& _zw);

  template<typename A, typename B, typename C, qualifier P>
  constexpr vec(vec<1, A, P> const& _x, vec<1, B, P> const& _y, vec<2, C, P> const& _zw);

  template<typename A, typename B, qualifier P>
  constexpr vec(vec<3, A, P> const& _xyz, B _w);

  template<typename A, typename B, qualifier P>
  constexpr vec(vec<3, A, P> const& _xyz, vec<1, B, P> const& _w);

  template<typename A, typename B, qualifier P>
  constexpr vec(A _x, vec<3, B, P> const& _yzw);

  template<typename A, typename B, qualifier P>
  constexpr vec(vec<1, A, P> const& _x, vec<3, B, P> const& _yzw);

  template<typename A, typename B, qualifier P>
  constexpr vec(vec<2, A, P> const& _xy, vec<2, B, P> const& _zw);


  template<typename U, qualifier P>
  constexpr vec(vec<4, U, P> const& v);
# 252 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec4.hpp"
  constexpr vec<4, T, Q>& operator=(vec<4, T, Q> const& v) = default;

  template<typename U>
  constexpr vec<4, T, Q>& operator=(vec<4, U, Q> const& v);
  template<typename U>
  constexpr vec<4, T, Q>& operator+=(U scalar);
  template<typename U>
  constexpr vec<4, T, Q>& operator+=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<4, T, Q>& operator+=(vec<4, U, Q> const& v);
  template<typename U>
  constexpr vec<4, T, Q>& operator-=(U scalar);
  template<typename U>
  constexpr vec<4, T, Q>& operator-=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<4, T, Q>& operator-=(vec<4, U, Q> const& v);
  template<typename U>
  constexpr vec<4, T, Q>& operator*=(U scalar);
  template<typename U>
  constexpr vec<4, T, Q>& operator*=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<4, T, Q>& operator*=(vec<4, U, Q> const& v);
  template<typename U>
  constexpr vec<4, T, Q>& operator/=(U scalar);
  template<typename U>
  constexpr vec<4, T, Q>& operator/=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<4, T, Q>& operator/=(vec<4, U, Q> const& v);



  constexpr vec<4, T, Q> & operator++();
  constexpr vec<4, T, Q> & operator--();
  [[nodiscard]] constexpr vec<4, T, Q> operator++(int);
  [[nodiscard]] constexpr vec<4, T, Q> operator--(int);



  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator%=(U scalar);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator%=(vec<1, U, Q> const& v);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator%=(vec<4, U, Q> const& v);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator&=(U scalar);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator&=(vec<1, U, Q> const& v);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator&=(vec<4, U, Q> const& v);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator|=(U scalar);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator|=(vec<1, U, Q> const& v);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator|=(vec<4, U, Q> const& v);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator^=(U scalar);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator^=(vec<1, U, Q> const& v);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator^=(vec<4, U, Q> const& v);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator<<=(U scalar);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator<<=(vec<1, U, Q> const& v);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator<<=(vec<4, U, Q> const& v);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator>>=(U scalar);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator>>=(vec<1, U, Q> const& v);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator>>=(vec<4, U, Q> const& v);
 };



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator+(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator+(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator-(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator-(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator*(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator*(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator/(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator/(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator/(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator/(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator/(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator%(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator%(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator%(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator%(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator%(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator&(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator&(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator&(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator&(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator&(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator|(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator|(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator|(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator|(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator|(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator^(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator^(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator^(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator^(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator^(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator<<(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator<<(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator<<(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator<<(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator<<(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator>>(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator>>(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator>>(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator>>(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator>>(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator~(vec<4, T, Q> const& v);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<qualifier Q>
 [[nodiscard]] constexpr vec<4, bool, Q> operator&&(vec<4, bool, Q> const& v1, vec<4, bool, Q> const& v2);

 template<qualifier Q>
 [[nodiscard]] constexpr vec<4, bool, Q> operator||(vec<4, bool, Q> const& v1, vec<4, bool, Q> const& v2);
}


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec4.inl" 1




namespace glm{
namespace detail
{
 template<typename T, qualifier Q, bool Aligned>
 struct compute_vec4_add
 {
  inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_vec4_sub
 {
  inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_vec4_mul
 {
  inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_vec4_div
 {
  inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_vec4_mod
 {
  inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x % b.x, a.y % b.y, a.z % b.z, a.w % b.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_and
 {
  inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_or
 {
  inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_xor
 {
  inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_shift_left
 {
  inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x << b.x, a.y << b.y, a.z << b.z, a.w << b.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_shift_right
 {
  inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x >> b.x, a.y >> b.y, a.z >> b.z, a.w >> b.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_equal
 {
  inline constexpr static bool call(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
  {
   return
    detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.x, v2.x) &&
    detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.y, v2.y) &&
    detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.z, v2.z) &&
    detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.w, v2.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_nequal
 {
  inline constexpr static bool call(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
  {
   return !compute_vec4_equal<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(v1, v2);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_bitwise_not
 {
  inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& v)
  {
   return vec<4, T, Q>(~v.x, ~v.y, ~v.z, ~v.w);
  }
 };
}
# 148 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec4.inl"
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<4, T, P> const& v)
  : x(v.x), y(v.y), z(v.z), w(v.w)
 {}



 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q>::vec(T scalar)
  : x(scalar), y(scalar), z(scalar), w(scalar)
 {}

 template <typename T, qualifier Q>
 inline constexpr vec<4, T, Q>::vec(T _x, T _y, T _z, T _w)
  : x(_x), y(_y), z(_z), w(_w)
 {}



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<1, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.x))
  , z(static_cast<T>(v.x))
  , w(static_cast<T>(v.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(X _x, Y _y, Z _z, W _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, Z _z, W _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, Z _z, W _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z, W _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(X _x, Y _y, vec<1, Z, Q> const& _z, W _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z, W _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, W _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, W _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, Z _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, Z _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(X _x, Y _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w.x))
 {}



 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<2, A, P> const& _xy, B _z, C _w)
  : x(static_cast<T>(_xy.x))
  , y(static_cast<T>(_xy.y))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z, C _w)
  : x(static_cast<T>(_xy.x))
  , y(static_cast<T>(_xy.y))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<2, A, P> const& _xy, B _z, vec<1, C, P> const& _w)
  : x(static_cast<T>(_xy.x))
  , y(static_cast<T>(_xy.y))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z, vec<1, C, P> const& _w)
  : x(static_cast<T>(_xy.x))
  , y(static_cast<T>(_xy.y))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline constexpr vec<4, T, Q>::vec(A _x, vec<2, B, P> const& _yz, C _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_yz.x))
  , z(static_cast<T>(_yz.y))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz, C _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_yz.x))
  , z(static_cast<T>(_yz.y))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline constexpr vec<4, T, Q>::vec(A _x, vec<2, B, P> const& _yz, vec<1, C, P> const& _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_yz.x))
  , z(static_cast<T>(_yz.y))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz, vec<1, C, P> const& _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_yz.x))
  , z(static_cast<T>(_yz.y))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline constexpr vec<4, T, Q>::vec(A _x, B _y, vec<2, C, P> const& _zw)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_zw.x))
  , w(static_cast<T>(_zw.y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<1, A, P> const& _x, B _y, vec<2, C, P> const& _zw)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_zw.x))
  , w(static_cast<T>(_zw.y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline constexpr vec<4, T, Q>::vec(A _x, vec<1, B, P> const& _y, vec<2, C, P> const& _zw)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_zw.x))
  , w(static_cast<T>(_zw.y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<1, A, P> const& _x, vec<1, B, P> const& _y, vec<2, C, P> const& _zw)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_zw.x))
  , w(static_cast<T>(_zw.y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<3, A, P> const& _xyz, B _w)
  : x(static_cast<T>(_xyz.x))
  , y(static_cast<T>(_xyz.y))
  , z(static_cast<T>(_xyz.z))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<3, A, P> const& _xyz, vec<1, B, P> const& _w)
  : x(static_cast<T>(_xyz.x))
  , y(static_cast<T>(_xyz.y))
  , z(static_cast<T>(_xyz.z))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline constexpr vec<4, T, Q>::vec(A _x, vec<3, B, P> const& _yzw)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_yzw.x))
  , z(static_cast<T>(_yzw.y))
  , w(static_cast<T>(_yzw.z))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<1, A, P> const& _x, vec<3, B, P> const& _yzw)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_yzw.x))
  , z(static_cast<T>(_yzw.y))
  , w(static_cast<T>(_yzw.z))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<2, A, P> const& _xy, vec<2, B, P> const& _zw)
  : x(static_cast<T>(_xy.x))
  , y(static_cast<T>(_xy.y))
  , z(static_cast<T>(_zw.x))
  , w(static_cast<T>(_zw.y))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<4, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
  , z(static_cast<T>(v.z))
  , w(static_cast<T>(v.w))
 {}



 template<typename T, qualifier Q>
 inline constexpr T& vec<4, T, Q>::operator[](typename vec<4, T, Q>::length_type i)
 {
  (
# 481 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec4.inl" 3
 ((void)0)
# 481 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec4.inl"
 );
  switch(i)
  {
  default:
  case 0:
   return x;
  case 1:
   return y;
  case 2:
   return z;
  case 3:
   return w;
  }
 }

 template<typename T, qualifier Q>
 inline constexpr T const& vec<4, T, Q>::operator[](typename vec<4, T, Q>::length_type i) const
 {
  (
# 499 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec4.inl" 3
 ((void)0)
# 499 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec4.inl"
 );
  switch(i)
  {
  default:
  case 0:
   return x;
  case 1:
   return y;
  case 2:
   return z;
  case 3:
   return w;
  }
 }
# 528 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec4.inl"
 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q>& vec<4, T, Q>::operator=(vec<4, U, Q> const& v)
 {
  this->x = static_cast<T>(v.x);
  this->y = static_cast<T>(v.y);
  this->z = static_cast<T>(v.z);
  this->w = static_cast<T>(v.w);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator+=(U scalar)
 {
  return (*this = detail::compute_vec4_add<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator+=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_add<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v.x)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator+=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_add<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator-=(U scalar)
 {
  return (*this = detail::compute_vec4_sub<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator-=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_sub<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v.x)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator-=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_sub<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator*=(U scalar)
 {
  return (*this = detail::compute_vec4_mul<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator*=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_mul<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v.x)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator*=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_mul<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator/=(U scalar)
 {
  return (*this = detail::compute_vec4_div<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator/=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_div<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v.x)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator/=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_div<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }



 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator++()
 {
  ++this->x;
  ++this->y;
  ++this->z;
  ++this->w;
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator--()
 {
  --this->x;
  --this->y;
  --this->z;
  --this->w;
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> vec<4, T, Q>::operator++(int)
 {
  vec<4, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> vec<4, T, Q>::operator--(int)
 {
  vec<4, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator%=(U scalar)
 {
  return (*this = detail::compute_vec4_mod<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator%=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_mod<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator%=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_mod<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator&=(U scalar)
 {
  return (*this = detail::compute_vec4_and<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator&=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_and<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator&=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_and<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator|=(U scalar)
 {
  return (*this = detail::compute_vec4_or<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator|=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_or<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator|=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_or<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator^=(U scalar)
 {
  return (*this = detail::compute_vec4_xor<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator^=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_xor<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator^=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_xor<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator<<=(U scalar)
 {
  return (*this = detail::compute_vec4_shift_left<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator<<=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_shift_left<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator<<=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_shift_left<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator>>=(U scalar)
 {
  return (*this = detail::compute_vec4_shift_right<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator>>=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_shift_right<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator>>=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_shift_right<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }



 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v)
 {
  return v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(0) -= v;
 }



 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) += scalar;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) += v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator+(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(v) += scalar;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator+(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v2) += v1;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) += v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) -= scalar;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) -= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator-(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) -= v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator-(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) -= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) -= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) *= scalar;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) *= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator*(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(v) *= scalar;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator*(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v2) *= v1;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) *= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator/(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) /= scalar;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator/(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) /= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator/(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) /= v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator/(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) /= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator/(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) /= v2;
 }



 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator%(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) %= scalar;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator%(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) %= v2.x;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator%(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) %= v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator%(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar.x) %= v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator%(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) %= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator&(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) &= scalar;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator&(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<4, T, Q>(v) &= scalar;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator&(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) &= v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator&(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) &= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator&(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) &= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator|(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) |= scalar;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator|(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) |= v2.x;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator|(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) |= v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator|(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) |= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator|(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) |= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator^(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) ^= scalar;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator^(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) ^= v2.x;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator^(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) ^= v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator^(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) ^= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator^(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) ^= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator<<(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) <<= scalar;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator<<(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) <<= v2.x;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator<<(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) <<= v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator<<(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) <<= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator<<(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) <<= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator>>(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) >>= scalar;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator>>(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) >>= v2.x;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator>>(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) >>= v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator>>(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) >>= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator>>(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) >>= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator~(vec<4, T, Q> const& v)
 {
  return detail::compute_vec4_bitwise_not<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(v);
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return detail::compute_vec4_equal<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(v1, v2);
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return detail::compute_vec4_nequal<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(v1, v2);
 }

 template<qualifier Q>
 inline constexpr vec<4, bool, Q> operator&&(vec<4, bool, Q> const& v1, vec<4, bool, Q> const& v2)
 {
  return vec<4, bool, Q>(v1.x && v2.x, v1.y && v2.y, v1.z && v2.z, v1.w && v2.w);
 }

 template<qualifier Q>
 inline constexpr vec<4, bool, Q> operator||(vec<4, bool, Q> const& v1, vec<4, bool, Q> const& v2)
 {
  return vec<4, bool, Q>(v1.x || v2.x, v1.y || v2.y, v1.z || v2.z, v1.w || v2.w);
 }
}
# 508 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec4.hpp" 2
# 6 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_bool4.hpp" 2

namespace glm
{






 typedef vec<4, bool, defaultp> bvec4;


}
# 6 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vec4.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_bool4_precision.hpp" 1



       


namespace glm
{







 typedef vec<4, bool, highp> highp_bvec4;





 typedef vec<4, bool, mediump> mediump_bvec4;





 typedef vec<4, bool, lowp> lowp_bvec4;


}
# 7 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vec4.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_float4.hpp" 1



       


namespace glm
{






 typedef vec<4, float, defaultp> vec4;


}
# 8 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vec4.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_float4_precision.hpp" 1



       


namespace glm
{







 typedef vec<4, float, highp> highp_vec4;





 typedef vec<4, float, mediump> mediump_vec4;





 typedef vec<4, float, lowp> lowp_vec4;


}
# 9 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vec4.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_double4.hpp" 1



       


namespace glm
{






 typedef vec<4, double, defaultp> dvec4;


}
# 10 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vec4.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_double4_precision.hpp" 1



       
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/setup.hpp" 1
# 6 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_double4_precision.hpp" 2


namespace glm
{
# 18 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_double4_precision.hpp"
 typedef vec<4, double, highp> highp_dvec4;






 typedef vec<4, double, mediump> mediump_dvec4;






 typedef vec<4, double, lowp> lowp_dvec4;


}
# 11 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vec4.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_int4.hpp" 1



       


namespace glm
{






 typedef vec<4, int, defaultp> ivec4;


}
# 12 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vec4.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_int4_sized.hpp" 1
# 14 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_int4_sized.hpp"
       
# 23 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_int4_sized.hpp"
namespace glm
{






 typedef vec<4, int8, defaultp> i8vec4;




 typedef vec<4, int16, defaultp> i16vec4;




 typedef vec<4, int32, defaultp> i32vec4;




 typedef vec<4, int64, defaultp> i64vec4;


}
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vec4.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_uint4.hpp" 1



       


namespace glm
{






 typedef vec<4, unsigned int, defaultp> uvec4;


}
# 14 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vec4.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_uint4_sized.hpp" 1
# 14 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_uint4_sized.hpp"
       
# 23 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_uint4_sized.hpp"
namespace glm
{






 typedef vec<4, uint8, defaultp> u8vec4;




 typedef vec<4, uint16, defaultp> u16vec4;




 typedef vec<4, uint32, defaultp> u32vec4;




 typedef vec<4, uint64, defaultp> u64vec4;


}
# 15 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vec4.hpp" 2
# 120 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/glm.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat2x2.hpp" 1



       
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_double2x2.hpp" 1



       
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat2x2.hpp" 1



       





namespace glm
{
 template<typename T, qualifier Q>
 struct mat<2, 2, T, Q>
 {
  typedef vec<2, T, Q> col_type;
  typedef vec<2, T, Q> row_type;
  typedef mat<2, 2, T, Q> type;
  typedef mat<2, 2, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[2];

 public:


  typedef length_t length_type;
  [[nodiscard]] static constexpr length_type length() { return 2; }

  [[nodiscard]] constexpr col_type & operator[](length_type i) noexcept;
  [[nodiscard]] constexpr col_type const& operator[](length_type i) const noexcept;



  constexpr mat() = default;
  template<qualifier P>
  constexpr mat(mat<2, 2, T, P> const& m);

  constexpr mat(T scalar);
  constexpr mat(
   T const& x1, T const& y1,
   T const& x2, T const& y2);
  constexpr mat(
   col_type const& v1,
   col_type const& v2);



  template<typename U, typename V, typename M, typename N>
  constexpr mat(
   U const& x1, V const& y1,
   M const& x2, N const& y2);

  template<typename U, typename V>
  constexpr mat(
   vec<2, U, Q> const& v1,
   vec<2, V, Q> const& v2);



  template<typename U, qualifier P>
  constexpr mat(mat<2, 2, U, P> const& m);

  constexpr mat(mat<3, 3, T, Q> const& x);
  constexpr mat(mat<4, 4, T, Q> const& x);
  constexpr mat(mat<2, 3, T, Q> const& x);
  constexpr mat(mat<3, 2, T, Q> const& x);
  constexpr mat(mat<2, 4, T, Q> const& x);
  constexpr mat(mat<4, 2, T, Q> const& x);
  constexpr mat(mat<3, 4, T, Q> const& x);
  constexpr mat(mat<4, 3, T, Q> const& x);



  template<typename U>
  constexpr mat<2, 2, T, Q> & operator=(mat<2, 2, U, Q> const& m);
  template<typename U>
  constexpr mat<2, 2, T, Q> & operator+=(U s);
  template<typename U>
  constexpr mat<2, 2, T, Q> & operator+=(mat<2, 2, U, Q> const& m);
  template<typename U>
  constexpr mat<2, 2, T, Q> & operator-=(U s);
  template<typename U>
  constexpr mat<2, 2, T, Q> & operator-=(mat<2, 2, U, Q> const& m);
  template<typename U>
  constexpr mat<2, 2, T, Q> & operator*=(U s);
  template<typename U>
  constexpr mat<2, 2, T, Q> & operator*=(mat<2, 2, U, Q> const& m);
  template<typename U>
  constexpr mat<2, 2, T, Q> & operator/=(U s);
  template<typename U>
  constexpr mat<2, 2, T, Q> & operator/=(mat<2, 2, U, Q> const& m);



  constexpr mat<2, 2, T, Q> & operator++ ();
  constexpr mat<2, 2, T, Q> & operator-- ();
  [[nodiscard]] constexpr mat<2, 2, T, Q> operator++(int);
  [[nodiscard]] constexpr mat<2, 2, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator+(T scalar, mat<2, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator-(T scalar, mat<2, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator*(mat<2, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator*(T scalar, mat<2, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<2, 2, T, Q>::col_type operator*(mat<2, 2, T, Q> const& m, typename mat<2, 2, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<2, 2, T, Q>::row_type operator*(typename mat<2, 2, T, Q>::col_type const& v, mat<2, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator/(mat<2, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator/(T scalar, mat<2, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<2, 2, T, Q>::col_type operator/(mat<2, 2, T, Q> const& m, typename mat<2, 2, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<2, 2, T, Q>::row_type operator/(typename mat<2, 2, T, Q>::col_type const& v, mat<2, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator/(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);
}


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat2x2.inl" 1
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/matrix.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/matrix.hpp"
       



# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/setup.hpp" 1
# 18 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/matrix.hpp" 2




# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat2x3.hpp" 1



       
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_double2x3.hpp" 1



       
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat2x3.hpp" 1



       






namespace glm
{
 template<typename T, qualifier Q>
 struct mat<2, 3, T, Q>
 {
  typedef vec<3, T, Q> col_type;
  typedef vec<2, T, Q> row_type;
  typedef mat<2, 3, T, Q> type;
  typedef mat<3, 2, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[2];

 public:


  typedef length_t length_type;
  [[nodiscard]] static constexpr length_type length() { return 2; }

  [[nodiscard]] constexpr col_type & operator[](length_type i) noexcept;
  [[nodiscard]] constexpr col_type const& operator[](length_type i) const noexcept;



  constexpr mat() = default;
  template<qualifier P>
  constexpr mat(mat<2, 3, T, P> const& m);

  constexpr mat(T scalar);
  constexpr mat(
   T x0, T y0, T z0,
   T x1, T y1, T z1);
  constexpr mat(
   col_type const& v0,
   col_type const& v1);



  template<typename X1, typename Y1, typename Z1, typename X2, typename Y2, typename Z2>
  constexpr mat(
   X1 x1, Y1 y1, Z1 z1,
   X2 x2, Y2 y2, Z2 z2);

  template<typename U, typename V>
  constexpr mat(
   vec<3, U, Q> const& v1,
   vec<3, V, Q> const& v2);



  template<typename U, qualifier P>
  constexpr mat(mat<2, 3, U, P> const& m);

  constexpr mat(mat<2, 2, T, Q> const& x);
  constexpr mat(mat<3, 3, T, Q> const& x);
  constexpr mat(mat<4, 4, T, Q> const& x);
  constexpr mat(mat<2, 4, T, Q> const& x);
  constexpr mat(mat<3, 2, T, Q> const& x);
  constexpr mat(mat<3, 4, T, Q> const& x);
  constexpr mat(mat<4, 2, T, Q> const& x);
  constexpr mat(mat<4, 3, T, Q> const& x);



  template<typename U>
  constexpr mat<2, 3, T, Q> & operator=(mat<2, 3, U, Q> const& m);
  template<typename U>
  constexpr mat<2, 3, T, Q> & operator+=(U s);
  template<typename U>
  constexpr mat<2, 3, T, Q> & operator+=(mat<2, 3, U, Q> const& m);
  template<typename U>
  constexpr mat<2, 3, T, Q> & operator-=(U s);
  template<typename U>
  constexpr mat<2, 3, T, Q> & operator-=(mat<2, 3, U, Q> const& m);
  template<typename U>
  constexpr mat<2, 3, T, Q> & operator*=(U s);
  template<typename U>
  constexpr mat<2, 3, T, Q> & operator/=(U s);



  constexpr mat<2, 3, T, Q> & operator++ ();
  constexpr mat<2, 3, T, Q> & operator-- ();
  [[nodiscard]] constexpr mat<2, 3, T, Q> operator++(int);
  [[nodiscard]] constexpr mat<2, 3, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 3, T, Q> operator*(mat<2, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 3, T, Q> operator*(T scalar, mat<2, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<2, 3, T, Q>::col_type operator*(mat<2, 3, T, Q> const& m, typename mat<2, 3, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<2, 3, T, Q>::row_type operator*(typename mat<2, 3, T, Q>::col_type const& v, mat<2, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<4, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 3, T, Q> operator/(mat<2, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 3, T, Q> operator/(T scalar, mat<2, 3, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2);
}


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat2x3.inl" 1
namespace glm
{
# 19 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat2x3.inl"
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr mat<2, 3, T, Q>::mat(mat<2, 3, T, P> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q>::mat(T scalar)

   : value{col_type(scalar, 0, 0), col_type(0, scalar, 0)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q>::mat
 (
  T x0, T y0, T z0,
  T x1, T y1, T z1
 )

   : value{col_type(x0, y0, z0), col_type(x1, y1, z1)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q>::mat(col_type const& v0, col_type const& v1)

   : value{col_type(v0), col_type(v1)}

 {




 }



 template<typename T, qualifier Q>
 template<
  typename X1, typename Y1, typename Z1,
  typename X2, typename Y2, typename Z2>
 inline constexpr mat<2, 3, T, Q>::mat
 (
  X1 x1, Y1 y1, Z1 z1,
  X2 x2, Y2 y2, Z2 z2
 )

   : value{col_type(x1, y1, z1), col_type(x2, y2, z2)}

 {




 }

 template<typename T, qualifier Q>
 template<typename V1, typename V2>
 inline constexpr mat<2, 3, T, Q>::mat(vec<3, V1, Q> const& v1, vec<3, V2, Q> const& v2)

   : value{col_type(v1), col_type(v2)}

 {




 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr mat<2, 3, T, Q>::mat(mat<2, 3, U, P> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q>::mat(mat<2, 2, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q>::mat(mat<3, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q>::mat(mat<4, 4, T, Q> const& m)

  : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q>::mat(mat<2, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q>::mat(mat<3, 2, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q>::mat(mat<3, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q>::mat(mat<4, 2, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q>::mat(mat<4, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }



 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 3, T, Q>::col_type & mat<2, 3, T, Q>::operator[](typename mat<2, 3, T, Q>::length_type i) noexcept
 {
  (
# 222 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat2x3.inl" 3
 ((void)0)
# 222 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat2x3.inl"
 );
  return this->value[i];
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 3, T, Q>::col_type const& mat<2, 3, T, Q>::operator[](typename mat<2, 3, T, Q>::length_type i) const noexcept
 {
  (
# 229 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat2x3.inl" 3
 ((void)0)
# 229 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat2x3.inl"
 );
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 3, T, Q>& mat<2, 3, T, Q>::operator=(mat<2, 3, U, Q> const& m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 3, T, Q> & mat<2, 3, T, Q>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 3, T, Q>& mat<2, 3, T, Q>::operator+=(mat<2, 3, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 3, T, Q>& mat<2, 3, T, Q>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 3, T, Q>& mat<2, 3, T, Q>::operator-=(mat<2, 3, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 3, T, Q>& mat<2, 3, T, Q>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 3, T, Q> & mat<2, 3, T, Q>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  return *this;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> & mat<2, 3, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> & mat<2, 3, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> mat<2, 3, T, Q>::operator++(int)
 {
  mat<2, 3, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> mat<2, 3, T, Q>::operator--(int)
 {
  mat<2, 3, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m)
 {
  return mat<2, 3, T, Q>(
   -m[0],
   -m[1]);
 }



 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m, T scalar)
 {
  return mat<2, 3, T, Q>(
   m[0] + scalar,
   m[1] + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
 {
  return mat<2, 3, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m, T scalar)
 {
  return mat<2, 3, T, Q>(
   m[0] - scalar,
   m[1] - scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
 {
  return mat<2, 3, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> operator*(mat<2, 3, T, Q> const& m, T scalar)
 {
  return mat<2, 3, T, Q>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> operator*(T scalar, mat<2, 3, T, Q> const& m)
 {
  return mat<2, 3, T, Q>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 3, T, Q>::col_type operator*
 (
  mat<2, 3, T, Q> const& m,
  typename mat<2, 3, T, Q>::row_type const& v)
 {
  return typename mat<2, 3, T, Q>::col_type(
   m[0][0] * v.x + m[1][0] * v.y,
   m[0][1] * v.x + m[1][1] * v.y,
   m[0][2] * v.x + m[1][2] * v.y);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 3, T, Q>::row_type operator*
 (
  typename mat<2, 3, T, Q>::col_type const& v,
  mat<2, 3, T, Q> const& m)
 {
  return typename mat<2, 3, T, Q>::row_type(
   v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2],
   v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
 {
  return mat<2, 3, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
 {
  T SrcA00 = m1[0][0];
  T SrcA01 = m1[0][1];
  T SrcA02 = m1[0][2];
  T SrcA10 = m1[1][0];
  T SrcA11 = m1[1][1];
  T SrcA12 = m1[1][2];

  T SrcB00 = m2[0][0];
  T SrcB01 = m2[0][1];
  T SrcB10 = m2[1][0];
  T SrcB11 = m2[1][1];
  T SrcB20 = m2[2][0];
  T SrcB21 = m2[2][1];

  mat<3, 3, T, Q> Result;
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
 {
  return mat<4, 3, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1],
   m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> operator/(mat<2, 3, T, Q> const& m, T scalar)
 {
  return mat<2, 3, T, Q>(
   m[0] / scalar,
   m[1] / scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> operator/(T scalar, mat<2, 3, T, Q> const& m)
 {
  return mat<2, 3, T, Q>(
   scalar / m[0],
   scalar / m[1]);
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]);
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]);
 }
}
# 159 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat2x3.hpp" 2
# 6 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_double2x3.hpp" 2

namespace glm
{






 typedef mat<2, 3, double, defaultp> dmat2x3;


}
# 6 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat2x3.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_double2x3_precision.hpp" 1



       


namespace glm
{







 typedef mat<2, 3, double, lowp> lowp_dmat2x3;





 typedef mat<2, 3, double, mediump> mediump_dmat2x3;





 typedef mat<2, 3, double, highp> highp_dmat2x3;


}
# 7 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat2x3.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_float2x3.hpp" 1



       


namespace glm
{






 typedef mat<2, 3, float, defaultp> mat2x3;


}
# 8 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat2x3.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_float2x3_precision.hpp" 1



       


namespace glm
{







 typedef mat<2, 3, float, lowp> lowp_mat2x3;





 typedef mat<2, 3, float, mediump> mediump_mat2x3;





 typedef mat<2, 3, float, highp> highp_mat2x3;


}
# 9 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat2x3.hpp" 2
# 23 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/matrix.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat2x4.hpp" 1



       
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_double2x4.hpp" 1



       
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat2x4.hpp" 1



       






namespace glm
{
 template<typename T, qualifier Q>
 struct mat<2, 4, T, Q>
 {
  typedef vec<4, T, Q> col_type;
  typedef vec<2, T, Q> row_type;
  typedef mat<2, 4, T, Q> type;
  typedef mat<4, 2, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[2];

 public:


  typedef length_t length_type;
  [[nodiscard]] static constexpr length_type length() { return 2; }

  [[nodiscard]] constexpr col_type & operator[](length_type i) noexcept;
  [[nodiscard]] constexpr col_type const& operator[](length_type i) const noexcept;



  constexpr mat() = default;
  template<qualifier P>
  constexpr mat(mat<2, 4, T, P> const& m);

  constexpr mat(T scalar);
  constexpr mat(
   T x0, T y0, T z0, T w0,
   T x1, T y1, T z1, T w1);
  constexpr mat(
   col_type const& v0,
   col_type const& v1);



  template<
   typename X1, typename Y1, typename Z1, typename W1,
   typename X2, typename Y2, typename Z2, typename W2>
  constexpr mat(
   X1 x1, Y1 y1, Z1 z1, W1 w1,
   X2 x2, Y2 y2, Z2 z2, W2 w2);

  template<typename U, typename V>
  constexpr mat(
   vec<4, U, Q> const& v1,
   vec<4, V, Q> const& v2);



  template<typename U, qualifier P>
  constexpr mat(mat<2, 4, U, P> const& m);

  constexpr mat(mat<2, 2, T, Q> const& x);
  constexpr mat(mat<3, 3, T, Q> const& x);
  constexpr mat(mat<4, 4, T, Q> const& x);
  constexpr mat(mat<2, 3, T, Q> const& x);
  constexpr mat(mat<3, 2, T, Q> const& x);
  constexpr mat(mat<3, 4, T, Q> const& x);
  constexpr mat(mat<4, 2, T, Q> const& x);
  constexpr mat(mat<4, 3, T, Q> const& x);



  template<typename U>
  constexpr mat<2, 4, T, Q> & operator=(mat<2, 4, U, Q> const& m);
  template<typename U>
  constexpr mat<2, 4, T, Q> & operator+=(U s);
  template<typename U>
  constexpr mat<2, 4, T, Q> & operator+=(mat<2, 4, U, Q> const& m);
  template<typename U>
  constexpr mat<2, 4, T, Q> & operator-=(U s);
  template<typename U>
  constexpr mat<2, 4, T, Q> & operator-=(mat<2, 4, U, Q> const& m);
  template<typename U>
  constexpr mat<2, 4, T, Q> & operator*=(U s);
  template<typename U>
  constexpr mat<2, 4, T, Q> & operator/=(U s);



  constexpr mat<2, 4, T, Q> & operator++ ();
  constexpr mat<2, 4, T, Q> & operator-- ();
  [[nodiscard]] constexpr mat<2, 4, T, Q> operator++(int);
  [[nodiscard]] constexpr mat<2, 4, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 4, T, Q> operator*(mat<2, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 4, T, Q> operator*(T scalar, mat<2, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<2, 4, T, Q>::col_type operator*(mat<2, 4, T, Q> const& m, typename mat<2, 4, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<2, 4, T, Q>::row_type operator*(typename mat<2, 4, T, Q>::col_type const& v, mat<2, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<4, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 4, T, Q> operator/(mat<2, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 4, T, Q> operator/(T scalar, mat<2, 4, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2);
}


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat2x4.inl" 1
namespace glm
{
# 19 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat2x4.inl"
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr mat<2, 4, T, Q>::mat(mat<2, 4, T, P> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q>::mat(T s)

   : value{col_type(s, 0, 0, 0), col_type(0, s, 0, 0)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q>::mat
 (
  T x0, T y0, T z0, T w0,
  T x1, T y1, T z1, T w1
 )

   : value{col_type(x0, y0, z0, w0), col_type(x1, y1, z1, w1)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q>::mat(col_type const& v0, col_type const& v1)

   : value{col_type(v0), col_type(v1)}

 {




 }



 template<typename T, qualifier Q>
 template<
  typename X1, typename Y1, typename Z1, typename W1,
  typename X2, typename Y2, typename Z2, typename W2>
 inline constexpr mat<2, 4, T, Q>::mat
 (
  X1 x1, Y1 y1, Z1 z1, W1 w1,
  X2 x2, Y2 y2, Z2 z2, W2 w2
 )

   : value{
    col_type(x1, y1, z1, w1),
    col_type(x2, y2, z2, w2)}

 {




 }

 template<typename T, qualifier Q>
 template<typename V1, typename V2>
 inline constexpr mat<2, 4, T, Q>::mat(vec<4, V1, Q> const& v1, vec<4, V2, Q> const& v2)

   : value{col_type(v1), col_type(v2)}

 {




 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr mat<2, 4, T, Q>::mat(mat<2, 4, U, P> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q>::mat(mat<2, 2, T, Q> const& m)

   : value{col_type(m[0], 0, 0), col_type(m[1], 0, 0)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q>::mat(mat<3, 3, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q>::mat(mat<4, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q>::mat(mat<2, 3, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q>::mat(mat<3, 2, T, Q> const& m)

   : value{col_type(m[0], 0, 0), col_type(m[1], 0, 0)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q>::mat(mat<3, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q>::mat(mat<4, 2, T, Q> const& m)

   : value{col_type(m[0], 0, 0), col_type(m[1], 0, 0)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q>::mat(mat<4, 3, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0)}

 {




 }



 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 4, T, Q>::col_type & mat<2, 4, T, Q>::operator[](typename mat<2, 4, T, Q>::length_type i) noexcept
 {
  (
# 224 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat2x4.inl" 3
 ((void)0)
# 224 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat2x4.inl"
 );
  return this->value[i];
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 4, T, Q>::col_type const& mat<2, 4, T, Q>::operator[](typename mat<2, 4, T, Q>::length_type i) const noexcept
 {
  (
# 231 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat2x4.inl" 3
 ((void)0)
# 231 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat2x4.inl"
 );
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator=(mat<2, 4, U, Q> const& m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator+=(mat<2, 4, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator-=(mat<2, 4, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 4, T, Q> & mat<2, 4, T, Q>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  return *this;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> mat<2, 4, T, Q>::operator++(int)
 {
  mat<2, 4, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> mat<2, 4, T, Q>::operator--(int)
 {
  mat<2, 4, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m)
 {
  return mat<2, 4, T, Q>(
   -m[0],
   -m[1]);
 }



 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m, T scalar)
 {
  return mat<2, 4, T, Q>(
   m[0] + scalar,
   m[1] + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
 {
  return mat<2, 4, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m, T scalar)
 {
  return mat<2, 4, T, Q>(
   m[0] - scalar,
   m[1] - scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
 {
  return mat<2, 4, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> operator*(mat<2, 4, T, Q> const& m, T scalar)
 {
  return mat<2, 4, T, Q>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> operator*(T scalar, mat<2, 4, T, Q> const& m)
 {
  return mat<2, 4, T, Q>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 4, T, Q>::col_type operator*(mat<2, 4, T, Q> const& m, typename mat<2, 4, T, Q>::row_type const& v)
 {
  return typename mat<2, 4, T, Q>::col_type(
   m[0][0] * v.x + m[1][0] * v.y,
   m[0][1] * v.x + m[1][1] * v.y,
   m[0][2] * v.x + m[1][2] * v.y,
   m[0][3] * v.x + m[1][3] * v.y);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 4, T, Q>::row_type operator*(typename mat<2, 4, T, Q>::col_type const& v, mat<2, 4, T, Q> const& m)
 {
  return typename mat<2, 4, T, Q>::row_type(
   v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2] + v.w * m[0][3],
   v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2] + v.w * m[1][3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
 {
  T SrcA00 = m1[0][0];
  T SrcA01 = m1[0][1];
  T SrcA02 = m1[0][2];
  T SrcA03 = m1[0][3];
  T SrcA10 = m1[1][0];
  T SrcA11 = m1[1][1];
  T SrcA12 = m1[1][2];
  T SrcA13 = m1[1][3];

  T SrcB00 = m2[0][0];
  T SrcB01 = m2[0][1];
  T SrcB10 = m2[1][0];
  T SrcB11 = m2[1][1];
  T SrcB20 = m2[2][0];
  T SrcB21 = m2[2][1];
  T SrcB30 = m2[3][0];
  T SrcB31 = m2[3][1];

  mat<4, 4, T, Q> Result;
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01;
  Result[0][3] = SrcA03 * SrcB00 + SrcA13 * SrcB01;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11;
  Result[1][3] = SrcA03 * SrcB10 + SrcA13 * SrcB11;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21;
  Result[2][3] = SrcA03 * SrcB20 + SrcA13 * SrcB21;
  Result[3][0] = SrcA00 * SrcB30 + SrcA10 * SrcB31;
  Result[3][1] = SrcA01 * SrcB30 + SrcA11 * SrcB31;
  Result[3][2] = SrcA02 * SrcB30 + SrcA12 * SrcB31;
  Result[3][3] = SrcA03 * SrcB30 + SrcA13 * SrcB31;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
 {
  return mat<2, 4, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
 {
  return mat<3, 4, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1],
   m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> operator/(mat<2, 4, T, Q> const& m, T scalar)
 {
  return mat<2, 4, T, Q>(
   m[0] / scalar,
   m[1] / scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> operator/(T scalar, mat<2, 4, T, Q> const& m)
 {
  return mat<2, 4, T, Q>(
   scalar / m[0],
   scalar / m[1]);
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]);
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]);
 }
}
# 161 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat2x4.hpp" 2
# 6 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_double2x4.hpp" 2

namespace glm
{






 typedef mat<2, 4, double, defaultp> dmat2x4;


}
# 6 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat2x4.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_double2x4_precision.hpp" 1



       


namespace glm
{







 typedef mat<2, 4, double, lowp> lowp_dmat2x4;





 typedef mat<2, 4, double, mediump> mediump_dmat2x4;





 typedef mat<2, 4, double, highp> highp_dmat2x4;


}
# 7 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat2x4.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_float2x4.hpp" 1



       


namespace glm
{






 typedef mat<2, 4, float, defaultp> mat2x4;


}
# 8 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat2x4.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_float2x4_precision.hpp" 1



       


namespace glm
{







 typedef mat<2, 4, float, lowp> lowp_mat2x4;





 typedef mat<2, 4, float, mediump> mediump_mat2x4;





 typedef mat<2, 4, float, highp> highp_mat2x4;


}
# 9 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat2x4.hpp" 2
# 24 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/matrix.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat3x2.hpp" 1



       
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_double3x2.hpp" 1



       
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat3x2.hpp" 1



       






namespace glm
{
 template<typename T, qualifier Q>
 struct mat<3, 2, T, Q>
 {
  typedef vec<2, T, Q> col_type;
  typedef vec<3, T, Q> row_type;
  typedef mat<3, 2, T, Q> type;
  typedef mat<2, 3, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[3];

 public:


  typedef length_t length_type;
  [[nodiscard]] static constexpr length_type length() { return 3; }

  [[nodiscard]] constexpr col_type & operator[](length_type i) noexcept;
  [[nodiscard]] constexpr col_type const& operator[](length_type i) const noexcept;



  constexpr mat() = default;
  template<qualifier P>
  constexpr mat(mat<3, 2, T, P> const& m);

  constexpr mat(T scalar);
  constexpr mat(
   T x0, T y0,
   T x1, T y1,
   T x2, T y2);
  constexpr mat(
   col_type const& v0,
   col_type const& v1,
   col_type const& v2);



  template<
   typename X1, typename Y1,
   typename X2, typename Y2,
   typename X3, typename Y3>
   constexpr mat(
   X1 x1, Y1 y1,
   X2 x2, Y2 y2,
   X3 x3, Y3 y3);

  template<typename V1, typename V2, typename V3>
  constexpr mat(
   vec<2, V1, Q> const& v1,
   vec<2, V2, Q> const& v2,
   vec<2, V3, Q> const& v3);



  template<typename U, qualifier P>
  constexpr mat(mat<3, 2, U, P> const& m);

  constexpr mat(mat<2, 2, T, Q> const& x);
  constexpr mat(mat<3, 3, T, Q> const& x);
  constexpr mat(mat<4, 4, T, Q> const& x);
  constexpr mat(mat<2, 3, T, Q> const& x);
  constexpr mat(mat<2, 4, T, Q> const& x);
  constexpr mat(mat<3, 4, T, Q> const& x);
  constexpr mat(mat<4, 2, T, Q> const& x);
  constexpr mat(mat<4, 3, T, Q> const& x);



  template<typename U>
  constexpr mat<3, 2, T, Q> & operator=(mat<3, 2, U, Q> const& m);
  template<typename U>
  constexpr mat<3, 2, T, Q> & operator+=(U s);
  template<typename U>
  constexpr mat<3, 2, T, Q> & operator+=(mat<3, 2, U, Q> const& m);
  template<typename U>
  constexpr mat<3, 2, T, Q> & operator-=(U s);
  template<typename U>
  constexpr mat<3, 2, T, Q> & operator-=(mat<3, 2, U, Q> const& m);
  template<typename U>
  constexpr mat<3, 2, T, Q> & operator*=(U s);
  template<typename U>
  constexpr mat<3, 2, T, Q> & operator/=(U s);



  constexpr mat<3, 2, T, Q> & operator++ ();
  constexpr mat<3, 2, T, Q> & operator-- ();
  [[nodiscard]] constexpr mat<3, 2, T, Q> operator++(int);
  [[nodiscard]] constexpr mat<3, 2, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 2, T, Q> operator*(mat<3, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 2, T, Q> operator*(T scalar, mat<3, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<3, 2, T, Q>::col_type operator*(mat<3, 2, T, Q> const& m, typename mat<3, 2, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<3, 2, T, Q>::row_type operator*(typename mat<3, 2, T, Q>::col_type const& v, mat<3, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<4, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 2, T, Q> operator/(mat<3, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 2, T, Q> operator/(T scalar, mat<3, 2, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

}


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat3x2.inl" 1
namespace glm
{
# 20 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat3x2.inl"
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr mat<3, 2, T, Q>::mat(mat<3, 2, T, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q>::mat(T s)

   : value{col_type(s, 0), col_type(0, s), col_type(0, 0)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q>::mat
 (
  T x0, T y0,
  T x1, T y1,
  T x2, T y2
 )

   : value{col_type(x0, y0), col_type(x1, y1), col_type(x2, y2)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2)

   : value{col_type(v0), col_type(v1), col_type(v2)}

 {





 }



 template<typename T, qualifier Q>
 template<
  typename X0, typename Y0,
  typename X1, typename Y1,
  typename X2, typename Y2>
 inline constexpr mat<3, 2, T, Q>::mat
 (
  X0 x0, Y0 y0,
  X1 x1, Y1 y1,
  X2 x2, Y2 y2
 )

   : value{col_type(x0, y0), col_type(x1, y1), col_type(x2, y2)}

 {





 }

 template<typename T, qualifier Q>
 template<typename V0, typename V1, typename V2>
 inline constexpr mat<3, 2, T, Q>::mat(vec<2, V0, Q> const& v0, vec<2, V1, Q> const& v1, vec<2, V2, Q> const& v2)

   : value{col_type(v0), col_type(v1), col_type(v2)}

 {





 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr mat<3, 2, T, Q>::mat(mat<3, 2, U, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q>::mat(mat<2, 2, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q>::mat(mat<3, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q>::mat(mat<4, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q>::mat(mat<2, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q>::mat(mat<2, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q>::mat(mat<3, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q>::mat(mat<4, 2, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q>::mat(mat<4, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }



 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 2, T, Q>::col_type & mat<3, 2, T, Q>::operator[](typename mat<3, 2, T, Q>::length_type i) noexcept
 {
  (
# 241 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat3x2.inl" 3
 ((void)0)
# 241 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat3x2.inl"
 );
  return this->value[i];
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 2, T, Q>::col_type const& mat<3, 2, T, Q>::operator[](typename mat<3, 2, T, Q>::length_type i) const noexcept
 {
  (
# 248 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat3x2.inl" 3
 ((void)0)
# 248 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat3x2.inl"
 );
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator=(mat<3, 2, U, Q> const& m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator+=(mat<3, 2, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator-=(mat<3, 2, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 2, T, Q> & mat<3, 2, T, Q>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  return *this;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> mat<3, 2, T, Q>::operator++(int)
 {
  mat<3, 2, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> mat<3, 2, T, Q>::operator--(int)
 {
  mat<3, 2, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m)
 {
  return mat<3, 2, T, Q>(
   -m[0],
   -m[1],
   -m[2]);
 }



 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m, T scalar)
 {
  return mat<3, 2, T, Q>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
 {
  return mat<3, 2, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m, T scalar)
 {
  return mat<3, 2, T, Q>(
   m[0] - scalar,
   m[1] - scalar,
   m[2] - scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
 {
  return mat<3, 2, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> operator*(mat<3, 2, T, Q> const& m, T scalar)
 {
  return mat<3, 2, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> operator*(T scalar, mat<3, 2, T, Q> const& m)
 {
  return mat<3, 2, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 2, T, Q>::col_type operator*(mat<3, 2, T, Q> const& m, typename mat<3, 2, T, Q>::row_type const& v)
 {
  return typename mat<3, 2, T, Q>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 2, T, Q>::row_type operator*(typename mat<3, 2, T, Q>::col_type const& v, mat<3, 2, T, Q> const& m)
 {
  return typename mat<3, 2, T, Q>::row_type(
   v.x * m[0][0] + v.y * m[0][1],
   v.x * m[1][0] + v.y * m[1][1],
   v.x * m[2][0] + v.y * m[2][1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
 {
  const T SrcA00 = m1[0][0];
  const T SrcA01 = m1[0][1];
  const T SrcA10 = m1[1][0];
  const T SrcA11 = m1[1][1];
  const T SrcA20 = m1[2][0];
  const T SrcA21 = m1[2][1];

  const T SrcB00 = m2[0][0];
  const T SrcB01 = m2[0][1];
  const T SrcB02 = m2[0][2];
  const T SrcB10 = m2[1][0];
  const T SrcB11 = m2[1][1];
  const T SrcB12 = m2[1][2];

  mat<2, 2, T, Q> Result;
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
 {
  return mat<3, 2, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
 {
  return mat<4, 2, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> operator/(mat<3, 2, T, Q> const& m, T scalar)
 {
  return mat<3, 2, T, Q>(
   m[0] / scalar,
   m[1] / scalar,
   m[2] / scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> operator/(T scalar, mat<3, 2, T, Q> const& m)
 {
  return mat<3, 2, T, Q>(
   scalar / m[0],
   scalar / m[1],
   scalar / m[2]);
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
 }
}
# 167 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat3x2.hpp" 2
# 6 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_double3x2.hpp" 2

namespace glm
{






 typedef mat<3, 2, double, defaultp> dmat3x2;


}
# 6 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat3x2.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_double3x2_precision.hpp" 1



       


namespace glm
{







 typedef mat<3, 2, double, lowp> lowp_dmat3x2;





 typedef mat<3, 2, double, mediump> mediump_dmat3x2;





 typedef mat<3, 2, double, highp> highp_dmat3x2;


}
# 7 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat3x2.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_float3x2.hpp" 1



       


namespace glm
{






 typedef mat<3, 2, float, defaultp> mat3x2;


}
# 8 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat3x2.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_float3x2_precision.hpp" 1



       


namespace glm
{







 typedef mat<3, 2, float, lowp> lowp_mat3x2;





 typedef mat<3, 2, float, mediump> mediump_mat3x2;





 typedef mat<3, 2, float, highp> highp_mat3x2;


}
# 9 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat3x2.hpp" 2
# 25 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/matrix.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat3x3.hpp" 1



       
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_double3x3.hpp" 1



       
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat3x3.hpp" 1



       





namespace glm
{
 template<typename T, qualifier Q>
 struct mat<3, 3, T, Q>
 {
  typedef vec<3, T, Q> col_type;
  typedef vec<3, T, Q> row_type;
  typedef mat<3, 3, T, Q> type;
  typedef mat<3, 3, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[3];

 public:


  typedef length_t length_type;
  [[nodiscard]] static constexpr length_type length() { return 3; }

  [[nodiscard]] constexpr col_type & operator[](length_type i) noexcept;
  [[nodiscard]] constexpr col_type const& operator[](length_type i) const noexcept;



  constexpr mat() = default;
  template<qualifier P>
  constexpr mat(mat<3, 3, T, P> const& m);

  constexpr mat(T scalar);
  constexpr mat(
   T x0, T y0, T z0,
   T x1, T y1, T z1,
   T x2, T y2, T z2);
  constexpr mat(
   col_type const& v0,
   col_type const& v1,
   col_type const& v2);



  template<
   typename X1, typename Y1, typename Z1,
   typename X2, typename Y2, typename Z2,
   typename X3, typename Y3, typename Z3>
  constexpr mat(
   X1 x1, Y1 y1, Z1 z1,
   X2 x2, Y2 y2, Z2 z2,
   X3 x3, Y3 y3, Z3 z3);

  template<typename V1, typename V2, typename V3>
  constexpr mat(
   vec<3, V1, Q> const& v1,
   vec<3, V2, Q> const& v2,
   vec<3, V3, Q> const& v3);



  template<typename U, qualifier P>
  constexpr mat(mat<3, 3, U, P> const& m);

  constexpr mat(mat<2, 2, T, Q> const& x);
  constexpr mat(mat<4, 4, T, Q> const& x);
  constexpr mat(mat<2, 3, T, Q> const& x);
  constexpr mat(mat<3, 2, T, Q> const& x);
  constexpr mat(mat<2, 4, T, Q> const& x);
  constexpr mat(mat<4, 2, T, Q> const& x);
  constexpr mat(mat<3, 4, T, Q> const& x);
  constexpr mat(mat<4, 3, T, Q> const& x);



  template<typename U>
  constexpr mat<3, 3, T, Q> & operator=(mat<3, 3, U, Q> const& m);
  template<typename U>
  constexpr mat<3, 3, T, Q> & operator+=(U s);
  template<typename U>
  constexpr mat<3, 3, T, Q> & operator+=(mat<3, 3, U, Q> const& m);
  template<typename U>
  constexpr mat<3, 3, T, Q> & operator-=(U s);
  template<typename U>
  constexpr mat<3, 3, T, Q> & operator-=(mat<3, 3, U, Q> const& m);
  template<typename U>
  constexpr mat<3, 3, T, Q> & operator*=(U s);
  template<typename U>
  constexpr mat<3, 3, T, Q> & operator*=(mat<3, 3, U, Q> const& m);
  template<typename U>
  constexpr mat<3, 3, T, Q> & operator/=(U s);
  template<typename U>
  constexpr mat<3, 3, T, Q> & operator/=(mat<3, 3, U, Q> const& m);



  constexpr mat<3, 3, T, Q> & operator++();
  constexpr mat<3, 3, T, Q> & operator--();
  [[nodiscard]] constexpr mat<3, 3, T, Q> operator++(int);
  [[nodiscard]] constexpr mat<3, 3, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator+(T scalar, mat<3, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator-(T scalar, mat<3, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator*(mat<3, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator*(T scalar, mat<3, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<3, 3, T, Q>::col_type operator*(mat<3, 3, T, Q> const& m, typename mat<3, 3, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<3, 3, T, Q>::row_type operator*(typename mat<3, 3, T, Q>::col_type const& v, mat<3, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator/(mat<3, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator/(T scalar, mat<3, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<3, 3, T, Q>::col_type operator/(mat<3, 3, T, Q> const& m, typename mat<3, 3, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<3, 3, T, Q>::row_type operator/(typename mat<3, 3, T, Q>::col_type const& v, mat<3, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator/(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);
}


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat3x3.inl" 1


namespace glm
{
# 22 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat3x3.inl"
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr mat<3, 3, T, Q>::mat(mat<3, 3, T, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q>::mat(T s)

   : value{col_type(s, 0, 0), col_type(0, s, 0), col_type(0, 0, s)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q>::mat
 (
  T x0, T y0, T z0,
  T x1, T y1, T z1,
  T x2, T y2, T z2
 )

   : value{col_type(x0, y0, z0), col_type(x1, y1, z1), col_type(x2, y2, z2)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2)

   : value{col_type(v0), col_type(v1), col_type(v2)}

 {





 }



 template<typename T, qualifier Q>
 template<
  typename X1, typename Y1, typename Z1,
  typename X2, typename Y2, typename Z2,
  typename X3, typename Y3, typename Z3>
 inline constexpr mat<3, 3, T, Q>::mat
 (
  X1 x1, Y1 y1, Z1 z1,
  X2 x2, Y2 y2, Z2 z2,
  X3 x3, Y3 y3, Z3 z3
 )

   : value{col_type(x1, y1, z1), col_type(x2, y2, z2), col_type(x3, y3, z3)}

 {





 }

 template<typename T, qualifier Q>
 template<typename V1, typename V2, typename V3>
 inline constexpr mat<3, 3, T, Q>::mat(vec<3, V1, Q> const& v1, vec<3, V2, Q> const& v2, vec<3, V3, Q> const& v3)

   : value{col_type(v1), col_type(v2), col_type(v3)}

 {





 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr mat<3, 3, T, Q>::mat(mat<3, 3, U, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q>::mat(mat<2, 2, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(0, 0, 1)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q>::mat(mat<4, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q>::mat(mat<2, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q>::mat(mat<3, 2, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 1)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q>::mat(mat<2, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q>::mat(mat<4, 2, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 1)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q>::mat(mat<3, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q>::mat(mat<4, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }



 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 3, T, Q>::col_type & mat<3, 3, T, Q>::operator[](typename mat<3, 3, T, Q>::length_type i) noexcept
 {
  (
# 243 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat3x3.inl" 3
 ((void)0)
# 243 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat3x3.inl"
 );
  return this->value[i];
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 3, T, Q>::col_type const& mat<3, 3, T, Q>::operator[](typename mat<3, 3, T, Q>::length_type i) const noexcept
 {
  (
# 250 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat3x3.inl" 3
 ((void)0)
# 250 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat3x3.inl"
 );
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator=(mat<3, 3, U, Q> const& m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator+=(mat<3, 3, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator-=(mat<3, 3, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator*=(mat<3, 3, U, Q> const& m)
 {
  return (*this = *this * m);
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator/=(mat<3, 3, U, Q> const& m)
 {
  return *this *= inverse(m);
 }



 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> mat<3, 3, T, Q>::operator++(int)
 {
  mat<3, 3, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> mat<3, 3, T, Q>::operator--(int)
 {
  mat<3, 3, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m)
 {
  return mat<3, 3, T, Q>(
   -m[0],
   -m[1],
   -m[2]);
 }



 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m, T scalar)
 {
  return mat<3, 3, T, Q>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator+(T scalar, mat<3, 3, T, Q> const& m)
 {
  return mat<3, 3, T, Q>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
 {
  return mat<3, 3, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m, T scalar)
 {
  return mat<3, 3, T, Q>(
   m[0] - scalar,
   m[1] - scalar,
   m[2] - scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator-(T scalar, mat<3, 3, T, Q> const& m)
 {
  return mat<3, 3, T, Q>(
   scalar - m[0],
   scalar - m[1],
   scalar - m[2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
 {
  return mat<3, 3, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator*(mat<3, 3, T, Q> const& m, T scalar)
 {
  return mat<3, 3, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator*(T scalar, mat<3, 3, T, Q> const& m)
 {
  return mat<3, 3, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 3, T, Q>::col_type operator*(mat<3, 3, T, Q> const& m, typename mat<3, 3, T, Q>::row_type const& v)
 {
  return typename mat<3, 3, T, Q>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z,
   m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 3, T, Q>::row_type operator*(typename mat<3, 3, T, Q>::col_type const& v, mat<3, 3, T, Q> const& m)
 {
  return typename mat<3, 3, T, Q>::row_type(
   m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z,
   m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z,
   m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
 {
  T const SrcA00 = m1[0][0];
  T const SrcA01 = m1[0][1];
  T const SrcA02 = m1[0][2];
  T const SrcA10 = m1[1][0];
  T const SrcA11 = m1[1][1];
  T const SrcA12 = m1[1][2];
  T const SrcA20 = m1[2][0];
  T const SrcA21 = m1[2][1];
  T const SrcA22 = m1[2][2];

  T const SrcB00 = m2[0][0];
  T const SrcB01 = m2[0][1];
  T const SrcB02 = m2[0][2];
  T const SrcB10 = m2[1][0];
  T const SrcB11 = m2[1][1];
  T const SrcB12 = m2[1][2];
  T const SrcB20 = m2[2][0];
  T const SrcB21 = m2[2][1];
  T const SrcB22 = m2[2][2];

  mat<3, 3, T, Q> Result;
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
 {
  return mat<2, 3, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
 {
  return mat<4, 3, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2],
   m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1] + m1[2][2] * m2[3][2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator/(mat<3, 3, T, Q> const& m, T scalar)
 {
  return mat<3, 3, T, Q>(
   m[0] / scalar,
   m[1] / scalar,
   m[2] / scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator/(T scalar, mat<3, 3, T, Q> const& m)
 {
  return mat<3, 3, T, Q>(
   scalar / m[0],
   scalar / m[1],
   scalar / m[2]);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 3, T, Q>::col_type operator/(mat<3, 3, T, Q> const& m, typename mat<3, 3, T, Q>::row_type const& v)
 {
  return inverse(m) * v;
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 3, T, Q>::row_type operator/(typename mat<3, 3, T, Q>::col_type const& v, mat<3, 3, T, Q> const& m)
 {
  return v * inverse(m);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator/(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
 {
  mat<3, 3, T, Q> m1_copy(m1);
  return m1_copy /= m2;
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
 }
}
# 184 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat3x3.hpp" 2
# 6 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_double3x3.hpp" 2

namespace glm
{






 typedef mat<3, 3, double, defaultp> dmat3x3;




 typedef mat<3, 3, double, defaultp> dmat3;


}
# 6 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat3x3.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_double3x3_precision.hpp" 1



       


namespace glm
{







 typedef mat<3, 3, double, lowp> lowp_dmat3;





 typedef mat<3, 3, double, mediump> mediump_dmat3;





 typedef mat<3, 3, double, highp> highp_dmat3;





 typedef mat<3, 3, double, lowp> lowp_dmat3x3;





 typedef mat<3, 3, double, mediump> mediump_dmat3x3;





 typedef mat<3, 3, double, highp> highp_dmat3x3;


}
# 7 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat3x3.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_float3x3.hpp" 1



       


namespace glm
{






 typedef mat<3, 3, float, defaultp> mat3x3;




 typedef mat<3, 3, float, defaultp> mat3;


}
# 8 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat3x3.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_float3x3_precision.hpp" 1



       


namespace glm
{







 typedef mat<3, 3, float, lowp> lowp_mat3;





 typedef mat<3, 3, float, mediump> mediump_mat3;





 typedef mat<3, 3, float, highp> highp_mat3;





 typedef mat<3, 3, float, lowp> lowp_mat3x3;





 typedef mat<3, 3, float, mediump> mediump_mat3x3;





 typedef mat<3, 3, float, highp> highp_mat3x3;


}
# 9 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat3x3.hpp" 2
# 26 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/matrix.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat3x4.hpp" 1



       
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_double3x4.hpp" 1



       
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat3x4.hpp" 1



       






namespace glm
{
 template<typename T, qualifier Q>
 struct mat<3, 4, T, Q>
 {
  typedef vec<4, T, Q> col_type;
  typedef vec<3, T, Q> row_type;
  typedef mat<3, 4, T, Q> type;
  typedef mat<4, 3, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[3];

 public:


  typedef length_t length_type;
  [[nodiscard]] static constexpr length_type length() { return 3; }

  [[nodiscard]] constexpr col_type & operator[](length_type i) noexcept;
  [[nodiscard]] constexpr col_type const& operator[](length_type i) const noexcept;



  constexpr mat() = default;
  template<qualifier P>
  constexpr mat(mat<3, 4, T, P> const& m);

  constexpr mat(T scalar);
  constexpr mat(
   T x0, T y0, T z0, T w0,
   T x1, T y1, T z1, T w1,
   T x2, T y2, T z2, T w2);
  constexpr mat(
   col_type const& v0,
   col_type const& v1,
   col_type const& v2);



  template<
   typename X1, typename Y1, typename Z1, typename W1,
   typename X2, typename Y2, typename Z2, typename W2,
   typename X3, typename Y3, typename Z3, typename W3>
  constexpr mat(
   X1 x1, Y1 y1, Z1 z1, W1 w1,
   X2 x2, Y2 y2, Z2 z2, W2 w2,
   X3 x3, Y3 y3, Z3 z3, W3 w3);

  template<typename V1, typename V2, typename V3>
  constexpr mat(
   vec<4, V1, Q> const& v1,
   vec<4, V2, Q> const& v2,
   vec<4, V3, Q> const& v3);



  template<typename U, qualifier P>
  constexpr mat(mat<3, 4, U, P> const& m);

  constexpr mat(mat<2, 2, T, Q> const& x);
  constexpr mat(mat<3, 3, T, Q> const& x);
  constexpr mat(mat<4, 4, T, Q> const& x);
  constexpr mat(mat<2, 3, T, Q> const& x);
  constexpr mat(mat<3, 2, T, Q> const& x);
  constexpr mat(mat<2, 4, T, Q> const& x);
  constexpr mat(mat<4, 2, T, Q> const& x);
  constexpr mat(mat<4, 3, T, Q> const& x);



  template<typename U>
  constexpr mat<3, 4, T, Q> & operator=(mat<3, 4, U, Q> const& m);
  template<typename U>
  constexpr mat<3, 4, T, Q> & operator+=(U s);
  template<typename U>
  constexpr mat<3, 4, T, Q> & operator+=(mat<3, 4, U, Q> const& m);
  template<typename U>
  constexpr mat<3, 4, T, Q> & operator-=(U s);
  template<typename U>
  constexpr mat<3, 4, T, Q> & operator-=(mat<3, 4, U, Q> const& m);
  template<typename U>
  constexpr mat<3, 4, T, Q> & operator*=(U s);
  template<typename U>
  constexpr mat<3, 4, T, Q> & operator/=(U s);



  constexpr mat<3, 4, T, Q> & operator++();
  constexpr mat<3, 4, T, Q> & operator--();
  [[nodiscard]] constexpr mat<3, 4, T, Q> operator++(int);
  [[nodiscard]] constexpr mat<3, 4, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 4, T, Q> operator*(mat<3, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 4, T, Q> operator*(T scalar, mat<3, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<3, 4, T, Q>::col_type operator*(mat<3, 4, T, Q> const& m, typename mat<3, 4, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<3, 4, T, Q>::row_type operator*(typename mat<3, 4, T, Q>::col_type const& v, mat<3, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<4, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 4, T, Q> operator/(mat<3, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 4, T, Q> operator/(T scalar, mat<3, 4, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2);
}


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat3x4.inl" 1
namespace glm
{
# 20 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat3x4.inl"
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr mat<3, 4, T, Q>::mat(mat<3, 4, T, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q>::mat(T s)

   : value{col_type(s, 0, 0, 0), col_type(0, s, 0, 0), col_type(0, 0, s, 0)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q>::mat
 (
  T x0, T y0, T z0, T w0,
  T x1, T y1, T z1, T w1,
  T x2, T y2, T z2, T w2
 )

   : value{
    col_type(x0, y0, z0, w0),
    col_type(x1, y1, z1, w1),
    col_type(x2, y2, z2, w2)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2)

   : value{col_type(v0), col_type(v1), col_type(v2)}

 {





 }



 template<typename T, qualifier Q>
 template<
  typename X0, typename Y0, typename Z0, typename W0,
  typename X1, typename Y1, typename Z1, typename W1,
  typename X2, typename Y2, typename Z2, typename W2>
 inline constexpr mat<3, 4, T, Q>::mat
 (
  X0 x0, Y0 y0, Z0 z0, W0 w0,
  X1 x1, Y1 y1, Z1 z1, W1 w1,
  X2 x2, Y2 y2, Z2 z2, W2 w2
 )

   : value{
    col_type(x0, y0, z0, w0),
    col_type(x1, y1, z1, w1),
    col_type(x2, y2, z2, w2)}

 {





 }

 template<typename T, qualifier Q>
 template<typename V1, typename V2, typename V3>
 inline constexpr mat<3, 4, T, Q>::mat(vec<4, V1, Q> const& v0, vec<4, V2, Q> const& v1, vec<4, V3, Q> const& v2)

   : value{col_type(v0), col_type(v1), col_type(v2)}

 {





 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr mat<3, 4, T, Q>::mat(mat<3, 4, U, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q>::mat(mat<2, 2, T, Q> const& m)

   : value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(0, 0, 1, 0)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q>::mat(mat<3, 3, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 0)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q>::mat(mat<4, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q>::mat(mat<2, 3, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(0, 0, 1, 0)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q>::mat(mat<3, 2, T, Q> const& m)

   : value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(m[2], 1, 0)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q>::mat(mat<2, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1, 0)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q>::mat(mat<4, 2, T, Q> const& m)

   : value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(m[2], 1, 0)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q>::mat(mat<4, 3, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 0)}

 {





 }



 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 4, T, Q>::col_type & mat<3, 4, T, Q>::operator[](typename mat<3, 4, T, Q>::length_type i) noexcept
 {
  (
# 247 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat3x4.inl" 3
 ((void)0)
# 247 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat3x4.inl"
 );
  return this->value[i];
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 4, T, Q>::col_type const& mat<3, 4, T, Q>::operator[](typename mat<3, 4, T, Q>::length_type i) const noexcept
 {
  (
# 254 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat3x4.inl" 3
 ((void)0)
# 254 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat3x4.inl"
 );
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator=(mat<3, 4, U, Q> const& m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator+=(mat<3, 4, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator-=(mat<3, 4, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 4, T, Q> & mat<3, 4, T, Q>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  return *this;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> mat<3, 4, T, Q>::operator++(int)
 {
  mat<3, 4, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> mat<3, 4, T, Q>::operator--(int)
 {
  mat<3, 4, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m)
 {
  return mat<3, 4, T, Q>(
   -m[0],
   -m[1],
   -m[2]);
 }



 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m, T scalar)
 {
  return mat<3, 4, T, Q>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
 {
  return mat<3, 4, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m, T scalar)
 {
  return mat<3, 4, T, Q>(
   m[0] - scalar,
   m[1] - scalar,
   m[2] - scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
 {
  return mat<3, 4, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> operator*(mat<3, 4, T, Q> const& m, T scalar)
 {
  return mat<3, 4, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> operator*(T scalar, mat<3, 4, T, Q> const& m)
 {
  return mat<3, 4, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 4, T, Q>::col_type operator*
 (
  mat<3, 4, T, Q> const& m,
  typename mat<3, 4, T, Q>::row_type const& v
 )
 {
  return typename mat<3, 4, T, Q>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z,
   m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z,
   m[0][3] * v.x + m[1][3] * v.y + m[2][3] * v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 4, T, Q>::row_type operator*
 (
  typename mat<3, 4, T, Q>::col_type const& v,
  mat<3, 4, T, Q> const& m
 )
 {
  return typename mat<3, 4, T, Q>::row_type(
   v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2] + v.w * m[0][3],
   v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2] + v.w * m[1][3],
   v.x * m[2][0] + v.y * m[2][1] + v.z * m[2][2] + v.w * m[2][3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
 {
  const T SrcA00 = m1[0][0];
  const T SrcA01 = m1[0][1];
  const T SrcA02 = m1[0][2];
  const T SrcA03 = m1[0][3];
  const T SrcA10 = m1[1][0];
  const T SrcA11 = m1[1][1];
  const T SrcA12 = m1[1][2];
  const T SrcA13 = m1[1][3];
  const T SrcA20 = m1[2][0];
  const T SrcA21 = m1[2][1];
  const T SrcA22 = m1[2][2];
  const T SrcA23 = m1[2][3];

  const T SrcB00 = m2[0][0];
  const T SrcB01 = m2[0][1];
  const T SrcB02 = m2[0][2];
  const T SrcB10 = m2[1][0];
  const T SrcB11 = m2[1][1];
  const T SrcB12 = m2[1][2];
  const T SrcB20 = m2[2][0];
  const T SrcB21 = m2[2][1];
  const T SrcB22 = m2[2][2];
  const T SrcB30 = m2[3][0];
  const T SrcB31 = m2[3][1];
  const T SrcB32 = m2[3][2];

  mat<4, 4, T, Q> Result;
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02;
  Result[0][3] = SrcA03 * SrcB00 + SrcA13 * SrcB01 + SrcA23 * SrcB02;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12;
  Result[1][3] = SrcA03 * SrcB10 + SrcA13 * SrcB11 + SrcA23 * SrcB12;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22;
  Result[2][3] = SrcA03 * SrcB20 + SrcA13 * SrcB21 + SrcA23 * SrcB22;
  Result[3][0] = SrcA00 * SrcB30 + SrcA10 * SrcB31 + SrcA20 * SrcB32;
  Result[3][1] = SrcA01 * SrcB30 + SrcA11 * SrcB31 + SrcA21 * SrcB32;
  Result[3][2] = SrcA02 * SrcB30 + SrcA12 * SrcB31 + SrcA22 * SrcB32;
  Result[3][3] = SrcA03 * SrcB30 + SrcA13 * SrcB31 + SrcA23 * SrcB32;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
 {
  return mat<2, 4, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
 {
  return mat<3, 4, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2],
   m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> operator/(mat<3, 4, T, Q> const& m, T scalar)
 {
  return mat<3, 4, T, Q>(
   m[0] / scalar,
   m[1] / scalar,
   m[2] / scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> operator/(T scalar, mat<3, 4, T, Q> const& m)
 {
  return mat<3, 4, T, Q>(
   scalar / m[0],
   scalar / m[1],
   scalar / m[2]);
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
 }
}
# 166 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat3x4.hpp" 2
# 6 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_double3x4.hpp" 2

namespace glm
{






 typedef mat<3, 4, double, defaultp> dmat3x4;


}
# 6 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat3x4.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_double3x4_precision.hpp" 1



       


namespace glm
{







 typedef mat<3, 4, double, lowp> lowp_dmat3x4;





 typedef mat<3, 4, double, mediump> mediump_dmat3x4;





 typedef mat<3, 4, double, highp> highp_dmat3x4;


}
# 7 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat3x4.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_float3x4.hpp" 1



       


namespace glm
{






 typedef mat<3, 4, float, defaultp> mat3x4;


}
# 8 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat3x4.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_float3x4_precision.hpp" 1



       


namespace glm
{







 typedef mat<3, 4, float, lowp> lowp_mat3x4;





 typedef mat<3, 4, float, mediump> mediump_mat3x4;





 typedef mat<3, 4, float, highp> highp_mat3x4;


}
# 9 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat3x4.hpp" 2
# 27 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/matrix.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat4x2.hpp" 1



       
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_double4x2.hpp" 1



       
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat4x2.hpp" 1



       






namespace glm
{
 template<typename T, qualifier Q>
 struct mat<4, 2, T, Q>
 {
  typedef vec<2, T, Q> col_type;
  typedef vec<4, T, Q> row_type;
  typedef mat<4, 2, T, Q> type;
  typedef mat<2, 4, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[4];

 public:


  typedef length_t length_type;
  [[nodiscard]] static constexpr length_type length() { return 4; }

  [[nodiscard]] constexpr col_type & operator[](length_type i) noexcept;
  [[nodiscard]] constexpr col_type const& operator[](length_type i) const noexcept;



  constexpr mat() = default;
  template<qualifier P>
  constexpr mat(mat<4, 2, T, P> const& m);

  constexpr mat(T scalar);
  constexpr mat(
   T x0, T y0,
   T x1, T y1,
   T x2, T y2,
   T x3, T y3);
  constexpr mat(
   col_type const& v0,
   col_type const& v1,
   col_type const& v2,
   col_type const& v3);



  template<
   typename X0, typename Y0,
   typename X1, typename Y1,
   typename X2, typename Y2,
   typename X3, typename Y3>
  constexpr mat(
   X0 x0, Y0 y0,
   X1 x1, Y1 y1,
   X2 x2, Y2 y2,
   X3 x3, Y3 y3);

  template<typename V1, typename V2, typename V3, typename V4>
  constexpr mat(
   vec<2, V1, Q> const& v1,
   vec<2, V2, Q> const& v2,
   vec<2, V3, Q> const& v3,
   vec<2, V4, Q> const& v4);



  template<typename U, qualifier P>
  constexpr mat(mat<4, 2, U, P> const& m);

  constexpr mat(mat<2, 2, T, Q> const& x);
  constexpr mat(mat<3, 3, T, Q> const& x);
  constexpr mat(mat<4, 4, T, Q> const& x);
  constexpr mat(mat<2, 3, T, Q> const& x);
  constexpr mat(mat<3, 2, T, Q> const& x);
  constexpr mat(mat<2, 4, T, Q> const& x);
  constexpr mat(mat<4, 3, T, Q> const& x);
  constexpr mat(mat<3, 4, T, Q> const& x);



  template<typename U>
  constexpr mat<4, 2, T, Q> & operator=(mat<4, 2, U, Q> const& m);
  template<typename U>
  constexpr mat<4, 2, T, Q> & operator+=(U s);
  template<typename U>
  constexpr mat<4, 2, T, Q> & operator+=(mat<4, 2, U, Q> const& m);
  template<typename U>
  constexpr mat<4, 2, T, Q> & operator-=(U s);
  template<typename U>
  constexpr mat<4, 2, T, Q> & operator-=(mat<4, 2, U, Q> const& m);
  template<typename U>
  constexpr mat<4, 2, T, Q> & operator*=(U s);
  template<typename U>
  constexpr mat<4, 2, T, Q> & operator/=(U s);



  constexpr mat<4, 2, T, Q> & operator++ ();
  constexpr mat<4, 2, T, Q> & operator-- ();
  [[nodiscard]] constexpr mat<4, 2, T, Q> operator++(int);
  [[nodiscard]] constexpr mat<4, 2, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 2, T, Q> operator*(mat<4, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 2, T, Q> operator*(T scalar, mat<4, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<4, 2, T, Q>::col_type operator*(mat<4, 2, T, Q> const& m, typename mat<4, 2, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<4, 2, T, Q>::row_type operator*(typename mat<4, 2, T, Q>::col_type const& v, mat<4, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<3, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<4, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 2, T, Q> operator/(mat<4, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 2, T, Q> operator/(T scalar, mat<4, 2, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2);
}


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat4x2.inl" 1
namespace glm
{
# 21 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat4x2.inl"
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr mat<4, 2, T, Q>::mat(mat<4, 2, T, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q>::mat(T s)

   : value{col_type(s, 0), col_type(0, s), col_type(0, 0), col_type(0, 0)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q>::mat
 (
  T x0, T y0,
  T x1, T y1,
  T x2, T y2,
  T x3, T y3
 )

   : value{col_type(x0, y0), col_type(x1, y1), col_type(x2, y2), col_type(x3, y3)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2, col_type const& v3)

   : value{col_type(v0), col_type(v1), col_type(v2), col_type(v3)}

 {






 }



 template<typename T, qualifier Q>
 template<
  typename X0, typename Y0,
  typename X1, typename Y1,
  typename X2, typename Y2,
  typename X3, typename Y3>
 inline constexpr mat<4, 2, T, Q>::mat
 (
  X0 x0, Y0 y0,
  X1 x1, Y1 y1,
  X2 x2, Y2 y2,
  X3 x3, Y3 y3
 )

   : value{col_type(x0, y0), col_type(x1, y1), col_type(x2, y2), col_type(x3, y3)}

 {






 }

 template<typename T, qualifier Q>
 template<typename V0, typename V1, typename V2, typename V3>
 inline constexpr mat<4, 2, T, Q>::mat(vec<2, V0, Q> const& v0, vec<2, V1, Q> const& v1, vec<2, V2, Q> const& v2, vec<2, V3, Q> const& v3)

   : value{col_type(v0), col_type(v1), col_type(v2), col_type(v3)}

 {






 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr mat<4, 2, T, Q>::mat(mat<4, 2, U, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q>::mat(mat<2, 2, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0), col_type(0)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q>::mat(mat<3, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q>::mat(mat<4, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q>::mat(mat<2, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0), col_type(0)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q>::mat(mat<3, 2, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q>::mat(mat<2, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0), col_type(0)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q>::mat(mat<4, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q>::mat(mat<3, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0)}

 {






 }



 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 2, T, Q>::col_type & mat<4, 2, T, Q>::operator[](typename mat<4, 2, T, Q>::length_type i) noexcept
 {
  (
# 260 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat4x2.inl" 3
 ((void)0)
# 260 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat4x2.inl"
 );
  return this->value[i];
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 2, T, Q>::col_type const& mat<4, 2, T, Q>::operator[](typename mat<4, 2, T, Q>::length_type i) const noexcept
 {
  (
# 267 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat4x2.inl" 3
 ((void)0)
# 267 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat4x2.inl"
 );
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 2, T, Q>& mat<4, 2, T, Q>::operator=(mat<4, 2, U, Q> const& m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  this->value[3] += s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator+=(mat<4, 2, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  this->value[3] += m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  this->value[3] -= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator-=(mat<4, 2, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  this->value[3] -= m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  this->value[3] *= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  this->value[3] /= s;
  return *this;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  ++this->value[3];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  --this->value[3];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> mat<4, 2, T, Q>::operator++(int)
 {
  mat<4, 2, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> mat<4, 2, T, Q>::operator--(int)
 {
  mat<4, 2, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m)
 {
  return mat<4, 2, T, Q>(
   -m[0],
   -m[1],
   -m[2],
   -m[3]);
 }



 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m, T scalar)
 {
  return mat<4, 2, T, Q>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar,
   m[3] + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
 {
  return mat<4, 2, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2],
   m1[3] + m2[3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m, T scalar)
 {
  return mat<4, 2, T, Q>(
   m[0] - scalar,
   m[1] - scalar,
   m[2] - scalar,
   m[3] - scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
 {
  return mat<4, 2, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2],
   m1[3] - m2[3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> operator*(mat<4, 2, T, Q> const& m, T scalar)
 {
  return mat<4, 2, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar,
   m[3] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> operator*(T scalar, mat<4, 2, T, Q> const& m)
 {
  return mat<4, 2, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar,
   m[3] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 2, T, Q>::col_type operator*(mat<4, 2, T, Q> const& m, typename mat<4, 2, T, Q>::row_type const& v)
 {
  return typename mat<4, 2, T, Q>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 2, T, Q>::row_type operator*(typename mat<4, 2, T, Q>::col_type const& v, mat<4, 2, T, Q> const& m)
 {
  return typename mat<4, 2, T, Q>::row_type(
   v.x * m[0][0] + v.y * m[0][1],
   v.x * m[1][0] + v.y * m[1][1],
   v.x * m[2][0] + v.y * m[2][1],
   v.x * m[3][0] + v.y * m[3][1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
 {
  T const SrcA00 = m1[0][0];
  T const SrcA01 = m1[0][1];
  T const SrcA10 = m1[1][0];
  T const SrcA11 = m1[1][1];
  T const SrcA20 = m1[2][0];
  T const SrcA21 = m1[2][1];
  T const SrcA30 = m1[3][0];
  T const SrcA31 = m1[3][1];

  T const SrcB00 = m2[0][0];
  T const SrcB01 = m2[0][1];
  T const SrcB02 = m2[0][2];
  T const SrcB03 = m2[0][3];
  T const SrcB10 = m2[1][0];
  T const SrcB11 = m2[1][1];
  T const SrcB12 = m2[1][2];
  T const SrcB13 = m2[1][3];

  mat<2, 2, T, Q> Result;
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02 + SrcA30 * SrcB03;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02 + SrcA31 * SrcB03;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12 + SrcA30 * SrcB13;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12 + SrcA31 * SrcB13;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
 {
  return mat<3, 2, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
 {
  return mat<4, 2, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2] + m1[3][0] * m2[3][3],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2] + m1[3][1] * m2[3][3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> operator/(mat<4, 2, T, Q> const& m, T scalar)
 {
  return mat<4, 2, T, Q>(
   m[0] / scalar,
   m[1] / scalar,
   m[2] / scalar,
   m[3] / scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> operator/(T scalar, mat<4, 2, T, Q> const& m)
 {
  return mat<4, 2, T, Q>(
   scalar / m[0],
   scalar / m[1],
   scalar / m[2],
   scalar / m[3]);
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
 }
}
# 171 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat4x2.hpp" 2
# 6 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_double4x2.hpp" 2

namespace glm
{






 typedef mat<4, 2, double, defaultp> dmat4x2;


}
# 6 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat4x2.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_double4x2_precision.hpp" 1



       


namespace glm
{







 typedef mat<4, 2, double, lowp> lowp_dmat4x2;





 typedef mat<4, 2, double, mediump> mediump_dmat4x2;





 typedef mat<4, 2, double, highp> highp_dmat4x2;


}
# 7 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat4x2.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_float4x2.hpp" 1



       


namespace glm
{






 typedef mat<4, 2, float, defaultp> mat4x2;


}
# 8 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat4x2.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_float4x2_precision.hpp" 1



       


namespace glm
{







 typedef mat<4, 2, float, lowp> lowp_mat4x2;





 typedef mat<4, 2, float, mediump> mediump_mat4x2;





 typedef mat<4, 2, float, highp> highp_mat4x2;


}
# 9 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat4x2.hpp" 2
# 28 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/matrix.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat4x3.hpp" 1



       
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_double4x3.hpp" 1



       
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat4x3.hpp" 1



       






namespace glm
{
 template<typename T, qualifier Q>
 struct mat<4, 3, T, Q>
 {
  typedef vec<3, T, Q> col_type;
  typedef vec<4, T, Q> row_type;
  typedef mat<4, 3, T, Q> type;
  typedef mat<3, 4, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[4];

 public:


  typedef length_t length_type;
  [[nodiscard]] static constexpr length_type length() { return 4; }

  [[nodiscard]] constexpr col_type & operator[](length_type i) noexcept;
  [[nodiscard]] constexpr col_type const& operator[](length_type i) const noexcept;



  constexpr mat() = default;
  template<qualifier P>
  constexpr mat(mat<4, 3, T, P> const& m);

  constexpr mat(T s);
  constexpr mat(
   T const& x0, T const& y0, T const& z0,
   T const& x1, T const& y1, T const& z1,
   T const& x2, T const& y2, T const& z2,
   T const& x3, T const& y3, T const& z3);
  constexpr mat(
   col_type const& v0,
   col_type const& v1,
   col_type const& v2,
   col_type const& v3);



  template<
   typename X1, typename Y1, typename Z1,
   typename X2, typename Y2, typename Z2,
   typename X3, typename Y3, typename Z3,
   typename X4, typename Y4, typename Z4>
  constexpr mat(
   X1 const& x1, Y1 const& y1, Z1 const& z1,
   X2 const& x2, Y2 const& y2, Z2 const& z2,
   X3 const& x3, Y3 const& y3, Z3 const& z3,
   X4 const& x4, Y4 const& y4, Z4 const& z4);

  template<typename V1, typename V2, typename V3, typename V4>
  constexpr mat(
   vec<3, V1, Q> const& v1,
   vec<3, V2, Q> const& v2,
   vec<3, V3, Q> const& v3,
   vec<3, V4, Q> const& v4);



  template<typename U, qualifier P>
  constexpr mat(mat<4, 3, U, P> const& m);

  constexpr mat(mat<2, 2, T, Q> const& x);
  constexpr mat(mat<3, 3, T, Q> const& x);
  constexpr mat(mat<4, 4, T, Q> const& x);
  constexpr mat(mat<2, 3, T, Q> const& x);
  constexpr mat(mat<3, 2, T, Q> const& x);
  constexpr mat(mat<2, 4, T, Q> const& x);
  constexpr mat(mat<4, 2, T, Q> const& x);
  constexpr mat(mat<3, 4, T, Q> const& x);



  template<typename U>
  constexpr mat<4, 3, T, Q> & operator=(mat<4, 3, U, Q> const& m);
  template<typename U>
  constexpr mat<4, 3, T, Q> & operator+=(U s);
  template<typename U>
  constexpr mat<4, 3, T, Q> & operator+=(mat<4, 3, U, Q> const& m);
  template<typename U>
  constexpr mat<4, 3, T, Q> & operator-=(U s);
  template<typename U>
  constexpr mat<4, 3, T, Q> & operator-=(mat<4, 3, U, Q> const& m);
  template<typename U>
  constexpr mat<4, 3, T, Q> & operator*=(U s);
  template<typename U>
  constexpr mat<4, 3, T, Q> & operator/=(U s);



  constexpr mat<4, 3, T, Q>& operator++();
  constexpr mat<4, 3, T, Q>& operator--();
  [[nodiscard]] constexpr mat<4, 3, T, Q> operator++(int);
  [[nodiscard]] constexpr mat<4, 3, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 3, T, Q> operator*(mat<4, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 3, T, Q> operator*(T scalar, mat<4, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<4, 3, T, Q>::col_type operator*(mat<4, 3, T, Q> const& m, typename mat<4, 3, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<4, 3, T, Q>::row_type operator*(typename mat<4, 3, T, Q>::col_type const& v, mat<4, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<3, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<4, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 3, T, Q> operator/(mat<4, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 3, T, Q> operator/(T scalar, mat<4, 3, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2);
}


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat4x3.inl" 1
namespace glm
{
# 21 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat4x3.inl"
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr mat<4, 3, T, Q>::mat(mat<4, 3, T, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q>::mat(T s)

   : value{col_type(s, 0, 0), col_type(0, s, 0), col_type(0, 0, s), col_type(0, 0, 0)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q>::mat
 (
  T const& x0, T const& y0, T const& z0,
  T const& x1, T const& y1, T const& z1,
  T const& x2, T const& y2, T const& z2,
  T const& x3, T const& y3, T const& z3
 )

   : value{col_type(x0, y0, z0), col_type(x1, y1, z1), col_type(x2, y2, z2), col_type(x3, y3, z3)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2, col_type const& v3)

   : value{col_type(v0), col_type(v1), col_type(v2), col_type(v3)}

 {






 }



 template<typename T, qualifier Q>
 template<
  typename X0, typename Y0, typename Z0,
  typename X1, typename Y1, typename Z1,
  typename X2, typename Y2, typename Z2,
  typename X3, typename Y3, typename Z3>
 inline constexpr mat<4, 3, T, Q>::mat
 (
  X0 const& x0, Y0 const& y0, Z0 const& z0,
  X1 const& x1, Y1 const& y1, Z1 const& z1,
  X2 const& x2, Y2 const& y2, Z2 const& z2,
  X3 const& x3, Y3 const& y3, Z3 const& z3
 )

   : value{col_type(x0, y0, z0), col_type(x1, y1, z1), col_type(x2, y2, z2), col_type(x3, y3, z3)}

 {






 }

 template<typename T, qualifier Q>
 template<typename V1, typename V2, typename V3, typename V4>
 inline constexpr mat<4, 3, T, Q>::mat(vec<3, V1, Q> const& v1, vec<3, V2, Q> const& v2, vec<3, V3, Q> const& v3, vec<3, V4, Q> const& v4)

   : value{col_type(v1), col_type(v2), col_type(v3), col_type(v4)}

 {






 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr mat<4, 3, T, Q>::mat(mat<4, 3, U, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q>::mat(mat<2, 2, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(0, 0, 1), col_type(0)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q>::mat(mat<3, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q>::mat(mat<4, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q>::mat(mat<2, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1), col_type(0)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q>::mat(mat<3, 2, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 1), col_type(0)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q>::mat(mat<2, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1), col_type(0)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q>::mat(mat<4, 2, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 1), col_type(m[3], 0)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q>::mat(mat<3, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0)}

 {






 }



 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 3, T, Q>::col_type & mat<4, 3, T, Q>::operator[](typename mat<4, 3, T, Q>::length_type i) noexcept
 {
  (
# 260 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat4x3.inl" 3
 ((void)0)
# 260 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat4x3.inl"
 );
  return this->value[i];
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 3, T, Q>::col_type const& mat<4, 3, T, Q>::operator[](typename mat<4, 3, T, Q>::length_type i) const noexcept
 {
  (
# 267 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat4x3.inl" 3
 ((void)0)
# 267 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat4x3.inl"
 );
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 3, T, Q>& mat<4, 3, T, Q>::operator=(mat<4, 3, U, Q> const& m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  this->value[3] += s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator+=(mat<4, 3, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  this->value[3] += m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  this->value[3] -= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator-=(mat<4, 3, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  this->value[3] -= m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  this->value[3] *= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  this->value[3] /= s;
  return *this;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  ++this->value[3];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  --this->value[3];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> mat<4, 3, T, Q>::operator++(int)
 {
  mat<4, 3, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> mat<4, 3, T, Q>::operator--(int)
 {
  mat<4, 3, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m)
 {
  return mat<4, 3, T, Q>(
   -m[0],
   -m[1],
   -m[2],
   -m[3]);
 }



 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m, T scalar)
 {
  return mat<4, 3, T, Q>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar,
   m[3] + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
 {
  return mat<4, 3, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2],
   m1[3] + m2[3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m, T scalar)
 {
  return mat<4, 3, T, Q>(
   m[0] - scalar,
   m[1] - scalar,
   m[2] - scalar,
   m[3] - scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
 {
  return mat<4, 3, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2],
   m1[3] - m2[3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> operator*(mat<4, 3, T, Q> const& m, T scalar)
 {
  return mat<4, 3, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar,
   m[3] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> operator*(T scalar, mat<4, 3, T, Q> const& m)
 {
  return mat<4, 3, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar,
   m[3] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 3, T, Q>::col_type operator*
 (
  mat<4, 3, T, Q> const& m,
  typename mat<4, 3, T, Q>::row_type const& v)
 {
  return typename mat<4, 3, T, Q>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w,
   m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z + m[3][2] * v.w);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 3, T, Q>::row_type operator*
 (
  typename mat<4, 3, T, Q>::col_type const& v,
  mat<4, 3, T, Q> const& m)
 {
  return typename mat<4, 3, T, Q>::row_type(
   v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2],
   v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2],
   v.x * m[2][0] + v.y * m[2][1] + v.z * m[2][2],
   v.x * m[3][0] + v.y * m[3][1] + v.z * m[3][2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
 {
  return mat<2, 3, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
 {
  T const SrcA00 = m1[0][0];
  T const SrcA01 = m1[0][1];
  T const SrcA02 = m1[0][2];
  T const SrcA10 = m1[1][0];
  T const SrcA11 = m1[1][1];
  T const SrcA12 = m1[1][2];
  T const SrcA20 = m1[2][0];
  T const SrcA21 = m1[2][1];
  T const SrcA22 = m1[2][2];
  T const SrcA30 = m1[3][0];
  T const SrcA31 = m1[3][1];
  T const SrcA32 = m1[3][2];

  T const SrcB00 = m2[0][0];
  T const SrcB01 = m2[0][1];
  T const SrcB02 = m2[0][2];
  T const SrcB03 = m2[0][3];
  T const SrcB10 = m2[1][0];
  T const SrcB11 = m2[1][1];
  T const SrcB12 = m2[1][2];
  T const SrcB13 = m2[1][3];
  T const SrcB20 = m2[2][0];
  T const SrcB21 = m2[2][1];
  T const SrcB22 = m2[2][2];
  T const SrcB23 = m2[2][3];

  mat<3, 3, T, Q> Result;
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02 + SrcA30 * SrcB03;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02 + SrcA31 * SrcB03;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02 + SrcA32 * SrcB03;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12 + SrcA30 * SrcB13;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12 + SrcA31 * SrcB13;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12 + SrcA32 * SrcB13;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22 + SrcA30 * SrcB23;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22 + SrcA31 * SrcB23;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22 + SrcA32 * SrcB23;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
 {
  return mat<4, 3, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2] + m1[3][0] * m2[3][3],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2] + m1[3][1] * m2[3][3],
   m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1] + m1[2][2] * m2[3][2] + m1[3][2] * m2[3][3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> operator/(mat<4, 3, T, Q> const& m, T scalar)
 {
  return mat<4, 3, T, Q>(
   m[0] / scalar,
   m[1] / scalar,
   m[2] / scalar,
   m[3] / scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> operator/(T scalar, mat<4, 3, T, Q> const& m)
 {
  return mat<4, 3, T, Q>(
   scalar / m[0],
   scalar / m[1],
   scalar / m[2],
   scalar / m[3]);
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
 }
}
# 171 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat4x3.hpp" 2
# 6 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_double4x3.hpp" 2

namespace glm
{






 typedef mat<4, 3, double, defaultp> dmat4x3;


}
# 6 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat4x3.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_double4x3_precision.hpp" 1



       


namespace glm
{







 typedef mat<4, 3, double, lowp> lowp_dmat4x3;





 typedef mat<4, 3, double, mediump> mediump_dmat4x3;





 typedef mat<4, 3, double, highp> highp_dmat4x3;


}
# 7 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat4x3.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_float4x3.hpp" 1



       


namespace glm
{






 typedef mat<4, 3, float, defaultp> mat4x3;


}
# 8 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat4x3.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_float4x3_precision.hpp" 1



       


namespace glm
{







 typedef mat<4, 3, float, lowp> lowp_mat4x3;





 typedef mat<4, 3, float, mediump> mediump_mat4x3;





 typedef mat<4, 3, float, highp> highp_mat4x3;


}
# 9 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat4x3.hpp" 2
# 29 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/matrix.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat4x4.hpp" 1



       
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_double4x4.hpp" 1



       
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat4x4.hpp" 1



       





namespace glm
{
 template<typename T, qualifier Q>
 struct mat<4, 4, T, Q>
 {
  typedef vec<4, T, Q> col_type;
  typedef vec<4, T, Q> row_type;
  typedef mat<4, 4, T, Q> type;
  typedef mat<4, 4, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[4];

 public:


  typedef length_t length_type;
  [[nodiscard]] static constexpr length_type length(){return 4;}

  [[nodiscard]] constexpr col_type & operator[](length_type i) noexcept;
  [[nodiscard]] constexpr col_type const& operator[](length_type i) const noexcept;



  constexpr mat() = default;
  template<qualifier P>
  constexpr mat(mat<4, 4, T, P> const& m);

  constexpr mat(T s);
  constexpr mat(
   T const& x0, T const& y0, T const& z0, T const& w0,
   T const& x1, T const& y1, T const& z1, T const& w1,
   T const& x2, T const& y2, T const& z2, T const& w2,
   T const& x3, T const& y3, T const& z3, T const& w3);
  constexpr mat(
   col_type const& v0,
   col_type const& v1,
   col_type const& v2,
   col_type const& v3);



  template<
   typename X1, typename Y1, typename Z1, typename W1,
   typename X2, typename Y2, typename Z2, typename W2,
   typename X3, typename Y3, typename Z3, typename W3,
   typename X4, typename Y4, typename Z4, typename W4>
  constexpr mat(
   X1 const& x1, Y1 const& y1, Z1 const& z1, W1 const& w1,
   X2 const& x2, Y2 const& y2, Z2 const& z2, W2 const& w2,
   X3 const& x3, Y3 const& y3, Z3 const& z3, W3 const& w3,
   X4 const& x4, Y4 const& y4, Z4 const& z4, W4 const& w4);

  template<typename V1, typename V2, typename V3, typename V4>
  constexpr mat(
   vec<4, V1, Q> const& v1,
   vec<4, V2, Q> const& v2,
   vec<4, V3, Q> const& v3,
   vec<4, V4, Q> const& v4);



  template<typename U, qualifier P>
  constexpr mat(mat<4, 4, U, P> const& m);

  constexpr mat(mat<2, 2, T, Q> const& x);
  constexpr mat(mat<3, 3, T, Q> const& x);
  constexpr mat(mat<2, 3, T, Q> const& x);
  constexpr mat(mat<3, 2, T, Q> const& x);
  constexpr mat(mat<2, 4, T, Q> const& x);
  constexpr mat(mat<4, 2, T, Q> const& x);
  constexpr mat(mat<3, 4, T, Q> const& x);
  constexpr mat(mat<4, 3, T, Q> const& x);



  template<typename U>
  constexpr mat<4, 4, T, Q> & operator=(mat<4, 4, U, Q> const& m);
  template<typename U>
  constexpr mat<4, 4, T, Q> & operator+=(U s);
  template<typename U>
  constexpr mat<4, 4, T, Q> & operator+=(mat<4, 4, U, Q> const& m);
  template<typename U>
  constexpr mat<4, 4, T, Q> & operator-=(U s);
  template<typename U>
  constexpr mat<4, 4, T, Q> & operator-=(mat<4, 4, U, Q> const& m);
  template<typename U>
  constexpr mat<4, 4, T, Q> & operator*=(U s);
  template<typename U>
  constexpr mat<4, 4, T, Q> & operator*=(mat<4, 4, U, Q> const& m);
  template<typename U>
  constexpr mat<4, 4, T, Q> & operator/=(U s);
  template<typename U>
  constexpr mat<4, 4, T, Q> & operator/=(mat<4, 4, U, Q> const& m);



  constexpr mat<4, 4, T, Q> & operator++();
  constexpr mat<4, 4, T, Q> & operator--();
  [[nodiscard]] constexpr mat<4, 4, T, Q> operator++(int);
  [[nodiscard]] constexpr mat<4, 4, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator+(T scalar, mat<4, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator-(T scalar, mat<4, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator*(mat<4, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator*(T scalar, mat<4, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<4, 4, T, Q>::col_type operator*(mat<4, 4, T, Q> const& m, typename mat<4, 4, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<4, 4, T, Q>::row_type operator*(typename mat<4, 4, T, Q>::col_type const& v, mat<4, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator/(mat<4, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator/(T scalar, mat<4, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<4, 4, T, Q>::col_type operator/(mat<4, 4, T, Q> const& m, typename mat<4, 4, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<4, 4, T, Q>::row_type operator/(typename mat<4, 4, T, Q>::col_type const& v, mat<4, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator/(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);
}


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat4x4.inl" 1


namespace glm
{
# 23 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat4x4.inl"
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr mat<4, 4, T, Q>::mat(mat<4, 4, T, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q>::mat(T s)

   : value{col_type(s, 0, 0, 0), col_type(0, s, 0, 0), col_type(0, 0, s, 0), col_type(0, 0, 0, s)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q>::mat
 (
  T const& x0, T const& y0, T const& z0, T const& w0,
  T const& x1, T const& y1, T const& z1, T const& w1,
  T const& x2, T const& y2, T const& z2, T const& w2,
  T const& x3, T const& y3, T const& z3, T const& w3
 )

   : value{
    col_type(x0, y0, z0, w0),
    col_type(x1, y1, z1, w1),
    col_type(x2, y2, z2, w2),
    col_type(x3, y3, z3, w3)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2, col_type const& v3)

   : value{col_type(v0), col_type(v1), col_type(v2), col_type(v3)}

 {






 }

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr mat<4, 4, T, Q>::mat(mat<4, 4, U, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}

 {






 }



 template<typename T, qualifier Q>
 template<
  typename X1, typename Y1, typename Z1, typename W1,
  typename X2, typename Y2, typename Z2, typename W2,
  typename X3, typename Y3, typename Z3, typename W3,
  typename X4, typename Y4, typename Z4, typename W4>
 inline constexpr mat<4, 4, T, Q>::mat
 (
  X1 const& x1, Y1 const& y1, Z1 const& z1, W1 const& w1,
  X2 const& x2, Y2 const& y2, Z2 const& z2, W2 const& w2,
  X3 const& x3, Y3 const& y3, Z3 const& z3, W3 const& w3,
  X4 const& x4, Y4 const& y4, Z4 const& z4, W4 const& w4
 )

   : value{col_type(x1, y1, z1, w1), col_type(x2, y2, z2, w2), col_type(x3, y3, z3, w3), col_type(x4, y4, z4, w4)}

 {
  static_assert(std::numeric_limits<X1>::is_iec559 || std::numeric_limits<X1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 1st parameter type invalid.");
  static_assert(std::numeric_limits<Y1>::is_iec559 || std::numeric_limits<Y1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 2nd parameter type invalid.");
  static_assert(std::numeric_limits<Z1>::is_iec559 || std::numeric_limits<Z1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 3rd parameter type invalid.");
  static_assert(std::numeric_limits<W1>::is_iec559 || std::numeric_limits<W1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 4th parameter type invalid.");

  static_assert(std::numeric_limits<X2>::is_iec559 || std::numeric_limits<X2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 5th parameter type invalid.");
  static_assert(std::numeric_limits<Y2>::is_iec559 || std::numeric_limits<Y2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 6th parameter type invalid.");
  static_assert(std::numeric_limits<Z2>::is_iec559 || std::numeric_limits<Z2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 7th parameter type invalid.");
  static_assert(std::numeric_limits<W2>::is_iec559 || std::numeric_limits<W2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 8th parameter type invalid.");

  static_assert(std::numeric_limits<X3>::is_iec559 || std::numeric_limits<X3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 9th parameter type invalid.");
  static_assert(std::numeric_limits<Y3>::is_iec559 || std::numeric_limits<Y3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 10th parameter type invalid.");
  static_assert(std::numeric_limits<Z3>::is_iec559 || std::numeric_limits<Z3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 11th parameter type invalid.");
  static_assert(std::numeric_limits<W3>::is_iec559 || std::numeric_limits<W3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 12th parameter type invalid.");

  static_assert(std::numeric_limits<X4>::is_iec559 || std::numeric_limits<X4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 13th parameter type invalid.");
  static_assert(std::numeric_limits<Y4>::is_iec559 || std::numeric_limits<Y4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 14th parameter type invalid.");
  static_assert(std::numeric_limits<Z4>::is_iec559 || std::numeric_limits<Z4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 15th parameter type invalid.");
  static_assert(std::numeric_limits<W4>::is_iec559 || std::numeric_limits<W4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 16th parameter type invalid.");







 }

 template<typename T, qualifier Q>
 template<typename V1, typename V2, typename V3, typename V4>
 inline constexpr mat<4, 4, T, Q>::mat(vec<4, V1, Q> const& v1, vec<4, V2, Q> const& v2, vec<4, V3, Q> const& v3, vec<4, V4, Q> const& v4)

   : value{col_type(v1), col_type(v2), col_type(v3), col_type(v4)}

 {
  static_assert(std::numeric_limits<V1>::is_iec559 || std::numeric_limits<V1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 1st parameter type invalid.");
  static_assert(std::numeric_limits<V2>::is_iec559 || std::numeric_limits<V2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 2nd parameter type invalid.");
  static_assert(std::numeric_limits<V3>::is_iec559 || std::numeric_limits<V3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 3rd parameter type invalid.");
  static_assert(std::numeric_limits<V4>::is_iec559 || std::numeric_limits<V4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 4th parameter type invalid.");







 }



 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q>::mat(mat<2, 2, T, Q> const& m)

   : value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(0, 0, 1, 0), col_type(0, 0, 0, 1)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q>::mat(mat<3, 3, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 0), col_type(0, 0, 0, 1)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q>::mat(mat<2, 3, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(0, 0, 1, 0), col_type(0, 0, 0, 1)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q>::mat(mat<3, 2, T, Q> const& m)

   : value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(m[2], 1, 0), col_type(0, 0, 0, 1)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q>::mat(mat<2, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1, 0), col_type(0, 0, 0, 1)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q>::mat(mat<4, 2, T, Q> const& m)

   : value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(0, 0, 1, 0), col_type(0, 0, 0, 1)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q>::mat(mat<3, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0, 0, 0, 1)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q>::mat(mat<4, 3, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 0), col_type(m[3], 1)}

 {






 }



 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 4, T, Q>::col_type & mat<4, 4, T, Q>::operator[](typename mat<4, 4, T, Q>::length_type i) noexcept
 {
  (
# 291 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat4x4.inl" 3
 ((void)0)
# 291 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat4x4.inl"
 );
  return this->value[i];
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 4, T, Q>::col_type const& mat<4, 4, T, Q>::operator[](typename mat<4, 4, T, Q>::length_type i) const noexcept
 {
  (
# 298 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat4x4.inl" 3
 ((void)0)
# 298 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat4x4.inl"
 );
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 4, T, Q>& mat<4, 4, T, Q>::operator=(mat<4, 4, U, Q> const& m)
 {


  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 4, T, Q>& mat<4, 4, T, Q>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  this->value[3] += s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 4, T, Q>& mat<4, 4, T, Q>::operator+=(mat<4, 4, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  this->value[3] += m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  this->value[3] -= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator-=(mat<4, 4, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  this->value[3] -= m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  this->value[3] *= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator*=(mat<4, 4, U, Q> const& m)
 {
  return (*this = *this * m);
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  this->value[3] /= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator/=(mat<4, 4, U, Q> const& m)
 {
  return *this *= inverse(m);
 }



 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  ++this->value[3];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  --this->value[3];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> mat<4, 4, T, Q>::operator++(int)
 {
  mat<4, 4, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> mat<4, 4, T, Q>::operator--(int)
 {
  mat<4, 4, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m)
 {
  return mat<4, 4, T, Q>(
   -m[0],
   -m[1],
   -m[2],
   -m[3]);
 }



 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m, T scalar)
 {
  return mat<4, 4, T, Q>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar,
   m[3] + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator+(T scalar, mat<4, 4, T, Q> const& m)
 {
  return mat<4, 4, T, Q>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar,
   m[3] + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
 {
  return mat<4, 4, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2],
   m1[3] + m2[3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m, T scalar)
 {
  return mat<4, 4, T, Q>(
   m[0] - scalar,
   m[1] - scalar,
   m[2] - scalar,
   m[3] - scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator-(T scalar, mat<4, 4, T, Q> const& m)
 {
  return mat<4, 4, T, Q>(
   scalar - m[0],
   scalar - m[1],
   scalar - m[2],
   scalar - m[3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
 {
  return mat<4, 4, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2],
   m1[3] - m2[3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator*(mat<4, 4, T, Q> const& m, T scalar)
 {
  return mat<4, 4, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar,
   m[3] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator*(T scalar, mat<4, 4, T, Q> const& m)
 {
  return mat<4, 4, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar,
   m[3] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 4, T, Q>::col_type operator*
 (
  mat<4, 4, T, Q> const& m,
  typename mat<4, 4, T, Q>::row_type const& v
 )
 {
# 561 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat4x4.inl"
  typename mat<4, 4, T, Q>::col_type const Mov0(v[0]);
  typename mat<4, 4, T, Q>::col_type const Mov1(v[1]);
  typename mat<4, 4, T, Q>::col_type const Mul0 = m[0] * Mov0;
  typename mat<4, 4, T, Q>::col_type const Mul1 = m[1] * Mov1;
  typename mat<4, 4, T, Q>::col_type const Add0 = Mul0 + Mul1;
  typename mat<4, 4, T, Q>::col_type const Mov2(v[2]);
  typename mat<4, 4, T, Q>::col_type const Mov3(v[3]);
  typename mat<4, 4, T, Q>::col_type const Mul2 = m[2] * Mov2;
  typename mat<4, 4, T, Q>::col_type const Mul3 = m[3] * Mov3;
  typename mat<4, 4, T, Q>::col_type const Add1 = Mul2 + Mul3;
  typename mat<4, 4, T, Q>::col_type const Add2 = Add0 + Add1;
  return Add2;
# 581 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat4x4.inl"
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 4, T, Q>::row_type operator*
 (
  typename mat<4, 4, T, Q>::col_type const& v,
  mat<4, 4, T, Q> const& m
 )
 {
  return typename mat<4, 4, T, Q>::row_type(
   m[0][0] * v[0] + m[0][1] * v[1] + m[0][2] * v[2] + m[0][3] * v[3],
   m[1][0] * v[0] + m[1][1] * v[1] + m[1][2] * v[2] + m[1][3] * v[3],
   m[2][0] * v[0] + m[2][1] * v[1] + m[2][2] * v[2] + m[2][3] * v[3],
   m[3][0] * v[0] + m[3][1] * v[1] + m[3][2] * v[2] + m[3][3] * v[3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
 {
  return mat<2, 4, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
 {
  return mat<3, 4, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],
   m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2] + m1[3][3] * m2[2][3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
 {
  typename mat<4, 4, T, Q>::col_type const SrcA0 = m1[0];
  typename mat<4, 4, T, Q>::col_type const SrcA1 = m1[1];
  typename mat<4, 4, T, Q>::col_type const SrcA2 = m1[2];
  typename mat<4, 4, T, Q>::col_type const SrcA3 = m1[3];

  typename mat<4, 4, T, Q>::col_type const SrcB0 = m2[0];
  typename mat<4, 4, T, Q>::col_type const SrcB1 = m2[1];
  typename mat<4, 4, T, Q>::col_type const SrcB2 = m2[2];
  typename mat<4, 4, T, Q>::col_type const SrcB3 = m2[3];

  mat<4, 4, T, Q> Result;
  Result[0] = SrcA0 * SrcB0[0] + SrcA1 * SrcB0[1] + SrcA2 * SrcB0[2] + SrcA3 * SrcB0[3];
  Result[1] = SrcA0 * SrcB1[0] + SrcA1 * SrcB1[1] + SrcA2 * SrcB1[2] + SrcA3 * SrcB1[3];
  Result[2] = SrcA0 * SrcB2[0] + SrcA1 * SrcB2[1] + SrcA2 * SrcB2[2] + SrcA3 * SrcB2[3];
  Result[3] = SrcA0 * SrcB3[0] + SrcA1 * SrcB3[1] + SrcA2 * SrcB3[2] + SrcA3 * SrcB3[3];
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator/(mat<4, 4, T, Q> const& m, T scalar)
 {
  return mat<4, 4, T, Q>(
   m[0] / scalar,
   m[1] / scalar,
   m[2] / scalar,
   m[3] / scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator/(T scalar, mat<4, 4, T, Q> const& m)
 {
  return mat<4, 4, T, Q>(
   scalar / m[0],
   scalar / m[1],
   scalar / m[2],
   scalar / m[3]);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 4, T, Q>::col_type operator/(mat<4, 4, T, Q> const& m, typename mat<4, 4, T, Q>::row_type const& v)
 {
  return inverse(m) * v;
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 4, T, Q>::row_type operator/(typename mat<4, 4, T, Q>::col_type const& v, mat<4, 4, T, Q> const& m)
 {
  return v * inverse(m);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator/(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
 {
  mat<4, 4, T, Q> m1_copy(m1);
  return m1_copy /= m2;
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
 }
}
# 189 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat4x4.hpp" 2
# 6 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_double4x4.hpp" 2

namespace glm
{






 typedef mat<4, 4, double, defaultp> dmat4x4;




 typedef mat<4, 4, double, defaultp> dmat4;


}
# 6 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat4x4.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_double4x4_precision.hpp" 1



       


namespace glm
{







 typedef mat<4, 4, double, lowp> lowp_dmat4;





 typedef mat<4, 4, double, mediump> mediump_dmat4;





 typedef mat<4, 4, double, highp> highp_dmat4;





 typedef mat<4, 4, double, lowp> lowp_dmat4x4;





 typedef mat<4, 4, double, mediump> mediump_dmat4x4;





 typedef mat<4, 4, double, highp> highp_dmat4x4;


}
# 7 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat4x4.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_float4x4.hpp" 1



       


namespace glm
{






 typedef mat<4, 4, float, defaultp> mat4x4;




 typedef mat<4, 4, float, defaultp> mat4;


}
# 8 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat4x4.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_float4x4_precision.hpp" 1



       


namespace glm
{







 typedef mat<4, 4, float, lowp> lowp_mat4;





 typedef mat<4, 4, float, mediump> mediump_mat4;





 typedef mat<4, 4, float, highp> highp_mat4;





 typedef mat<4, 4, float, lowp> lowp_mat4x4;





 typedef mat<4, 4, float, mediump> mediump_mat4x4;





 typedef mat<4, 4, float, highp> highp_mat4x4;


}
# 9 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat4x4.hpp" 2
# 30 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/matrix.hpp" 2

namespace glm {
namespace detail
{
 template<length_t C, length_t R, typename T, qualifier Q>
 struct outerProduct_trait{};

 template<typename T, qualifier Q>
 struct outerProduct_trait<2, 2, T, Q>
 {
  typedef mat<2, 2, T, Q> type;
 };

 template<typename T, qualifier Q>
 struct outerProduct_trait<2, 3, T, Q>
 {
  typedef mat<3, 2, T, Q> type;
 };

 template<typename T, qualifier Q>
 struct outerProduct_trait<2, 4, T, Q>
 {
  typedef mat<4, 2, T, Q> type;
 };

 template<typename T, qualifier Q>
 struct outerProduct_trait<3, 2, T, Q>
 {
  typedef mat<2, 3, T, Q> type;
 };

 template<typename T, qualifier Q>
 struct outerProduct_trait<3, 3, T, Q>
 {
  typedef mat<3, 3, T, Q> type;
 };

 template<typename T, qualifier Q>
 struct outerProduct_trait<3, 4, T, Q>
 {
  typedef mat<4, 3, T, Q> type;
 };

 template<typename T, qualifier Q>
 struct outerProduct_trait<4, 2, T, Q>
 {
  typedef mat<2, 4, T, Q> type;
 };

 template<typename T, qualifier Q>
 struct outerProduct_trait<4, 3, T, Q>
 {
  typedef mat<3, 4, T, Q> type;
 };

 template<typename T, qualifier Q>
 struct outerProduct_trait<4, 4, T, Q>
 {
  typedef mat<4, 4, T, Q> type;
 };
}
# 105 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/matrix.hpp"
 template<length_t C, length_t R, typename T, qualifier Q>
 [[nodiscard]] mat<C, R, T, Q> matrixCompMult(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y);
# 119 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/matrix.hpp"
 template<length_t C, length_t R, typename T, qualifier Q>
 [[nodiscard]] typename detail::outerProduct_trait<C, R, T, Q>::type outerProduct(vec<C, T, Q> const& c, vec<R, T, Q> const& r);
# 131 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/matrix.hpp"
 template<length_t C, length_t R, typename T, qualifier Q>
 [[nodiscard]] typename mat<C, R, T, Q>::transpose_type transpose(mat<C, R, T, Q> const& x);
# 143 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/matrix.hpp"
 template<length_t C, length_t R, typename T, qualifier Q>
 [[nodiscard]] T determinant(mat<C, R, T, Q> const& m);
# 155 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/matrix.hpp"
 template<length_t C, length_t R, typename T, qualifier Q>
 [[nodiscard]] mat<C, R, T, Q> inverse(mat<C, R, T, Q> const& m);


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/func_matrix.inl" 1
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/geometric.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/geometric.hpp"
       



namespace glm
{
# 29 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/geometric.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] T length(vec<L, T, Q> const& x);
# 39 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/geometric.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] T distance(vec<L, T, Q> const& p0, vec<L, T, Q> const& p1);
# 49 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/geometric.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr T dot(vec<L, T, Q> const& x, vec<L, T, Q> const& y);







 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> cross(vec<3, T, Q> const& x, vec<3, T, Q> const& y);
# 69 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/geometric.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> normalize(vec<L, T, Q> const& x);
# 79 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/geometric.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> faceforward(
  vec<L, T, Q> const& N,
  vec<L, T, Q> const& I,
  vec<L, T, Q> const& Nref);
# 93 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/geometric.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> reflect(
  vec<L, T, Q> const& I,
  vec<L, T, Q> const& N);
# 107 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/geometric.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> refract(
  vec<L, T, Q> const& I,
  vec<L, T, Q> const& N,
  T eta);


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/func_geometric.inl" 1
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/exponential.hpp" 1
# 15 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/exponential.hpp"
       

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec1.hpp" 1



       
# 14 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec1.hpp"
namespace glm
{
 template<typename T, qualifier Q>
 struct vec<1, T, Q>
 {


  typedef T value_type;
  typedef vec<1, T, Q> type;
  typedef vec<1, bool, Q> bool_type;





#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpedantic"
# 66 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec1.hpp"
   union {T x, r, s;};
# 78 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec1.hpp"
#pragma GCC diagnostic pop
# 87 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec1.hpp"
  typedef length_t length_type;
  [[nodiscard]] static constexpr length_type length(){return 1;}

  [[nodiscard]] constexpr T & operator[](length_type i);
  [[nodiscard]] constexpr T const& operator[](length_type i) const;



  constexpr vec() = default;
  constexpr vec(vec const& v) = default;
  template<qualifier P>
  constexpr vec(vec<1, T, P> const& v);



  constexpr explicit vec(T scalar);




  template<typename U, qualifier P>
  constexpr vec(vec<2, U, P> const& v);

  template<typename U, qualifier P>
  constexpr vec(vec<3, U, P> const& v);

  template<typename U, qualifier P>
  constexpr vec(vec<4, U, P> const& v);


  template<typename U, qualifier P>
  constexpr vec(vec<1, U, P> const& v);
# 132 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec1.hpp"
  constexpr vec<1, T, Q> & operator=(vec const& v) = default;

  template<typename U>
  constexpr vec<1, T, Q> & operator=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<1, T, Q> & operator+=(U scalar);
  template<typename U>
  constexpr vec<1, T, Q> & operator+=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<1, T, Q> & operator-=(U scalar);
  template<typename U>
  constexpr vec<1, T, Q> & operator-=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<1, T, Q> & operator*=(U scalar);
  template<typename U>
  constexpr vec<1, T, Q> & operator*=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<1, T, Q> & operator/=(U scalar);
  template<typename U>
  constexpr vec<1, T, Q> & operator/=(vec<1, U, Q> const& v);



  constexpr vec<1, T, Q> & operator++();
  constexpr vec<1, T, Q> & operator--();
  [[nodiscard]] constexpr vec<1, T, Q> operator++(int);
  [[nodiscard]] constexpr vec<1, T, Q> operator--(int);



  template<typename U>
  constexpr vec<1, T, Q> & operator%=(U scalar);
  template<typename U>
  constexpr vec<1, T, Q> & operator%=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<1, T, Q> & operator&=(U scalar);
  template<typename U>
  constexpr vec<1, T, Q> & operator&=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<1, T, Q> & operator|=(U scalar);
  template<typename U>
  constexpr vec<1, T, Q> & operator|=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<1, T, Q> & operator^=(U scalar);
  template<typename U>
  constexpr vec<1, T, Q> & operator^=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<1, T, Q> & operator<<=(U scalar);
  template<typename U>
  constexpr vec<1, T, Q> & operator<<=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<1, T, Q> & operator>>=(U scalar);
  template<typename U>
  constexpr vec<1, T, Q> & operator>>=(vec<1, U, Q> const& v);
 };



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator+(vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator-(vec<1, T, Q> const& v);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator+(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator+(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator+(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator-(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator-(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator-(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator*(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator*(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator*(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator/(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator/(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator/(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator%(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator%(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator%(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator&(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator&(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator&(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator|(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator|(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator|(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator^(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator^(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator^(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator<<(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator<<(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator<<(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator>>(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator>>(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator>>(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator~(vec<1, T, Q> const& v);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<qualifier Q>
 [[nodiscard]] constexpr vec<1, bool, Q> operator&&(vec<1, bool, Q> const& v1, vec<1, bool, Q> const& v2);

 template<qualifier Q>
 [[nodiscard]] constexpr vec<1, bool, Q> operator||(vec<1, bool, Q> const& v1, vec<1, bool, Q> const& v2);
}


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec1.inl" 1




namespace glm
{
# 25 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec1.inl"
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr vec<1, T, Q>::vec(vec<1, T, P> const& v)
  : x(v.x)
 {}



 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q>::vec(T scalar)
  : x(scalar)
 {}



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr vec<1, T, Q>::vec(vec<1, U, P> const& v)
  : x(static_cast<T>(v.x))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr vec<1, T, Q>::vec(vec<2, U, P> const& v)
  : x(static_cast<T>(v.x))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr vec<1, T, Q>::vec(vec<3, U, P> const& v)
  : x(static_cast<T>(v.x))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr vec<1, T, Q>::vec(vec<4, U, P> const& v)
  : x(static_cast<T>(v.x))
 {}



 template<typename T, qualifier Q>
 inline constexpr T & vec<1, T, Q>::operator[](typename vec<1, T, Q>::length_type)
 {
  return x;
 }

 template<typename T, qualifier Q>
 inline constexpr T const& vec<1, T, Q>::operator[](typename vec<1, T, Q>::length_type) const
 {
  return x;
 }
# 89 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec1.inl"
 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator=(vec<1, U, Q> const& v)
 {
  this->x = static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator+=(U scalar)
 {
  this->x += static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator+=(vec<1, U, Q> const& v)
 {
  this->x += static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator-=(U scalar)
 {
  this->x -= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator-=(vec<1, U, Q> const& v)
 {
  this->x -= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator*=(U scalar)
 {
  this->x *= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator*=(vec<1, U, Q> const& v)
 {
  this->x *= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator/=(U scalar)
 {
  this->x /= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator/=(vec<1, U, Q> const& v)
 {
  this->x /= static_cast<T>(v.x);
  return *this;
 }



 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator++()
 {
  ++this->x;
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator--()
 {
  --this->x;
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> vec<1, T, Q>::operator++(int)
 {
  vec<1, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> vec<1, T, Q>::operator--(int)
 {
  vec<1, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator%=(U scalar)
 {
  this->x %= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator%=(vec<1, U, Q> const& v)
 {
  this->x %= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator&=(U scalar)
 {
  this->x &= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator&=(vec<1, U, Q> const& v)
 {
  this->x &= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator|=(U scalar)
 {
  this->x |= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator|=(vec<1, U, Q> const& v)
 {
  this->x |= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator^=(U scalar)
 {
  this->x ^= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator^=(vec<1, U, Q> const& v)
 {
  this->x ^= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator<<=(U scalar)
 {
  this->x <<= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator<<=(vec<1, U, Q> const& v)
 {
  this->x <<= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator>>=(U scalar)
 {
  this->x >>= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator>>=(vec<1, U, Q> const& v)
 {
  this->x >>= static_cast<T>(v.x);
  return *this;
 }



 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator+(vec<1, T, Q> const& v)
 {
  return v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator-(vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   -v.x);
 }



 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator+(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   v.x + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator+(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   scalar + v.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator+(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   v1.x + v2.x);
 }


 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator-(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   v.x - scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator-(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   scalar - v.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator-(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   v1.x - v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator*(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   v.x * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator*(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   scalar * v.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator*(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   v1.x * v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator/(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   v.x / scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator/(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   scalar / v.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator/(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   v1.x / v2.x);
 }



 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator%(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   v.x % scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator%(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   scalar % v.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator%(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   v1.x % v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator&(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   v.x & scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator&(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   scalar & v.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator&(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   v1.x & v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator|(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   v.x | scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator|(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   scalar | v.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator|(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   v1.x | v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator^(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   v.x ^ scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator^(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   scalar ^ v.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator^(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   v1.x ^ v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator<<(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   static_cast<T>(v.x << scalar));
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator<<(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   static_cast<T>(scalar << v.x));
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator<<(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   static_cast<T>(v1.x << v2.x));
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator>>(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   static_cast<T>(v.x >> scalar));
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator>>(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   static_cast<T>(scalar >> v.x));
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator>>(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   static_cast<T>(v1.x >> v2.x));
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator~(vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   ~v.x);
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.x, v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return !(v1 == v2);
 }

 template<qualifier Q>
 inline constexpr vec<1, bool, Q> operator&&(vec<1, bool, Q> const& v1, vec<1, bool, Q> const& v2)
 {
  return vec<1, bool, Q>(v1.x && v2.x);
 }

 template<qualifier Q>
 inline constexpr vec<1, bool, Q> operator||(vec<1, bool, Q> const& v1, vec<1, bool, Q> const& v2)
 {
  return vec<1, bool, Q>(v1.x || v2.x);
 }
}
# 308 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_vec1.hpp" 2
# 18 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/exponential.hpp" 2



# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 1 3
# 39 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 3
       
# 40 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 3
# 22 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/exponential.hpp" 2

namespace glm
{
# 35 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/exponential.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> pow(vec<L, T, Q> const& base, vec<L, T, Q> const& exponent);
# 46 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/exponential.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> exp(vec<L, T, Q> const& v);
# 59 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/exponential.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> log(vec<L, T, Q> const& v);
# 70 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/exponential.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> exp2(vec<L, T, Q> const& v);
# 82 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/exponential.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> log2(vec<L, T, Q> const& v);
# 93 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/exponential.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> sqrt(vec<L, T, Q> const& v);
# 104 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/exponential.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> inversesqrt(vec<L, T, Q> const& v);


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/func_exponential.inl" 1



# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vector_relational.hpp" 1
# 20 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vector_relational.hpp"
       


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/setup.hpp" 1
# 24 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vector_relational.hpp" 2

namespace glm
{
# 37 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vector_relational.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> lessThan(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
# 47 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vector_relational.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> lessThanEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
# 57 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vector_relational.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> greaterThan(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
# 67 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vector_relational.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> greaterThanEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
# 77 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vector_relational.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
# 87 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vector_relational.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y);







 template<length_t L, qualifier Q>
 [[nodiscard]] constexpr bool any(vec<L, bool, Q> const& v);







 template<length_t L, qualifier Q>
 [[nodiscard]] constexpr bool all(vec<L, bool, Q> const& v);
# 115 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vector_relational.hpp"
 template<length_t L, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> not_(vec<L, bool, Q> const& v);


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/func_vector_relational.inl" 1
namespace glm
{
 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> lessThan(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
 {
  vec<L, bool, Q> Result(true);
  for(length_t i = 0; i < L; ++i)
   Result[i] = x[i] < y[i];
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> lessThanEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
 {
  vec<L, bool, Q> Result(true);
  for(length_t i = 0; i < L; ++i)
   Result[i] = x[i] <= y[i];
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> greaterThan(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
 {
  vec<L, bool, Q> Result(true);
  for(length_t i = 0; i < L; ++i)
   Result[i] = x[i] > y[i];
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> greaterThanEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
 {
  vec<L, bool, Q> Result(true);
  for(length_t i = 0; i < L; ++i)
   Result[i] = x[i] >= y[i];
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
 {
  vec<L, bool, Q> Result(true);
  for(length_t i = 0; i < L; ++i)
   Result[i] = x[i] == y[i];
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
 {
  vec<L, bool, Q> Result(true);
  for(length_t i = 0; i < L; ++i)
   Result[i] = x[i] != y[i];
  return Result;
 }

 template<length_t L, qualifier Q>
 inline constexpr bool any(vec<L, bool, Q> const& v)
 {
  bool Result = false;
  for(length_t i = 0; i < L; ++i)
   Result = Result || v[i];
  return Result;
 }

 template<length_t L, qualifier Q>
 inline constexpr bool all(vec<L, bool, Q> const& v)
 {
  bool Result = true;
  for(length_t i = 0; i < L; ++i)
   Result = Result && v[i];
  return Result;
 }

 template<length_t L, qualifier Q>
 inline constexpr vec<L, bool, Q> not_(vec<L, bool, Q> const& v)
 {
  vec<L, bool, Q> Result(true);
  for(length_t i = 0; i < L; ++i)
   Result[i] = !v[i];
  return Result;
 }
}
# 122 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/vector_relational.hpp" 2
# 5 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/func_exponential.inl" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/_vectorize.hpp" 1
       

namespace glm{
namespace detail
{
 template<template<length_t L, typename T, qualifier Q> class vec, length_t L, typename R, typename T, qualifier Q>
 struct functor1{};

 template<template<length_t L, typename T, qualifier Q> class vec, typename R, typename T, qualifier Q>
 struct functor1<vec, 1, R, T, Q>
 {
  inline constexpr static vec<1, R, Q> call(R (*Func) (T x), vec<1, T, Q> const& v)
  {
   return vec<1, R, Q>(Func(v.x));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename R, typename T, qualifier Q>
 struct functor1<vec, 2, R, T, Q>
 {
  inline constexpr static vec<2, R, Q> call(R (*Func) (T x), vec<2, T, Q> const& v)
  {
   return vec<2, R, Q>(Func(v.x), Func(v.y));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename R, typename T, qualifier Q>
 struct functor1<vec, 3, R, T, Q>
 {
  inline constexpr static vec<3, R, Q> call(R (*Func) (T x), vec<3, T, Q> const& v)
  {
   return vec<3, R, Q>(Func(v.x), Func(v.y), Func(v.z));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename R, typename T, qualifier Q>
 struct functor1<vec, 4, R, T, Q>
 {
  inline constexpr static vec<4, R, Q> call(R (*Func) (T x), vec<4, T, Q> const& v)
  {
   return vec<4, R, Q>(Func(v.x), Func(v.y), Func(v.z), Func(v.w));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, length_t L, typename T, qualifier Q>
 struct functor2{};

 template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
 struct functor2<vec, 1, T, Q>
 {
  inline static vec<1, T, Q> call(T (*Func) (T x, T y), vec<1, T, Q> const& a, vec<1, T, Q> const& b)
  {
   return vec<1, T, Q>(Func(a.x, b.x));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
 struct functor2<vec, 2, T, Q>
 {
  inline static vec<2, T, Q> call(T (*Func) (T x, T y), vec<2, T, Q> const& a, vec<2, T, Q> const& b)
  {
   return vec<2, T, Q>(Func(a.x, b.x), Func(a.y, b.y));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
 struct functor2<vec, 3, T, Q>
 {
  inline static vec<3, T, Q> call(T (*Func) (T x, T y), vec<3, T, Q> const& a, vec<3, T, Q> const& b)
  {
   return vec<3, T, Q>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
 struct functor2<vec, 4, T, Q>
 {
  inline static vec<4, T, Q> call(T (*Func) (T x, T y), vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z), Func(a.w, b.w));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, length_t L, typename T, qualifier Q>
 struct functor2_vec_sca{};

 template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
 struct functor2_vec_sca<vec, 1, T, Q>
 {
  inline static vec<1, T, Q> call(T (*Func) (T x, T y), vec<1, T, Q> const& a, T b)
  {
   return vec<1, T, Q>(Func(a.x, b));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
 struct functor2_vec_sca<vec, 2, T, Q>
 {
  inline static vec<2, T, Q> call(T (*Func) (T x, T y), vec<2, T, Q> const& a, T b)
  {
   return vec<2, T, Q>(Func(a.x, b), Func(a.y, b));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
 struct functor2_vec_sca<vec, 3, T, Q>
 {
  inline static vec<3, T, Q> call(T (*Func) (T x, T y), vec<3, T, Q> const& a, T b)
  {
   return vec<3, T, Q>(Func(a.x, b), Func(a.y, b), Func(a.z, b));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
 struct functor2_vec_sca<vec, 4, T, Q>
 {
  inline static vec<4, T, Q> call(T (*Func) (T x, T y), vec<4, T, Q> const& a, T b)
  {
   return vec<4, T, Q>(Func(a.x, b), Func(a.y, b), Func(a.z, b), Func(a.w, b));
  }
 };

 template<length_t L, typename T, qualifier Q>
 struct functor2_vec_int {};

 template<typename T, qualifier Q>
 struct functor2_vec_int<1, T, Q>
 {
  inline static vec<1, int, Q> call(int (*Func) (T x, int y), vec<1, T, Q> const& a, vec<1, int, Q> const& b)
  {
   return vec<1, int, Q>(Func(a.x, b.x));
  }
 };

 template<typename T, qualifier Q>
 struct functor2_vec_int<2, T, Q>
 {
  inline static vec<2, int, Q> call(int (*Func) (T x, int y), vec<2, T, Q> const& a, vec<2, int, Q> const& b)
  {
   return vec<2, int, Q>(Func(a.x, b.x), Func(a.y, b.y));
  }
 };

 template<typename T, qualifier Q>
 struct functor2_vec_int<3, T, Q>
 {
  inline static vec<3, int, Q> call(int (*Func) (T x, int y), vec<3, T, Q> const& a, vec<3, int, Q> const& b)
  {
   return vec<3, int, Q>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z));
  }
 };

 template<typename T, qualifier Q>
 struct functor2_vec_int<4, T, Q>
 {
  inline static vec<4, int, Q> call(int (*Func) (T x, int y), vec<4, T, Q> const& a, vec<4, int, Q> const& b)
  {
   return vec<4, int, Q>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z), Func(a.w, b.w));
  }
 };
}
}
# 6 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/func_exponential.inl" 2

# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 1 3
# 39 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 3
       
# 40 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 3
# 8 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/func_exponential.inl" 2
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cassert" 1 3
# 41 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cassert" 3
       
# 42 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cassert" 3


# 1 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/assert.h" 1 3
# 45 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cassert" 2 3
# 9 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/func_exponential.inl" 2

namespace glm{
namespace detail
{

  using std::log2;
# 23 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/func_exponential.inl"
 template<length_t L, typename T, qualifier Q, bool isFloat, bool Aligned>
 struct compute_log2
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& v)
  {
   static_assert(std::numeric_limits<T>::is_iec559 || 0, "'log2' only accept floating-point inputs. Include <glm/gtc/integer.hpp> for integer inputs.");

   return detail::functor1<vec, L, T, T, Q>::call(log2, v);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_sqrt
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return detail::functor1<vec, L, T, T, Q>::call(std::sqrt, x);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_inversesqrt
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return static_cast<T>(1) / sqrt(x);
  }
 };

 template<length_t L, bool Aligned>
 struct compute_inversesqrt<L, float, lowp, Aligned>
 {
  inline static vec<L, float, lowp> call(vec<L, float, lowp> const& x)
  {
   vec<L, float, lowp> tmp(x);
   vec<L, float, lowp> xhalf(tmp * 0.5f);
   vec<L, uint, lowp>* p = reinterpret_cast<vec<L, uint, lowp>*>(const_cast<vec<L, float, lowp>*>(&x));
   vec<L, uint, lowp> i = vec<L, uint, lowp>(0x5f375a86) - (*p >> vec<L, uint, lowp>(1));
   vec<L, float, lowp>* ptmp = reinterpret_cast<vec<L, float, lowp>*>(&i);
   tmp = *ptmp;
   tmp = tmp * (1.5f - xhalf * tmp * tmp);
   return tmp;
  }
 };
}


 using std::pow;
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> pow(vec<L, T, Q> const& base, vec<L, T, Q> const& exponent)
 {
  return detail::functor2<vec, L, T, Q>::call(pow, base, exponent);
 }


 using std::exp;
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> exp(vec<L, T, Q> const& x)
 {
  return detail::functor1<vec, L, T, T, Q>::call(exp, x);
 }


 using std::log;
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> log(vec<L, T, Q> const& x)
 {
  return detail::functor1<vec, L, T, T, Q>::call(log, x);
 }


    using std::exp2;
# 106 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/func_exponential.inl"
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> exp2(vec<L, T, Q> const& x)
 {
  return detail::functor1<vec, L, T, T, Q>::call(exp2, x);
 }


 template<typename genType>
 inline genType log2(genType x)
 {
  return log2(vec<1, genType>(x)).x;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> log2(vec<L, T, Q> const& x)
 {
  return detail::compute_log2<L, T, Q, std::numeric_limits<T>::is_iec559, detail::is_aligned<Q>::value>::call(x);
 }


 using std::sqrt;
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> sqrt(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'sqrt' only accept floating-point inputs");
  return detail::compute_sqrt<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }


 template<typename genType>
 inline genType inversesqrt(genType x)
 {
  return static_cast<genType>(1) / sqrt(x);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> inversesqrt(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'inversesqrt' only accept floating-point inputs");
  return detail::compute_inversesqrt<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }
}
# 111 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/exponential.hpp" 2
# 2 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/func_geometric.inl" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/common.hpp" 1
# 15 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/common.hpp"
       


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/_fixes.hpp" 1
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 1 3
# 39 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 3
       
# 40 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 3
# 2 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/_fixes.hpp" 2
# 19 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/common.hpp" 2

namespace glm
{
# 31 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/common.hpp"
 template<typename genType>
 [[nodiscard]] constexpr genType abs(genType x);
# 42 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/common.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, T, Q> abs(vec<L, T, Q> const& x);
# 53 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/common.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, T, Q> sign(vec<L, T, Q> const& x);
# 64 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/common.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> floor(vec<L, T, Q> const& x);
# 76 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/common.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> trunc(vec<L, T, Q> const& x);
# 91 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/common.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> round(vec<L, T, Q> const& x);
# 105 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/common.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> roundEven(vec<L, T, Q> const& x);
# 117 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/common.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> ceil(vec<L, T, Q> const& x);







 template<typename genType>
 [[nodiscard]] genType fract(genType x);
# 137 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/common.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> fract(vec<L, T, Q> const& x);

 template<typename genType>
 [[nodiscard]] genType mod(genType x, genType y);

 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> mod(vec<L, T, Q> const& x, T y);
# 155 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/common.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> mod(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
# 167 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/common.hpp"
 template<typename genType>
 [[nodiscard]] genType modf(genType x, genType& i);







 template<typename genType>
 [[nodiscard]] constexpr genType min(genType x, genType y);
# 187 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/common.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, T, Q> min(vec<L, T, Q> const& x, T y);
# 198 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/common.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, T, Q> min(vec<L, T, Q> const& x, vec<L, T, Q> const& y);







 template<typename genType>
 [[nodiscard]] constexpr genType max(genType x, genType y);
# 218 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/common.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, T, Q> max(vec<L, T, Q> const& x, T y);
# 229 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/common.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, T, Q> max(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
# 239 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/common.hpp"
 template<typename genType>
 [[nodiscard]] constexpr genType clamp(genType x, genType minVal, genType maxVal);
# 251 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/common.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, T, Q> clamp(vec<L, T, Q> const& x, T minVal, T maxVal);
# 263 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/common.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, T, Q> clamp(vec<L, T, Q> const& x, vec<L, T, Q> const& minVal, vec<L, T, Q> const& maxVal);
# 308 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/common.hpp"
 template<typename genTypeT, typename genTypeU>
 [[nodiscard]] constexpr genTypeT mix(genTypeT x, genTypeT y, genTypeU a);

 template<length_t L, typename T, typename U, qualifier Q>
 [[nodiscard]] constexpr vec<L, T, Q> mix(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, U, Q> const& a);

 template<length_t L, typename T, typename U, qualifier Q>
 [[nodiscard]] constexpr vec<L, T, Q> mix(vec<L, T, Q> const& x, vec<L, T, Q> const& y, U a);





 template<typename genType>
 [[nodiscard]] genType step(genType edge, genType x);
# 332 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/common.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> step(T edge, vec<L, T, Q> const& x);
# 343 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/common.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> step(vec<L, T, Q> const& edge, vec<L, T, Q> const& x);
# 360 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/common.hpp"
 template<typename genType>
 [[nodiscard]] genType smoothstep(genType edge0, genType edge1, genType x);

 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> smoothstep(T edge0, T edge1, vec<L, T, Q> const& x);

 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> smoothstep(vec<L, T, Q> const& edge0, vec<L, T, Q> const& edge1, vec<L, T, Q> const& x);
# 383 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/common.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, bool, Q> isnan(vec<L, T, Q> const& x);
# 398 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/common.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, bool, Q> isinf(vec<L, T, Q> const& x);







 [[nodiscard]] int floatBitsToInt(float v);
# 418 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/common.hpp"
 template<length_t L, qualifier Q>
 [[nodiscard]] vec<L, int, Q> floatBitsToInt(vec<L, float, Q> const& v);







 [[nodiscard]] uint floatBitsToUint(float v);
# 438 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/common.hpp"
 template<length_t L, qualifier Q>
 [[nodiscard]] vec<L, uint, Q> floatBitsToUint(vec<L, float, Q> const& v);
# 449 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/common.hpp"
 [[nodiscard]] float intBitsToFloat(int v);
# 462 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/common.hpp"
 template<length_t L, qualifier Q>
 [[nodiscard]] vec<L, float, Q> intBitsToFloat(vec<L, int, Q> const& v);
# 473 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/common.hpp"
 [[nodiscard]] float uintBitsToFloat(uint v);
# 486 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/common.hpp"
 template<length_t L, qualifier Q>
 [[nodiscard]] vec<L, float, Q> uintBitsToFloat(vec<L, uint, Q> const& v);







 template<typename genType>
 [[nodiscard]] genType fma(genType const& a, genType const& b, genType const& c);
# 512 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/common.hpp"
 template<typename genType>
 [[nodiscard]] genType frexp(genType x, int& exp);

 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> frexp(vec<L, T, Q> const& v, vec<L, int, Q>& exp);
# 529 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/common.hpp"
 template<typename genType>
 [[nodiscard]] genType ldexp(genType const& x, int const& exp);

 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> ldexp(vec<L, T, Q> const& v, vec<L, int, Q> const& exp);


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/func_common.inl" 1




# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/compute_common.hpp" 1
       

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/setup.hpp" 1
# 4 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/compute_common.hpp" 2


namespace glm{
namespace detail
{
 template<typename genFIType, bool >
 struct compute_abs
 {};

 template<typename genFIType>
 struct compute_abs<genFIType, true>
 {
  inline constexpr static genFIType call(genFIType x)
  {
   static_assert(std::numeric_limits<genFIType>::is_iec559 || 0 || std::numeric_limits<genFIType>::is_signed, "'abs' only accept floating-point and integer scalar or vector inputs")

                                                                           ;

   return x >= genFIType(0) ? x : -x;

  }
 };
# 38 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/compute_common.hpp"
 template<typename genFIType>
 struct compute_abs<genFIType, false>
 {
  inline constexpr static genFIType call(genFIType x)
  {
   static_assert((!std::numeric_limits<genFIType>::is_signed && std::numeric_limits<genFIType>::is_integer), "'abs' only accept floating-point and integer scalar or vector inputs")

                                                                           ;
   return x;
  }
 };
}
}
# 6 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/func_common.inl" 2







namespace glm
{

 template<typename genType>
 inline constexpr genType min(genType x, genType y)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0 || std::numeric_limits<genType>::is_integer, "'min' only accept floating-point or integer inputs");
  return (y < x) ? y : x;
 }


 template<typename genType>
 inline constexpr genType max(genType x, genType y)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0 || std::numeric_limits<genType>::is_integer, "'max' only accept floating-point or integer inputs");

  return (x < y) ? y : x;
 }


 template<>
 inline constexpr int abs(int x)
 {
  int const y = x >> (sizeof(int) * 8 - 1);
  return (x ^ y) - y;
 }



  using ::std::round;
# 55 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/func_common.inl"
  using ::std::trunc;
# 66 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/func_common.inl"
}

namespace glm{
namespace detail
{
 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_abs_vector
 {
  inline constexpr static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return detail::functor1<vec, L, T, T, Q>::call(abs, x);
  }
 };

 template<length_t L, typename T, typename U, qualifier Q, bool Aligned>
 struct compute_mix_vector
 {
  inline constexpr static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, U, Q> const& a)
  {
   static_assert(std::numeric_limits<U>::is_iec559 || 0 || 0, "'mix' only accept floating-point inputs for the interpolator a");

   return vec<L, T, Q>(vec<L, U, Q>(x) * (static_cast<U>(1) - a) + vec<L, U, Q>(y) * a);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_mix_vector<L, T, bool, Q, Aligned>
 {
  inline constexpr static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, bool, Q> const& a)
  {
   vec<L, T, Q> Result(0);
   for(length_t i = 0; i < x.length(); ++i)
    Result[i] = a[i] ? y[i] : x[i];
   return Result;
  }
 };

 template<length_t L, typename T, typename U, qualifier Q, bool Aligned>
 struct compute_mix_scalar
 {
  inline constexpr static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y, U const& a)
  {
   static_assert(std::numeric_limits<U>::is_iec559 || 0 || 0, "'mix' only accept floating-point inputs for the interpolator a");

   return vec<L, T, Q>(vec<L, U, Q>(x) * (static_cast<U>(1) - a) + vec<L, U, Q>(y) * a);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_mix_scalar<L, T, bool, Q, Aligned>
 {
  inline constexpr static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y, bool const& a)
  {
   return a ? y : x;
  }
 };

 template<typename T, typename U>
 struct compute_mix
 {
  inline constexpr static T call(T const& x, T const& y, U const& a)
  {
   static_assert(std::numeric_limits<U>::is_iec559 || 0 || 0, "'mix' only accept floating-point inputs for the interpolator a");

   return static_cast<T>(static_cast<U>(x) * (static_cast<U>(1) - a) + static_cast<U>(y) * a);
  }
 };

 template<typename T>
 struct compute_mix<T, bool>
 {
  inline constexpr static T call(T const& x, T const& y, bool const& a)
  {
   return a ? y : x;
  }
 };

 template<length_t L, typename T, qualifier Q, bool isFloat, bool Aligned>
 struct compute_sign
 {
  inline constexpr static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return vec<L, T, Q>(glm::lessThan(vec<L, T, Q>(0), x)) - vec<L, T, Q>(glm::lessThan(x, vec<L, T, Q>(0)));
  }
 };


 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_sign<L, T, Q, false, Aligned>
 {
  inline constexpr static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   T const Shift(static_cast<T>(sizeof(T) * 8 - 1));
   vec<L, T, Q> const y(vec<L, typename detail::make_unsigned<T>::type, Q>(-x) >> typename detail::make_unsigned<T>::type(Shift));

   return (x >> Shift) | y;
  }
 };


 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_floor
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return detail::functor1<vec, L, T, T, Q>::call(std::floor, x);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_ceil
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return detail::functor1<vec, L, T, T, Q>::call(std::ceil, x);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_fract
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return x - floor(x);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_trunc
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return detail::functor1<vec, L, T, T, Q>::call(trunc, x);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_round
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return detail::functor1<vec, L, T, T, Q>::call(round, x);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_mod
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& a, vec<L, T, Q> const& b)
  {
   static_assert(std::numeric_limits<T>::is_iec559 || 0, "'mod' only accept floating-point inputs. Include <glm/gtc/integer.hpp> for integer inputs.");
   return a - b * floor(a / b);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_min_vector
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
  {
   return detail::functor2<vec, L, T, Q>::call(min, x, y);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_max_vector
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
  {
   return detail::functor2<vec, L, T, Q>::call(max, x, y);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_clamp_vector
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& minVal, vec<L, T, Q> const& maxVal)
  {
   return min(max(x, minVal), maxVal);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_step_vector
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& edge, vec<L, T, Q> const& x)
  {
   return mix(vec<L, T, Q>(1), vec<L, T, Q>(0), glm::lessThan(x, edge));
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_smoothstep_vector
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& edge0, vec<L, T, Q> const& edge1, vec<L, T, Q> const& x)
  {
   static_assert(std::numeric_limits<T>::is_iec559 || 0 || 0, "'smoothstep' only accept floating-point inputs");
   vec<L, T, Q> const tmp(clamp((x - edge0) / (edge1 - edge0), static_cast<T>(0), static_cast<T>(1)));
   return tmp * tmp * (static_cast<T>(3) - static_cast<T>(2) * tmp);
  }
 };
}

 template<typename genFIType>
 inline constexpr genFIType abs(genFIType x)
 {
  return detail::compute_abs<genFIType, std::numeric_limits<genFIType>::is_signed>::call(x);
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, T, Q> abs(vec<L, T, Q> const& x)
 {
  return detail::compute_abs_vector<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }



 template<typename genFIType>
 inline constexpr genFIType sign(genFIType x)
 {
  static_assert(std::numeric_limits<genFIType>::is_iec559 || 0 || (std::numeric_limits<genFIType>::is_signed && std::numeric_limits<genFIType>::is_integer), "'sign' only accept signed inputs")

                                      ;

  return detail::compute_sign<1, genFIType, defaultp,
                                    std::numeric_limits<genFIType>::is_iec559, detail::is_aligned<highp>::value>::call(vec<1, genFIType>(x)).x;
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, T, Q> sign(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0 || (std::numeric_limits<T>::is_signed && std::numeric_limits<T>::is_integer), "'sign' only accept signed inputs")

                                      ;

  return detail::compute_sign<L, T, Q, std::numeric_limits<T>::is_iec559, detail::is_aligned<Q>::value>::call(x);
 }


 using ::std::floor;
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> floor(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'floor' only accept floating-point inputs.");
  return detail::compute_floor<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> trunc(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'trunc' only accept floating-point inputs");
  return detail::compute_trunc<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> round(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'round' only accept floating-point inputs");
  return detail::compute_round<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }
# 339 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/func_common.inl"
 template<typename genType>
 inline genType roundEven(genType x)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'roundEven' only accept floating-point inputs");

  int Integer = static_cast<int>(x);
  genType IntegerPart = static_cast<genType>(Integer);
  genType FractionalPart = fract(x);

  if(FractionalPart > static_cast<genType>(0.5) || FractionalPart < static_cast<genType>(0.5))
  {
   return round(x);
  }
  else if((Integer % 2) == 0)
  {
   return IntegerPart;
  }
  else if(x <= static_cast<genType>(0))
  {
   return IntegerPart - static_cast<genType>(1);
  }
  else
  {
   return IntegerPart + static_cast<genType>(1);
  }




 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> roundEven(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'roundEven' only accept floating-point inputs");
  return detail::functor1<vec, L, T, T, Q>::call(roundEven, x);
 }


 using ::std::ceil;
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> ceil(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'ceil' only accept floating-point inputs");
  return detail::compute_ceil<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }


 template<typename genType>
 inline genType fract(genType x)
 {
  return fract(vec<1, genType>(x)).x;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> fract(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'fract' only accept floating-point inputs");
  return detail::compute_fract<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }


 template<typename genType>
 inline genType mod(genType x, genType y)
 {





   return mod(vec<1, genType, defaultp>(x), y).x;

 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> mod(vec<L, T, Q> const& x, T y)
 {
  return detail::compute_mod<L, T, Q, detail::is_aligned<Q>::value>::call(x, vec<L, T, Q>(y));
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> mod(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
 {
  return detail::compute_mod<L, T, Q, detail::is_aligned<Q>::value>::call(x, y);
 }


 template<typename genType>
 inline genType modf(genType x, genType & i)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'modf' only accept floating-point inputs");
  return std::modf(x, &i);
 }

 template<typename T, qualifier Q>
 inline vec<1, T, Q> modf(vec<1, T, Q> const& x, vec<1, T, Q> & i)
 {
  return vec<1, T, Q>(
   modf(x.x, i.x));
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> modf(vec<2, T, Q> const& x, vec<2, T, Q> & i)
 {
  return vec<2, T, Q>(
   modf(x.x, i.x),
   modf(x.y, i.y));
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> modf(vec<3, T, Q> const& x, vec<3, T, Q> & i)
 {
  return vec<3, T, Q>(
   modf(x.x, i.x),
   modf(x.y, i.y),
   modf(x.z, i.z));
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> modf(vec<4, T, Q> const& x, vec<4, T, Q> & i)
 {
  return vec<4, T, Q>(
   modf(x.x, i.x),
   modf(x.y, i.y),
   modf(x.z, i.z),
   modf(x.w, i.w));
 }
# 476 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/func_common.inl"
 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, T, Q> min(vec<L, T, Q> const& a, T b)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0 || std::numeric_limits<T>::is_integer, "'min' only accept floating-point or integer inputs");
  return detail::compute_min_vector<L, T, Q, detail::is_aligned<Q>::value>::call(a, vec<L, T, Q>(b));
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, T, Q> min(vec<L, T, Q> const& a, vec<L, T, Q> const& b)
 {
  return detail::compute_min_vector<L, T, Q, detail::is_aligned<Q>::value>::call(a, b);
 }


 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, T, Q> max(vec<L, T, Q> const& a, T b)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0 || std::numeric_limits<T>::is_integer, "'max' only accept floating-point or integer inputs");
  return detail::compute_max_vector<L, T, Q, detail::is_aligned<Q>::value>::call(a, vec<L, T, Q>(b));
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, T, Q> max(vec<L, T, Q> const& a, vec<L, T, Q> const& b)
 {
  return detail::compute_max_vector<L, T, Q, detail::is_aligned<Q>::value>::call(a, b);
 }


 template<typename genType>
 inline constexpr genType clamp(genType x, genType minVal, genType maxVal)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0 || std::numeric_limits<genType>::is_integer, "'clamp' only accept floating-point or integer inputs");
  return min(max(x, minVal), maxVal);
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, T, Q> clamp(vec<L, T, Q> const& x, T minVal, T maxVal)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0 || std::numeric_limits<T>::is_integer, "'clamp' only accept floating-point or integer inputs");
  return detail::compute_clamp_vector<L, T, Q, detail::is_aligned<Q>::value>::call(x, vec<L, T, Q>(minVal), vec<L, T, Q>(maxVal));
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, T, Q> clamp(vec<L, T, Q> const& x, vec<L, T, Q> const& minVal, vec<L, T, Q> const& maxVal)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0 || std::numeric_limits<T>::is_integer, "'clamp' only accept floating-point or integer inputs");
  return detail::compute_clamp_vector<L, T, Q, detail::is_aligned<Q>::value>::call(x, minVal, maxVal);
 }

 template<typename genTypeT, typename genTypeU>
 inline constexpr genTypeT mix(genTypeT x, genTypeT y, genTypeU a)
 {
  return detail::compute_mix<genTypeT, genTypeU>::call(x, y, a);
 }

 template<length_t L, typename T, typename U, qualifier Q>
 inline constexpr vec<L, T, Q> mix(vec<L, T, Q> const& x, vec<L, T, Q> const& y, U a)
 {
  return detail::compute_mix_scalar<L, T, U, Q, detail::is_aligned<Q>::value>::call(x, y, a);
 }

 template<length_t L, typename T, typename U, qualifier Q>
 inline constexpr vec<L, T, Q> mix(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, U, Q> const& a)
 {
  return detail::compute_mix_vector<L, T, U, Q, detail::is_aligned<Q>::value>::call(x, y, a);
 }


 template<typename genType>
 inline genType step(genType edge, genType x)
 {
  return mix(static_cast<genType>(1), static_cast<genType>(0), x < edge);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> step(T edge, vec<L, T, Q> const& x)
 {
  return detail::compute_step_vector<L, T, Q, detail::is_aligned<Q>::value>::call(vec<L, T, Q>(edge), x);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> step(vec<L, T, Q> const& edge, vec<L, T, Q> const& x)
 {
  return detail::compute_step_vector<L, T, Q, detail::is_aligned<Q>::value>::call(edge, x);
 }


 template<typename genType>
 inline genType smoothstep(genType edge0, genType edge1, genType x)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0 || 0, "'smoothstep' only accept floating-point inputs");

  genType const tmp(clamp((x - edge0) / (edge1 - edge0), genType(0), genType(1)));
  return tmp * tmp * (genType(3) - genType(2) * tmp);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> smoothstep(T edge0, T edge1, vec<L, T, Q> const& x)
 {
  return detail::compute_smoothstep_vector<L, T, Q, detail::is_aligned<Q>::value>::call(vec<L, T, Q>(edge0), vec<L, T, Q>(edge1), x);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> smoothstep(vec<L, T, Q> const& edge0, vec<L, T, Q> const& edge1, vec<L, T, Q> const& x)
 {
  return detail::compute_smoothstep_vector<L, T, Q, detail::is_aligned<Q>::value>::call(edge0, edge1, x);
 }


  using std::isnan;
# 612 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/func_common.inl"
 template<length_t L, typename T, qualifier Q>
 inline vec<L, bool, Q> isnan(vec<L, T, Q> const& v)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'isnan' only accept floating-point inputs");

  vec<L, bool, Q> Result(0);
  for (length_t l = 0; l < v.length(); ++l)
   Result[l] = glm::isnan(v[l]);
  return Result;
 }


  using std::isinf;
# 654 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/func_common.inl"
 template<length_t L, typename T, qualifier Q>
 inline vec<L, bool, Q> isinf(vec<L, T, Q> const& v)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'isinf' only accept floating-point inputs");

  vec<L, bool, Q> Result(0);
  for (length_t l = 0; l < v.length(); ++l)
   Result[l] = glm::isinf(v[l]);
  return Result;
 }

 inline int floatBitsToInt(float v)
 {
  union
  {
   float in;
   int out;
  } u;

  u.in = v;

  return u.out;
 }

 template<length_t L, qualifier Q>
 inline vec<L, int, Q> floatBitsToInt(vec<L, float, Q> const& v)
 {
  return detail::functor1<vec, L, int, float, Q>::call(floatBitsToInt, v);
 }

 inline uint floatBitsToUint(float v)
 {
  union
  {
   float in;
   uint out;
  } u;

  u.in = v;

  return u.out;
 }

 template<length_t L, qualifier Q>
 inline vec<L, uint, Q> floatBitsToUint(vec<L, float, Q> const& v)
 {
  return detail::functor1<vec, L, uint, float, Q>::call(floatBitsToUint, v);
 }

 inline float intBitsToFloat(int v)
 {
  union
  {
   int in;
   float out;
  } u;

  u.in = v;

  return u.out;
 }

 template<length_t L, qualifier Q>
 inline vec<L, float, Q> intBitsToFloat(vec<L, int, Q> const& v)
 {
  return detail::functor1<vec, L, float, int, Q>::call(intBitsToFloat, v);
 }

 inline float uintBitsToFloat(uint v)
 {
  union
  {
   uint in;
   float out;
  } u;

  u.in = v;

  return u.out;
 }

 template<length_t L, qualifier Q>
 inline vec<L, float, Q> uintBitsToFloat(vec<L, uint, Q> const& v)
 {
  return reinterpret_cast<vec<L, float, Q>&>(const_cast<vec<L, uint, Q>&>(v));
 }


  using std::fma;
# 751 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/func_common.inl"
 template<typename genType>
 inline genType frexp(genType x, int& exp)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'frexp' only accept floating-point inputs");

  return std::frexp(x, &exp);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> frexp(vec<L, T, Q> const& v, vec<L, int, Q>& exp)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'frexp' only accept floating-point inputs");

  vec<L, T, Q> Result(0);
  for (length_t l = 0; l < v.length(); ++l)
   Result[l] = std::frexp(v[l], &exp[l]);
  return Result;
 }

 template<typename genType>
 inline genType ldexp(genType const& x, int const& exp)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'ldexp' only accept floating-point inputs");

  return std::ldexp(x, exp);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> ldexp(vec<L, T, Q> const& v, vec<L, int, Q> const& exp)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'ldexp' only accept floating-point inputs");

  vec<L, T, Q> Result(0);
  for (length_t l = 0; l < v.length(); ++l)
   Result[l] = std::ldexp(v[l], exp[l]);
  return Result;
 }
}
# 539 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/common.hpp" 2
# 3 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/func_geometric.inl" 2

namespace glm{
namespace detail
{
 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_length
 {
  inline static T call(vec<L, T, Q> const& v)
  {
   return sqrt(dot(v, v));
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_distance
 {
  inline static T call(vec<L, T, Q> const& p0, vec<L, T, Q> const& p1)
  {
   return length(p1 - p0);
  }
 };

 template<typename V, typename T, bool Aligned>
 struct compute_dot{};

 template<typename T, qualifier Q, bool Aligned>
 struct compute_dot<vec<1, T, Q>, T, Aligned>
 {
  inline constexpr static T call(vec<1, T, Q> const& a, vec<1, T, Q> const& b)
  {
   return a.x * b.x;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_dot<vec<2, T, Q>, T, Aligned>
 {
  inline constexpr static T call(vec<2, T, Q> const& a, vec<2, T, Q> const& b)
  {
   vec<2, T, Q> tmp(a * b);
   return tmp.x + tmp.y;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_dot<vec<3, T, Q>, T, Aligned>
 {
  inline constexpr static T call(vec<3, T, Q> const& a, vec<3, T, Q> const& b)
  {
   vec<3, T, Q> tmp(a * b);
   return tmp.x + tmp.y + tmp.z;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_dot<vec<4, T, Q>, T, Aligned>
 {
  inline constexpr static T call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   vec<4, T, Q> tmp(a * b);
   return (tmp.x + tmp.y) + (tmp.z + tmp.w);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_cross
 {
  inline constexpr static vec<3, T, Q> call(vec<3, T, Q> const& x, vec<3, T, Q> const& y)
  {
   static_assert(std::numeric_limits<T>::is_iec559, "'cross' accepts only floating-point inputs");

   return vec<3, T, Q>(
    x.y * y.z - y.y * x.z,
    x.z * y.x - y.z * x.x,
    x.x * y.y - y.x * x.y);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_normalize
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& v)
  {
   static_assert(std::numeric_limits<T>::is_iec559, "'normalize' accepts only floating-point inputs");

   return v * inversesqrt(dot(v, v));
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_faceforward
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& N, vec<L, T, Q> const& I, vec<L, T, Q> const& Nref)
  {
   static_assert(std::numeric_limits<T>::is_iec559, "'normalize' accepts only floating-point inputs");

   return dot(Nref, I) < static_cast<T>(0) ? N : -N;
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_reflect
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& I, vec<L, T, Q> const& N)
  {
   return I - N * dot(N, I) * static_cast<T>(2);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_refract
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& I, vec<L, T, Q> const& N, T eta)
  {
   T const dotValue(dot(N, I));
   T const k(static_cast<T>(1) - eta * eta * (static_cast<T>(1) - dotValue * dotValue));
   vec<L, T, Q> const Result =
                (k >= static_cast<T>(0)) ? (eta * I - (eta * dotValue + std::sqrt(k)) * N) : vec<L, T, Q>(0);
   return Result;
  }
 };
}


 template<typename genType>
 inline genType length(genType x)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'length' accepts only floating-point inputs");

  return abs(x);
 }

 template<length_t L, typename T, qualifier Q>
 inline T length(vec<L, T, Q> const& v)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'length' accepts only floating-point inputs");

  return detail::compute_length<L, T, Q, detail::is_aligned<Q>::value>::call(v);
 }


 template<typename genType>
 inline genType distance(genType const& p0, genType const& p1)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'distance' accepts only floating-point inputs");

  return length(p1 - p0);
 }

 template<length_t L, typename T, qualifier Q>
 inline T distance(vec<L, T, Q> const& p0, vec<L, T, Q> const& p1)
 {
  return detail::compute_distance<L, T, Q, detail::is_aligned<Q>::value>::call(p0, p1);
 }


 template<typename T>
 inline constexpr T dot(T x, T y)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'dot' accepts only floating-point inputs");
  return x * y;
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr T dot(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'dot' accepts only floating-point inputs");
  return detail::compute_dot<vec<L, T, Q>, T, detail::is_aligned<Q>::value>::call(x, y);
 }


 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> cross(vec<3, T, Q> const& x, vec<3, T, Q> const& y)
 {
  return detail::compute_cross<T, Q, detail::is_aligned<Q>::value>::call(x, y);
 }
# 189 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/func_geometric.inl"
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> normalize(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'normalize' accepts only floating-point inputs");

  return detail::compute_normalize<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }


 template<typename genType>
 inline genType faceforward(genType const& N, genType const& I, genType const& Nref)
 {
  return dot(Nref, I) < static_cast<genType>(0) ? N : -N;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> faceforward(vec<L, T, Q> const& N, vec<L, T, Q> const& I, vec<L, T, Q> const& Nref)
 {
  return detail::compute_faceforward<L, T, Q, detail::is_aligned<Q>::value>::call(N, I, Nref);
 }


 template<typename genType>
 inline genType reflect(genType const& I, genType const& N)
 {
  return I - N * dot(N, I) * genType(2);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> reflect(vec<L, T, Q> const& I, vec<L, T, Q> const& N)
 {
  return detail::compute_reflect<L, T, Q, detail::is_aligned<Q>::value>::call(I, N);
 }


 template<typename genType>
 inline genType refract(genType const& I, genType const& N, genType eta)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'refract' accepts only floating-point inputs");
  genType const dotValue(dot(N, I));
  genType const k(static_cast<genType>(1) - eta * eta * (static_cast<genType>(1) - dotValue * dotValue));
  return (eta * I - (eta * dotValue + sqrt(k)) * N) * static_cast<genType>(k >= static_cast<genType>(0));
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> refract(vec<L, T, Q> const& I, vec<L, T, Q> const& N, T eta)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'refract' accepts only floating-point inputs");
  return detail::compute_refract<L, T, Q, detail::is_aligned<Q>::value>::call(I, N, eta);
 }
}
# 117 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/geometric.hpp" 2
# 2 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/func_matrix.inl" 2


namespace glm{
namespace detail
{
 template<length_t C, length_t R, typename T, qualifier Q, bool Aligned>
 struct compute_matrixCompMult
 {
  inline static mat<C, R, T, Q> call(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y)
  {
   mat<C, R, T, Q> Result(1);
   for(length_t i = 0; i < Result.length(); ++i)
    Result[i] = x[i] * y[i];
   return Result;
  }
 };

 template<length_t C, length_t R, typename T, qualifier Q, bool IsFloat, bool Aligned>
 struct compute_matrixCompMult_type {
  inline static mat<C, R, T, Q> call(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y)
  {
   static_assert(std::numeric_limits<T>::is_iec559 || 0, "'matrixCompMult' only accept floating-point inputs, include <glm/ext/matrix_integer.hpp> to discard this restriction.")
                                                                                                                            ;
   return detail::compute_matrixCompMult<C, R, T, Q, detail::is_aligned<Q>::value>::call(x, y);
  }
 };

 template<length_t DA, length_t DB, typename T, qualifier Q>
 struct compute_outerProduct {
  inline static typename detail::outerProduct_trait<DA, DB, T, Q>::type call(vec<DA, T, Q> const& c, vec<DB, T, Q> const& r)
  {
   typename detail::outerProduct_trait<DA, DB, T, Q>::type m(0);
   for(length_t i = 0; i < m.length(); ++i)
    m[i] = c * r[i];
   return m;
  }
 };

 template<length_t DA, length_t DB, typename T, qualifier Q, bool IsFloat>
 struct compute_outerProduct_type {
  inline static typename detail::outerProduct_trait<DA, DB, T, Q>::type call(vec<DA, T, Q> const& c, vec<DB, T, Q> const& r)
  {
   static_assert(std::numeric_limits<T>::is_iec559 || 0, "'outerProduct' only accept floating-point inputs, include <glm/ext/matrix_integer.hpp> to discard this restriction.")
                                                                                                                          ;

   return detail::compute_outerProduct<DA, DB, T, Q>::call(c, r);
  }
 };

 template<length_t C, length_t R, typename T, qualifier Q, bool Aligned>
 struct compute_transpose{};

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<2, 2, T, Q, Aligned>
 {
  inline static mat<2, 2, T, Q> call(mat<2, 2, T, Q> const& m)
  {
   mat<2, 2, T, Q> Result(1);
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   return Result;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<2, 3, T, Q, Aligned>
 {
  inline static mat<3, 2, T, Q> call(mat<2, 3, T, Q> const& m)
  {
   mat<3,2, T, Q> Result(1);
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   Result[2][0] = m[0][2];
   Result[2][1] = m[1][2];
   return Result;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<2, 4, T, Q, Aligned>
 {
  inline static mat<4, 2, T, Q> call(mat<2, 4, T, Q> const& m)
  {
   mat<4, 2, T, Q> Result(1);
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   Result[2][0] = m[0][2];
   Result[2][1] = m[1][2];
   Result[3][0] = m[0][3];
   Result[3][1] = m[1][3];
   return Result;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<3, 2, T, Q, Aligned>
 {
  inline static mat<2, 3, T, Q> call(mat<3, 2, T, Q> const& m)
  {
   mat<2, 3, T, Q> Result(1);
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[0][2] = m[2][0];
   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   Result[1][2] = m[2][1];
   return Result;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<3, 3, T, Q, Aligned>
 {
  inline static mat<3, 3, T, Q> call(mat<3, 3, T, Q> const& m)
  {
   mat<3, 3, T, Q> Result(1);
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[0][2] = m[2][0];

   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   Result[1][2] = m[2][1];

   Result[2][0] = m[0][2];
   Result[2][1] = m[1][2];
   Result[2][2] = m[2][2];
   return Result;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<3, 4, T, Q, Aligned>
 {
  inline static mat<4, 3, T, Q> call(mat<3, 4, T, Q> const& m)
  {
   mat<4, 3, T, Q> Result(1);
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[0][2] = m[2][0];
   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   Result[1][2] = m[2][1];
   Result[2][0] = m[0][2];
   Result[2][1] = m[1][2];
   Result[2][2] = m[2][2];
   Result[3][0] = m[0][3];
   Result[3][1] = m[1][3];
   Result[3][2] = m[2][3];
   return Result;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<4, 2, T, Q, Aligned>
 {
  inline static mat<2, 4, T, Q> call(mat<4, 2, T, Q> const& m)
  {
   mat<2, 4, T, Q> Result(1);
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[0][2] = m[2][0];
   Result[0][3] = m[3][0];
   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   Result[1][2] = m[2][1];
   Result[1][3] = m[3][1];
   return Result;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<4, 3, T, Q, Aligned>
 {
  inline static mat<3, 4, T, Q> call(mat<4, 3, T, Q> const& m)
  {
   mat<3, 4, T, Q> Result(1);
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[0][2] = m[2][0];
   Result[0][3] = m[3][0];
   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   Result[1][2] = m[2][1];
   Result[1][3] = m[3][1];
   Result[2][0] = m[0][2];
   Result[2][1] = m[1][2];
   Result[2][2] = m[2][2];
   Result[2][3] = m[3][2];
   return Result;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<4, 4, T, Q, Aligned>
 {
  inline static mat<4, 4, T, Q> call(mat<4, 4, T, Q> const& m)
  {
   mat<4, 4, T, Q> Result(1);
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[0][2] = m[2][0];
   Result[0][3] = m[3][0];

   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   Result[1][2] = m[2][1];
   Result[1][3] = m[3][1];

   Result[2][0] = m[0][2];
   Result[2][1] = m[1][2];
   Result[2][2] = m[2][2];
   Result[2][3] = m[3][2];

   Result[3][0] = m[0][3];
   Result[3][1] = m[1][3];
   Result[3][2] = m[2][3];
   Result[3][3] = m[3][3];
   return Result;
  }
 };

 template<length_t C, length_t R, typename T, qualifier Q, bool IsFloat, bool Aligned>
 struct compute_transpose_type {
  inline static mat<R, C, T, Q> call(mat<C, R, T, Q> const& m)
  {
   static_assert(std::numeric_limits<T>::is_iec559 || 0, "'transpose' only accept floating-point inputs, include <glm/ext/matrix_integer.hpp> to discard this restriction.")
                                                                                                                       ;
   return detail::compute_transpose<C, R, T, Q, detail::is_aligned<Q>::value>::call(m);
  }
 };

 template<length_t C, length_t R, typename T, qualifier Q, bool Aligned>
 struct compute_determinant{};

 template<typename T, qualifier Q, bool Aligned>
 struct compute_determinant<2, 2, T, Q, Aligned>
 {
  inline static T call(mat<2, 2, T, Q> const& m)
  {
   return m[0][0] * m[1][1] - m[1][0] * m[0][1];
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_determinant<3, 3, T, Q, Aligned>
 {
  inline static T call(mat<3, 3, T, Q> const& m)
  {
   return
    + m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])
    - m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])
    + m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_determinant<4, 4, T, Q, Aligned>
 {
  inline static T call(mat<4, 4, T, Q> const& m)
  {
   T SubFactor00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
   T SubFactor01 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
   T SubFactor02 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
   T SubFactor03 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
   T SubFactor04 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
   T SubFactor05 = m[2][0] * m[3][1] - m[3][0] * m[2][1];

   vec<4, T, Q> DetCof(
    + (m[1][1] * SubFactor00 - m[1][2] * SubFactor01 + m[1][3] * SubFactor02),
    - (m[1][0] * SubFactor00 - m[1][2] * SubFactor03 + m[1][3] * SubFactor04),
    + (m[1][0] * SubFactor01 - m[1][1] * SubFactor03 + m[1][3] * SubFactor05),
    - (m[1][0] * SubFactor02 - m[1][1] * SubFactor04 + m[1][2] * SubFactor05));

   return
    m[0][0] * DetCof[0] + m[0][1] * DetCof[1] +
    m[0][2] * DetCof[2] + m[0][3] * DetCof[3];
  }
 };

 template<length_t C, length_t R, typename T, qualifier Q, bool IsFloat, bool Aligned>
 struct compute_determinant_type{

  inline static T call(mat<C, R, T, Q> const& m)
  {
   static_assert(std::numeric_limits<T>::is_iec559 || 0, "'determinant' only accept floating-point inputs, include <glm/ext/matrix_integer.hpp> to discard this restriction.")
                                                                                                                         ;
   return detail::compute_determinant<C, R, T, Q, detail::is_aligned<Q>::value>::call(m);
  }
 };

 template<length_t C, length_t R, typename T, qualifier Q, bool Aligned>
 struct compute_inverse{};

 template<typename T, qualifier Q, bool Aligned>
 struct compute_inverse<2, 2, T, Q, Aligned>
 {
  inline static mat<2, 2, T, Q> call(mat<2, 2, T, Q> const& m)
  {
   T OneOverDeterminant = static_cast<T>(1) / (
    + m[0][0] * m[1][1]
    - m[1][0] * m[0][1]);

   mat<2, 2, T, Q> Inverse(
    + m[1][1] * OneOverDeterminant,
    - m[0][1] * OneOverDeterminant,
    - m[1][0] * OneOverDeterminant,
    + m[0][0] * OneOverDeterminant);

   return Inverse;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_inverse<3, 3, T, Q, Aligned>
 {
  inline static mat<3, 3, T, Q> call(mat<3, 3, T, Q> const& m)
  {
   T OneOverDeterminant = static_cast<T>(1) / (
    + m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])
    - m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])
    + m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]));

   mat<3, 3, T, Q> Inverse;
   Inverse[0][0] = + (m[1][1] * m[2][2] - m[2][1] * m[1][2]) * OneOverDeterminant;
   Inverse[1][0] = - (m[1][0] * m[2][2] - m[2][0] * m[1][2]) * OneOverDeterminant;
   Inverse[2][0] = + (m[1][0] * m[2][1] - m[2][0] * m[1][1]) * OneOverDeterminant;
   Inverse[0][1] = - (m[0][1] * m[2][2] - m[2][1] * m[0][2]) * OneOverDeterminant;
   Inverse[1][1] = + (m[0][0] * m[2][2] - m[2][0] * m[0][2]) * OneOverDeterminant;
   Inverse[2][1] = - (m[0][0] * m[2][1] - m[2][0] * m[0][1]) * OneOverDeterminant;
   Inverse[0][2] = + (m[0][1] * m[1][2] - m[1][1] * m[0][2]) * OneOverDeterminant;
   Inverse[1][2] = - (m[0][0] * m[1][2] - m[1][0] * m[0][2]) * OneOverDeterminant;
   Inverse[2][2] = + (m[0][0] * m[1][1] - m[1][0] * m[0][1]) * OneOverDeterminant;

   return Inverse;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_inverse<4, 4, T, Q, Aligned>
 {
  inline static mat<4, 4, T, Q> call(mat<4, 4, T, Q> const& m)
  {
   T Coef00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
   T Coef02 = m[1][2] * m[3][3] - m[3][2] * m[1][3];
   T Coef03 = m[1][2] * m[2][3] - m[2][2] * m[1][3];

   T Coef04 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
   T Coef06 = m[1][1] * m[3][3] - m[3][1] * m[1][3];
   T Coef07 = m[1][1] * m[2][3] - m[2][1] * m[1][3];

   T Coef08 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
   T Coef10 = m[1][1] * m[3][2] - m[3][1] * m[1][2];
   T Coef11 = m[1][1] * m[2][2] - m[2][1] * m[1][2];

   T Coef12 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
   T Coef14 = m[1][0] * m[3][3] - m[3][0] * m[1][3];
   T Coef15 = m[1][0] * m[2][3] - m[2][0] * m[1][3];

   T Coef16 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
   T Coef18 = m[1][0] * m[3][2] - m[3][0] * m[1][2];
   T Coef19 = m[1][0] * m[2][2] - m[2][0] * m[1][2];

   T Coef20 = m[2][0] * m[3][1] - m[3][0] * m[2][1];
   T Coef22 = m[1][0] * m[3][1] - m[3][0] * m[1][1];
   T Coef23 = m[1][0] * m[2][1] - m[2][0] * m[1][1];

   vec<4, T, Q> Fac0(Coef00, Coef00, Coef02, Coef03);
   vec<4, T, Q> Fac1(Coef04, Coef04, Coef06, Coef07);
   vec<4, T, Q> Fac2(Coef08, Coef08, Coef10, Coef11);
   vec<4, T, Q> Fac3(Coef12, Coef12, Coef14, Coef15);
   vec<4, T, Q> Fac4(Coef16, Coef16, Coef18, Coef19);
   vec<4, T, Q> Fac5(Coef20, Coef20, Coef22, Coef23);

   vec<4, T, Q> Vec0(m[1][0], m[0][0], m[0][0], m[0][0]);
   vec<4, T, Q> Vec1(m[1][1], m[0][1], m[0][1], m[0][1]);
   vec<4, T, Q> Vec2(m[1][2], m[0][2], m[0][2], m[0][2]);
   vec<4, T, Q> Vec3(m[1][3], m[0][3], m[0][3], m[0][3]);

   vec<4, T, Q> Inv0(Vec1 * Fac0 - Vec2 * Fac1 + Vec3 * Fac2);
   vec<4, T, Q> Inv1(Vec0 * Fac0 - Vec2 * Fac3 + Vec3 * Fac4);
   vec<4, T, Q> Inv2(Vec0 * Fac1 - Vec1 * Fac3 + Vec3 * Fac5);
   vec<4, T, Q> Inv3(Vec0 * Fac2 - Vec1 * Fac4 + Vec2 * Fac5);

   vec<4, T, Q> SignA(+1, -1, +1, -1);
   vec<4, T, Q> SignB(-1, +1, -1, +1);
   mat<4, 4, T, Q> Inverse(Inv0 * SignA, Inv1 * SignB, Inv2 * SignA, Inv3 * SignB);

   vec<4, T, Q> Row0(Inverse[0][0], Inverse[1][0], Inverse[2][0], Inverse[3][0]);

   vec<4, T, Q> Dot0(m[0] * Row0);
   T Dot1 = (Dot0.x + Dot0.y) + (Dot0.z + Dot0.w);

   T OneOverDeterminant = static_cast<T>(1) / Dot1;

   return Inverse * OneOverDeterminant;
  }
 };
}

 template<length_t C, length_t R, typename T, qualifier Q>
 inline mat<C, R, T, Q> matrixCompMult(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y)
 {
  return detail::compute_matrixCompMult_type<C, R, T, Q, std::numeric_limits<T>::is_iec559, detail::is_aligned<Q>::value>::call(x, y);
 }

 template<length_t DA, length_t DB, typename T, qualifier Q>
 inline typename detail::outerProduct_trait<DA, DB, T, Q>::type outerProduct(vec<DA, T, Q> const& c, vec<DB, T, Q> const& r)
 {
  return detail::compute_outerProduct_type<DA, DB, T, Q, std::numeric_limits<T>::is_iec559>::call(c, r);
 }

 template<length_t C, length_t R, typename T, qualifier Q>
 inline typename mat<C, R, T, Q>::transpose_type transpose(mat<C, R, T, Q> const& m)
 {
  return detail::compute_transpose_type<C, R, T, Q, std::numeric_limits<T>::is_iec559, detail::is_aligned<Q>::value>::call(m);
 }

 template<length_t C, length_t R, typename T, qualifier Q>
 inline T determinant(mat<C, R, T, Q> const& m)
 {
  return detail::compute_determinant_type<C, R, T, Q, std::numeric_limits<T>::is_iec559, detail::is_aligned<Q>::value>::call(m);
 }

 template<length_t C, length_t R, typename T, qualifier Q>
 inline mat<C, R, T, Q> inverse(mat<C, R, T, Q> const& m)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'inverse' only accept floating-point inputs");
  return detail::compute_inverse<C, R, T, Q, detail::is_aligned<Q>::value>::call(m);
 }
}
# 162 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/matrix.hpp" 2
# 2 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat2x2.inl" 2

namespace glm
{
# 21 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat2x2.inl"
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr mat<2, 2, T, Q>::mat(mat<2, 2, T, P> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q>::mat(T scalar)

   : value{col_type(scalar, 0), col_type(0, scalar)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q>::mat
 (
  T const& x0, T const& y0,
  T const& x1, T const& y1
 )

   : value{col_type(x0, y0), col_type(x1, y1)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q>::mat(col_type const& v0, col_type const& v1)

   : value{v0, v1}

 {




 }



 template<typename T, qualifier Q>
 template<typename X1, typename Y1, typename X2, typename Y2>
 inline constexpr mat<2, 2, T, Q>::mat
 (
  X1 const& x1, Y1 const& y1,
  X2 const& x2, Y2 const& y2
 )

   : value{col_type(static_cast<T>(x1), value_type(y1)), col_type(static_cast<T>(x2), value_type(y2)) }

 {




 }

 template<typename T, qualifier Q>
 template<typename V1, typename V2>
 inline constexpr mat<2, 2, T, Q>::mat(vec<2, V1, Q> const& v1, vec<2, V2, Q> const& v2)

   : value{col_type(v1), col_type(v2)}

 {




 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr mat<2, 2, T, Q>::mat(mat<2, 2, U, P> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q>::mat(mat<3, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q>::mat(mat<4, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q>::mat(mat<2, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q>::mat(mat<3, 2, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q>::mat(mat<2, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q>::mat(mat<4, 2, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q>::mat(mat<3, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q>::mat(mat<4, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }



 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 2, T, Q>::col_type& mat<2, 2, T, Q>::operator[](typename mat<2, 2, T, Q>::length_type i) noexcept
 {
  (
# 222 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat2x2.inl" 3
 ((void)0)
# 222 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat2x2.inl"
 );
  return this->value[i];
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 2, T, Q>::col_type const& mat<2, 2, T, Q>::operator[](typename mat<2, 2, T, Q>::length_type i) const noexcept
 {
  (
# 229 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat2x2.inl" 3
 ((void)0)
# 229 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat2x2.inl"
 );
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator=(mat<2, 2, U, Q> const& m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator+=(U scalar)
 {
  this->value[0] += scalar;
  this->value[1] += scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator+=(mat<2, 2, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator-=(U scalar)
 {
  this->value[0] -= scalar;
  this->value[1] -= scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator-=(mat<2, 2, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator*=(U scalar)
 {
  this->value[0] *= scalar;
  this->value[1] *= scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator*=(mat<2, 2, U, Q> const& m)
 {
  return (*this = *this * m);
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator/=(U scalar)
 {
  this->value[0] /= scalar;
  this->value[1] /= scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator/=(mat<2, 2, U, Q> const& m)
 {
  return *this *= inverse(m);
 }



 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> mat<2, 2, T, Q>::operator++(int)
 {
  mat<2, 2, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> mat<2, 2, T, Q>::operator--(int)
 {
  mat<2, 2, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m)
 {
  return mat<2, 2, T, Q>(
   -m[0],
   -m[1]);
 }



 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m, T scalar)
 {
  return mat<2, 2, T, Q>(
   m[0] + scalar,
   m[1] + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator+(T scalar, mat<2, 2, T, Q> const& m)
 {
  return mat<2, 2, T, Q>(
   m[0] + scalar,
   m[1] + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
 {
  return mat<2, 2, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m, T scalar)
 {
  return mat<2, 2, T, Q>(
   m[0] - scalar,
   m[1] - scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator-(T scalar, mat<2, 2, T, Q> const& m)
 {
  return mat<2, 2, T, Q>(
   scalar - m[0],
   scalar - m[1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
 {
  return mat<2, 2, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator*(mat<2, 2, T, Q> const& m, T scalar)
 {
  return mat<2, 2, T, Q>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator*(T scalar, mat<2, 2, T, Q> const& m)
 {
  return mat<2, 2, T, Q>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 2, T, Q>::col_type operator*
 (
  mat<2, 2, T, Q> const& m,
  typename mat<2, 2, T, Q>::row_type const& v
 )
 {
  return vec<2, T, Q>(
   m[0][0] * v.x + m[1][0] * v.y,
   m[0][1] * v.x + m[1][1] * v.y);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 2, T, Q>::row_type operator*
 (
  typename mat<2, 2, T, Q>::col_type const& v,
  mat<2, 2, T, Q> const& m
 )
 {
  return vec<2, T, Q>(
   v.x * m[0][0] + v.y * m[0][1],
   v.x * m[1][0] + v.y * m[1][1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
 {
  return mat<2, 2, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
 {
  return mat<3, 2, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
 {
  return mat<4, 2, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator/(mat<2, 2, T, Q> const& m, T scalar)
 {
  return mat<2, 2, T, Q>(
   m[0] / scalar,
   m[1] / scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator/(T scalar, mat<2, 2, T, Q> const& m)
 {
  return mat<2, 2, T, Q>(
   scalar / m[0],
   scalar / m[1]);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 2, T, Q>::col_type operator/(mat<2, 2, T, Q> const& m, typename mat<2, 2, T, Q>::row_type const& v)
 {
  return inverse(m) * v;
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 2, T, Q>::row_type operator/(typename mat<2, 2, T, Q>::col_type const& v, mat<2, 2, T, Q> const& m)
 {
  return v * inverse(m);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator/(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
 {
  mat<2, 2, T, Q> m1_copy(m1);
  return m1_copy /= m2;
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]);
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]);
 }
}
# 177 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_mat2x2.hpp" 2
# 6 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_double2x2.hpp" 2

namespace glm
{






 typedef mat<2, 2, double, defaultp> dmat2x2;




 typedef mat<2, 2, double, defaultp> dmat2;


}
# 6 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat2x2.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_double2x2_precision.hpp" 1



       


namespace glm
{







 typedef mat<2, 2, double, lowp> lowp_dmat2;





 typedef mat<2, 2, double, mediump> mediump_dmat2;





 typedef mat<2, 2, double, highp> highp_dmat2;





 typedef mat<2, 2, double, lowp> lowp_dmat2x2;





 typedef mat<2, 2, double, mediump> mediump_dmat2x2;





 typedef mat<2, 2, double, highp> highp_dmat2x2;


}
# 7 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat2x2.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_float2x2.hpp" 1



       


namespace glm
{






 typedef mat<2, 2, float, defaultp> mat2x2;




 typedef mat<2, 2, float, defaultp> mat2;


}
# 8 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat2x2.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_float2x2_precision.hpp" 1



       


namespace glm
{







 typedef mat<2, 2, float, lowp> lowp_mat2;





 typedef mat<2, 2, float, mediump> mediump_mat2;





 typedef mat<2, 2, float, highp> highp_mat2;





 typedef mat<2, 2, float, lowp> lowp_mat2x2;





 typedef mat<2, 2, float, mediump> mediump_mat2x2;





 typedef mat<2, 2, float, highp> highp_mat2x2;


}
# 9 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/mat2x2.hpp" 2
# 121 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/glm.hpp" 2
# 130 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/glm.hpp"
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/trigonometric.hpp" 1
# 19 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/trigonometric.hpp"
       

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/setup.hpp" 1
# 22 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/trigonometric.hpp" 2


namespace glm
{
# 37 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, T, Q> radians(vec<L, T, Q> const& degrees);
# 48 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, T, Q> degrees(vec<L, T, Q> const& radians);
# 60 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> sin(vec<L, T, Q> const& angle);
# 72 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> cos(vec<L, T, Q> const& angle);
# 83 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> tan(vec<L, T, Q> const& angle);
# 96 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> asin(vec<L, T, Q> const& x);
# 109 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> acos(vec<L, T, Q> const& x);
# 124 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> atan(vec<L, T, Q> const& y, vec<L, T, Q> const& x);
# 136 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> atan(vec<L, T, Q> const& y_over_x);
# 147 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> sinh(vec<L, T, Q> const& angle);
# 158 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> cosh(vec<L, T, Q> const& angle);
# 169 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> tanh(vec<L, T, Q> const& angle);
# 180 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> asinh(vec<L, T, Q> const& x);
# 192 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> acosh(vec<L, T, Q> const& x);
# 204 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> atanh(vec<L, T, Q> const& x);


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/func_trigonometric.inl" 1

# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 1 3
# 39 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 3
       
# 40 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 3
# 3 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/func_trigonometric.inl" 2


namespace glm
{

 template<typename genType>
 inline constexpr genType radians(genType degrees)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'radians' only accept floating-point input");

  return degrees * static_cast<genType>(0.01745329251994329576923690768489);
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, T, Q> radians(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(radians, v);
 }


 template<typename genType>
 inline constexpr genType degrees(genType radians)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'degrees' only accept floating-point input");

  return radians * static_cast<genType>(57.295779513082320876798154814105);
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, T, Q> degrees(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(degrees, v);
 }


 using ::std::sin;

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> sin(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(sin, v);
 }


 using std::cos;

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> cos(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(cos, v);
 }


 using std::tan;

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> tan(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(tan, v);
 }


 using std::asin;

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> asin(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(asin, v);
 }


 using std::acos;

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> acos(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(acos, v);
 }


 template<typename genType>
 inline genType atan(genType y, genType x)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'atan' only accept floating-point input");

  return ::std::atan2(y, x);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> atan(vec<L, T, Q> const& y, vec<L, T, Q> const& x)
 {
  return detail::functor2<vec, L, T, Q>::call(::std::atan2, y, x);
 }

 using std::atan;

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> atan(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(atan, v);
 }


 using std::sinh;

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> sinh(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(sinh, v);
 }


 using std::cosh;

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> cosh(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(cosh, v);
 }


 using std::tanh;

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> tanh(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(tanh, v);
 }



  using std::asinh;
# 145 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/func_trigonometric.inl"
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> asinh(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(asinh, v);
 }



  using std::acosh;
# 166 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/func_trigonometric.inl"
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> acosh(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(acosh, v);
 }



  using std::atanh;
# 187 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/func_trigonometric.inl"
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> atanh(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(atanh, v);
 }
}
# 211 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/trigonometric.hpp" 2
# 131 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/glm.hpp" 2


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/packing.hpp" 1
# 16 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/packing.hpp"
       





namespace glm
{
# 38 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/packing.hpp"
 [[nodiscard]] uint packUnorm2x16(vec2 const& v);
# 51 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/packing.hpp"
 [[nodiscard]] uint packSnorm2x16(vec2 const& v);
# 64 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/packing.hpp"
 [[nodiscard]] uint packUnorm4x8(vec4 const& v);
# 77 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/packing.hpp"
 [[nodiscard]] uint packSnorm4x8(vec4 const& v);
# 90 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/packing.hpp"
 [[nodiscard]] vec2 unpackUnorm2x16(uint p);
# 103 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/packing.hpp"
 [[nodiscard]] vec2 unpackSnorm2x16(uint p);
# 116 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/packing.hpp"
 [[nodiscard]] vec4 unpackUnorm4x8(uint p);
# 129 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/packing.hpp"
 [[nodiscard]] vec4 unpackSnorm4x8(uint p);
# 139 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/packing.hpp"
 [[nodiscard]] double packDouble2x32(uvec2 const& v);
# 148 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/packing.hpp"
 [[nodiscard]] uvec2 unpackDouble2x32(double v);
# 158 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/packing.hpp"
 [[nodiscard]] uint packHalf2x16(vec2 const& v);
# 168 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/packing.hpp"
 [[nodiscard]] vec2 unpackHalf2x16(uint v);


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/func_packing.inl" 1




# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_half.hpp" 1
       

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/setup.hpp" 1
# 4 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_half.hpp" 2

namespace glm{
namespace detail
{
 typedef short hdata;

 [[nodiscard]] float toFloat32(hdata value);
 [[nodiscard]] hdata toFloat16(float const& value);

}
}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_half.inl" 1
namespace glm{
namespace detail
{
 inline float overflow()
 {
  volatile float f = 1e10;

  for(int i = 0; i < 10; ++i)
   f = f * f;
  return f;
 }

 union uif32
 {
  inline uif32() :
   i(0)
  {}

  inline uif32(float f_) :
   f(f_)
  {}

  inline uif32(unsigned int i_) :
   i(i_)
  {}

  float f;
  unsigned int i;
 };

 inline float toFloat32(hdata value)
 {
  int s = (value >> 15) & 0x00000001;
  int e = (value >> 10) & 0x0000001f;
  int m = value & 0x000003ff;

  if(e == 0)
  {
   if(m == 0)
   {




    detail::uif32 result;
    result.i = static_cast<unsigned int>(s << 31);
    return result.f;
   }
   else
   {




    while(!(m & 0x00000400))
    {
     m <<= 1;
     e -= 1;
    }

    e += 1;
    m &= ~0x00000400;
   }
  }
  else if(e == 31)
  {
   if(m == 0)
   {




    uif32 result;
    result.i = static_cast<unsigned int>((s << 31) | 0x7f800000);
    return result.f;
   }
   else
   {




    uif32 result;
    result.i = static_cast<unsigned int>((s << 31) | 0x7f800000 | (m << 13));
    return result.f;
   }
  }





  e = e + (127 - 15);
  m = m << 13;





  uif32 Result;
  Result.i = static_cast<unsigned int>((s << 31) | (e << 23) | m);
  return Result.f;
 }

 inline hdata toFloat16(float const& f)
 {
  uif32 Entry;
  Entry.f = f;
  int i = static_cast<int>(Entry.i);
# 121 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_half.inl"
  int s = (i >> 16) & 0x00008000;
  int e = ((i >> 23) & 0x000000ff) - (127 - 15);
  int m = i & 0x007fffff;





  if(e <= 0)
  {
   if(e < -10)
   {
# 141 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_half.inl"
    return hdata(s);
   }
# 151 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_half.inl"
   m = (m | 0x00800000) >> (1 - e);
# 162 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_half.inl"
   if(m & 0x00001000)
    m += 0x00002000;





   return hdata(s | (m >> 13));
  }
  else if(e == 0xff - (127 - 15))
  {
   if(m == 0)
   {





    return hdata(s | 0x7c00);
   }
   else
   {
# 193 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_half.inl"
    m >>= 13;

    return hdata(s | 0x7c00 | m | (m == 0));
   }
  }
  else
  {
# 209 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_half.inl"
   if(m & 0x00001000)
   {
    m += 0x00002000;

    if(m & 0x00800000)
    {
     m = 0;
     e += 1;
    }
   }





   if (e > 30)
   {
    overflow();

    return hdata(s | 0x7c00);

   }





   return hdata(s | (e << 10) | (m >> 13));
  }
 }

}
}
# 17 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_half.hpp" 2
# 6 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/func_packing.inl" 2

namespace glm
{
 inline uint packUnorm2x16(vec2 const& v)
 {
  union
  {
   unsigned short in[2];
   uint out;
  } u;

  vec<2, unsigned short, defaultp> result(round(clamp(v, 0.0f, 1.0f) * 65535.0f));

  u.in[0] = result[0];
  u.in[1] = result[1];

  return u.out;
 }

 inline vec2 unpackUnorm2x16(uint p)
 {
  union
  {
   uint in;
   unsigned short out[2];
  } u;

  u.in = p;

  return vec2(u.out[0], u.out[1]) * 1.5259021896696421759365224689097e-5f;
 }

 inline uint packSnorm2x16(vec2 const& v)
 {
  union
  {
   signed short in[2];
   uint out;
  } u;

  vec<2, short, defaultp> result(round(clamp(v, -1.0f, 1.0f) * 32767.0f));

  u.in[0] = result[0];
  u.in[1] = result[1];

  return u.out;
 }

 inline vec2 unpackSnorm2x16(uint p)
 {
  union
  {
   uint in;
   signed short out[2];
  } u;

  u.in = p;

  return clamp(vec2(u.out[0], u.out[1]) * 3.0518509475997192297128208258309e-5f, -1.0f, 1.0f);
 }

 inline uint packUnorm4x8(vec4 const& v)
 {
  union
  {
   unsigned char in[4];
   uint out;
  } u;

  vec<4, unsigned char, defaultp> result(round(clamp(v, 0.0f, 1.0f) * 255.0f));

  u.in[0] = result[0];
  u.in[1] = result[1];
  u.in[2] = result[2];
  u.in[3] = result[3];

  return u.out;
 }

 inline vec4 unpackUnorm4x8(uint p)
 {
  union
  {
   uint in;
   unsigned char out[4];
  } u;

  u.in = p;

  return vec4(u.out[0], u.out[1], u.out[2], u.out[3]) * 0.0039215686274509803921568627451f;
 }

 inline uint packSnorm4x8(vec4 const& v)
 {
  union
  {
   signed char in[4];
   uint out;
  } u;

  vec<4, signed char, defaultp> result(round(clamp(v, -1.0f, 1.0f) * 127.0f));

  u.in[0] = result[0];
  u.in[1] = result[1];
  u.in[2] = result[2];
  u.in[3] = result[3];

  return u.out;
 }

 inline glm::vec4 unpackSnorm4x8(uint p)
 {
  union
  {
   uint in;
   signed char out[4];
  } u;

  u.in = p;

  return clamp(vec4(u.out[0], u.out[1], u.out[2], u.out[3]) * 0.0078740157480315f, -1.0f, 1.0f);
 }

 inline double packDouble2x32(uvec2 const& v)
 {
  union
  {
   uint in[2];
   double out;
  } u;

  u.in[0] = v[0];
  u.in[1] = v[1];

  return u.out;
 }

 inline uvec2 unpackDouble2x32(double v)
 {
  union
  {
   double in;
   uint out[2];
  } u;

  u.in = v;

  return uvec2(u.out[0], u.out[1]);
 }

 inline uint packHalf2x16(vec2 const& v)
 {
  union
  {
   signed short in[2];
   uint out;
  } u;

  u.in[0] = detail::toFloat16(v.x);
  u.in[1] = detail::toFloat16(v.y);

  return u.out;
 }

 inline vec2 unpackHalf2x16(uint v)
 {
  union
  {
   uint in;
   signed short out[2];
  } u;

  u.in = v;

  return vec2(
   detail::toFloat32(u.out[0]),
   detail::toFloat32(u.out[1]));
 }
}
# 174 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/packing.hpp" 2
# 134 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/glm.hpp" 2



# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/integer.hpp" 1
# 17 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/integer.hpp"
       





namespace glm
{
# 36 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/integer.hpp"
 template<length_t L, qualifier Q>
 [[nodiscard]] vec<L, uint, Q> uaddCarry(
  vec<L, uint, Q> const& x,
  vec<L, uint, Q> const& y,
  vec<L, uint, Q> & carry);
# 50 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/integer.hpp"
 template<length_t L, qualifier Q>
 [[nodiscard]] vec<L, uint, Q> usubBorrow(
  vec<L, uint, Q> const& x,
  vec<L, uint, Q> const& y,
  vec<L, uint, Q> & borrow);
# 64 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/integer.hpp"
 template<length_t L, qualifier Q>
 void umulExtended(
  vec<L, uint, Q> const& x,
  vec<L, uint, Q> const& y,
  vec<L, uint, Q> & msb,
  vec<L, uint, Q> & lsb);
# 79 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/integer.hpp"
 template<length_t L, qualifier Q>
 void imulExtended(
  vec<L, int, Q> const& x,
  vec<L, int, Q> const& y,
  vec<L, int, Q> & msb,
  vec<L, int, Q> & lsb);
# 102 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/integer.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> bitfieldExtract(
  vec<L, T, Q> const& Value,
  int Offset,
  int Bits);
# 123 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/integer.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> bitfieldInsert(
  vec<L, T, Q> const& Base,
  vec<L, T, Q> const& Insert,
  int Offset,
  int Bits);
# 139 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/integer.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> bitfieldReverse(vec<L, T, Q> const& v);







 template<typename genType>
 [[nodiscard]] int bitCount(genType v);
# 158 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/integer.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, int, Q> bitCount(vec<L, T, Q> const& v);
# 169 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/integer.hpp"
 template<typename genIUType>
 [[nodiscard]] int findLSB(genIUType x);
# 181 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/integer.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, int, Q> findLSB(vec<L, T, Q> const& v);
# 193 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/integer.hpp"
 template<typename genIUType>
 [[nodiscard]] int findMSB(genIUType x);
# 206 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/integer.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, int, Q> findMSB(vec<L, T, Q> const& v);


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/func_integer.inl" 1
# 21 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/func_integer.inl"
namespace glm{
namespace detail
{
 template<typename T>
 inline T mask(T Bits)
 {
  return Bits >= static_cast<T>(sizeof(T) * 8) ? ~static_cast<T>(0) : (static_cast<T>(1) << Bits) - static_cast<T>(1);
 }

 template<length_t L, typename T, qualifier Q, bool Aligned, bool EXEC>
 struct compute_bitfieldReverseStep
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& v, T, T)
  {
   return v;
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_bitfieldReverseStep<L, T, Q, Aligned, true>
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& v, T Mask, T Shift)
  {
   return (v & Mask) << Shift | (v & (~Mask)) >> Shift;
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned, bool EXEC>
 struct compute_bitfieldBitCountStep
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& v, T, T)
  {
   return v;
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_bitfieldBitCountStep<L, T, Q, Aligned, true>
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& v, T Mask, T Shift)
  {
   return (v & Mask) + ((v >> Shift) & Mask);
  }
 };

 template<typename genIUType, size_t Bits>
 struct compute_findLSB
 {
  inline static int call(genIUType Value)
  {
   if(Value == 0)
    return -1;

   return glm::bitCount(~Value & (Value - static_cast<genIUType>(1)));
  }
 };
# 104 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/func_integer.inl"
 template<length_t L, typename T, qualifier Q, bool EXEC = true>
 struct compute_findMSB_step_vec
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x, T Shift)
  {
   return x | (x >> Shift);
  }
 };

 template<length_t L, typename T, qualifier Q>
 struct compute_findMSB_step_vec<L, T, Q, false>
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x, T)
  {
   return x;
  }
 };

 template<length_t L, typename T, qualifier Q, int>
 struct compute_findMSB_vec
 {
  inline static vec<L, int, Q> call(vec<L, T, Q> const& v)
  {
   vec<L, T, Q> x(v);
   x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >= 8>::call(x, static_cast<T>( 1));
   x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >= 8>::call(x, static_cast<T>( 2));
   x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >= 8>::call(x, static_cast<T>( 4));
   x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >= 16>::call(x, static_cast<T>( 8));
   x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >= 32>::call(x, static_cast<T>(16));
   x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >= 64>::call(x, static_cast<T>(32));
   return vec<L, int, Q>(sizeof(T) * 8 - 1) - glm::bitCount(~x);
  }
 };
# 175 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/func_integer.inl"
}


 inline uint uaddCarry(uint const& x, uint const& y, uint & Carry)
 {
  detail::uint64 const Value64(static_cast<detail::uint64>(x) + static_cast<detail::uint64>(y));
  detail::uint64 const Max32((static_cast<detail::uint64>(1) << static_cast<detail::uint64>(32)) - static_cast<detail::uint64>(1));
  Carry = Value64 > Max32 ? 1u : 0u;
  return static_cast<uint>(Value64 % (Max32 + static_cast<detail::uint64>(1)));
 }

 template<length_t L, qualifier Q>
 inline vec<L, uint, Q> uaddCarry(vec<L, uint, Q> const& x, vec<L, uint, Q> const& y, vec<L, uint, Q>& Carry)
 {
  vec<L, detail::uint64, Q> Value64(vec<L, detail::uint64, Q>(x) + vec<L, detail::uint64, Q>(y));
  vec<L, detail::uint64, Q> Max32((static_cast<detail::uint64>(1) << static_cast<detail::uint64>(32)) - static_cast<detail::uint64>(1));
  Carry = mix(vec<L, uint, Q>(0), vec<L, uint, Q>(1), greaterThan(Value64, Max32));
  return vec<L, uint, Q>(Value64 % (Max32 + static_cast<detail::uint64>(1)));
 }


 inline uint usubBorrow(uint const& x, uint const& y, uint & Borrow)
 {
  Borrow = x >= y ? static_cast<uint>(0) : static_cast<uint>(1);
  if(y >= x)
   return y - x;
  else
   return static_cast<uint>((static_cast<detail::int64>(1) << static_cast<detail::int64>(32)) + (static_cast<detail::int64>(y) - static_cast<detail::int64>(x)));
 }

 template<length_t L, qualifier Q>
 inline vec<L, uint, Q> usubBorrow(vec<L, uint, Q> const& x, vec<L, uint, Q> const& y, vec<L, uint, Q>& Borrow)
 {
  Borrow = mix(vec<L, uint, Q>(1), vec<L, uint, Q>(0), greaterThanEqual(x, y));
  vec<L, uint, Q> const YgeX(y - x);
  vec<L, uint, Q> const XgeY(vec<L, uint, Q>((static_cast<detail::int64>(1) << static_cast<detail::int64>(32)) + (vec<L, detail::int64, Q>(y) - vec<L, detail::int64, Q>(x))));
  return mix(XgeY, YgeX, greaterThanEqual(y, x));
 }


 inline void umulExtended(uint const& x, uint const& y, uint & msb, uint & lsb)
 {
  detail::uint64 Value64 = static_cast<detail::uint64>(x) * static_cast<detail::uint64>(y);
  msb = static_cast<uint>(Value64 >> static_cast<detail::uint64>(32));
  lsb = static_cast<uint>(Value64);
 }

 template<length_t L, qualifier Q>
 inline void umulExtended(vec<L, uint, Q> const& x, vec<L, uint, Q> const& y, vec<L, uint, Q>& msb, vec<L, uint, Q>& lsb)
 {
  vec<L, detail::uint64, Q> Value64(vec<L, detail::uint64, Q>(x) * vec<L, detail::uint64, Q>(y));
  msb = vec<L, uint, Q>(Value64 >> static_cast<detail::uint64>(32));
  lsb = vec<L, uint, Q>(Value64);
 }


 inline void imulExtended(int x, int y, int& msb, int& lsb)
 {
  detail::int64 Value64 = static_cast<detail::int64>(x) * static_cast<detail::int64>(y);
  msb = static_cast<int>(Value64 >> static_cast<detail::int64>(32));
  lsb = static_cast<int>(Value64);
 }

 template<length_t L, qualifier Q>
 inline void imulExtended(vec<L, int, Q> const& x, vec<L, int, Q> const& y, vec<L, int, Q>& msb, vec<L, int, Q>& lsb)
 {
  vec<L, detail::int64, Q> Value64(vec<L, detail::int64, Q>(x) * vec<L, detail::int64, Q>(y));
  lsb = vec<L, int, Q>(Value64 & static_cast<detail::int64>(0xFFFFFFFF));
  msb = vec<L, int, Q>((Value64 >> static_cast<detail::int64>(32)) & static_cast<detail::int64>(0xFFFFFFFF));
 }


 template<typename genIUType>
 inline genIUType bitfieldExtract(genIUType Value, int Offset, int Bits)
 {
  return bitfieldExtract(vec<1, genIUType>(Value), Offset, Bits).x;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> bitfieldExtract(vec<L, T, Q> const& Value, int Offset, int Bits)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'bitfieldExtract' only accept integer inputs");

  return (Value >> static_cast<T>(Offset)) & static_cast<T>(detail::mask(Bits));
 }


 template<typename genIUType>
 inline genIUType bitfieldInsert(genIUType const& Base, genIUType const& Insert, int Offset, int Bits)
 {
  static_assert(std::numeric_limits<genIUType>::is_integer, "'bitfieldInsert' only accept integer values");

  return bitfieldInsert(vec<1, genIUType>(Base), vec<1, genIUType>(Insert), Offset, Bits).x;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> bitfieldInsert(vec<L, T, Q> const& Base, vec<L, T, Q> const& Insert, int Offset, int Bits)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'bitfieldInsert' only accept integer values");

  T const Mask = detail::mask(static_cast<T>(Bits)) << Offset;
  return (Base & ~Mask) | ((Insert << static_cast<T>(Offset)) & Mask);
 }







 template<typename genIUType>
 inline genIUType bitfieldReverse(genIUType x)
 {
  static_assert(std::numeric_limits<genIUType>::is_integer, "'bitfieldReverse' only accept integer values");

  return bitfieldReverse(glm::vec<1, genIUType, glm::defaultp>(x)).x;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> bitfieldReverse(vec<L, T, Q> const& v)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'bitfieldReverse' only accept integer values");

  vec<L, T, Q> x(v);
  x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 2>::call(x, static_cast<T>(0x5555555555555555ull), static_cast<T>( 1));
  x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 4>::call(x, static_cast<T>(0x3333333333333333ull), static_cast<T>( 2));
  x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 8>::call(x, static_cast<T>(0x0F0F0F0F0F0F0F0Full), static_cast<T>( 4));
  x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 16>::call(x, static_cast<T>(0x00FF00FF00FF00FFull), static_cast<T>( 8));
  x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 32>::call(x, static_cast<T>(0x0000FFFF0000FFFFull), static_cast<T>(16));
  x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 64>::call(x, static_cast<T>(0x00000000FFFFFFFFull), static_cast<T>(32));
  return x;
 }






 template<typename genIUType>
 inline int bitCount(genIUType x)
 {
  static_assert(std::numeric_limits<genIUType>::is_integer, "'bitCount' only accept integer values");

  return bitCount(glm::vec<1, genIUType, glm::defaultp>(x)).x;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, int, Q> bitCount(vec<L, T, Q> const& v)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'bitCount' only accept integer values");






  vec<L, typename detail::make_unsigned<T>::type, Q> x(v);
  x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 2>::call(x, typename detail::make_unsigned<T>::type(0x5555555555555555ull), typename detail::make_unsigned<T>::type( 1));
  x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 4>::call(x, typename detail::make_unsigned<T>::type(0x3333333333333333ull), typename detail::make_unsigned<T>::type( 2));
  x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 8>::call(x, typename detail::make_unsigned<T>::type(0x0F0F0F0F0F0F0F0Full), typename detail::make_unsigned<T>::type( 4));
  x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 16>::call(x, typename detail::make_unsigned<T>::type(0x00FF00FF00FF00FFull), typename detail::make_unsigned<T>::type( 8));
  x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 32>::call(x, typename detail::make_unsigned<T>::type(0x0000FFFF0000FFFFull), typename detail::make_unsigned<T>::type(16));
  x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 64>::call(x, typename detail::make_unsigned<T>::type(0x00000000FFFFFFFFull), typename detail::make_unsigned<T>::type(32));
  return vec<L, int, Q>(x);




 }


 template<typename genIUType>
 inline int findLSB(genIUType Value)
 {
  static_assert(std::numeric_limits<genIUType>::is_integer, "'findLSB' only accept integer values");

  return detail::compute_findLSB<genIUType, sizeof(genIUType) * 8>::call(Value);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, int, Q> findLSB(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'findLSB' only accept integer values");

  return detail::functor1<vec, L, int, T, Q>::call(findLSB, x);
 }


 template<typename genIUType>
 inline int findMSB(genIUType v)
 {
  static_assert(std::numeric_limits<genIUType>::is_integer, "'findMSB' only accept integer values");

  return findMSB(vec<1, genIUType>(v)).x;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, int, Q> findMSB(vec<L, T, Q> const& v)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'findMSB' only accept integer values");

  return detail::compute_findMSB_vec<L, T, Q, static_cast<int>(sizeof(T) * 8)>::call(v);
 }
}
# 213 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/integer.hpp" 2
# 138 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/glm.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 1




# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/setup.hpp" 1
# 6 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2

       
# 16 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp"
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.hpp" 1
# 20 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.hpp"
       


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_constants.hpp" 1
# 11 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_constants.hpp"
       


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/setup.hpp" 1
# 15 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_constants.hpp" 2





namespace glm
{




 template<typename genType>
 [[nodiscard]] constexpr genType epsilon();


 template<typename genType>
 [[nodiscard]] constexpr genType pi();


 template<typename genType>
 [[nodiscard]] constexpr genType cos_one_over_two();


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_constants.inl" 1


namespace glm
{
 template<typename genType>
 inline constexpr genType epsilon()
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'epsilon' only accepts floating-point inputs");
  return std::numeric_limits<genType>::epsilon();
 }

 template<typename genType>
 inline constexpr genType pi()
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'pi' only accepts floating-point inputs");
  return static_cast<genType>(3.14159265358979323846264338327950288);
 }

 template<typename genType>
 inline constexpr genType cos_one_over_two()
 {
  return genType(0.877582561890372716130286068203503191);
 }
}
# 41 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_constants.hpp" 2
# 24 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.hpp" 2







namespace glm
{
# 42 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.hpp"
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> ortho(
  T left, T right, T bottom, T top);







 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> orthoLH_ZO(
  T left, T right, T bottom, T top, T zNear, T zFar);







 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> orthoLH_NO(
  T left, T right, T bottom, T top, T zNear, T zFar);







 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> orthoRH_ZO(
  T left, T right, T bottom, T top, T zNear, T zFar);







 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> orthoRH_NO(
  T left, T right, T bottom, T top, T zNear, T zFar);







 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> orthoZO(
  T left, T right, T bottom, T top, T zNear, T zFar);







 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> orthoNO(
  T left, T right, T bottom, T top, T zNear, T zFar);
# 113 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.hpp"
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> orthoLH(
  T left, T right, T bottom, T top, T zNear, T zFar);
# 124 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.hpp"
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> orthoRH(
  T left, T right, T bottom, T top, T zNear, T zFar);
# 135 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.hpp"
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> ortho(
  T left, T right, T bottom, T top, T zNear, T zFar);





 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> frustumLH_ZO(
  T left, T right, T bottom, T top, T near, T far);





 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> frustumLH_NO(
  T left, T right, T bottom, T top, T near, T far);





 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> frustumRH_ZO(
  T left, T right, T bottom, T top, T near, T far);





 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> frustumRH_NO(
  T left, T right, T bottom, T top, T near, T far);





 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> frustumZO(
  T left, T right, T bottom, T top, T near, T far);





 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> frustumNO(
  T left, T right, T bottom, T top, T near, T far);






 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> frustumLH(
  T left, T right, T bottom, T top, T near, T far);






 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> frustumRH(
  T left, T right, T bottom, T top, T near, T far);






 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> frustum(
  T left, T right, T bottom, T top, T near, T far);
# 224 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.hpp"
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveRH_ZO(
  T fovy, T aspect, T near, T far);
# 237 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.hpp"
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveRH_NO(
  T fovy, T aspect, T near, T far);
# 250 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.hpp"
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveLH_ZO(
  T fovy, T aspect, T near, T far);
# 263 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.hpp"
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveLH_NO(
  T fovy, T aspect, T near, T far);
# 276 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.hpp"
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveZO(
  T fovy, T aspect, T near, T far);
# 289 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.hpp"
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveNO(
  T fovy, T aspect, T near, T far);
# 303 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.hpp"
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveRH(
  T fovy, T aspect, T near, T far);
# 317 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.hpp"
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveLH(
  T fovy, T aspect, T near, T far);
# 331 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.hpp"
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspective(
  T fovy, T aspect, T near, T far);
# 345 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.hpp"
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveFovRH_ZO(
  T fov, T width, T height, T near, T far);
# 359 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.hpp"
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveFovRH_NO(
  T fov, T width, T height, T near, T far);
# 373 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.hpp"
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveFovLH_ZO(
  T fov, T width, T height, T near, T far);
# 387 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.hpp"
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveFovLH_NO(
  T fov, T width, T height, T near, T far);
# 401 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.hpp"
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveFovZO(
  T fov, T width, T height, T near, T far);
# 415 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.hpp"
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveFovNO(
  T fov, T width, T height, T near, T far);
# 430 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.hpp"
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveFovRH(
  T fov, T width, T height, T near, T far);
# 445 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.hpp"
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveFovLH(
  T fov, T width, T height, T near, T far);
# 459 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.hpp"
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveFov(
  T fov, T width, T height, T near, T far);
# 470 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.hpp"
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> infinitePerspectiveLH(
  T fovy, T aspect, T near);
# 481 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.hpp"
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> infinitePerspectiveRH(
  T fovy, T aspect, T near);
# 492 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.hpp"
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> infinitePerspective(
  T fovy, T aspect, T near);
# 503 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.hpp"
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> tweakedInfinitePerspective(
  T fovy, T aspect, T near);
# 515 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.hpp"
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> tweakedInfinitePerspective(
  T fovy, T aspect, T near, T ep);


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.inl" 1
namespace glm
{
 template<typename T>
 inline mat<4, 4, T, defaultp> ortho(T left, T right, T bottom, T top)
 {
  mat<4, 4, T, defaultp> Result(static_cast<T>(1));
  Result[0][0] = static_cast<T>(2) / (right - left);
  Result[1][1] = static_cast<T>(2) / (top - bottom);
  Result[2][2] = - static_cast<T>(1);
  Result[3][0] = - (right + left) / (right - left);
  Result[3][1] = - (top + bottom) / (top - bottom);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> orthoLH_ZO(T left, T right, T bottom, T top, T zNear, T zFar)
 {
  mat<4, 4, T, defaultp> Result(1);
  Result[0][0] = static_cast<T>(2) / (right - left);
  Result[1][1] = static_cast<T>(2) / (top - bottom);
  Result[2][2] = static_cast<T>(1) / (zFar - zNear);
  Result[3][0] = - (right + left) / (right - left);
  Result[3][1] = - (top + bottom) / (top - bottom);
  Result[3][2] = - zNear / (zFar - zNear);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> orthoLH_NO(T left, T right, T bottom, T top, T zNear, T zFar)
 {
  mat<4, 4, T, defaultp> Result(1);
  Result[0][0] = static_cast<T>(2) / (right - left);
  Result[1][1] = static_cast<T>(2) / (top - bottom);
  Result[2][2] = static_cast<T>(2) / (zFar - zNear);
  Result[3][0] = - (right + left) / (right - left);
  Result[3][1] = - (top + bottom) / (top - bottom);
  Result[3][2] = - (zFar + zNear) / (zFar - zNear);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> orthoRH_ZO(T left, T right, T bottom, T top, T zNear, T zFar)
 {
  mat<4, 4, T, defaultp> Result(1);
  Result[0][0] = static_cast<T>(2) / (right - left);
  Result[1][1] = static_cast<T>(2) / (top - bottom);
  Result[2][2] = - static_cast<T>(1) / (zFar - zNear);
  Result[3][0] = - (right + left) / (right - left);
  Result[3][1] = - (top + bottom) / (top - bottom);
  Result[3][2] = - zNear / (zFar - zNear);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> orthoRH_NO(T left, T right, T bottom, T top, T zNear, T zFar)
 {
  mat<4, 4, T, defaultp> Result(1);
  Result[0][0] = static_cast<T>(2) / (right - left);
  Result[1][1] = static_cast<T>(2) / (top - bottom);
  Result[2][2] = - static_cast<T>(2) / (zFar - zNear);
  Result[3][0] = - (right + left) / (right - left);
  Result[3][1] = - (top + bottom) / (top - bottom);
  Result[3][2] = - (zFar + zNear) / (zFar - zNear);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> orthoZO(T left, T right, T bottom, T top, T zNear, T zFar)
 {



   return orthoRH_ZO(left, right, bottom, top, zNear, zFar);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> orthoNO(T left, T right, T bottom, T top, T zNear, T zFar)
 {



   return orthoRH_NO(left, right, bottom, top, zNear, zFar);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> orthoLH(T left, T right, T bottom, T top, T zNear, T zFar)
 {



   return orthoLH_NO(left, right, bottom, top, zNear, zFar);


 }

 template<typename T>
 inline mat<4, 4, T, defaultp> orthoRH(T left, T right, T bottom, T top, T zNear, T zFar)
 {



   return orthoRH_NO(left, right, bottom, top, zNear, zFar);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> ortho(T left, T right, T bottom, T top, T zNear, T zFar)
 {







   return orthoRH_NO(left, right, bottom, top, zNear, zFar);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> frustumLH_ZO(T left, T right, T bottom, T top, T nearVal, T farVal)
 {
  mat<4, 4, T, defaultp> Result(0);
  Result[0][0] = (static_cast<T>(2) * nearVal) / (right - left);
  Result[1][1] = (static_cast<T>(2) * nearVal) / (top - bottom);
  Result[2][0] = -(right + left) / (right - left);
  Result[2][1] = -(top + bottom) / (top - bottom);
  Result[2][2] = farVal / (farVal - nearVal);
  Result[2][3] = static_cast<T>(1);
  Result[3][2] = -(farVal * nearVal) / (farVal - nearVal);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> frustumLH_NO(T left, T right, T bottom, T top, T nearVal, T farVal)
 {
  mat<4, 4, T, defaultp> Result(0);
  Result[0][0] = (static_cast<T>(2) * nearVal) / (right - left);
  Result[1][1] = (static_cast<T>(2) * nearVal) / (top - bottom);
  Result[2][0] = -(right + left) / (right - left);
  Result[2][1] = -(top + bottom) / (top - bottom);
  Result[2][2] = (farVal + nearVal) / (farVal - nearVal);
  Result[2][3] = static_cast<T>(1);
  Result[3][2] = - (static_cast<T>(2) * farVal * nearVal) / (farVal - nearVal);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> frustumRH_ZO(T left, T right, T bottom, T top, T nearVal, T farVal)
 {
  mat<4, 4, T, defaultp> Result(0);
  Result[0][0] = (static_cast<T>(2) * nearVal) / (right - left);
  Result[1][1] = (static_cast<T>(2) * nearVal) / (top - bottom);
  Result[2][0] = (right + left) / (right - left);
  Result[2][1] = (top + bottom) / (top - bottom);
  Result[2][2] = farVal / (nearVal - farVal);
  Result[2][3] = static_cast<T>(-1);
  Result[3][2] = -(farVal * nearVal) / (farVal - nearVal);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> frustumRH_NO(T left, T right, T bottom, T top, T nearVal, T farVal)
 {
  mat<4, 4, T, defaultp> Result(0);
  Result[0][0] = (static_cast<T>(2) * nearVal) / (right - left);
  Result[1][1] = (static_cast<T>(2) * nearVal) / (top - bottom);
  Result[2][0] = (right + left) / (right - left);
  Result[2][1] = (top + bottom) / (top - bottom);
  Result[2][2] = - (farVal + nearVal) / (farVal - nearVal);
  Result[2][3] = static_cast<T>(-1);
  Result[3][2] = - (static_cast<T>(2) * farVal * nearVal) / (farVal - nearVal);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> frustumZO(T left, T right, T bottom, T top, T nearVal, T farVal)
 {



   return frustumRH_ZO(left, right, bottom, top, nearVal, farVal);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> frustumNO(T left, T right, T bottom, T top, T nearVal, T farVal)
 {



   return frustumRH_NO(left, right, bottom, top, nearVal, farVal);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> frustumLH(T left, T right, T bottom, T top, T nearVal, T farVal)
 {



   return frustumLH_NO(left, right, bottom, top, nearVal, farVal);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> frustumRH(T left, T right, T bottom, T top, T nearVal, T farVal)
 {



   return frustumRH_NO(left, right, bottom, top, nearVal, farVal);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> frustum(T left, T right, T bottom, T top, T nearVal, T farVal)
 {







   return frustumRH_NO(left, right, bottom, top, nearVal, farVal);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveRH_ZO(T fovy, T aspect, T zNear, T zFar)
 {
  
# 235 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.inl" 3
 ((void)0)
# 235 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.inl"
                                                                            ;

  T const tanHalfFovy = tan(fovy / static_cast<T>(2));

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = static_cast<T>(1) / (aspect * tanHalfFovy);
  Result[1][1] = static_cast<T>(1) / (tanHalfFovy);
  Result[2][2] = zFar / (zNear - zFar);
  Result[2][3] = - static_cast<T>(1);
  Result[3][2] = -(zFar * zNear) / (zFar - zNear);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveRH_NO(T fovy, T aspect, T zNear, T zFar)
 {
  
# 251 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.inl" 3
 ((void)0)
# 251 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.inl"
                                                                            ;

  T const tanHalfFovy = tan(fovy / static_cast<T>(2));

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = static_cast<T>(1) / (aspect * tanHalfFovy);
  Result[1][1] = static_cast<T>(1) / (tanHalfFovy);
  Result[2][2] = - (zFar + zNear) / (zFar - zNear);
  Result[2][3] = - static_cast<T>(1);
  Result[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveLH_ZO(T fovy, T aspect, T zNear, T zFar)
 {
  
# 267 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.inl" 3
 ((void)0)
# 267 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.inl"
                                                                            ;

  T const tanHalfFovy = tan(fovy / static_cast<T>(2));

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = static_cast<T>(1) / (aspect * tanHalfFovy);
  Result[1][1] = static_cast<T>(1) / (tanHalfFovy);
  Result[2][2] = zFar / (zFar - zNear);
  Result[2][3] = static_cast<T>(1);
  Result[3][2] = -(zFar * zNear) / (zFar - zNear);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveLH_NO(T fovy, T aspect, T zNear, T zFar)
 {
  
# 283 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.inl" 3
 ((void)0)
# 283 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.inl"
                                                                            ;

  T const tanHalfFovy = tan(fovy / static_cast<T>(2));

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = static_cast<T>(1) / (aspect * tanHalfFovy);
  Result[1][1] = static_cast<T>(1) / (tanHalfFovy);
  Result[2][2] = (zFar + zNear) / (zFar - zNear);
  Result[2][3] = static_cast<T>(1);
  Result[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveZO(T fovy, T aspect, T zNear, T zFar)
 {



   return perspectiveRH_ZO(fovy, aspect, zNear, zFar);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveNO(T fovy, T aspect, T zNear, T zFar)
 {



   return perspectiveRH_NO(fovy, aspect, zNear, zFar);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveLH(T fovy, T aspect, T zNear, T zFar)
 {



   return perspectiveLH_NO(fovy, aspect, zNear, zFar);


 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveRH(T fovy, T aspect, T zNear, T zFar)
 {



   return perspectiveRH_NO(fovy, aspect, zNear, zFar);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspective(T fovy, T aspect, T zNear, T zFar)
 {







   return perspectiveRH_NO(fovy, aspect, zNear, zFar);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveFovRH_ZO(T fov, T width, T height, T zNear, T zFar)
 {
  
# 354 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.inl" 3
 ((void)0)
# 354 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.inl"
                                  ;
  
# 355 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.inl" 3
 ((void)0)
# 355 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.inl"
                                   ;
  
# 356 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.inl" 3
 ((void)0)
# 356 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.inl"
                                ;

  T const rad = fov;
  T const h = glm::cos(static_cast<T>(0.5) * rad) / glm::sin(static_cast<T>(0.5) * rad);
  T const w = h * height / width;

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = w;
  Result[1][1] = h;
  Result[2][2] = zFar / (zNear - zFar);
  Result[2][3] = - static_cast<T>(1);
  Result[3][2] = -(zFar * zNear) / (zFar - zNear);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveFovRH_NO(T fov, T width, T height, T zNear, T zFar)
 {
  
# 374 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.inl" 3
 ((void)0)
# 374 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.inl"
                                  ;
  
# 375 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.inl" 3
 ((void)0)
# 375 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.inl"
                                   ;
  
# 376 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.inl" 3
 ((void)0)
# 376 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.inl"
                                ;

  T const rad = fov;
  T const h = glm::cos(static_cast<T>(0.5) * rad) / glm::sin(static_cast<T>(0.5) * rad);
  T const w = h * height / width;

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = w;
  Result[1][1] = h;
  Result[2][2] = - (zFar + zNear) / (zFar - zNear);
  Result[2][3] = - static_cast<T>(1);
  Result[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveFovLH_ZO(T fov, T width, T height, T zNear, T zFar)
 {
  
# 394 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.inl" 3
 ((void)0)
# 394 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.inl"
                                  ;
  
# 395 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.inl" 3
 ((void)0)
# 395 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.inl"
                                   ;
  
# 396 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.inl" 3
 ((void)0)
# 396 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.inl"
                                ;

  T const rad = fov;
  T const h = glm::cos(static_cast<T>(0.5) * rad) / glm::sin(static_cast<T>(0.5) * rad);
  T const w = h * height / width;

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = w;
  Result[1][1] = h;
  Result[2][2] = zFar / (zFar - zNear);
  Result[2][3] = static_cast<T>(1);
  Result[3][2] = -(zFar * zNear) / (zFar - zNear);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveFovLH_NO(T fov, T width, T height, T zNear, T zFar)
 {
  
# 414 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.inl" 3
 ((void)0)
# 414 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.inl"
                                  ;
  
# 415 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.inl" 3
 ((void)0)
# 415 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.inl"
                                   ;
  
# 416 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.inl" 3
 ((void)0)
# 416 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.inl"
                                ;

  T const rad = fov;
  T const h = glm::cos(static_cast<T>(0.5) * rad) / glm::sin(static_cast<T>(0.5) * rad);
  T const w = h * height / width;

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = w;
  Result[1][1] = h;
  Result[2][2] = (zFar + zNear) / (zFar - zNear);
  Result[2][3] = static_cast<T>(1);
  Result[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveFovZO(T fov, T width, T height, T zNear, T zFar)
 {



   return perspectiveFovRH_ZO(fov, width, height, zNear, zFar);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveFovNO(T fov, T width, T height, T zNear, T zFar)
 {



   return perspectiveFovRH_NO(fov, width, height, zNear, zFar);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveFovLH(T fov, T width, T height, T zNear, T zFar)
 {



   return perspectiveFovLH_NO(fov, width, height, zNear, zFar);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveFovRH(T fov, T width, T height, T zNear, T zFar)
 {



   return perspectiveFovRH_NO(fov, width, height, zNear, zFar);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveFov(T fov, T width, T height, T zNear, T zFar)
 {







   return perspectiveFovRH_NO(fov, width, height, zNear, zFar);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> infinitePerspectiveRH_NO(T fovy, T aspect, T zNear)
 {
  T const range = tan(fovy / static_cast<T>(2)) * zNear;
  T const left = -range * aspect;
  T const right = range * aspect;
  T const bottom = -range;
  T const top = range;

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = (static_cast<T>(2) * zNear) / (right - left);
  Result[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);
  Result[2][2] = - static_cast<T>(1);
  Result[2][3] = - static_cast<T>(1);
  Result[3][2] = - static_cast<T>(2) * zNear;
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> infinitePerspectiveRH_ZO(T fovy, T aspect, T zNear)
 {
  T const range = tan(fovy / static_cast<T>(2)) * zNear;
  T const left = -range * aspect;
  T const right = range * aspect;
  T const bottom = -range;
  T const top = range;

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = (static_cast<T>(2) * zNear) / (right - left);
  Result[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);
  Result[2][2] = - static_cast<T>(1);
  Result[2][3] = - static_cast<T>(1);
  Result[3][2] = - zNear;
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> infinitePerspectiveLH_NO(T fovy, T aspect, T zNear)
 {
  T const range = tan(fovy / static_cast<T>(2)) * zNear;
  T const left = -range * aspect;
  T const right = range * aspect;
  T const bottom = -range;
  T const top = range;

  mat<4, 4, T, defaultp> Result(T(0));
  Result[0][0] = (static_cast<T>(2) * zNear) / (right - left);
  Result[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);
  Result[2][2] = static_cast<T>(1);
  Result[2][3] = static_cast<T>(1);
  Result[3][2] = - static_cast<T>(2) * zNear;
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> infinitePerspectiveLH_ZO(T fovy, T aspect, T zNear)
 {
  T const range = tan(fovy / static_cast<T>(2)) * zNear;
  T const left = -range * aspect;
  T const right = range * aspect;
  T const bottom = -range;
  T const top = range;

  mat<4, 4, T, defaultp> Result(T(0));
  Result[0][0] = (static_cast<T>(2) * zNear) / (right - left);
  Result[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);
  Result[2][2] = static_cast<T>(1);
  Result[2][3] = static_cast<T>(1);
  Result[3][2] = - zNear;
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> infinitePerspective(T fovy, T aspect, T zNear)
 {







   return infinitePerspectiveRH_NO(fovy, aspect, zNear);

 }


 template<typename T>
 inline mat<4, 4, T, defaultp> tweakedInfinitePerspective(T fovy, T aspect, T zNear, T ep)
 {
  T const range = tan(fovy / static_cast<T>(2)) * zNear;
  T const left = -range * aspect;
  T const right = range * aspect;
  T const bottom = -range;
  T const top = range;

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = (static_cast<T>(2) * zNear) / (right - left);
  Result[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);
  Result[2][2] = ep - static_cast<T>(1);
  Result[2][3] = static_cast<T>(-1);
  Result[3][2] = (ep - static_cast<T>(2)) * zNear;
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> tweakedInfinitePerspective(T fovy, T aspect, T zNear)
 {
  return tweakedInfinitePerspective(fovy, aspect, zNear, epsilon<T>());
 }
}
# 523 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_clip_space.hpp" 2
# 17 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_common.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_common.hpp"
       


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/_fixes.hpp" 1
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 1 3
# 39 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 3
       
# 40 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 3
# 2 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/_fixes.hpp" 2
# 17 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_common.hpp" 2





namespace glm
{



 template<length_t C, length_t R, typename T, typename U, qualifier Q>
 [[nodiscard]] mat<C, R, T, Q> mix(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y, mat<C, R, U, Q> const& a);

 template<length_t C, length_t R, typename T, typename U, qualifier Q>
 [[nodiscard]] mat<C, R, T, Q> mix(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y, U a);

 template <length_t C, length_t R, typename T, qualifier Q>
 [[nodiscard]] constexpr mat<C, R, T, Q> abs(mat<C, R, T, Q> const& x);


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_common.inl" 1


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/_matrix_vectorize.hpp" 1
       

namespace glm {

 namespace detail {

  template<template<length_t C, length_t R, typename T, qualifier Q> class mat, length_t C, length_t R, typename Ret, typename T, qualifier Q>
  struct matrix_functor_1 {
  };

  template<template<length_t C, length_t R, typename T, qualifier Q> class mat, typename Ret, typename T, qualifier Q>
  struct matrix_functor_1<mat, 2, 2, Ret, T, Q> {
   inline constexpr static mat<2, 2, T, Q> call(Ret (*Func)(T x), mat<2, 2, T, Q> const &x) {
    return mat<2, 2, Ret, Q>(
     Func(x[0][0]), Func(x[0][1]),
     Func(x[1][0]), Func(x[1][1])
    );
   }
  };

  template<template<length_t C, length_t R, typename T, qualifier Q> class mat, typename Ret, typename T, qualifier Q>
  struct matrix_functor_1<mat, 2, 3, Ret, T, Q> {

   inline constexpr static mat<2, 3, T, Q> call(Ret (*Func)(T x), mat<2, 3, T, Q> const &x) {
    return mat<2, 3, Ret, Q>(
     Func(x[0][0]), Func(x[0][1]), Func(x[0][2]),
     Func(x[1][0]), Func(x[1][1]), Func(x[1][2])
    );
   }

  };

  template<template<length_t C, length_t R, typename T, qualifier Q> class mat, typename Ret, typename T, qualifier Q>
  struct matrix_functor_1<mat, 2, 4, Ret, T, Q> {

   inline constexpr static mat<2, 4, T, Q> call(Ret (*Func)(T x), mat<2, 4, T, Q> const &x) {
    return mat<2, 4, Ret, Q>(
     Func(x[0][0]), Func(x[0][1]), Func(x[0][2]), Func(x[0][3]),
     Func(x[1][0]), Func(x[1][1]), Func(x[1][2]), Func(x[1][3])
    );
   }

  };

  template<template<length_t C, length_t R, typename T, qualifier Q> class mat, typename Ret, typename T, qualifier Q>
  struct matrix_functor_1<mat, 3, 2, Ret, T, Q> {

   inline constexpr static mat<3, 2, T, Q> call(Ret (*Func)(T x), mat<3, 2, T, Q> const &x) {
    return mat<3, 2, Ret, Q>(
     Func(x[0][0]), Func(x[0][1]),
     Func(x[1][0]), Func(x[1][1]),
     Func(x[2][0]), Func(x[2][1])
    );
   }

  };

  template<template<length_t C, length_t R, typename T, qualifier Q> class mat, typename Ret, typename T, qualifier Q>
  struct matrix_functor_1<mat, 3, 3, Ret, T, Q> {

   inline constexpr static mat<3, 3, T, Q> call(Ret (*Func)(T x), mat<3, 3, T, Q> const &x) {
    return mat<3, 3, Ret, Q>(
     Func(x[0][0]), Func(x[0][1]), Func(x[0][2]),
     Func(x[1][0]), Func(x[1][1]), Func(x[1][2]),
     Func(x[2][0]), Func(x[2][1]), Func(x[2][2])
    );
   }

  };

  template<template<length_t C, length_t R, typename T, qualifier Q> class mat, typename Ret, typename T, qualifier Q>
  struct matrix_functor_1<mat, 3, 4, Ret, T, Q> {

   inline constexpr static mat<3, 4, T, Q> call(Ret (*Func)(T x), mat<3, 4, T, Q> const &x) {
    return mat<3, 4, Ret, Q>(
     Func(x[0][0]), Func(x[0][1]), Func(x[0][2]), Func(x[0][3]),
     Func(x[1][0]), Func(x[1][1]), Func(x[1][2]), Func(x[1][3]),
     Func(x[2][0]), Func(x[2][1]), Func(x[2][2]), Func(x[2][3])
    );
   }

  };

  template<template<length_t C, length_t R, typename T, qualifier Q> class mat, typename Ret, typename T, qualifier Q>
  struct matrix_functor_1<mat, 4, 2, Ret, T, Q> {

   inline constexpr static mat<4, 2, T, Q> call(Ret (*Func)(T x), mat<4, 2, T, Q> const &x) {
    return mat<4, 2, Ret, Q>(
     Func(x[0][0]), Func(x[0][1]),
     Func(x[1][0]), Func(x[1][1]),
     Func(x[2][0]), Func(x[2][1]),
     Func(x[3][0]), Func(x[3][1])
    );
   }

  };

  template<template<length_t C, length_t R, typename T, qualifier Q> class mat, typename Ret, typename T, qualifier Q>
  struct matrix_functor_1<mat, 4, 3, Ret, T, Q> {

   inline constexpr static mat<4, 3, T, Q> call(Ret (*Func)(T x), mat<4, 3, T, Q> const &x) {
    return mat<4, 3, Ret, Q>(
     Func(x[0][0]), Func(x[0][1]), Func(x[0][2]),
     Func(x[1][0]), Func(x[1][1]), Func(x[1][2]),
     Func(x[2][0]), Func(x[2][1]), Func(x[2][2]),
     Func(x[3][0]), Func(x[3][1]), Func(x[3][2])
    );
   }

  };

  template<template<length_t C, length_t R, typename T, qualifier Q> class mat, typename Ret, typename T, qualifier Q>
  struct matrix_functor_1<mat, 4, 4, Ret, T, Q> {

   inline constexpr static mat<4, 4, T, Q> call(Ret (*Func)(T x), mat<4, 4, T, Q> const &x) {
    return mat<4, 4, Ret, Q>(
     Func(x[0][0]), Func(x[0][1]), Func(x[0][2]), Func(x[0][3]),
     Func(x[1][0]), Func(x[1][1]), Func(x[1][2]), Func(x[1][3]),
     Func(x[2][0]), Func(x[2][1]), Func(x[2][2]), Func(x[2][3]),
     Func(x[3][0]), Func(x[3][1]), Func(x[3][2]), Func(x[3][3])
    );
   }

  };

 }

}
# 4 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_common.inl" 2

namespace glm
{
 template<length_t C, length_t R, typename T, typename U, qualifier Q>
 inline mat<C, R, T, Q> mix(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y, U a)
 {
  return mat<C, R, U, Q>(x) * (static_cast<U>(1) - a) + mat<C, R, U, Q>(y) * a;
 }

 template<length_t C, length_t R, typename T, typename U, qualifier Q>
 inline mat<C, R, T, Q> mix(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y, mat<C, R, U, Q> const& a)
 {
  return matrixCompMult(mat<C, R, U, Q>(x), static_cast<U>(1) - a) + matrixCompMult(mat<C, R, U, Q>(y), a);
 }

 template<length_t C, length_t R, typename T, qualifier Q, bool Aligned>
 struct compute_abs_matrix
 {
  inline constexpr static mat<C, R, T, Q> call(mat<C, R, T, Q> const& x)
  {
   return detail::matrix_functor_1<mat, C, R, T, T, Q>::call(abs, x);
  }
 };

 template<length_t C, length_t R, typename T, qualifier Q>
 [[nodiscard]] constexpr mat<C, R, T, Q> abs(mat<C, R, T, Q> const& x)
 {
  return compute_abs_matrix<C, R, T, Q, detail::is_aligned<Q>::value>::call(x);
 }

}
# 40 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_common.hpp" 2
# 18 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 57 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp"
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int2x2.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int2x2.hpp"
       
# 22 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int2x2.hpp"
namespace glm
{






 typedef mat<2, 2, int, defaultp> imat2x2;




 typedef mat<2, 2, int, defaultp> imat2;


}
# 58 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int2x2_sized.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int2x2_sized.hpp"
       
# 23 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int2x2_sized.hpp"
namespace glm
{






 typedef mat<2, 2, int8, defaultp> i8mat2x2;




 typedef mat<2, 2, int16, defaultp> i16mat2x2;




 typedef mat<2, 2, int32, defaultp> i32mat2x2;




 typedef mat<2, 2, int64, defaultp> i64mat2x2;





 typedef mat<2, 2, int8, defaultp> i8mat2;




 typedef mat<2, 2, int16, defaultp> i16mat2;




 typedef mat<2, 2, int32, defaultp> i32mat2;




 typedef mat<2, 2, int64, defaultp> i64mat2;


}
# 59 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int2x3.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int2x3.hpp"
       
# 22 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int2x3.hpp"
namespace glm
{






 typedef mat<2, 3, int, defaultp> imat2x3;


}
# 60 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int2x3_sized.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int2x3_sized.hpp"
       
# 23 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int2x3_sized.hpp"
namespace glm
{






 typedef mat<2, 3, int8, defaultp> i8mat2x3;




 typedef mat<2, 3, int16, defaultp> i16mat2x3;




 typedef mat<2, 3, int32, defaultp> i32mat2x3;




 typedef mat<2, 3, int64, defaultp> i64mat2x3;


}
# 61 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int2x4.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int2x4.hpp"
       
# 22 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int2x4.hpp"
namespace glm
{






 typedef mat<2, 4, int, defaultp> imat2x4;


}
# 62 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int2x4_sized.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int2x4_sized.hpp"
       
# 23 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int2x4_sized.hpp"
namespace glm
{






 typedef mat<2, 4, int8, defaultp> i8mat2x4;




 typedef mat<2, 4, int16, defaultp> i16mat2x4;




 typedef mat<2, 4, int32, defaultp> i32mat2x4;




 typedef mat<2, 4, int64, defaultp> i64mat2x4;


}
# 63 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int3x2.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int3x2.hpp"
       
# 22 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int3x2.hpp"
namespace glm
{






 typedef mat<3, 2, int, defaultp> imat3x2;


}
# 64 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int3x2_sized.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int3x2_sized.hpp"
       
# 23 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int3x2_sized.hpp"
namespace glm
{






 typedef mat<3, 2, int8, defaultp> i8mat3x2;




 typedef mat<3, 2, int16, defaultp> i16mat3x2;




 typedef mat<3, 2, int32, defaultp> i32mat3x2;




 typedef mat<3, 2, int64, defaultp> i64mat3x2;


}
# 65 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int3x3.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int3x3.hpp"
       
# 22 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int3x3.hpp"
namespace glm
{






 typedef mat<3, 3, int, defaultp> imat3x3;




 typedef mat<3, 3, int, defaultp> imat3;


}
# 66 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int3x3_sized.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int3x3_sized.hpp"
       
# 23 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int3x3_sized.hpp"
namespace glm
{






 typedef mat<3, 3, int8, defaultp> i8mat3x3;




 typedef mat<3, 3, int16, defaultp> i16mat3x3;




 typedef mat<3, 3, int32, defaultp> i32mat3x3;




 typedef mat<3, 3, int64, defaultp> i64mat3x3;





 typedef mat<3, 3, int8, defaultp> i8mat3;




 typedef mat<3, 3, int16, defaultp> i16mat3;




 typedef mat<3, 3, int32, defaultp> i32mat3;




 typedef mat<3, 3, int64, defaultp> i64mat3;


}
# 67 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int3x4.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int3x4.hpp"
       
# 22 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int3x4.hpp"
namespace glm
{






 typedef mat<3, 4, int, defaultp> imat3x4;


}
# 68 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int3x4_sized.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int3x4_sized.hpp"
       
# 23 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int3x4_sized.hpp"
namespace glm
{






 typedef mat<3, 4, int8, defaultp> i8mat3x4;




 typedef mat<3, 4, int16, defaultp> i16mat3x4;




 typedef mat<3, 4, int32, defaultp> i32mat3x4;




 typedef mat<3, 4, int64, defaultp> i64mat3x4;


}
# 69 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int4x2.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int4x2.hpp"
       
# 22 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int4x2.hpp"
namespace glm
{






 typedef mat<4, 2, int, defaultp> imat4x2;


}
# 70 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int4x2_sized.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int4x2_sized.hpp"
       
# 23 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int4x2_sized.hpp"
namespace glm
{






 typedef mat<4, 2, int8, defaultp> i8mat4x2;




 typedef mat<4, 2, int16, defaultp> i16mat4x2;




 typedef mat<4, 2, int32, defaultp> i32mat4x2;




 typedef mat<4, 2, int64, defaultp> i64mat4x2;


}
# 71 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int4x3.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int4x3.hpp"
       
# 22 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int4x3.hpp"
namespace glm
{






 typedef mat<4, 3, int, defaultp> imat4x3;


}
# 72 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int4x3_sized.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int4x3_sized.hpp"
       
# 23 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int4x3_sized.hpp"
namespace glm
{






 typedef mat<4, 3, int8, defaultp> i8mat4x3;




 typedef mat<4, 3, int16, defaultp> i16mat4x3;




 typedef mat<4, 3, int32, defaultp> i32mat4x3;




 typedef mat<4, 3, int64, defaultp> i64mat4x3;


}
# 73 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int4x4.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int4x4.hpp"
       
# 22 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int4x4.hpp"
namespace glm
{






 typedef mat<4, 4, int, defaultp> imat4x4;




 typedef mat<4, 4, int, defaultp> imat4;


}
# 74 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int4x4_sized.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int4x4_sized.hpp"
       
# 23 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_int4x4_sized.hpp"
namespace glm
{






 typedef mat<4, 4, int8, defaultp> i8mat4x4;




 typedef mat<4, 4, int16, defaultp> i16mat4x4;




 typedef mat<4, 4, int32, defaultp> i32mat4x4;




 typedef mat<4, 4, int64, defaultp> i64mat4x4;





 typedef mat<4, 4, int8, defaultp> i8mat4;




 typedef mat<4, 4, int16, defaultp> i16mat4;




 typedef mat<4, 4, int32, defaultp> i32mat4;




 typedef mat<4, 4, int64, defaultp> i64mat4;


}
# 75 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint2x2.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint2x2.hpp"
       
# 22 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint2x2.hpp"
namespace glm
{






 typedef mat<2, 2, uint, defaultp> umat2x2;




 typedef mat<2, 2, uint, defaultp> umat2;


}
# 77 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint2x2_sized.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint2x2_sized.hpp"
       
# 23 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint2x2_sized.hpp"
namespace glm
{






 typedef mat<2, 2, uint8, defaultp> u8mat2x2;




 typedef mat<2, 2, uint16, defaultp> u16mat2x2;




 typedef mat<2, 2, uint32, defaultp> u32mat2x2;




 typedef mat<2, 2, uint64, defaultp> u64mat2x2;





 typedef mat<2, 2, uint8, defaultp> u8mat2;




 typedef mat<2, 2, uint16, defaultp> u16mat2;




 typedef mat<2, 2, uint32, defaultp> u32mat2;




 typedef mat<2, 2, uint64, defaultp> u64mat2;


}
# 78 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint2x3.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint2x3.hpp"
       
# 22 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint2x3.hpp"
namespace glm
{






 typedef mat<2, 3, uint, defaultp> umat2x3;


}
# 79 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint2x3_sized.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint2x3_sized.hpp"
       
# 23 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint2x3_sized.hpp"
namespace glm
{






 typedef mat<2, 3, uint8, defaultp> u8mat2x3;




 typedef mat<2, 3, uint16, defaultp> u16mat2x3;




 typedef mat<2, 3, uint32, defaultp> u32mat2x3;




 typedef mat<2, 3, uint64, defaultp> u64mat2x3;


}
# 80 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint2x4.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint2x4.hpp"
       
# 22 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint2x4.hpp"
namespace glm
{






 typedef mat<2, 4, uint, defaultp> umat2x4;


}
# 81 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint2x4_sized.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint2x4_sized.hpp"
       
# 23 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint2x4_sized.hpp"
namespace glm
{






 typedef mat<2, 4, uint8, defaultp> u8mat2x4;




 typedef mat<2, 4, uint16, defaultp> u16mat2x4;




 typedef mat<2, 4, uint32, defaultp> u32mat2x4;




 typedef mat<2, 4, uint64, defaultp> u64mat2x4;


}
# 82 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint3x2.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint3x2.hpp"
       
# 22 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint3x2.hpp"
namespace glm
{






 typedef mat<3, 2, uint, defaultp> umat3x2;


}
# 83 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint3x2_sized.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint3x2_sized.hpp"
       
# 23 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint3x2_sized.hpp"
namespace glm
{






 typedef mat<3, 2, uint8, defaultp> u8mat3x2;




 typedef mat<3, 2, uint16, defaultp> u16mat3x2;




 typedef mat<3, 2, uint32, defaultp> u32mat3x2;




 typedef mat<3, 2, uint64, defaultp> u64mat3x2;


}
# 84 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint3x3.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint3x3.hpp"
       
# 22 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint3x3.hpp"
namespace glm
{






 typedef mat<3, 3, uint, defaultp> umat3x3;




 typedef mat<3, 3, uint, defaultp> umat3;


}
# 85 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint3x3_sized.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint3x3_sized.hpp"
       
# 23 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint3x3_sized.hpp"
namespace glm
{






 typedef mat<3, 3, uint8, defaultp> u8mat3x3;




 typedef mat<3, 3, uint16, defaultp> u16mat3x3;




 typedef mat<3, 3, uint32, defaultp> u32mat3x3;




 typedef mat<3, 3, uint64, defaultp> u64mat3x3;





 typedef mat<3, 3, uint8, defaultp> u8mat3;




 typedef mat<3, 3, uint16, defaultp> u16mat3;




 typedef mat<3, 3, uint32, defaultp> u32mat3;




 typedef mat<3, 3, uint64, defaultp> u64mat3;


}
# 86 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint3x4.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint3x4.hpp"
       
# 22 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint3x4.hpp"
namespace glm
{






 typedef mat<3, 4, uint, defaultp> umat3x4;


}
# 87 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint3x4_sized.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint3x4_sized.hpp"
       
# 23 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint3x4_sized.hpp"
namespace glm
{






 typedef mat<3, 4, uint8, defaultp> u8mat3x4;




 typedef mat<3, 4, uint16, defaultp> u16mat3x4;




 typedef mat<3, 4, uint32, defaultp> u32mat3x4;




 typedef mat<3, 4, uint64, defaultp> u64mat3x4;


}
# 88 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint4x2.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint4x2.hpp"
       
# 22 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint4x2.hpp"
namespace glm
{






 typedef mat<4, 2, uint, defaultp> umat4x2;


}
# 89 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint4x2_sized.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint4x2_sized.hpp"
       
# 23 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint4x2_sized.hpp"
namespace glm
{






 typedef mat<4, 2, uint8, defaultp> u8mat4x2;




 typedef mat<4, 2, uint16, defaultp> u16mat4x2;




 typedef mat<4, 2, uint32, defaultp> u32mat4x2;




 typedef mat<4, 2, uint64, defaultp> u64mat4x2;


}
# 90 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint4x3.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint4x3.hpp"
       
# 22 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint4x3.hpp"
namespace glm
{






 typedef mat<4, 3, uint, defaultp> umat4x3;


}
# 91 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint4x3_sized.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint4x3_sized.hpp"
       
# 23 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint4x3_sized.hpp"
namespace glm
{






 typedef mat<4, 3, uint8, defaultp> u8mat4x3;




 typedef mat<4, 3, uint16, defaultp> u16mat4x3;




 typedef mat<4, 3, uint32, defaultp> u32mat4x3;




 typedef mat<4, 3, uint64, defaultp> u64mat4x3;


}
# 92 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint4x4.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint4x4.hpp"
       
# 22 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint4x4.hpp"
namespace glm
{






 typedef mat<4, 4, uint, defaultp> umat4x4;




 typedef mat<4, 4, uint, defaultp> umat4;


}
# 93 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint4x4_sized.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint4x4_sized.hpp"
       
# 23 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_uint4x4_sized.hpp"
namespace glm
{






 typedef mat<4, 4, uint8, defaultp> u8mat4x4;




 typedef mat<4, 4, uint16, defaultp> u16mat4x4;




 typedef mat<4, 4, uint32, defaultp> u32mat4x4;




 typedef mat<4, 4, uint64, defaultp> u64mat4x4;





 typedef mat<4, 4, uint8, defaultp> u8mat4;




 typedef mat<4, 4, uint16, defaultp> u16mat4;




 typedef mat<4, 4, uint32, defaultp> u32mat4;




 typedef mat<4, 4, uint64, defaultp> u64mat4;


}
# 94 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_projection.hpp" 1
# 20 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_projection.hpp"
       


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/constants.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/constants.hpp"
       
# 22 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/constants.hpp"
namespace glm
{





 template<typename genType>
 [[nodiscard]] constexpr genType zero();



 template<typename genType>
 [[nodiscard]] constexpr genType one();



 template<typename genType>
 [[nodiscard]] constexpr genType two_pi();



 template<typename genType>
 [[nodiscard]] constexpr genType tau();



 template<typename genType>
 [[nodiscard]] constexpr genType root_pi();



 template<typename genType>
 [[nodiscard]] constexpr genType half_pi();



 template<typename genType>
 [[nodiscard]] constexpr genType three_over_two_pi();



 template<typename genType>
 [[nodiscard]] constexpr genType quarter_pi();



 template<typename genType>
 [[nodiscard]] constexpr genType one_over_pi();



 template<typename genType>
 [[nodiscard]] constexpr genType one_over_two_pi();



 template<typename genType>
 [[nodiscard]] constexpr genType two_over_pi();



 template<typename genType>
 [[nodiscard]] constexpr genType four_over_pi();



 template<typename genType>
 [[nodiscard]] constexpr genType two_over_root_pi();



 template<typename genType>
 [[nodiscard]] constexpr genType one_over_root_two();



 template<typename genType>
 [[nodiscard]] constexpr genType root_half_pi();



 template<typename genType>
 [[nodiscard]] constexpr genType root_two_pi();



 template<typename genType>
 [[nodiscard]] constexpr genType root_ln_four();



 template<typename genType>
 [[nodiscard]] constexpr genType e();



 template<typename genType>
 [[nodiscard]] constexpr genType euler();



 template<typename genType>
 [[nodiscard]] constexpr genType root_two();



 template<typename genType>
 [[nodiscard]] constexpr genType root_three();



 template<typename genType>
 [[nodiscard]] constexpr genType root_five();



 template<typename genType>
 [[nodiscard]] constexpr genType ln_two();



 template<typename genType>
 [[nodiscard]] constexpr genType ln_ten();



 template<typename genType>
 [[nodiscard]] constexpr genType ln_ln_two();



 template<typename genType>
 [[nodiscard]] constexpr genType third();



 template<typename genType>
 [[nodiscard]] constexpr genType two_thirds();



 template<typename genType>
 [[nodiscard]] constexpr genType golden_ratio();


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/constants.inl" 1


namespace glm
{
 template<typename genType>
 inline constexpr genType zero()
 {
  return genType(0);
 }

 template<typename genType>
 inline constexpr genType one()
 {
  return genType(1);
 }

 template<typename genType>
 inline constexpr genType two_pi()
 {
  return genType(6.28318530717958647692528676655900576);
 }

 template<typename genType>
 inline constexpr genType tau()
 {
  return two_pi<genType>();
 }

 template<typename genType>
 inline constexpr genType root_pi()
 {
  return genType(1.772453850905516027);
 }

 template<typename genType>
 inline constexpr genType half_pi()
 {
  return genType(1.57079632679489661923132169163975144);
 }

 template<typename genType>
 inline constexpr genType three_over_two_pi()
 {
  return genType(4.71238898038468985769396507491925432);
 }

 template<typename genType>
 inline constexpr genType quarter_pi()
 {
  return genType(0.785398163397448309615660845819875721);
 }

 template<typename genType>
 inline constexpr genType one_over_pi()
 {
  return genType(0.318309886183790671537767526745028724);
 }

 template<typename genType>
 inline constexpr genType one_over_two_pi()
 {
  return genType(0.159154943091895335768883763372514362);
 }

 template<typename genType>
 inline constexpr genType two_over_pi()
 {
  return genType(0.636619772367581343075535053490057448);
 }

 template<typename genType>
 inline constexpr genType four_over_pi()
 {
  return genType(1.273239544735162686151070106980114898);
 }

 template<typename genType>
 inline constexpr genType two_over_root_pi()
 {
  return genType(1.12837916709551257389615890312154517);
 }

 template<typename genType>
 inline constexpr genType one_over_root_two()
 {
  return genType(0.707106781186547524400844362104849039);
 }

 template<typename genType>
 inline constexpr genType root_half_pi()
 {
  return genType(1.253314137315500251);
 }

 template<typename genType>
 inline constexpr genType root_two_pi()
 {
  return genType(2.506628274631000502);
 }

 template<typename genType>
 inline constexpr genType root_ln_four()
 {
  return genType(1.17741002251547469);
 }

 template<typename genType>
 inline constexpr genType e()
 {
  return genType(2.71828182845904523536);
 }

 template<typename genType>
 inline constexpr genType euler()
 {
  return genType(0.577215664901532860606);
 }

 template<typename genType>
 inline constexpr genType root_two()
 {
  return genType(1.41421356237309504880168872420969808);
 }

 template<typename genType>
 inline constexpr genType root_three()
 {
  return genType(1.73205080756887729352744634150587236);
 }

 template<typename genType>
 inline constexpr genType root_five()
 {
  return genType(2.23606797749978969640917366873127623);
 }

 template<typename genType>
 inline constexpr genType ln_two()
 {
  return genType(0.693147180559945309417232121458176568);
 }

 template<typename genType>
 inline constexpr genType ln_ten()
 {
  return genType(2.30258509299404568401799145468436421);
 }

 template<typename genType>
 inline constexpr genType ln_ln_two()
 {
  return genType(-0.3665129205816643);
 }

 template<typename genType>
 inline constexpr genType third()
 {
  return genType(0.3333333333333333333333333333333333333333);
 }

 template<typename genType>
 inline constexpr genType two_thirds()
 {
  return genType(0.666666666666666666666666666666666666667);
 }

 template<typename genType>
 inline constexpr genType golden_ratio()
 {
  return genType(1.61803398874989484820458683436563811);
 }

}
# 171 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/constants.hpp" 2
# 24 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_projection.hpp" 2
# 32 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_projection.hpp"
namespace glm
{
# 49 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_projection.hpp"
 template<typename T, typename U, qualifier Q>
 [[nodiscard]] vec<3, T, Q> projectZO(
  vec<3, T, Q> const& obj, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport);
# 65 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_projection.hpp"
 template<typename T, typename U, qualifier Q>
 [[nodiscard]] vec<3, T, Q> projectNO(
  vec<3, T, Q> const& obj, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport);
# 81 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_projection.hpp"
 template<typename T, typename U, qualifier Q>
 [[nodiscard]] vec<3, T, Q> project(
  vec<3, T, Q> const& obj, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport);
# 97 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_projection.hpp"
 template<typename T, typename U, qualifier Q>
 [[nodiscard]] vec<3, T, Q> unProjectZO(
  vec<3, T, Q> const& win, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport);
# 113 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_projection.hpp"
 template<typename T, typename U, qualifier Q>
 [[nodiscard]] vec<3, T, Q> unProjectNO(
  vec<3, T, Q> const& win, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport);
# 129 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_projection.hpp"
 template<typename T, typename U, qualifier Q>
 [[nodiscard]] vec<3, T, Q> unProject(
  vec<3, T, Q> const& win, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport);
# 142 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_projection.hpp"
 template<typename T, qualifier Q, typename U>
 [[nodiscard]] mat<4, 4, T, Q> pickMatrix(
  vec<2, T, Q> const& center, vec<2, T, Q> const& delta, vec<4, U, Q> const& viewport);


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_projection.inl" 1
namespace glm
{
 template<typename T, typename U, qualifier Q>
 inline vec<3, T, Q> projectZO(vec<3, T, Q> const& obj, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport)
 {
  vec<4, T, Q> tmp = vec<4, T, Q>(obj, static_cast<T>(1));
  tmp = model * tmp;
  tmp = proj * tmp;

  tmp /= tmp.w;
  tmp.x = tmp.x * static_cast<T>(0.5) + static_cast<T>(0.5);
  tmp.y = tmp.y * static_cast<T>(0.5) + static_cast<T>(0.5);

  tmp[0] = tmp[0] * T(viewport[2]) + T(viewport[0]);
  tmp[1] = tmp[1] * T(viewport[3]) + T(viewport[1]);

  return vec<3, T, Q>(tmp);
 }

 template<typename T, typename U, qualifier Q>
 inline vec<3, T, Q> projectNO(vec<3, T, Q> const& obj, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport)
 {
  vec<4, T, Q> tmp = vec<4, T, Q>(obj, static_cast<T>(1));
  tmp = model * tmp;
  tmp = proj * tmp;

  tmp /= tmp.w;
  tmp = tmp * static_cast<T>(0.5) + static_cast<T>(0.5);
  tmp[0] = tmp[0] * T(viewport[2]) + T(viewport[0]);
  tmp[1] = tmp[1] * T(viewport[3]) + T(viewport[1]);

  return vec<3, T, Q>(tmp);
 }

 template<typename T, typename U, qualifier Q>
 inline vec<3, T, Q> project(vec<3, T, Q> const& obj, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport)
 {



   return projectNO(obj, model, proj, viewport);

 }

 template<typename T, typename U, qualifier Q>
 inline vec<3, T, Q> unProjectZO(vec<3, T, Q> const& win, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport)
 {
  mat<4, 4, T, Q> Inverse = inverse(proj * model);

  vec<4, T, Q> tmp = vec<4, T, Q>(win, T(1));
  tmp.x = (tmp.x - T(viewport[0])) / T(viewport[2]);
  tmp.y = (tmp.y - T(viewport[1])) / T(viewport[3]);
  tmp.x = tmp.x * static_cast<T>(2) - static_cast<T>(1);
  tmp.y = tmp.y * static_cast<T>(2) - static_cast<T>(1);

  vec<4, T, Q> obj = Inverse * tmp;
  obj /= obj.w;

  return vec<3, T, Q>(obj);
 }

 template<typename T, typename U, qualifier Q>
 inline vec<3, T, Q> unProjectNO(vec<3, T, Q> const& win, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport)
 {
  mat<4, 4, T, Q> Inverse = inverse(proj * model);

  vec<4, T, Q> tmp = vec<4, T, Q>(win, T(1));
  tmp.x = (tmp.x - T(viewport[0])) / T(viewport[2]);
  tmp.y = (tmp.y - T(viewport[1])) / T(viewport[3]);
  tmp = tmp * static_cast<T>(2) - static_cast<T>(1);

  vec<4, T, Q> obj = Inverse * tmp;
  obj /= obj.w;

  return vec<3, T, Q>(obj);
 }

 template<typename T, typename U, qualifier Q>
 inline vec<3, T, Q> unProject(vec<3, T, Q> const& win, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport)
 {



   return unProjectNO(win, model, proj, viewport);

 }

 template<typename T, qualifier Q, typename U>
 inline mat<4, 4, T, Q> pickMatrix(vec<2, T, Q> const& center, vec<2, T, Q> const& delta, vec<4, U, Q> const& viewport)
 {
  
# 91 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_projection.inl" 3
 ((void)0)
# 91 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_projection.inl"
                                                                   ;
  mat<4, 4, T, Q> Result(static_cast<T>(1));

  if(!(delta.x > static_cast<T>(0) && delta.y > static_cast<T>(0)))
   return Result;

  vec<3, T, Q> Temp(
   (static_cast<T>(viewport[2]) - static_cast<T>(2) * (center.x - static_cast<T>(viewport[0]))) / delta.x,
   (static_cast<T>(viewport[3]) - static_cast<T>(2) * (center.y - static_cast<T>(viewport[1]))) / delta.y,
   static_cast<T>(0));


  Result = translate(Result, Temp);
  return scale(Result, vec<3, T, Q>(static_cast<T>(viewport[2]) / delta.x, static_cast<T>(viewport[3]) / delta.y, static_cast<T>(1)));
 }
}
# 150 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_projection.hpp" 2
# 96 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_relational.hpp" 1
# 15 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_relational.hpp"
       
# 24 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_relational.hpp"
namespace glm
{
# 36 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_relational.hpp"
 template<length_t C, length_t R, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<C, bool, Q> equal(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y);
# 46 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_relational.hpp"
 template<length_t C, length_t R, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<C, bool, Q> notEqual(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y);
# 56 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_relational.hpp"
 template<length_t C, length_t R, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<C, bool, Q> equal(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y, T epsilon);
# 66 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_relational.hpp"
 template<length_t C, length_t R, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<C, bool, Q> equal(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y, vec<C, T, Q> const& epsilon);
# 76 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_relational.hpp"
 template<length_t C, length_t R, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<C, bool, Q> notEqual(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y, T epsilon);
# 86 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_relational.hpp"
 template<length_t C, length_t R, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<C, bool, Q> notEqual(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y, vec<C, T, Q> const& epsilon);
# 96 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_relational.hpp"
 template<length_t C, length_t R, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<C, bool, Q> equal(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y, int ULPs);
# 106 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_relational.hpp"
 template<length_t C, length_t R, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<C, bool, Q> equal(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y, vec<C, int, Q> const& ULPs);
# 116 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_relational.hpp"
 template<length_t C, length_t R, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<C, bool, Q> notEqual(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y, int ULPs);
# 126 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_relational.hpp"
 template<length_t C, length_t R, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<C, bool, Q> notEqual(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y, vec<C, int, Q> const& ULPs);


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_relational.inl" 1




# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_relational.hpp" 1
# 18 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_relational.hpp"
       
# 27 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_relational.hpp"
namespace glm
{
# 38 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_relational.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y, T epsilon);







 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& epsilon);







 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, T epsilon);







 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& epsilon);







 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y, int ULPs);







 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, int, Q> const& ULPs);







 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, int ULPs);







 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, int, Q> const& ULPs);


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_relational.inl" 1



# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_float.hpp" 1
       

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/setup.hpp" 1
# 4 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_float.hpp" 2






namespace glm{
namespace detail
{
 template <typename T>
 union float_t
 {};


 template <>
 union float_t<float>
 {
  typedef int int_type;
  typedef float float_type;

  constexpr float_t(float_type Num = 0.0f) : f(Num) {}

  constexpr float_t& operator=(float_t const& x)
  {
   f = x.f;
   return *this;
  }


  constexpr bool negative() const { return i < 0; }
  constexpr int_type mantissa() const { return i & ((1 << 23) - 1); }
  constexpr int_type exponent() const { return (i >> 23) & ((1 << 8) - 1); }

  int_type i;
  float_type f;
 };

 template <>
 union float_t<double>
 {
  typedef detail::int64 int_type;
  typedef double float_type;

  constexpr float_t(float_type Num = static_cast<float_type>(0)) : f(Num) {}

  constexpr float_t& operator=(float_t const& x)
  {
   f = x.f;
   return *this;
  }


  constexpr bool negative() const { return i < 0; }
  constexpr int_type mantissa() const { return i & ((int_type(1) << 52) - 1); }
  constexpr int_type exponent() const { return (i >> 52) & ((int_type(1) << 11) - 1); }

  int_type i;
  float_type f;
 };
}
}
# 5 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_relational.inl" 2

namespace glm
{
 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y, T Epsilon)
 {
  return equal(x, y, vec<L, T, Q>(Epsilon));
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& Epsilon)
 {
  return lessThanEqual(abs(x - y), Epsilon);
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, T Epsilon)
 {
  return notEqual(x, y, vec<L, T, Q>(Epsilon));
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& Epsilon)
 {
  return greaterThan(abs(x - y), Epsilon);
 }


 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y, int MaxULPs)
 {
  return equal(x, y, vec<L, int, Q>(MaxULPs));
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, int, Q> const& MaxULPs)
 {
  vec<L, bool, Q> Result(false);
  for(length_t i = 0; i < L; ++i)
  {
   detail::float_t<T> const a(x[i]);
   detail::float_t<T> const b(y[i]);


   if(a.negative() != b.negative())
   {

    Result[i] = a.mantissa() == b.mantissa() && a.exponent() == b.exponent();
   }
   else
   {

    typename detail::float_t<T>::int_type const DiffULPs = abs(a.i - b.i);
    Result[i] = DiffULPs <= MaxULPs[i];
   }
  }
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, int MaxULPs)
 {
  return notEqual(x, y, vec<L, int, Q>(MaxULPs));
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, int, Q> const& MaxULPs)
 {
  return not_(equal(x, y, MaxULPs));
 }
}
# 108 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_relational.hpp" 2
# 6 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_relational.inl" 2


namespace glm
{
 template<length_t C, length_t R, typename T, qualifier Q>
 inline constexpr vec<C, bool, Q> equal(mat<C, R, T, Q> const& a, mat<C, R, T, Q> const& b)
 {
  vec<C, bool, Q> Result(true);
  for(length_t i = 0; i < C; ++i)
   Result[i] = all(equal(a[i], b[i]));
  return Result;
 }

 template<length_t C, length_t R, typename T, qualifier Q>
 inline constexpr vec<C, bool, Q> equal(mat<C, R, T, Q> const& a, mat<C, R, T, Q> const& b, T Epsilon)
 {
  return equal(a, b, vec<C, T, Q>(Epsilon));
 }

 template<length_t C, length_t R, typename T, qualifier Q>
 inline constexpr vec<C, bool, Q> equal(mat<C, R, T, Q> const& a, mat<C, R, T, Q> const& b, vec<C, T, Q> const& Epsilon)
 {
  vec<C, bool, Q> Result(true);
  for(length_t i = 0; i < C; ++i)
   Result[i] = all(equal(a[i], b[i], Epsilon[i]));
  return Result;
 }

 template<length_t C, length_t R, typename T, qualifier Q>
 inline constexpr vec<C, bool, Q> notEqual(mat<C, R, T, Q> const& a, mat<C, R, T, Q> const& b)
 {
  vec<C, bool, Q> Result(true);
  for(length_t i = 0; i < C; ++i)
   Result[i] = any(notEqual(a[i], b[i]));
  return Result;
 }

 template<length_t C, length_t R, typename T, qualifier Q>
 inline constexpr vec<C, bool, Q> notEqual(mat<C, R, T, Q> const& a, mat<C, R, T, Q> const& b, T Epsilon)
 {
  return notEqual(a, b, vec<C, T, Q>(Epsilon));
 }

 template<length_t C, length_t R, typename T, qualifier Q>
 inline constexpr vec<C, bool, Q> notEqual(mat<C, R, T, Q> const& a, mat<C, R, T, Q> const& b, vec<C, T, Q> const& Epsilon)
 {
  vec<C, bool, Q> Result(true);
  for(length_t i = 0; i < C; ++i)
   Result[i] = any(notEqual(a[i], b[i], Epsilon[i]));
  return Result;
 }

 template<length_t C, length_t R, typename T, qualifier Q>
 inline constexpr vec<C, bool, Q> equal(mat<C, R, T, Q> const& a, mat<C, R, T, Q> const& b, int MaxULPs)
 {
  return equal(a, b, vec<C, int, Q>(MaxULPs));
 }

 template<length_t C, length_t R, typename T, qualifier Q>
 inline constexpr vec<C, bool, Q> equal(mat<C, R, T, Q> const& a, mat<C, R, T, Q> const& b, vec<C, int, Q> const& MaxULPs)
 {
  vec<C, bool, Q> Result(true);
  for(length_t i = 0; i < C; ++i)
   Result[i] = all(equal(a[i], b[i], MaxULPs[i]));
  return Result;
 }

 template<length_t C, length_t R, typename T, qualifier Q>
 inline constexpr vec<C, bool, Q> notEqual(mat<C, R, T, Q> const& a, mat<C, R, T, Q> const& b, int MaxULPs)
 {
  return notEqual(a, b, vec<C, int, Q>(MaxULPs));
 }

 template<length_t C, length_t R, typename T, qualifier Q>
 inline constexpr vec<C, bool, Q> notEqual(mat<C, R, T, Q> const& a, mat<C, R, T, Q> const& b, vec<C, int, Q> const& MaxULPs)
 {
  vec<C, bool, Q> Result(true);
  for(length_t i = 0; i < C; ++i)
   Result[i] = any(notEqual(a[i], b[i], MaxULPs[i]));
  return Result;
 }

}
# 133 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_relational.hpp" 2
# 97 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_transform.hpp" 1
# 20 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_transform.hpp"
       
# 32 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_transform.hpp"
namespace glm
{




 template<typename genType>
 [[nodiscard]] constexpr genType identity();
# 63 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_transform.hpp"
 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> translate(
  mat<4, 4, T, Q> const& m, vec<3, T, Q> const& v);
# 79 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_transform.hpp"
 template<typename T, qualifier Q>
 [[nodiscard]] mat<4, 4, T, Q> rotate(
  mat<4, 4, T, Q> const& m, T angle, vec<3, T, Q> const& axis);
# 94 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_transform.hpp"
 template<typename T, qualifier Q>
 [[nodiscard]] mat<4, 4, T, Q> scale(
  mat<4, 4, T, Q> const& m, vec<3, T, Q> const& v);
# 121 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_transform.hpp"
    template <typename T, qualifier Q>
    inline mat<4, 4, T, Q> shear(
        mat<4, 4, T, Q> const &m, vec<3, T, Q> const& p, vec<2, T, Q> const &l_x, vec<2, T, Q> const &l_y, vec<2, T, Q> const &l_z);
# 135 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_transform.hpp"
 template<typename T, qualifier Q>
 [[nodiscard]] mat<4, 4, T, Q> lookAtRH(
  vec<3, T, Q> const& eye, vec<3, T, Q> const& center, vec<3, T, Q> const& up);
# 149 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_transform.hpp"
 template<typename T, qualifier Q>
 [[nodiscard]] mat<4, 4, T, Q> lookAtLH(
  vec<3, T, Q> const& eye, vec<3, T, Q> const& center, vec<3, T, Q> const& up);
# 164 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_transform.hpp"
 template<typename T, qualifier Q>
 [[nodiscard]] mat<4, 4, T, Q> lookAt(
  vec<3, T, Q> const& eye, vec<3, T, Q> const& center, vec<3, T, Q> const& up);


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_transform.inl" 1
namespace glm
{
 template<typename genType>
 inline constexpr genType identity()
 {
  return detail::init_gentype<genType, detail::genTypeTrait<genType>::GENTYPE>::identity();
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> translate(mat<4, 4, T, Q> const& m, vec<3, T, Q> const& v)
 {
  mat<4, 4, T, Q> Result(m);
  Result[3] = m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3];
  return Result;
 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> rotate(mat<4, 4, T, Q> const& m, T angle, vec<3, T, Q> const& v)
 {
  T const a = angle;
  T const c = cos(a);
  T const s = sin(a);

  vec<3, T, Q> axis(normalize(v));
  vec<3, T, Q> temp((T(1) - c) * axis);

  mat<4, 4, T, Q> Rotate;
  Rotate[0][0] = c + temp[0] * axis[0];
  Rotate[0][1] = temp[0] * axis[1] + s * axis[2];
  Rotate[0][2] = temp[0] * axis[2] - s * axis[1];

  Rotate[1][0] = temp[1] * axis[0] - s * axis[2];
  Rotate[1][1] = c + temp[1] * axis[1];
  Rotate[1][2] = temp[1] * axis[2] + s * axis[0];

  Rotate[2][0] = temp[2] * axis[0] + s * axis[1];
  Rotate[2][1] = temp[2] * axis[1] - s * axis[0];
  Rotate[2][2] = c + temp[2] * axis[2];

  mat<4, 4, T, Q> Result;
  Result[0] = m[0] * Rotate[0][0] + m[1] * Rotate[0][1] + m[2] * Rotate[0][2];
  Result[1] = m[0] * Rotate[1][0] + m[1] * Rotate[1][1] + m[2] * Rotate[1][2];
  Result[2] = m[0] * Rotate[2][0] + m[1] * Rotate[2][1] + m[2] * Rotate[2][2];
  Result[3] = m[3];
  return Result;
 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> rotate_slow(mat<4, 4, T, Q> const& m, T angle, vec<3, T, Q> const& v)
 {
  T const a = angle;
  T const c = cos(a);
  T const s = sin(a);
  mat<4, 4, T, Q> Result;

  vec<3, T, Q> axis = normalize(v);

  Result[0][0] = c + (static_cast<T>(1) - c) * axis.x * axis.x;
  Result[0][1] = (static_cast<T>(1) - c) * axis.x * axis.y + s * axis.z;
  Result[0][2] = (static_cast<T>(1) - c) * axis.x * axis.z - s * axis.y;
  Result[0][3] = static_cast<T>(0);

  Result[1][0] = (static_cast<T>(1) - c) * axis.y * axis.x - s * axis.z;
  Result[1][1] = c + (static_cast<T>(1) - c) * axis.y * axis.y;
  Result[1][2] = (static_cast<T>(1) - c) * axis.y * axis.z + s * axis.x;
  Result[1][3] = static_cast<T>(0);

  Result[2][0] = (static_cast<T>(1) - c) * axis.z * axis.x + s * axis.y;
  Result[2][1] = (static_cast<T>(1) - c) * axis.z * axis.y - s * axis.x;
  Result[2][2] = c + (static_cast<T>(1) - c) * axis.z * axis.z;
  Result[2][3] = static_cast<T>(0);

  Result[3] = vec<4, T, Q>(0, 0, 0, 1);
  return m * Result;
 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> scale(mat<4, 4, T, Q> const& m, vec<3, T, Q> const& v)
 {
  mat<4, 4, T, Q> Result;
  Result[0] = m[0] * v[0];
  Result[1] = m[1] * v[1];
  Result[2] = m[2] * v[2];
  Result[3] = m[3];
  return Result;
 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> scale_slow(mat<4, 4, T, Q> const& m, vec<3, T, Q> const& v)
 {
  mat<4, 4, T, Q> Result(T(1));
  Result[0][0] = v.x;
  Result[1][1] = v.y;
  Result[2][2] = v.z;
  return m * Result;
 }

    template <typename T, qualifier Q>
    inline mat<4, 4, T, Q> shear(mat<4, 4, T, Q> const &m, vec<3, T, Q> const& p, vec<2, T, Q> const &l_x, vec<2, T, Q> const &l_y, vec<2, T, Q> const &l_z)
    {
        T const lambda_xy = l_x[0];
        T const lambda_xz = l_x[1];
        T const lambda_yx = l_y[0];
        T const lambda_yz = l_y[1];
        T const lambda_zx = l_z[0];
        T const lambda_zy = l_z[1];

        vec<3, T, Q> point_lambda = vec<3, T, Q>(
            (lambda_xy + lambda_xz), (lambda_yx + lambda_yz), (lambda_zx + lambda_zy)
        );

        mat<4, 4, T, Q> Shear = mat<4, 4, T, Q>(
            1 , lambda_yx , lambda_zx , 0,
            lambda_xy , 1 , lambda_zy , 0,
            lambda_xz , lambda_yz , 1 , 0,
            -point_lambda[0] * p[0], -point_lambda[1] * p[1], -point_lambda[2] * p[2], 1
        );

        mat<4, 4, T, Q> Result;
  Result[0] = m[0] * Shear[0][0] + m[1] * Shear[0][1] + m[2] * Shear[0][2] + m[3] * Shear[0][3];
  Result[1] = m[0] * Shear[1][0] + m[1] * Shear[1][1] + m[2] * Shear[1][2] + m[3] * Shear[1][3];
  Result[2] = m[0] * Shear[2][0] + m[1] * Shear[2][1] + m[2] * Shear[2][2] + m[3] * Shear[2][3];
  Result[3] = m[0] * Shear[3][0] + m[1] * Shear[3][1] + m[2] * Shear[3][2] + m[3] * Shear[3][3];
        return Result;
    }

    template <typename T, qualifier Q>
    inline mat<4, 4, T, Q> shear_slow(mat<4, 4, T, Q> const &m, vec<3, T, Q> const& p, vec<2, T, Q> const &l_x, vec<2, T, Q> const &l_y, vec<2, T, Q> const &l_z)
    {
        T const lambda_xy = static_cast<T>(l_x[0]);
        T const lambda_xz = static_cast<T>(l_x[1]);
        T const lambda_yx = static_cast<T>(l_y[0]);
        T const lambda_yz = static_cast<T>(l_y[1]);
        T const lambda_zx = static_cast<T>(l_z[0]);
        T const lambda_zy = static_cast<T>(l_z[1]);

        vec<3, T, Q> point_lambda = vec<3, T, Q>(
            static_cast<T>(lambda_xy + lambda_xz),
            static_cast<T>(lambda_yx + lambda_yz),
            static_cast<T>(lambda_zx + lambda_zy)
        );

        mat<4, 4, T, Q> Shear = mat<4, 4, T, Q>(
            1 , lambda_yx , lambda_zx , 0,
            lambda_xy , 1 , lambda_zy , 0,
            lambda_xz , lambda_yz , 1 , 0,
            -point_lambda[0] * p[0], -point_lambda[1] * p[1], -point_lambda[2] * p[2], 1
        );
        return m * Shear;
    }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> lookAtRH(vec<3, T, Q> const& eye, vec<3, T, Q> const& center, vec<3, T, Q> const& up)
 {
  vec<3, T, Q> const f(normalize(center - eye));
  vec<3, T, Q> const s(normalize(cross(f, up)));
  vec<3, T, Q> const u(cross(s, f));

  mat<4, 4, T, Q> Result(1);
  Result[0][0] = s.x;
  Result[1][0] = s.y;
  Result[2][0] = s.z;
  Result[0][1] = u.x;
  Result[1][1] = u.y;
  Result[2][1] = u.z;
  Result[0][2] =-f.x;
  Result[1][2] =-f.y;
  Result[2][2] =-f.z;
  Result[3][0] =-dot(s, eye);
  Result[3][1] =-dot(u, eye);
  Result[3][2] = dot(f, eye);
  return Result;
 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> lookAtLH(vec<3, T, Q> const& eye, vec<3, T, Q> const& center, vec<3, T, Q> const& up)
 {
  vec<3, T, Q> const f(normalize(center - eye));
  vec<3, T, Q> const s(normalize(cross(up, f)));
  vec<3, T, Q> const u(cross(f, s));

  mat<4, 4, T, Q> Result(1);
  Result[0][0] = s.x;
  Result[1][0] = s.y;
  Result[2][0] = s.z;
  Result[0][1] = u.x;
  Result[1][1] = u.y;
  Result[2][1] = u.z;
  Result[0][2] = f.x;
  Result[1][2] = f.y;
  Result[2][2] = f.z;
  Result[3][0] = -dot(s, eye);
  Result[3][1] = -dot(u, eye);
  Result[3][2] = -dot(f, eye);
  return Result;
 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> lookAt(vec<3, T, Q> const& eye, vec<3, T, Q> const& center, vec<3, T, Q> const& up)
 {



            return lookAtRH(eye, center, up);

 }
}
# 172 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/matrix_transform.hpp" 2
# 98 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_common.hpp" 1
# 21 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_common.hpp"
       



# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_geometric.hpp" 1
# 15 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_geometric.hpp"
       
# 26 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_geometric.hpp"
namespace glm
{
# 37 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_geometric.hpp"
 template<typename T, qualifier Q>
 [[nodiscard]] T length(qua<T, Q> const& q);







 template<typename T, qualifier Q>
 [[nodiscard]] qua<T, Q> normalize(qua<T, Q> const& q);







 template<typename T, qualifier Q>
 [[nodiscard]] constexpr T dot(qua<T, Q> const& x, qua<T, Q> const& y);







 template<typename T, qualifier Q>
 inline constexpr qua<T, Q> cross(qua<T, Q> const& q1, qua<T, Q> const& q2);


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_geometric.inl" 1
namespace glm
{
 template<typename T, qualifier Q>
 inline constexpr T dot(qua<T, Q> const& x, qua<T, Q> const& y)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'dot' accepts only floating-point inputs");
  return detail::compute_dot<qua<T, Q>, T, detail::is_aligned<Q>::value>::call(x, y);
 }

 template<typename T, qualifier Q>
 inline T length(qua<T, Q> const& q)
 {
  return glm::sqrt(dot(q, q));
 }

 template<typename T, qualifier Q>
 inline qua<T, Q> normalize(qua<T, Q> const& q)
 {
  T len = length(q);
  if(len <= static_cast<T>(0))
   return qua<T, Q>::wxyz(static_cast<T>(1), static_cast<T>(0), static_cast<T>(0), static_cast<T>(0));
  T oneOverLen = static_cast<T>(1) / len;
  return qua<T, Q>::wxyz(q.w * oneOverLen, q.x * oneOverLen, q.y * oneOverLen, q.z * oneOverLen);
 }

 template<typename T, qualifier Q>
 inline constexpr qua<T, Q> cross(qua<T, Q> const& q1, qua<T, Q> const& q2)
 {
  return qua<T, Q>::wxyz(
   q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z,
   q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,
   q1.w * q2.y + q1.y * q2.w + q1.z * q2.x - q1.x * q2.z,
   q1.w * q2.z + q1.z * q2.w + q1.x * q2.y - q1.y * q2.x);
 }
}
# 71 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_geometric.hpp" 2
# 26 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_common.hpp" 2
# 35 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_common.hpp"
namespace glm
{
# 52 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_common.hpp"
 template<typename T, qualifier Q>
 [[nodiscard]] qua<T, Q> mix(qua<T, Q> const& x, qua<T, Q> const& y, T a);
# 64 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_common.hpp"
 template<typename T, qualifier Q>
 [[nodiscard]] constexpr qua<T, Q> lerp(qua<T, Q> const& x, qua<T, Q> const& y, T a);
# 76 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_common.hpp"
 template<typename T, qualifier Q>
 [[nodiscard]] qua<T, Q> slerp(qua<T, Q> const& x, qua<T, Q> const& y, T a);
# 91 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_common.hpp"
    template<typename T, typename S, qualifier Q>
    [[nodiscard]] qua<T, Q> slerp(qua<T, Q> const& x, qua<T, Q> const& y, T a, S k);





 template<typename T, qualifier Q>
 [[nodiscard]] constexpr qua<T, Q> conjugate(qua<T, Q> const& q);





 template<typename T, qualifier Q>
 [[nodiscard]] constexpr qua<T, Q> inverse(qua<T, Q> const& q);
# 118 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_common.hpp"
 template<typename T, qualifier Q>
 [[nodiscard]] vec<4, bool, Q> isnan(qua<T, Q> const& x);
# 129 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_common.hpp"
 template<typename T, qualifier Q>
 [[nodiscard]] vec<4, bool, Q> isinf(qua<T, Q> const& x);


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_common.inl" 1
namespace glm
{
 template<typename T, qualifier Q>
 inline qua<T, Q> mix(qua<T, Q> const& x, qua<T, Q> const& y, T a)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'mix' only accept floating-point inputs");

  T const cosTheta = dot(x, y);


  if(cosTheta > static_cast<T>(1) - epsilon<T>())
  {

   return qua<T, Q>::wxyz(
    mix(x.w, y.w, a),
    mix(x.x, y.x, a),
    mix(x.y, y.y, a),
    mix(x.z, y.z, a));
  }
  else
  {

   T angle = acos(cosTheta);
   return (sin((static_cast<T>(1) - a) * angle) * x + sin(a * angle) * y) / sin(angle);
  }
 }

 template<typename T, qualifier Q>
 inline constexpr qua<T, Q> lerp(qua<T, Q> const& x, qua<T, Q> const& y, T a)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'lerp' only accept floating-point inputs");


  
# 34 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_common.inl" 3
 ((void)0)
# 34 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_common.inl"
                               ;
  
# 35 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_common.inl" 3
 ((void)0)
# 35 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_common.inl"
                               ;

  return x * (static_cast<T>(1) - a) + (y * a);
 }

 template<typename T, qualifier Q>
 inline qua<T, Q> slerp(qua<T, Q> const& x, qua<T, Q> const& y, T a)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'slerp' only accept floating-point inputs");

  qua<T, Q> z = y;

  T cosTheta = dot(x, y);



  if(cosTheta < static_cast<T>(0))
  {
   z = -y;
   cosTheta = -cosTheta;
  }


  if(cosTheta > static_cast<T>(1) - epsilon<T>())
  {

   return qua<T, Q>::wxyz(
    mix(x.w, z.w, a),
    mix(x.x, z.x, a),
    mix(x.y, z.y, a),
    mix(x.z, z.z, a));
  }
  else
  {

   T angle = acos(cosTheta);
   return (sin((static_cast<T>(1) - a) * angle) * x + sin(a * angle) * z) / sin(angle);
  }
 }

    template<typename T, typename S, qualifier Q>
    inline qua<T, Q> slerp(qua<T, Q> const& x, qua<T, Q> const& y, T a, S k)
    {
        static_assert(std::numeric_limits<T>::is_iec559 || 0, "'slerp' only accept floating-point inputs");
        static_assert(std::numeric_limits<S>::is_integer, "'slerp' only accept integer for spin count");

        qua<T, Q> z = y;

        T cosTheta = dot(x, y);



        if (cosTheta < static_cast<T>(0))
        {
            z = -y;
            cosTheta = -cosTheta;
        }


        if (cosTheta > static_cast<T>(1) - epsilon<T>())
        {

            return qua<T, Q>::wxyz(
                mix(x.w, z.w, a),
                mix(x.x, z.x, a),
                mix(x.y, z.y, a),
                mix(x.z, z.z, a));
        }
        else
        {

            T angle = acos(cosTheta);
            T phi = angle + static_cast<T>(k) * glm::pi<T>();
            return (sin(angle - a * phi)* x + sin(a * phi) * z) / sin(angle);
        }
    }

 template<typename T, qualifier Q>
 inline constexpr qua<T, Q> conjugate(qua<T, Q> const& q)
 {
  return qua<T, Q>::wxyz(q.w, -q.x, -q.y, -q.z);
 }

 template<typename T, qualifier Q>
 inline constexpr qua<T, Q> inverse(qua<T, Q> const& q)
 {
  return conjugate(q) / dot(q, q);
 }

 template<typename T, qualifier Q>
 inline vec<4, bool, Q> isnan(qua<T, Q> const& q)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'isnan' only accept floating-point inputs");

  return vec<4, bool, Q>(isnan(q.x), isnan(q.y), isnan(q.z), isnan(q.w));
 }

 template<typename T, qualifier Q>
 inline vec<4, bool, Q> isinf(qua<T, Q> const& q)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'isinf' only accept floating-point inputs");

  return vec<4, bool, Q>(isinf(q.x), isinf(q.y), isinf(q.z), isinf(q.w));
 }
}
# 136 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_common.hpp" 2
# 100 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_double.hpp" 1
# 20 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_double.hpp"
       


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_quat.hpp" 1



       







# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_relational.hpp" 1
# 17 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_relational.hpp"
       
# 26 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_relational.hpp"
namespace glm
{







 template<typename T, qualifier Q>
 [[nodiscard]] vec<4, bool, Q> equal(qua<T, Q> const& x, qua<T, Q> const& y);





 template<typename T, qualifier Q>
 [[nodiscard]] vec<4, bool, Q> equal(qua<T, Q> const& x, qua<T, Q> const& y, T epsilon);





 template<typename T, qualifier Q>
 [[nodiscard]] vec<4, bool, Q> notEqual(qua<T, Q> const& x, qua<T, Q> const& y);





 template<typename T, qualifier Q>
 [[nodiscard]] vec<4, bool, Q> notEqual(qua<T, Q> const& x, qua<T, Q> const& y, T epsilon);


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_relational.inl" 1
namespace glm
{
 template<typename T, qualifier Q>
 inline vec<4, bool, Q> equal(qua<T, Q> const& x, qua<T, Q> const& y)
 {
  vec<4, bool, Q> Result;
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] == y[i];
  return Result;
 }

 template<typename T, qualifier Q>
 inline vec<4, bool, Q> equal(qua<T, Q> const& x, qua<T, Q> const& y, T epsilon)
 {
  vec<4, T, Q> v(x.x - y.x, x.y - y.y, x.z - y.z, x.w - y.w);
  return lessThan(abs(v), vec<4, T, Q>(epsilon));
 }

 template<typename T, qualifier Q>
 inline vec<4, bool, Q> notEqual(qua<T, Q> const& x, qua<T, Q> const& y)
 {
  vec<4, bool, Q> Result;
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] != y[i];
  return Result;
 }

 template<typename T, qualifier Q>
 inline vec<4, bool, Q> notEqual(qua<T, Q> const& x, qua<T, Q> const& y, T epsilon)
 {
  vec<4, T, Q> v(x.x - y.x, x.y - y.y, x.z - y.z, x.w - y.w);
  return greaterThanEqual(abs(v), vec<4, T, Q>(epsilon));
 }
}
# 63 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_relational.hpp" 2
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_quat.hpp" 2

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/matrix_transform.hpp" 1
# 21 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/matrix_transform.hpp"
       
# 36 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/matrix_transform.hpp"
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/matrix_transform.inl" 1
# 37 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/matrix_transform.hpp" 2
# 15 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_quat.hpp" 2

namespace glm
{


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpedantic"
# 32 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_quat.hpp"
 template<typename T, qualifier Q>
 struct qua
 {


  typedef qua<T, Q> type;
  typedef T value_type;
# 57 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_quat.hpp"
    T x, y, z, w;





  typedef length_t length_type;


  [[nodiscard]] static constexpr length_type length(){return 4;}

  [[nodiscard]] constexpr T & operator[](length_type i);
  [[nodiscard]] constexpr T const& operator[](length_type i) const;



  constexpr qua() = default;
  constexpr qua(qua<T, Q> const& q) = default;
  template<qualifier P>
  constexpr qua(qua<T, P> const& q);



  constexpr qua(T s, vec<3, T, Q> const& v);




  constexpr qua(T w, T x, T y, T z);


  [[nodiscard]] static constexpr qua<T, Q> wxyz(T w, T x, T y, T z);



  template<typename U, qualifier P>
  constexpr qua(qua<U, P> const& q);



   [[nodiscard]] explicit operator mat<3, 3, T, Q>() const;
   [[nodiscard]] explicit operator mat<4, 4, T, Q>() const;
# 107 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_quat.hpp"
  qua(vec<3, T, Q> const& u, vec<3, T, Q> const& v);


  constexpr qua(vec<3, T, Q> const& eulerAngles);
  constexpr qua(mat<3, 3, T, Q> const& q);
  constexpr qua(mat<4, 4, T, Q> const& q);



  constexpr qua<T, Q>& operator=(qua<T, Q> const& q) = default;

  template<typename U>
  constexpr qua<T, Q>& operator=(qua<U, Q> const& q);
  template<typename U>
  constexpr qua<T, Q>& operator+=(qua<U, Q> const& q);
  template<typename U>
  constexpr qua<T, Q>& operator-=(qua<U, Q> const& q);
  template<typename U>
  constexpr qua<T, Q>& operator*=(qua<U, Q> const& q);
  template<typename U>
  constexpr qua<T, Q>& operator*=(U s);
  template<typename U>
  constexpr qua<T, Q>& operator/=(U s);
 };





#pragma GCC diagnostic pop







 template<typename T, qualifier Q>
 [[nodiscard]] constexpr qua<T, Q> operator+(qua<T, Q> const& q);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr qua<T, Q> operator-(qua<T, Q> const& q);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr qua<T, Q> operator+(qua<T, Q> const& q, qua<T, Q> const& p);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr qua<T, Q> operator-(qua<T, Q> const& q, qua<T, Q> const& p);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr qua<T, Q> operator*(qua<T, Q> const& q, qua<T, Q> const& p);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator*(qua<T, Q> const& q, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v, qua<T, Q> const& q);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator*(qua<T, Q> const& q, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v, qua<T, Q> const& q);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr qua<T, Q> operator*(qua<T, Q> const& q, T const& s);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr qua<T, Q> operator*(T const& s, qua<T, Q> const& q);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr qua<T, Q> operator/(qua<T, Q> const& q, T const& s);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(qua<T, Q> const& q1, qua<T, Q> const& q2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(qua<T, Q> const& q1, qua<T, Q> const& q2);
}


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_quat.inl" 1






namespace glm{
namespace detail
{
 template <typename T>
 struct genTypeTrait<qua<T> >
 {
  static const genTypeEnum GENTYPE = GENTYPE_QUAT;
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_dot<qua<T, Q>, T, Aligned>
 {
  inline constexpr static T call(qua<T, Q> const& a, qua<T, Q> const& b)
  {
   vec<4, T, Q> tmp(a.w * b.w, a.x * b.x, a.y * b.y, a.z * b.z);
   return (tmp.x + tmp.y) + (tmp.z + tmp.w);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_quat_add
 {
  inline constexpr static qua<T, Q> call(qua<T, Q> const& q, qua<T, Q> const& p)
  {
   return qua<T, Q>::wxyz(q.w + p.w, q.x + p.x, q.y + p.y, q.z + p.z);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_quat_sub
 {
  inline constexpr static qua<T, Q> call(qua<T, Q> const& q, qua<T, Q> const& p)
  {
   return qua<T, Q>::wxyz(q.w - p.w, q.x - p.x, q.y - p.y, q.z - p.z);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_quat_mul_scalar
 {
  inline constexpr static qua<T, Q> call(qua<T, Q> const& q, T s)
  {
   return qua<T, Q>::wxyz(q.w * s, q.x * s, q.y * s, q.z * s);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_quat_div_scalar
 {
  inline constexpr static qua<T, Q> call(qua<T, Q> const& q, T s)
  {
   return qua<T, Q>::wxyz(q.w / s, q.x / s, q.y / s, q.z / s);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_quat_mul_vec4
 {
  inline constexpr static vec<4, T, Q> call(qua<T, Q> const& q, vec<4, T, Q> const& v)
  {
   return vec<4, T, Q>(q * vec<3, T, Q>(v), v.w);
  }
 };
}



 template<typename T, qualifier Q>
 inline constexpr T & qua<T, Q>::operator[](typename qua<T, Q>::length_type i)
 {
  (
# 77 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_quat.inl" 3
 ((void)0)
# 77 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_quat.inl"
 );



   return (&x)[i];

 }

 template<typename T, qualifier Q>
 inline constexpr T const& qua<T, Q>::operator[](typename qua<T, Q>::length_type i) const
 {
  (
# 88 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_quat.inl" 3
 ((void)0)
# 88 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_quat.inl"
 );



   return (&x)[i];

 }
# 122 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_quat.inl"
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr qua<T, Q>::qua(qua<T, P> const& q)



   : x(q.x), y(q.y), z(q.z), w(q.w)

 {}



 template<typename T, qualifier Q>
 inline constexpr qua<T, Q>::qua(T s, vec<3, T, Q> const& v)



   : x(v.x), y(v.y), z(v.z), w(s)

 {}

 template <typename T, qualifier Q>



 inline constexpr qua<T, Q>::qua(T _w, T _x, T _y, T _z)




   : x(_x), y(_y), z(_z), w(_w)

 {}

 template <typename T, qualifier Q>
 constexpr qua<T, Q> qua<T, Q>::wxyz(T w, T x, T y, T z) {



  return qua<T, Q>(w, x, y, z);

 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr qua<T, Q>::qua(qua<U, P> const& q)



   : x(static_cast<T>(q.x)), y(static_cast<T>(q.y)), z(static_cast<T>(q.z)), w(static_cast<T>(q.w))

 {}
# 195 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_quat.inl"
 template<typename T, qualifier Q>
 inline qua<T, Q>::qua(vec<3, T, Q> const& u, vec<3, T, Q> const& v)
 {
  T norm_u_norm_v = sqrt(dot(u, u) * dot(v, v));
  T real_part = norm_u_norm_v + dot(u, v);
  vec<3, T, Q> t;

  if(real_part < static_cast<T>(1.e-6f) * norm_u_norm_v)
  {



   real_part = static_cast<T>(0);
   t = abs(u.x) > abs(u.z) ? vec<3, T, Q>(-u.y, u.x, static_cast<T>(0)) : vec<3, T, Q>(static_cast<T>(0), -u.z, u.y);
  }
  else
  {

   t = cross(u, v);
  }

  *this = normalize(qua<T, Q>::wxyz(real_part, t.x, t.y, t.z));
 }

 template<typename T, qualifier Q>
 inline constexpr qua<T, Q>::qua(vec<3, T, Q> const& eulerAngle)
 {
  vec<3, T, Q> c = glm::cos(eulerAngle * T(0.5));
  vec<3, T, Q> s = glm::sin(eulerAngle * T(0.5));

  this->w = c.x * c.y * c.z + s.x * s.y * s.z;
  this->x = s.x * c.y * c.z - c.x * s.y * s.z;
  this->y = c.x * s.y * c.z + s.x * c.y * s.z;
  this->z = c.x * c.y * s.z - s.x * s.y * c.z;
 }

 template<typename T, qualifier Q>
 inline constexpr qua<T, Q>::qua(mat<3, 3, T, Q> const& m)
 {
  *this = quat_cast(m);
 }

 template<typename T, qualifier Q>
 inline constexpr qua<T, Q>::qua(mat<4, 4, T, Q> const& m)
 {
  *this = quat_cast(m);
 }


 template<typename T, qualifier Q>
 inline qua<T, Q>::operator mat<3, 3, T, Q>() const
 {
  return mat3_cast(*this);
 }

 template<typename T, qualifier Q>
 inline qua<T, Q>::operator mat<4, 4, T, Q>() const
 {
  return mat4_cast(*this);
 }
# 271 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_quat.inl"
 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr qua<T, Q> & qua<T, Q>::operator=(qua<U, Q> const& q)
 {
  this->w = static_cast<T>(q.w);
  this->x = static_cast<T>(q.x);
  this->y = static_cast<T>(q.y);
  this->z = static_cast<T>(q.z);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr qua<T, Q> & qua<T, Q>::operator+=(qua<U, Q> const& q)
 {
  return (*this = detail::compute_quat_add<T, Q, detail::is_aligned<Q>::value>::call(*this, qua<T, Q>(q)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr qua<T, Q> & qua<T, Q>::operator-=(qua<U, Q> const& q)
 {
  return (*this = detail::compute_quat_sub<T, Q, detail::is_aligned<Q>::value>::call(*this, qua<T, Q>(q)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr qua<T, Q> & qua<T, Q>::operator*=(qua<U, Q> const& r)
 {
  qua<T, Q> const p(*this);
  qua<T, Q> const q(r);

  this->w = p.w * q.w - p.x * q.x - p.y * q.y - p.z * q.z;
  this->x = p.w * q.x + p.x * q.w + p.y * q.z - p.z * q.y;
  this->y = p.w * q.y + p.y * q.w + p.z * q.x - p.x * q.z;
  this->z = p.w * q.z + p.z * q.w + p.x * q.y - p.y * q.x;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr qua<T, Q> & qua<T, Q>::operator*=(U s)
 {
  return (*this = detail::compute_quat_mul_scalar<T, Q, detail::is_aligned<Q>::value>::call(*this, static_cast<U>(s)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr qua<T, Q> & qua<T, Q>::operator/=(U s)
 {
  return (*this = detail::compute_quat_div_scalar<T, Q, detail::is_aligned<Q>::value>::call(*this, static_cast<U>(s)));
 }



 template<typename T, qualifier Q>
 inline constexpr qua<T, Q> operator+(qua<T, Q> const& q)
 {
  return q;
 }

 template<typename T, qualifier Q>
 inline constexpr qua<T, Q> operator-(qua<T, Q> const& q)
 {
  return qua<T, Q>::wxyz(-q.w, -q.x, -q.y, -q.z);
 }



 template<typename T, qualifier Q>
 inline constexpr qua<T, Q> operator+(qua<T, Q> const& q, qua<T, Q> const& p)
 {
  return qua<T, Q>(q) += p;
 }

 template<typename T, qualifier Q>
 inline constexpr qua<T, Q> operator-(qua<T, Q> const& q, qua<T, Q> const& p)
 {
  return qua<T, Q>(q) -= p;
 }

 template<typename T, qualifier Q>
 inline constexpr qua<T, Q> operator*(qua<T, Q> const& q, qua<T, Q> const& p)
 {
  return qua<T, Q>(q) *= p;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator*(qua<T, Q> const& q, vec<3, T, Q> const& v)
 {
  vec<3, T, Q> const QuatVector(q.x, q.y, q.z);
  vec<3, T, Q> const uv(glm::cross(QuatVector, v));
  vec<3, T, Q> const uuv(glm::cross(QuatVector, uv));

  return v + ((uv * q.w) + uuv) * static_cast<T>(2);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v, qua<T, Q> const& q)
 {
  return glm::inverse(q) * v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator*(qua<T, Q> const& q, vec<4, T, Q> const& v)
 {
  return detail::compute_quat_mul_vec4<T, Q, detail::is_aligned<Q>::value>::call(q, v);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v, qua<T, Q> const& q)
 {
  return glm::inverse(q) * v;
 }

 template<typename T, qualifier Q>
 inline constexpr qua<T, Q> operator*(qua<T, Q> const& q, T const& s)
 {
  return qua<T, Q>::wxyz(
   q.w * s, q.x * s, q.y * s, q.z * s);
 }

 template<typename T, qualifier Q>
 inline constexpr qua<T, Q> operator*(T const& s, qua<T, Q> const& q)
 {
  return q * s;
 }

 template<typename T, qualifier Q>
 inline constexpr qua<T, Q> operator/(qua<T, Q> const& q, T const& s)
 {
  return qua<T, Q>::wxyz(
   q.w / s, q.x / s, q.y / s, q.z / s);
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(qua<T, Q> const& q1, qua<T, Q> const& q2)
 {
  return q1.x == q2.x && q1.y == q2.y && q1.z == q2.z && q1.w == q2.w;
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(qua<T, Q> const& q1, qua<T, Q> const& q2)
 {
  return q1.x != q2.x || q1.y != q2.y || q1.z != q2.z || q1.w != q2.w;
 }
}
# 193 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/type_quat.hpp" 2
# 24 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_double.hpp" 2





namespace glm
{




 typedef qua<double, defaultp> dquat;


}
# 101 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_double_precision.hpp" 1
# 11 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_double_precision.hpp"
       
# 20 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_double_precision.hpp"
namespace glm
{






 typedef qua<double, lowp> lowp_dquat;




 typedef qua<double, mediump> mediump_dquat;




 typedef qua<double, highp> highp_dquat;


}
# 102 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_float.hpp" 1
# 20 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_float.hpp"
       
# 29 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_float.hpp"
namespace glm
{




 typedef qua<float, defaultp> quat;


}
# 103 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_float_precision.hpp" 1
# 11 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_float_precision.hpp"
       
# 20 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_float_precision.hpp"
namespace glm
{




 typedef qua<float, lowp> lowp_quat;


 typedef qua<float, mediump> mediump_quat;


 typedef qua<float, highp> highp_quat;


}
# 104 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_exponential.hpp" 1
# 15 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_exponential.hpp"
       
# 27 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_exponential.hpp"
namespace glm
{







 template<typename T, qualifier Q>
 [[nodiscard]] qua<T, Q> exp(qua<T, Q> const& q);





 template<typename T, qualifier Q>
 [[nodiscard]] qua<T, Q> log(qua<T, Q> const& q);





 template<typename T, qualifier Q>
 [[nodiscard]] qua<T, Q> pow(qua<T, Q> const& q, T y);





 template<typename T, qualifier Q>
 [[nodiscard]] qua<T, Q> sqrt(qua<T, Q> const& q);


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_exponential.inl" 1


namespace glm
{
 template<typename T, qualifier Q>
 inline qua<T, Q> exp(qua<T, Q> const& q)
 {
  vec<3, T, Q> u(q.x, q.y, q.z);
  T const Angle = glm::length(u);
  if (Angle < epsilon<T>())
   return qua<T, Q>();

  vec<3, T, Q> const v(u / Angle);
  return qua<T, Q>(cos(Angle), sin(Angle) * v);
 }

 template<typename T, qualifier Q>
 inline qua<T, Q> log(qua<T, Q> const& q)
 {
  vec<3, T, Q> u(q.x, q.y, q.z);
  T Vec3Len = length(u);

  if (Vec3Len < epsilon<T>())
  {
   if(q.w > static_cast<T>(0))
    return qua<T, Q>::wxyz(log(q.w), static_cast<T>(0), static_cast<T>(0), static_cast<T>(0));
   else if(q.w < static_cast<T>(0))
    return qua<T, Q>::wxyz(log(-q.w), pi<T>(), static_cast<T>(0), static_cast<T>(0));
   else
    return qua<T, Q>::wxyz(std::numeric_limits<T>::infinity(), std::numeric_limits<T>::infinity(), std::numeric_limits<T>::infinity(), std::numeric_limits<T>::infinity());
  }
  else
  {
   T t = atan(Vec3Len, T(q.w)) / Vec3Len;
   T QuatLen2 = Vec3Len * Vec3Len + q.w * q.w;
   return qua<T, Q>::wxyz(static_cast<T>(0.5) * log(QuatLen2), t * q.x, t * q.y, t * q.z);
  }
 }

 template<typename T, qualifier Q>
 inline qua<T, Q> pow(qua<T, Q> const& x, T y)
 {


  if(y > -epsilon<T>() && y < epsilon<T>())
   return qua<T, Q>::wxyz(1,0,0,0);


  T magnitude = sqrt(x.x * x.x + x.y * x.y + x.z * x.z + x.w *x.w);

  T Angle;
  if(abs(x.w / magnitude) > cos_one_over_two<T>())
  {




   T VectorMagnitude = x.x * x.x + x.y * x.y + x.z * x.z;




   if (VectorMagnitude < std::numeric_limits<T>::min()) {

    return qua<T, Q>::wxyz(pow(x.w, y), 0, 0, 0);
   }

   Angle = asin(sqrt(VectorMagnitude) / magnitude);
  }
  else
  {

   Angle = acos(x.w / magnitude);
  }

  T NewAngle = Angle * y;
  T Div = sin(NewAngle) / sin(Angle);
  T Mag = pow(magnitude, y - static_cast<T>(1));
  return qua<T, Q>::wxyz(cos(NewAngle) * magnitude * Mag, x.x * Div * Mag, x.y * Div * Mag, x.z * Div * Mag);
 }

 template<typename T, qualifier Q>
 inline qua<T, Q> sqrt(qua<T, Q> const& x)
 {
  return pow(x, static_cast<T>(0.5));
 }
}
# 64 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_exponential.hpp" 2
# 105 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_transform.hpp" 1
# 18 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_transform.hpp"
       
# 29 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_transform.hpp"
namespace glm
{
# 42 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_transform.hpp"
 template<typename T, qualifier Q>
 [[nodiscard]] qua<T, Q> rotate(qua<T, Q> const& q, T const& angle, vec<3, T, Q> const& axis);

}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_transform.inl" 1
namespace glm
{
 template<typename T, qualifier Q>
 inline qua<T, Q> rotate(qua<T, Q> const& q, T const& angle, vec<3, T, Q> const& v)
 {
  vec<3, T, Q> Tmp = v;


  T len = glm::length(Tmp);
  if(abs(len - static_cast<T>(1)) > static_cast<T>(0.001))
  {
   T oneOverLen = static_cast<T>(1) / len;
   Tmp.x *= oneOverLen;
   Tmp.y *= oneOverLen;
   Tmp.z *= oneOverLen;
  }

  T const AngleRad(angle);
  T const Sin = sin(AngleRad * static_cast<T>(0.5));

  return q * qua<T, Q>::wxyz(cos(AngleRad * static_cast<T>(0.5)), Tmp.x * Sin, Tmp.y * Sin, Tmp.z * Sin);
 }
}
# 48 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_transform.hpp" 2
# 108 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_trigonometric.hpp" 1
# 18 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_trigonometric.hpp"
       
# 31 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_trigonometric.hpp"
namespace glm
{
# 42 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_trigonometric.hpp"
 template<typename T, qualifier Q>
 [[nodiscard]] T angle(qua<T, Q> const& x);





 template<typename T, qualifier Q>
 [[nodiscard]] vec<3, T, Q> axis(qua<T, Q> const& x);
# 59 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_trigonometric.hpp"
 template<typename T, qualifier Q>
 [[nodiscard]] qua<T, Q> angleAxis(T const& angle, vec<3, T, Q> const& axis);


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_trigonometric.inl" 1


namespace glm
{
 template<typename T, qualifier Q>
 inline T angle(qua<T, Q> const& x)
 {
  if (abs(x.w) > cos_one_over_two<T>())
  {
   T const a = asin(sqrt(x.x * x.x + x.y * x.y + x.z * x.z)) * static_cast<T>(2);
   if(x.w < static_cast<T>(0))
    return pi<T>() * static_cast<T>(2) - a;
   return a;
  }

  return acos(x.w) * static_cast<T>(2);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> axis(qua<T, Q> const& x)
 {
  T const tmp1 = static_cast<T>(1) - x.w * x.w;
  if(tmp1 <= static_cast<T>(0))
   return vec<3, T, Q>(0, 0, 1);
  T const tmp2 = static_cast<T>(1) / sqrt(tmp1);
  return vec<3, T, Q>(x.x * tmp2, x.y * tmp2, x.z * tmp2);
 }

 template<typename T, qualifier Q>
 inline qua<T, Q> angleAxis(T const& angle, vec<3, T, Q> const& v)
 {
  T const a(angle);
  T const s = glm::sin(a * static_cast<T>(0.5));

  return qua<T, Q>(glm::cos(a * static_cast<T>(0.5)), v * s);
 }
}
# 66 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/quaternion_trigonometric.hpp" 2
# 109 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_common.hpp" 1
# 14 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_common.hpp"
       
# 23 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_common.hpp"
namespace glm
{
# 33 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_common.hpp"
 template<typename T>
 [[nodiscard]] T min(T a, T b, T c);






 template<typename T>
 [[nodiscard]] T min(T a, T b, T c, T d);






 template<typename T>
 [[nodiscard]] T max(T a, T b, T c);






 template<typename T>
 [[nodiscard]] T max(T a, T b, T c, T d);







 template<typename T>
 [[nodiscard]] T fmin(T a, T b);







 template<typename T>
 [[nodiscard]] T fmin(T a, T b, T c);







 template<typename T>
 [[nodiscard]] T fmin(T a, T b, T c, T d);







 template<typename T>
 [[nodiscard]] T fmax(T a, T b);







 template<typename T>
 [[nodiscard]] T fmax(T a, T b, T C);







 template<typename T>
 [[nodiscard]] T fmax(T a, T b, T C, T D);






 template<typename genType>
 [[nodiscard]] genType fclamp(genType x, genType minVal, genType maxVal);






 template<typename genType>
 [[nodiscard]] genType clamp(genType const& Texcoord);






 template<typename genType>
 [[nodiscard]] genType repeat(genType const& Texcoord);






 template<typename genType>
 [[nodiscard]] genType mirrorClamp(genType const& Texcoord);






 template<typename genType>
 [[nodiscard]] genType mirrorRepeat(genType const& Texcoord);
# 163 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_common.hpp"
 template<typename genType>
 [[nodiscard]] int iround(genType const& x);
# 175 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_common.hpp"
 template<typename genType>
 [[nodiscard]] uint uround(genType const& x);


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_common.inl" 1
namespace glm
{
 template<typename T>
 inline T min(T a, T b, T c)
 {
  return glm::min(glm::min(a, b), c);
 }

 template<typename T>
 inline T min(T a, T b, T c, T d)
 {
  return glm::min(glm::min(a, b), glm::min(c, d));
 }

 template<typename T>
 inline T max(T a, T b, T c)
 {
  return glm::max(glm::max(a, b), c);
 }

 template<typename T>
 inline T max(T a, T b, T c, T d)
 {
  return glm::max(glm::max(a, b), glm::max(c, d));
 }


  using std::fmin;
# 41 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_common.inl"
 template<typename T>
 inline T fmin(T a, T b, T c)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'fmin' only accept floating-point input");

  if (isnan(a))
   return fmin(b, c);
  if (isnan(b))
   return fmin(a, c);
  if (isnan(c))
   return min(a, b);
  return min(a, b, c);
 }

 template<typename T>
 inline T fmin(T a, T b, T c, T d)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'fmin' only accept floating-point input");

  if (isnan(a))
   return fmin(b, c, d);
  if (isnan(b))
   return min(a, fmin(c, d));
  if (isnan(c))
   return fmin(min(a, b), d);
  if (isnan(d))
   return min(a, b, c);
  return min(a, b, c, d);
 }



  using std::fmax;
# 86 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_common.inl"
 template<typename T>
 inline T fmax(T a, T b, T c)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'fmax' only accept floating-point input");

  if (isnan(a))
   return fmax(b, c);
  if (isnan(b))
   return fmax(a, c);
  if (isnan(c))
   return max(a, b);
  return max(a, b, c);
 }

 template<typename T>
 inline T fmax(T a, T b, T c, T d)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'fmax' only accept floating-point input");

  if (isnan(a))
   return fmax(b, c, d);
  if (isnan(b))
   return max(a, fmax(c, d));
  if (isnan(c))
   return fmax(max(a, b), d);
  if (isnan(d))
   return max(a, b, c);
  return max(a, b, c, d);
 }


 template<typename genType>
 inline genType fclamp(genType x, genType minVal, genType maxVal)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'fclamp' only accept floating-point or integer inputs");
  return fmin(fmax(x, minVal), maxVal);
 }

 template<typename genType>
 inline genType clamp(genType const& Texcoord)
 {
  return glm::clamp(Texcoord, static_cast<genType>(0), static_cast<genType>(1));
 }

 template<typename genType>
 inline genType repeat(genType const& Texcoord)
 {
  return glm::fract(Texcoord);
 }

 template<typename genType>
 inline genType mirrorClamp(genType const& Texcoord)
 {
  return glm::fract(glm::abs(Texcoord));
 }

 template<typename genType>
 inline genType mirrorRepeat(genType const& Texcoord)
 {
  genType const Abs = glm::abs(Texcoord);
  genType const Clamp = glm::mod(glm::floor(Abs), static_cast<genType>(2));
  genType const Floor = glm::floor(Abs);
  genType const Rest = Abs - Floor;
  genType const Mirror = Clamp + Rest;
  return mix(Rest, static_cast<genType>(1) - Rest, Mirror >= static_cast<genType>(1));
 }

 template<typename genType>
 inline int iround(genType const& x)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'iround' only accept floating-point inputs");
  
# 157 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_common.inl" 3
 ((void)0)
# 157 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_common.inl"
                                       ;

  return static_cast<int>(x + static_cast<genType>(0.5));
 }

 template<typename genType>
 inline uint uround(genType const& x)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'uround' only accept floating-point inputs");
  
# 166 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_common.inl" 3
 ((void)0)
# 166 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_common.inl"
                                       ;

  return static_cast<uint>(x + static_cast<genType>(0.5));
 }
}
# 182 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_common.hpp" 2
# 111 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_integer.hpp" 1
# 11 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_integer.hpp"
       


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/setup.hpp" 1
# 15 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_integer.hpp" 2
# 26 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_integer.hpp"
namespace glm
{






 template<typename genIUType>
 [[nodiscard]] bool isPowerOfTwo(genIUType v);





 template<typename genIUType>
 [[nodiscard]] genIUType nextPowerOfTwo(genIUType v);





 template<typename genIUType>
 [[nodiscard]] genIUType prevPowerOfTwo(genIUType v);




 template<typename genIUType>
 [[nodiscard]] bool isMultiple(genIUType v, genIUType Multiple);
# 65 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_integer.hpp"
 template<typename genIUType>
 [[nodiscard]] genIUType nextMultiple(genIUType v, genIUType Multiple);
# 76 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_integer.hpp"
 template<typename genIUType>
 [[nodiscard]] genIUType prevMultiple(genIUType v, genIUType Multiple);
# 86 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_integer.hpp"
 template<typename genIUType>
 [[nodiscard]] int findNSB(genIUType x, int significantBitCount);


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_integer.inl" 1


namespace glm{
namespace detail
{
 template<length_t L, typename T, qualifier Q, bool compute = false>
 struct compute_ceilShift
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& v, T)
  {
   return v;
  }
 };

 template<length_t L, typename T, qualifier Q>
 struct compute_ceilShift<L, T, Q, true>
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& v, T Shift)
  {
   return v | (v >> Shift);
  }
 };

 template<length_t L, typename T, qualifier Q, bool isSigned = true>
 struct compute_ceilPowerOfTwo
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   static_assert(!std::numeric_limits<T>::is_iec559 || 0, "'ceilPowerOfTwo' only accept integer scalar or vector inputs");

   vec<L, T, Q> const Sign(sign(x));

   vec<L, T, Q> v(abs(x));

   v = v - static_cast<T>(1);
   v = v | (v >> static_cast<T>(1));
   v = v | (v >> static_cast<T>(2));
   v = v | (v >> static_cast<T>(4));
   v = compute_ceilShift<L, T, Q, sizeof(T) >= 2>::call(v, 8);
   v = compute_ceilShift<L, T, Q, sizeof(T) >= 4>::call(v, 16);
   v = compute_ceilShift<L, T, Q, sizeof(T) >= 8>::call(v, 32);
   return (v + static_cast<T>(1)) * Sign;
  }
 };

 template<length_t L, typename T, qualifier Q>
 struct compute_ceilPowerOfTwo<L, T, Q, false>
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   static_assert(!std::numeric_limits<T>::is_iec559 || 0, "'ceilPowerOfTwo' only accept integer scalar or vector inputs");

   vec<L, T, Q> v(x);

   v = v - static_cast<T>(1);
   v = v | (v >> static_cast<T>(1));
   v = v | (v >> static_cast<T>(2));
   v = v | (v >> static_cast<T>(4));
   v = compute_ceilShift<L, T, Q, sizeof(T) >= 2>::call(v, 8);
   v = compute_ceilShift<L, T, Q, sizeof(T) >= 4>::call(v, 16);
   v = compute_ceilShift<L, T, Q, sizeof(T) >= 8>::call(v, 32);
   return v + static_cast<T>(1);
  }
 };

 template<bool is_float, bool is_signed>
 struct compute_ceilMultiple{};

 template<>
 struct compute_ceilMultiple<true, true>
 {
  template<typename genType>
  inline static genType call(genType Source, genType Multiple)
  {
   if(Source > genType(0))
    return Source + (Multiple - std::fmod(Source, Multiple));
   else
    return Source + std::fmod(-Source, Multiple);
  }
 };

 template<>
 struct compute_ceilMultiple<false, false>
 {
  template<typename genType>
  inline static genType call(genType Source, genType Multiple)
  {
   genType Tmp = Source - genType(1);
   return Tmp + (Multiple - (Tmp % Multiple));
  }
 };

 template<>
 struct compute_ceilMultiple<false, true>
 {
  template<typename genType>
  inline static genType call(genType Source, genType Multiple)
  {
   
# 99 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_integer.inl" 3
  ((void)0)
# 99 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_integer.inl"
                               ;
   if(Source > genType(0))
   {
    genType Tmp = Source - genType(1);
    return Tmp + (Multiple - (Tmp % Multiple));
   }
   else
    return Source + (-Source % Multiple);
  }
 };

 template<bool is_float, bool is_signed>
 struct compute_floorMultiple{};

 template<>
 struct compute_floorMultiple<true, true>
 {
  template<typename genType>
  inline static genType call(genType Source, genType Multiple)
  {
   if(Source >= genType(0))
    return Source - std::fmod(Source, Multiple);
   else
    return Source - std::fmod(Source, Multiple) - Multiple;
  }
 };

 template<>
 struct compute_floorMultiple<false, false>
 {
  template<typename genType>
  inline static genType call(genType Source, genType Multiple)
  {
   if(Source >= genType(0))
    return Source - Source % Multiple;
   else
   {
    genType Tmp = Source + genType(1);
    return Tmp - Tmp % Multiple - Multiple;
   }
  }
 };

 template<>
 struct compute_floorMultiple<false, true>
 {
  template<typename genType>
  inline static genType call(genType Source, genType Multiple)
  {
   if(Source >= genType(0))
    return Source - Source % Multiple;
   else
   {
    genType Tmp = Source + genType(1);
    return Tmp - Tmp % Multiple - Multiple;
   }
  }
 };
}

 template<typename genIUType>
 inline bool isPowerOfTwo(genIUType Value)
 {
  static_assert(std::numeric_limits<genIUType>::is_integer, "'isPowerOfTwo' only accept integer inputs");

  genIUType const Result = glm::abs(Value);
  return !(Result & (Result - 1));
 }

 template<typename genIUType>
 inline genIUType nextPowerOfTwo(genIUType value)
 {
  static_assert(std::numeric_limits<genIUType>::is_integer, "'nextPowerOfTwo' only accept integer inputs");

  return detail::compute_ceilPowerOfTwo<1, genIUType, defaultp, std::numeric_limits<genIUType>::is_signed>::call(vec<1, genIUType, defaultp>(value)).x;
 }

 template<typename genIUType>
 inline genIUType prevPowerOfTwo(genIUType value)
 {
  static_assert(std::numeric_limits<genIUType>::is_integer, "'prevPowerOfTwo' only accept integer inputs");

  return isPowerOfTwo(value) ? value : static_cast<genIUType>(static_cast<genIUType>(1) << static_cast<genIUType>(findMSB(value)));
 }

 template<typename genIUType>
 inline bool isMultiple(genIUType Value, genIUType Multiple)
 {
  static_assert(std::numeric_limits<genIUType>::is_integer, "'isMultiple' only accept integer inputs");

  return isMultiple(vec<1, genIUType>(Value), vec<1, genIUType>(Multiple)).x;
 }

 template<typename genIUType>
 inline genIUType nextMultiple(genIUType Source, genIUType Multiple)
 {
  static_assert(std::numeric_limits<genIUType>::is_integer, "'nextMultiple' only accept integer inputs");

  return detail::compute_ceilMultiple<std::numeric_limits<genIUType>::is_iec559, std::numeric_limits<genIUType>::is_signed>::call(Source, Multiple);
 }

 template<typename genIUType>
 inline genIUType prevMultiple(genIUType Source, genIUType Multiple)
 {
  static_assert(std::numeric_limits<genIUType>::is_integer, "'prevMultiple' only accept integer inputs");

  return detail::compute_floorMultiple<std::numeric_limits<genIUType>::is_iec559, std::numeric_limits<genIUType>::is_signed>::call(Source, Multiple);
 }

 template<typename genIUType>
 inline int findNSB(genIUType x, int significantBitCount)
 {
  static_assert(std::numeric_limits<genIUType>::is_integer, "'findNSB' only accept integer inputs");

  if(bitCount(x) < significantBitCount)
   return -1;

  genIUType const One = static_cast<genIUType>(1);
  int bitPos = 0;

  genIUType key = x;
  int nBitCount = significantBitCount;
  int Step = sizeof(x) * 8 / 2;
  while (key > One)
  {
   genIUType Mask = static_cast<genIUType>((One << Step) - One);
   genIUType currentKey = key & Mask;
   int currentBitCount = bitCount(currentKey);
   if (nBitCount > currentBitCount)
   {
    nBitCount -= currentBitCount;
    bitPos += Step;
    key >>= static_cast<genIUType>(Step);
   }
   else
   {
    key = key & Mask;
   }

   Step >>= 1;
  }

  return static_cast<int>(bitPos);
 }
}
# 93 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_integer.hpp" 2
# 113 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_packing.hpp" 1
# 14 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_packing.hpp"
       
# 23 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_packing.hpp"
namespace glm
{





}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_packing.inl" 1
# 33 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_packing.hpp" 2
# 114 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_reciprocal.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_reciprocal.hpp"
       


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/setup.hpp" 1
# 17 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_reciprocal.hpp" 2





namespace glm
{
# 33 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_reciprocal.hpp"
 template<typename genType>
 [[nodiscard]] genType sec(genType angle);







 template<typename genType>
 [[nodiscard]] genType csc(genType angle);







 template<typename genType>
 [[nodiscard]] genType cot(genType angle);







 template<typename genType>
 [[nodiscard]] genType asec(genType x);







 template<typename genType>
 [[nodiscard]] genType acsc(genType x);







 template<typename genType>
 [[nodiscard]] genType acot(genType x);






 template<typename genType>
 [[nodiscard]] genType sech(genType angle);






 template<typename genType>
 [[nodiscard]] genType csch(genType angle);






 template<typename genType>
 [[nodiscard]] genType coth(genType angle);







 template<typename genType>
 [[nodiscard]] genType asech(genType x);







 template<typename genType>
 [[nodiscard]] genType acsch(genType x);







 template<typename genType>
 [[nodiscard]] genType acoth(genType x);


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_reciprocal.inl" 1





namespace glm
{

 template<typename genType>
 inline genType sec(genType angle)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'sec' only accept floating-point values");
  return genType(1) / glm::cos(angle);
 }


 template<typename genType>
 inline genType csc(genType angle)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'csc' only accept floating-point values");
  return genType(1) / glm::sin(angle);
 }


 template<typename genType>
 inline genType cot(genType angle)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'cot' only accept floating-point values");

  genType const pi_over_2 = genType(3.1415926535897932384626433832795 / 2.0);
  return glm::tan(pi_over_2 - angle);
 }


 template<typename genType>
 inline genType asec(genType x)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'asec' only accept floating-point values");
  return acos(genType(1) / x);
 }


 template<typename genType>
 inline genType acsc(genType x)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'acsc' only accept floating-point values");
  return asin(genType(1) / x);
 }


 template<typename genType>
 inline genType acot(genType x)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'acot' only accept floating-point values");

  genType const pi_over_2 = genType(3.1415926535897932384626433832795 / 2.0);
  return pi_over_2 - atan(x);
 }


 template<typename genType>
 inline genType sech(genType angle)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'sech' only accept floating-point values");
  return genType(1) / glm::cosh(angle);
 }


 template<typename genType>
 inline genType csch(genType angle)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'csch' only accept floating-point values");
  return genType(1) / glm::sinh(angle);
 }


 template<typename genType>
 inline genType coth(genType angle)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'coth' only accept floating-point values");
  return glm::cosh(angle) / glm::sinh(angle);
 }


 template<typename genType>
 inline genType asech(genType x)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'asech' only accept floating-point values");
  return acosh(genType(1) / x);
 }


 template<typename genType>
 inline genType acsch(genType x)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'acsch' only accept floating-point values");
  return asinh(genType(1) / x);
 }


 template<typename genType>
 inline genType acoth(genType x)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'acoth' only accept floating-point values");
  return atanh(genType(1) / x);
 }
}
# 136 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_reciprocal.hpp" 2
# 115 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_relational.hpp" 1
# 15 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_relational.hpp"
       
# 24 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_relational.hpp"
namespace glm
{







 template<typename genType>
 [[nodiscard]] constexpr bool equal(genType const& x, genType const& y, genType const& epsilon);





 template<typename genType>
 [[nodiscard]] constexpr bool notEqual(genType const& x, genType const& y, genType const& epsilon);
# 51 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_relational.hpp"
 template<typename genType>
 [[nodiscard]] constexpr bool equal(genType const& x, genType const& y, int ULPs);
# 62 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_relational.hpp"
 template<typename genType>
 [[nodiscard]] constexpr bool notEqual(genType const& x, genType const& y, int ULPs);


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_relational.inl" 1





namespace glm
{
 template<typename genType>
 inline constexpr bool equal(genType const& x, genType const& y, genType const& epsilon)
 {
  return abs(x - y) <= epsilon;
 }

 template<typename genType>
 inline constexpr bool notEqual(genType const& x, genType const& y, genType const& epsilon)
 {
  return abs(x - y) > epsilon;
 }

 template<typename genType>
 inline constexpr bool equal(genType const& x, genType const& y, int MaxULPs)
 {
  detail::float_t<genType> const a(x);
  detail::float_t<genType> const b(y);


  if(a.negative() != b.negative())
   return false;


  typename detail::float_t<genType>::int_type const DiffULPs = abs(a.i - b.i);
  return DiffULPs <= MaxULPs;
 }

 template<typename genType>
 inline constexpr bool notEqual(genType const& x, genType const& y, int ULPs)
 {
  return !equal(x, y, ULPs);
 }
}
# 69 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_relational.hpp" 2
# 116 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_ulp.hpp" 1
# 16 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_ulp.hpp"
       
# 27 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_ulp.hpp"
namespace glm
{
# 37 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_ulp.hpp"
 template<typename genType>
 [[nodiscard]] genType nextFloat(genType x);






 template<typename genType>
 [[nodiscard]] genType prevFloat(genType x);






 template<typename genType>
 [[nodiscard]] genType nextFloat(genType x, int ULPs);






 template<typename genType>
 [[nodiscard]] genType prevFloat(genType x, int ULPs);




 [[nodiscard]] int floatDistance(float x, float y);




 [[nodiscard]] int64 floatDistance(double x, double y);


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_ulp.inl" 1
# 10 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_ulp.inl"
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 1 3
# 39 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 3
       
# 40 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 3
# 11 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_ulp.inl" 2
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cfloat" 1 3
# 39 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cfloat" 3
       
# 40 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cfloat" 3


# 1 "D:/Enviroments/mingw64_msvcrt/lib/gcc/x86_64-w64-mingw32/14.2.0/include/float.h" 1 3 4
# 632 "D:/Enviroments/mingw64_msvcrt/lib/gcc/x86_64-w64-mingw32/14.2.0/include/float.h" 3 4
# 1 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/float.h" 1 3 4
# 633 "D:/Enviroments/mingw64_msvcrt/lib/gcc/x86_64-w64-mingw32/14.2.0/include/float.h" 2 3 4
# 43 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cfloat" 2 3
# 12 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_ulp.inl" 2
# 23 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_ulp.inl"
typedef union
{
 float value;

 unsigned int word;
} ieee_float_shape_type;

typedef union
{
 double value;
 struct
 {
  int lsw;
  int msw;
 } parts;
} ieee_double_shape_type;
# 70 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_ulp.inl"
namespace glm{
namespace detail
{
 inline float nextafterf(float x, float y)
 {
  volatile float t;
  int hx, hy, ix, iy;

  do { ieee_float_shape_type gf_u; gf_u.value = (x); (hx) = static_cast<int>(gf_u.word); } while (0);
  do { ieee_float_shape_type gf_u; gf_u.value = (y); (hy) = static_cast<int>(gf_u.word); } while (0);
  ix = hx & 0x7fffffff;
  iy = hy & 0x7fffffff;

  if((ix > 0x7f800000) ||
   (iy > 0x7f800000))
   return x + y;
  if(abs(y - x) <= epsilon<float>())
   return y;
  if(ix == 0)
  {
   do { ieee_float_shape_type sf_u; sf_u.word = static_cast<unsigned int>((hy & 0x80000000) | 1); (x) = sf_u.value; } while (0);
   t = x * x;
   if(abs(t - x) <= epsilon<float>())
    return t;
   else
    return x;
  }
  if(hx >= 0)
  {
   if(hx > hy)
    hx -= 1;
   else
    hx += 1;
  }
  else
  {
   if(hy >= 0 || hx > hy)
    hx -= 1;
   else
    hx += 1;
  }
  hy = hx & 0x7f800000;
  if(hy >= 0x7f800000)
   return x + x;
  if(hy < 0x00800000)
  {
   t = x * x;
   if(abs(t - x) > epsilon<float>())
   {
    do { ieee_float_shape_type sf_u; sf_u.word = static_cast<unsigned int>(hx); (y) = sf_u.value; } while (0);
    return y;
   }
  }
  do { ieee_float_shape_type sf_u; sf_u.word = static_cast<unsigned int>(hx); (x) = sf_u.value; } while (0);
  return x;
 }

 inline double nextafter(double x, double y)
 {
  volatile double t;
  int hx, hy, ix, iy;
  unsigned int lx, ly;

  do { ieee_double_shape_type ew_u; ew_u.value = (x); (hx) = ew_u.parts.msw; (lx) = ew_u.parts.lsw; } while (0);
  do { ieee_double_shape_type ew_u; ew_u.value = (y); (hy) = ew_u.parts.msw; (ly) = ew_u.parts.lsw; } while (0);
  ix = hx & 0x7fffffff;
  iy = hy & 0x7fffffff;

  if(((ix >= 0x7ff00000) && ((ix - 0x7ff00000) | lx) != 0) ||
   ((iy >= 0x7ff00000) && ((iy - 0x7ff00000) | ly) != 0))
   return x + y;
  if(abs(y - x) <= epsilon<double>())
   return y;
  if((ix | lx) == 0)
  {
   do { ieee_double_shape_type iw_u; iw_u.parts.msw = (hy & 0x80000000); iw_u.parts.lsw = (1); (x) = iw_u.value; } while (0);
   t = x * x;
   if(abs(t - x) <= epsilon<double>())
    return t;
   else
    return x;
  }
  if(hx >= 0) {
   if(hx > hy || ((hx == hy) && (lx > ly))) {
    if(lx == 0) hx -= 1;
    lx -= 1;
   }
   else {
    lx += 1;
    if(lx == 0) hx += 1;
   }
  }
  else {
   if(hy >= 0 || hx > hy || ((hx == hy) && (lx > ly))){
    if(lx == 0) hx -= 1;
    lx -= 1;
   }
   else {
    lx += 1;
    if(lx == 0) hx += 1;
   }
  }
  hy = hx & 0x7ff00000;
  if(hy >= 0x7ff00000)
   return x + x;
  if(hy < 0x00100000)
  {
   t = x * x;
   if(abs(t - x) > epsilon<double>())
   {
    do { ieee_double_shape_type iw_u; iw_u.parts.msw = (hx); iw_u.parts.lsw = (lx); (y) = iw_u.value; } while (0);
    return y;
   }
  }
  do { ieee_double_shape_type iw_u; iw_u.parts.msw = (hx); iw_u.parts.lsw = (lx); (x) = iw_u.value; } while (0);
  return x;
 }
}
}







namespace glm
{
 template<>
 inline float nextFloat(float x)
 {

   return std::nextafter(x, std::numeric_limits<float>::max());







 }

 template<>
 inline double nextFloat(double x)
 {

   return std::nextafter(x, std::numeric_limits<double>::max());







 }

 template<typename T>
 inline T nextFloat(T x, int ULPs)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'next_float' only accept floating-point input");
  
# 230 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_ulp.inl" 3
 ((void)0)
# 230 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_ulp.inl"
                  ;

  T temp = x;
  for(int i = 0; i < ULPs; ++i)
   temp = nextFloat(temp);
  return temp;
 }

 inline float prevFloat(float x)
 {

   return std::nextafter(x, std::numeric_limits<float>::min());







 }

 inline double prevFloat(double x)
 {

   return std::nextafter(x, std::numeric_limits<double>::min());







 }

 template<typename T>
 inline T prevFloat(T x, int ULPs)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'prev_float' only accept floating-point input");
  
# 268 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_ulp.inl" 3
 ((void)0)
# 268 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_ulp.inl"
                  ;

  T temp = x;
  for(int i = 0; i < ULPs; ++i)
   temp = prevFloat(temp);
  return temp;
 }

 inline int floatDistance(float x, float y)
 {
  detail::float_t<float> const a(x);
  detail::float_t<float> const b(y);

  return abs(a.i - b.i);
 }

 inline int64 floatDistance(double x, double y)
 {
  detail::float_t<double> const a(x);
  detail::float_t<double> const b(y);

  return abs(a.i - b.i);
 }
}
# 78 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/scalar_ulp.hpp" 2
# 117 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2




# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_common.hpp" 1
# 14 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_common.hpp"
       
# 24 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_common.hpp"
namespace glm
{
# 34 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_common.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, T, Q> min(vec<L, T, Q> const& a, vec<L, T, Q> const& b, vec<L, T, Q> const& c);






 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, T, Q> min(vec<L, T, Q> const& a, vec<L, T, Q> const& b, vec<L, T, Q> const& c, vec<L, T, Q> const& d);






 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, T, Q> max(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& z);






 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, T, Q> max( vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& z, vec<L, T, Q> const& w);
# 68 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_common.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> fmin(vec<L, T, Q> const& x, T y);
# 78 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_common.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> fmin(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
# 88 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_common.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> fmin(vec<L, T, Q> const& a, vec<L, T, Q> const& b, vec<L, T, Q> const& c);
# 98 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_common.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> fmin(vec<L, T, Q> const& a, vec<L, T, Q> const& b, vec<L, T, Q> const& c, vec<L, T, Q> const& d);
# 108 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_common.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> fmax(vec<L, T, Q> const& a, T b);
# 118 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_common.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> fmax(vec<L, T, Q> const& a, vec<L, T, Q> const& b);
# 128 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_common.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> fmax(vec<L, T, Q> const& a, vec<L, T, Q> const& b, vec<L, T, Q> const& c);
# 138 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_common.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> fmax(vec<L, T, Q> const& a, vec<L, T, Q> const& b, vec<L, T, Q> const& c, vec<L, T, Q> const& d);
# 148 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_common.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> fclamp(vec<L, T, Q> const& x, T minVal, T maxVal);
# 158 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_common.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> fclamp(vec<L, T, Q> const& x, vec<L, T, Q> const& minVal, vec<L, T, Q> const& maxVal);
# 168 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_common.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> clamp(vec<L, T, Q> const& Texcoord);
# 178 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_common.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> repeat(vec<L, T, Q> const& Texcoord);
# 188 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_common.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> mirrorClamp(vec<L, T, Q> const& Texcoord);
# 198 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_common.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> mirrorRepeat(vec<L, T, Q> const& Texcoord);
# 210 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_common.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, int, Q> iround(vec<L, T, Q> const& x);
# 222 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_common.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, uint, Q> uround(vec<L, T, Q> const& x);


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_common.inl" 1


namespace glm
{
 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, T, Q> min(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& z)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer, "'min' only accept floating-point or integer inputs");
  return glm::min(glm::min(x, y), z);
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, T, Q> min(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& z, vec<L, T, Q> const& w)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer, "'min' only accept floating-point or integer inputs");
  return glm::min(glm::min(x, y), glm::min(z, w));
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, T, Q> max(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& z)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer, "'max' only accept floating-point or integer inputs");
  return glm::max(glm::max(x, y), z);
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, T, Q> max(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& z, vec<L, T, Q> const& w)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer, "'max' only accept floating-point or integer inputs");
  return glm::max(glm::max(x, y), glm::max(z, w));
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> fmin(vec<L, T, Q> const& a, T b)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'fmin' only accept floating-point inputs");
  return detail::functor2<vec, L, T, Q>::call(fmin, a, vec<L, T, Q>(b));
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> fmin(vec<L, T, Q> const& a, vec<L, T, Q> const& b)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'fmin' only accept floating-point inputs");
  return detail::functor2<vec, L, T, Q>::call(fmin, a, b);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> fmin(vec<L, T, Q> const& a, vec<L, T, Q> const& b, vec<L, T, Q> const& c)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'fmin' only accept floating-point inputs");
  return fmin(fmin(a, b), c);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> fmin(vec<L, T, Q> const& a, vec<L, T, Q> const& b, vec<L, T, Q> const& c, vec<L, T, Q> const& d)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'fmin' only accept floating-point inputs");
  return fmin(fmin(a, b), fmin(c, d));
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> fmax(vec<L, T, Q> const& a, T b)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'fmax' only accept floating-point inputs");
  return detail::functor2<vec, L, T, Q>::call(fmax, a, vec<L, T, Q>(b));
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> fmax(vec<L, T, Q> const& a, vec<L, T, Q> const& b)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'fmax' only accept floating-point inputs");
  return detail::functor2<vec, L, T, Q>::call(fmax, a, b);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> fmax(vec<L, T, Q> const& a, vec<L, T, Q> const& b, vec<L, T, Q> const& c)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'fmax' only accept floating-point inputs");
  return fmax(fmax(a, b), c);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> fmax(vec<L, T, Q> const& a, vec<L, T, Q> const& b, vec<L, T, Q> const& c, vec<L, T, Q> const& d)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'fmax' only accept floating-point inputs");
  return fmax(fmax(a, b), fmax(c, d));
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> fclamp(vec<L, T, Q> const& x, T minVal, T maxVal)
 {
  return fmin(fmax(x, vec<L, T, Q>(minVal)), vec<L, T, Q>(maxVal));
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> fclamp(vec<L, T, Q> const& x, vec<L, T, Q> const& minVal, vec<L, T, Q> const& maxVal)
 {
  return fmin(fmax(x, minVal), maxVal);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> clamp(vec<L, T, Q> const& Texcoord)
 {
  return glm::clamp(Texcoord, vec<L, T, Q>(0), vec<L, T, Q>(1));
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> repeat(vec<L, T, Q> const& Texcoord)
 {
  return glm::fract(Texcoord);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> mirrorClamp(vec<L, T, Q> const& Texcoord)
 {
  return glm::fract(glm::abs(Texcoord));
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> mirrorRepeat(vec<L, T, Q> const& Texcoord)
 {
  vec<L, T, Q> const Abs = glm::abs(Texcoord);
  vec<L, T, Q> const Clamp = glm::mod(glm::floor(Abs), vec<L, T, Q>(2));
  vec<L, T, Q> const Floor = glm::floor(Abs);
  vec<L, T, Q> const Rest = Abs - Floor;
  vec<L, T, Q> const Mirror = Clamp + Rest;
  return mix(Rest, vec<L, T, Q>(1) - Rest, glm::greaterThanEqual(Mirror, vec<L, T, Q>(1)));
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, int, Q> iround(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'iround' only accept floating-point inputs");
  
# 134 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_common.inl" 3
 ((void)0)
# 134 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_common.inl"
                                               ;

  return vec<L, int, Q>(x + static_cast<T>(0.5));
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, uint, Q> uround(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'uround' only accept floating-point inputs");
  
# 143 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_common.inl" 3
 ((void)0)
# 143 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_common.inl"
                                               ;

  return vec<L, uint, Q>(x + static_cast<T>(0.5));
 }
}
# 229 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_common.hpp" 2
# 122 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_integer.hpp" 1
# 12 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_integer.hpp"
       


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/setup.hpp" 1
# 16 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_integer.hpp" 2
# 26 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_integer.hpp"
namespace glm
{
# 38 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_integer.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, bool, Q> isPowerOfTwo(vec<L, T, Q> const& v);
# 49 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_integer.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> nextPowerOfTwo(vec<L, T, Q> const& v);
# 60 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_integer.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> prevPowerOfTwo(vec<L, T, Q> const& v);
# 70 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_integer.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, bool, Q> isMultiple(vec<L, T, Q> const& v, T Multiple);
# 80 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_integer.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, bool, Q> isMultiple(vec<L, T, Q> const& v, vec<L, T, Q> const& Multiple);
# 93 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_integer.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> nextMultiple(vec<L, T, Q> const& v, T Multiple);
# 106 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_integer.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> nextMultiple(vec<L, T, Q> const& v, vec<L, T, Q> const& Multiple);
# 119 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_integer.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> prevMultiple(vec<L, T, Q> const& v, T Multiple);
# 132 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_integer.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> prevMultiple(vec<L, T, Q> const& v, vec<L, T, Q> const& Multiple);
# 143 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_integer.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, int, Q> findNSB(vec<L, T, Q> const& Source, vec<L, int, Q> SignificantBitCount);


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_integer.inl" 1


namespace glm
{
 template<length_t L, typename T, qualifier Q>
 inline vec<L, bool, Q> isPowerOfTwo(vec<L, T, Q> const& Value)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'isPowerOfTwo' only accept integer inputs");

  vec<L, T, Q> const Result(abs(Value));
  return equal(Result & (Result - vec<L, T, Q>(1)), vec<L, T, Q>(0));
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> nextPowerOfTwo(vec<L, T, Q> const& v)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'nextPowerOfTwo' only accept integer inputs");

  return detail::compute_ceilPowerOfTwo<L, T, Q, std::numeric_limits<T>::is_signed>::call(v);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> prevPowerOfTwo(vec<L, T, Q> const& v)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'prevPowerOfTwo' only accept integer inputs");

  return detail::functor1<vec, L, T, T, Q>::call(prevPowerOfTwo, v);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, bool, Q> isMultiple(vec<L, T, Q> const& Value, T Multiple)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'isMultiple' only accept integer inputs");

  return equal(Value % Multiple, vec<L, T, Q>(0));
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, bool, Q> isMultiple(vec<L, T, Q> const& Value, vec<L, T, Q> const& Multiple)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'isMultiple' only accept integer inputs");

  return equal(Value % Multiple, vec<L, T, Q>(0));
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> nextMultiple(vec<L, T, Q> const& Source, T Multiple)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'nextMultiple' only accept integer inputs");

  return detail::functor2<vec, L, T, Q>::call(nextMultiple, Source, vec<L, T, Q>(Multiple));
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> nextMultiple(vec<L, T, Q> const& Source, vec<L, T, Q> const& Multiple)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'nextMultiple' only accept integer inputs");

  return detail::functor2<vec, L, T, Q>::call(nextMultiple, Source, Multiple);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> prevMultiple(vec<L, T, Q> const& Source, T Multiple)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'prevMultiple' only accept integer inputs");

  return detail::functor2<vec, L, T, Q>::call(prevMultiple, Source, vec<L, T, Q>(Multiple));
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> prevMultiple(vec<L, T, Q> const& Source, vec<L, T, Q> const& Multiple)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'prevMultiple' only accept integer inputs");

  return detail::functor2<vec, L, T, Q>::call(prevMultiple, Source, Multiple);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, int, Q> findNSB(vec<L, T, Q> const& Source, vec<L, int, Q> SignificantBitCount)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'findNSB' only accept integer inputs");

  return detail::functor2_vec_int<L, T, Q>::call(findNSB, Source, SignificantBitCount);
 }
}
# 150 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_integer.hpp" 2
# 123 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_packing.hpp" 1
# 14 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_packing.hpp"
       
# 23 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_packing.hpp"
namespace glm
{





}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_packing.inl" 1
# 33 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_packing.hpp" 2
# 124 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_reciprocal.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_reciprocal.hpp"
       


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/setup.hpp" 1
# 17 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_reciprocal.hpp" 2





namespace glm
{
# 33 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_reciprocal.hpp"
 template<typename genType>
 [[nodiscard]] genType sec(genType angle);







 template<typename genType>
 [[nodiscard]] genType csc(genType angle);







 template<typename genType>
 [[nodiscard]] genType cot(genType angle);







 template<typename genType>
 [[nodiscard]] genType asec(genType x);







 template<typename genType>
 [[nodiscard]] genType acsc(genType x);







 template<typename genType>
 [[nodiscard]] genType acot(genType x);






 template<typename genType>
 [[nodiscard]] genType sech(genType angle);






 template<typename genType>
 [[nodiscard]] genType csch(genType angle);






 template<typename genType>
 [[nodiscard]] genType coth(genType angle);







 template<typename genType>
 [[nodiscard]] genType asech(genType x);







 template<typename genType>
 [[nodiscard]] genType acsch(genType x);







 template<typename genType>
 [[nodiscard]] genType acoth(genType x);


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_reciprocal.inl" 1





namespace glm
{

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> sec(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'sec' only accept floating-point inputs");
  return static_cast<T>(1) / detail::functor1<vec, L, T, T, Q>::call(cos, x);
 }


 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> csc(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'csc' only accept floating-point inputs");
  return static_cast<T>(1) / detail::functor1<vec, L, T, T, Q>::call(sin, x);
 }


 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> cot(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'cot' only accept floating-point inputs");
  T const pi_over_2 = static_cast<T>(3.1415926535897932384626433832795 / 2.0);
  return detail::functor1<vec, L, T, T, Q>::call(tan, pi_over_2 - x);
 }


 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> asec(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'asec' only accept floating-point inputs");
  return detail::functor1<vec, L, T, T, Q>::call(acos, static_cast<T>(1) / x);
 }


 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> acsc(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'acsc' only accept floating-point inputs");
  return detail::functor1<vec, L, T, T, Q>::call(asin, static_cast<T>(1) / x);
 }


 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> acot(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'acot' only accept floating-point inputs");
  T const pi_over_2 = static_cast<T>(3.1415926535897932384626433832795 / 2.0);
  return pi_over_2 - detail::functor1<vec, L, T, T, Q>::call(atan, x);
 }


 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> sech(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'sech' only accept floating-point inputs");
  return static_cast<T>(1) / detail::functor1<vec, L, T, T, Q>::call(cosh, x);
 }


 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> csch(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'csch' only accept floating-point inputs");
  return static_cast<T>(1) / detail::functor1<vec, L, T, T, Q>::call(sinh, x);
 }


 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> coth(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'coth' only accept floating-point inputs");
  return glm::cosh(x) / glm::sinh(x);
 }


 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> asech(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'asech' only accept floating-point inputs");
  return detail::functor1<vec, L, T, T, Q>::call(acosh, static_cast<T>(1) / x);
 }


 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> acsch(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'acsch' only accept floating-point inputs");
  return detail::functor1<vec, L, T, T, Q>::call(asinh, static_cast<T>(1) / x);
 }


 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> acoth(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'acoth' only accept floating-point inputs");
  return detail::functor1<vec, L, T, T, Q>::call(atanh, static_cast<T>(1) / x);
 }
}
# 136 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_reciprocal.hpp" 2
# 125 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_ulp.hpp" 1
# 17 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_ulp.hpp"
       
# 26 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_ulp.hpp"
namespace glm
{
# 38 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_ulp.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> nextFloat(vec<L, T, Q> const& x);
# 48 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_ulp.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> nextFloat(vec<L, T, Q> const& x, int ULPs);
# 58 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_ulp.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> nextFloat(vec<L, T, Q> const& x, vec<L, int, Q> const& ULPs);
# 68 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_ulp.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> prevFloat(vec<L, T, Q> const& x);
# 78 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_ulp.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> prevFloat(vec<L, T, Q> const& x, int ULPs);
# 88 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_ulp.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> prevFloat(vec<L, T, Q> const& x, vec<L, int, Q> const& ULPs);







 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, int, Q> floatDistance(vec<L, float, Q> const& x, vec<L, float, Q> const& y);







 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, int64, Q> floatDistance(vec<L, double, Q> const& x, vec<L, double, Q> const& y);


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_ulp.inl" 1
namespace glm
{
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> nextFloat(vec<L, T, Q> const& x)
 {
  vec<L, T, Q> Result(0);
  for(length_t i = 0, n = Result.length(); i < n; ++i)
   Result[i] = nextFloat(x[i]);
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> nextFloat(vec<L, T, Q> const& x, int ULPs)
 {
  vec<L, T, Q> Result(0);
  for(length_t i = 0, n = Result.length(); i < n; ++i)
   Result[i] = nextFloat(x[i], ULPs);
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> nextFloat(vec<L, T, Q> const& x, vec<L, int, Q> const& ULPs)
 {
  vec<L, T, Q> Result(0);
  for(length_t i = 0, n = Result.length(); i < n; ++i)
   Result[i] = nextFloat(x[i], ULPs[i]);
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> prevFloat(vec<L, T, Q> const& x)
 {
  vec<L, T, Q> Result(0);
  for(length_t i = 0, n = Result.length(); i < n; ++i)
   Result[i] = prevFloat(x[i]);
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> prevFloat(vec<L, T, Q> const& x, int ULPs)
 {
  vec<L, T, Q> Result(0);
  for(length_t i = 0, n = Result.length(); i < n; ++i)
   Result[i] = prevFloat(x[i], ULPs);
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> prevFloat(vec<L, T, Q> const& x, vec<L, int, Q> const& ULPs)
 {
  vec<L, T, Q> Result(0);
  for(length_t i = 0, n = Result.length(); i < n; ++i)
   Result[i] = prevFloat(x[i], ULPs[i]);
  return Result;
 }

 template<length_t L, qualifier Q>
 inline vec<L, int, Q> floatDistance(vec<L, float, Q> const& x, vec<L, float, Q> const& y)
 {
  vec<L, int, Q> Result(0);
  for(length_t i = 0, n = Result.length(); i < n; ++i)
   Result[i] = floatDistance(x[i], y[i]);
  return Result;
 }

 template<length_t L, qualifier Q>
 inline vec<L, int64, Q> floatDistance(vec<L, double, Q> const& x, vec<L, double, Q> const& y)
 {
  vec<L, int64, Q> Result(0);
  for(length_t i = 0, n = Result.length(); i < n; ++i)
   Result[i] = floatDistance(x[i], y[i]);
  return Result;
 }
}
# 113 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_ulp.hpp" 2
# 127 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_bool1.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_bool1.hpp"
       







namespace glm
{




 typedef vec<1, bool, defaultp> bvec1;


}
# 129 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_bool1_precision.hpp" 1
# 11 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_bool1_precision.hpp"
       







namespace glm
{




 typedef vec<1, bool, highp> highp_bvec1;


 typedef vec<1, bool, mediump> mediump_bvec1;


 typedef vec<1, bool, lowp> lowp_bvec1;


}
# 130 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2







# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_double1.hpp" 1
# 14 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_double1.hpp"
       







namespace glm
{




 typedef vec<1, double, defaultp> dvec1;


}
# 138 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_double1_precision.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_double1_precision.hpp"
       







namespace glm
{




 typedef vec<1, double, highp> highp_dvec1;


 typedef vec<1, double, mediump> mediump_dvec1;


 typedef vec<1, double, lowp> lowp_dvec1;


}
# 139 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2







# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_float1.hpp" 1
# 14 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_float1.hpp"
       







namespace glm
{




 typedef vec<1, float, defaultp> vec1;


}
# 147 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_float1_precision.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_float1_precision.hpp"
       







namespace glm
{




 typedef vec<1, float, highp> highp_vec1;


 typedef vec<1, float, mediump> mediump_vec1;


 typedef vec<1, float, lowp> lowp_vec1;


}
# 148 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2







# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_int1.hpp" 1
# 14 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_int1.hpp"
       







namespace glm
{




 typedef vec<1, int, defaultp> ivec1;


}
# 156 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_int1_sized.hpp" 1
# 14 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_int1_sized.hpp"
       
# 23 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_int1_sized.hpp"
namespace glm
{






 typedef vec<1, int8, defaultp> i8vec1;




 typedef vec<1, int16, defaultp> i16vec1;




 typedef vec<1, int32, defaultp> i32vec1;




 typedef vec<1, int64, defaultp> i64vec1;


}
# 157 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2







# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_uint1.hpp" 1
# 14 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_uint1.hpp"
       







namespace glm
{




 typedef vec<1, unsigned int, defaultp> uvec1;


}
# 165 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_uint1_sized.hpp" 1
# 14 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_uint1_sized.hpp"
       
# 23 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext/vector_uint1_sized.hpp"
namespace glm
{






 typedef vec<1, uint8, defaultp> u8vec1;




 typedef vec<1, uint16, defaultp> u16vec1;




 typedef vec<1, uint32, defaultp> u32vec1;




 typedef vec<1, uint64, defaultp> u64vec1;


}
# 166 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2







# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/bitfield.hpp" 1
# 14 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/bitfield.hpp"
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/setup.hpp" 1
# 15 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/bitfield.hpp" 2

       






# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/type_precision.hpp" 1
# 14 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/type_precision.hpp"
       


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/quaternion.hpp" 1
# 14 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/quaternion.hpp"
       
# 38 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/quaternion.hpp"
namespace glm
{
# 49 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/quaternion.hpp"
 template<typename T, qualifier Q>
 [[nodiscard]] vec<3, T, Q> eulerAngles(qua<T, Q> const& x);






 template<typename T, qualifier Q>
 [[nodiscard]] T roll(qua<T, Q> const& x);






 template<typename T, qualifier Q>
 [[nodiscard]] T pitch(qua<T, Q> const& x);






 template<typename T, qualifier Q>
 [[nodiscard]] T yaw(qua<T, Q> const& x);






 template<typename T, qualifier Q>
 [[nodiscard]] mat<3, 3, T, Q> mat3_cast(qua<T, Q> const& x);






 template<typename T, qualifier Q>
 [[nodiscard]] mat<4, 4, T, Q> mat4_cast(qua<T, Q> const& x);






 template<typename T, qualifier Q>
 [[nodiscard]] qua<T, Q> quat_cast(mat<3, 3, T, Q> const& x);






 template<typename T, qualifier Q>
 [[nodiscard]] qua<T, Q> quat_cast(mat<4, 4, T, Q> const& x);







 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, bool, Q> lessThan(qua<T, Q> const& x, qua<T, Q> const& y);







 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, bool, Q> lessThanEqual(qua<T, Q> const& x, qua<T, Q> const& y);







 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, bool, Q> greaterThan(qua<T, Q> const& x, qua<T, Q> const& y);







 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, bool, Q> greaterThanEqual(qua<T, Q> const& x, qua<T, Q> const& y);





 template<typename T, qualifier Q>
 [[nodiscard]] qua<T, Q> quatLookAt(
  vec<3, T, Q> const& direction,
  vec<3, T, Q> const& up);





 template<typename T, qualifier Q>
 [[nodiscard]] qua<T, Q> quatLookAtRH(
  vec<3, T, Q> const& direction,
  vec<3, T, Q> const& up);





 template<typename T, qualifier Q>
 [[nodiscard]] qua<T, Q> quatLookAtLH(
  vec<3, T, Q> const& direction,
  vec<3, T, Q> const& up);

}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/quaternion.inl" 1



# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/epsilon.hpp" 1
# 14 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/epsilon.hpp"
       


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/setup.hpp" 1
# 18 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/epsilon.hpp" 2






namespace glm
{







 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, bool, Q> epsilonEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, T const& epsilon);





 template<typename genType>
 [[nodiscard]] bool epsilonEqual(genType const& x, genType const& y, genType const& epsilon);





 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, bool, Q> epsilonNotEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, T const& epsilon);





 template<typename genType>
 [[nodiscard]] bool epsilonNotEqual(genType const& x, genType const& y, genType const& epsilon);


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/epsilon.inl" 1






namespace glm
{
 template<>
 inline bool epsilonEqual
 (
  float const& x,
  float const& y,
  float const& epsilon
 )
 {
  return abs(x - y) < epsilon;
 }

 template<>
 inline bool epsilonEqual
 (
  double const& x,
  double const& y,
  double const& epsilon
 )
 {
  return abs(x - y) < epsilon;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, bool, Q> epsilonEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, T const& epsilon)
 {
  return lessThan(abs(x - y), vec<L, T, Q>(epsilon));
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, bool, Q> epsilonEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& epsilon)
 {
  return lessThan(abs(x - y), vec<L, T, Q>(epsilon));
 }

 template<>
 inline bool epsilonNotEqual(float const& x, float const& y, float const& epsilon)
 {
  return abs(x - y) >= epsilon;
 }

 template<>
 inline bool epsilonNotEqual(double const& x, double const& y, double const& epsilon)
 {
  return abs(x - y) >= epsilon;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, bool, Q> epsilonNotEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, T const& epsilon)
 {
  return greaterThanEqual(abs(x - y), vec<L, T, Q>(epsilon));
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, bool, Q> epsilonNotEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& epsilon)
 {
  return greaterThanEqual(abs(x - y), vec<L, T, Q>(epsilon));
 }

 template<typename T, qualifier Q>
 inline vec<4, bool, Q> epsilonEqual(qua<T, Q> const& x, qua<T, Q> const& y, T const& epsilon)
 {
  vec<4, T, Q> v(x.x - y.x, x.y - y.y, x.z - y.z, x.w - y.w);
  return lessThan(abs(v), vec<4, T, Q>(epsilon));
 }

 template<typename T, qualifier Q>
 inline vec<4, bool, Q> epsilonNotEqual(qua<T, Q> const& x, qua<T, Q> const& y, T const& epsilon)
 {
  vec<4, T, Q> v(x.x - y.x, x.y - y.y, x.z - y.z, x.w - y.w);
  return greaterThanEqual(abs(v), vec<4, T, Q>(epsilon));
 }
}
# 61 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/epsilon.hpp" 2
# 5 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/quaternion.inl" 2


namespace glm
{
 template<typename T, qualifier Q>
 inline vec<3, T, Q> eulerAngles(qua<T, Q> const& x)
 {
  return vec<3, T, Q>(pitch(x), yaw(x), roll(x));
 }

 template<typename T, qualifier Q>
 inline T roll(qua<T, Q> const& q)
 {
  T const y = static_cast<T>(2) * (q.x * q.y + q.w * q.z);
  T const x = q.w * q.w + q.x * q.x - q.y * q.y - q.z * q.z;

  if(all(equal(vec<2, T, Q>(x, y), vec<2, T, Q>(0), epsilon<T>())))
   return static_cast<T>(0);

  return static_cast<T>(atan(y, x));
 }

 template<typename T, qualifier Q>
 inline T pitch(qua<T, Q> const& q)
 {

  T const y = static_cast<T>(2) * (q.y * q.z + q.w * q.x);
  T const x = q.w * q.w - q.x * q.x - q.y * q.y + q.z * q.z;

  if(all(equal(vec<2, T, Q>(x, y), vec<2, T, Q>(0), epsilon<T>())))
   return static_cast<T>(static_cast<T>(2) * atan(q.x, q.w));

  return static_cast<T>(atan(y, x));
 }

 template<typename T, qualifier Q>
 inline T yaw(qua<T, Q> const& q)
 {
  return asin(clamp(static_cast<T>(-2) * (q.x * q.z - q.w * q.y), static_cast<T>(-1), static_cast<T>(1)));
 }

 template<typename T, qualifier Q>
 inline mat<3, 3, T, Q> mat3_cast(qua<T, Q> const& q)
 {
  mat<3, 3, T, Q> Result(T(1));
  T qxx(q.x * q.x);
  T qyy(q.y * q.y);
  T qzz(q.z * q.z);
  T qxz(q.x * q.z);
  T qxy(q.x * q.y);
  T qyz(q.y * q.z);
  T qwx(q.w * q.x);
  T qwy(q.w * q.y);
  T qwz(q.w * q.z);

  Result[0][0] = T(1) - T(2) * (qyy + qzz);
  Result[0][1] = T(2) * (qxy + qwz);
  Result[0][2] = T(2) * (qxz - qwy);

  Result[1][0] = T(2) * (qxy - qwz);
  Result[1][1] = T(1) - T(2) * (qxx + qzz);
  Result[1][2] = T(2) * (qyz + qwx);

  Result[2][0] = T(2) * (qxz + qwy);
  Result[2][1] = T(2) * (qyz - qwx);
  Result[2][2] = T(1) - T(2) * (qxx + qyy);
  return Result;
 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> mat4_cast(qua<T, Q> const& q)
 {
  return mat<4, 4, T, Q>(mat3_cast(q));
 }

 template<typename T, qualifier Q>
 inline qua<T, Q> quat_cast(mat<3, 3, T, Q> const& m)
 {
  T fourXSquaredMinus1 = m[0][0] - m[1][1] - m[2][2];
  T fourYSquaredMinus1 = m[1][1] - m[0][0] - m[2][2];
  T fourZSquaredMinus1 = m[2][2] - m[0][0] - m[1][1];
  T fourWSquaredMinus1 = m[0][0] + m[1][1] + m[2][2];

  int biggestIndex = 0;
  T fourBiggestSquaredMinus1 = fourWSquaredMinus1;
  if(fourXSquaredMinus1 > fourBiggestSquaredMinus1)
  {
   fourBiggestSquaredMinus1 = fourXSquaredMinus1;
   biggestIndex = 1;
  }
  if(fourYSquaredMinus1 > fourBiggestSquaredMinus1)
  {
   fourBiggestSquaredMinus1 = fourYSquaredMinus1;
   biggestIndex = 2;
  }
  if(fourZSquaredMinus1 > fourBiggestSquaredMinus1)
  {
   fourBiggestSquaredMinus1 = fourZSquaredMinus1;
   biggestIndex = 3;
  }

  T biggestVal = sqrt(fourBiggestSquaredMinus1 + static_cast<T>(1)) * static_cast<T>(0.5);
  T mult = static_cast<T>(0.25) / biggestVal;

  switch(biggestIndex)
  {
  case 0:
   return qua<T, Q>::wxyz(biggestVal, (m[1][2] - m[2][1]) * mult, (m[2][0] - m[0][2]) * mult, (m[0][1] - m[1][0]) * mult);
  case 1:
   return qua<T, Q>::wxyz((m[1][2] - m[2][1]) * mult, biggestVal, (m[0][1] + m[1][0]) * mult, (m[2][0] + m[0][2]) * mult);
  case 2:
   return qua<T, Q>::wxyz((m[2][0] - m[0][2]) * mult, (m[0][1] + m[1][0]) * mult, biggestVal, (m[1][2] + m[2][1]) * mult);
  case 3:
   return qua<T, Q>::wxyz((m[0][1] - m[1][0]) * mult, (m[2][0] + m[0][2]) * mult, (m[1][2] + m[2][1]) * mult, biggestVal);
  default:
   
# 120 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/quaternion.inl" 3
  ((void)0)
# 120 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/quaternion.inl"
               ;
   return qua<T, Q>::wxyz(1, 0, 0, 0);
  }
 }

 template<typename T, qualifier Q>
 inline qua<T, Q> quat_cast(mat<4, 4, T, Q> const& m4)
 {
  return quat_cast(mat<3, 3, T, Q>(m4));
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, bool, Q> lessThan(qua<T, Q> const& x, qua<T, Q> const& y)
 {
  vec<4, bool, Q> Result(false, false, false, false);
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] < y[i];
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, bool, Q> lessThanEqual(qua<T, Q> const& x, qua<T, Q> const& y)
 {
  vec<4, bool, Q> Result(false, false, false, false);
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] <= y[i];
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, bool, Q> greaterThan(qua<T, Q> const& x, qua<T, Q> const& y)
 {
  vec<4, bool, Q> Result(false, false, false, false);
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] > y[i];
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, bool, Q> greaterThanEqual(qua<T, Q> const& x, qua<T, Q> const& y)
 {
  vec<4, bool, Q> Result(false, false, false, false);
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] >= y[i];
  return Result;
 }


 template<typename T, qualifier Q>
 inline qua<T, Q> quatLookAt(vec<3, T, Q> const& direction, vec<3, T, Q> const& up)
 {



   return quatLookAtRH(direction, up);

 }

 template<typename T, qualifier Q>
 inline qua<T, Q> quatLookAtRH(vec<3, T, Q> const& direction, vec<3, T, Q> const& up)
 {
  mat<3, 3, T, Q> Result;

  Result[2] = -direction;
  vec<3, T, Q> const& Right = cross(up, Result[2]);
  Result[0] = Right * inversesqrt(max(static_cast<T>(0.00001), dot(Right, Right)));
  Result[1] = cross(Result[2], Result[0]);

  return quat_cast(Result);
 }

 template<typename T, qualifier Q>
 inline qua<T, Q> quatLookAtLH(vec<3, T, Q> const& direction, vec<3, T, Q> const& up)
 {
  mat<3, 3, T, Q> Result;

  Result[2] = direction;
  vec<3, T, Q> const& Right = cross(up, Result[2]);
  Result[0] = Right * inversesqrt(max(static_cast<T>(0.00001), dot(Right, Right)));
  Result[1] = cross(Result[2], Result[0]);

  return quat_cast(Result);
 }
}
# 174 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/quaternion.hpp" 2
# 18 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/type_precision.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/vec1.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/vec1.hpp"
       
# 19 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/type_precision.hpp" 2
# 46 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/type_precision.hpp"
namespace glm
{
# 56 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/type_precision.hpp"
 typedef detail::int8 lowp_int8;



 typedef detail::int16 lowp_int16;



 typedef detail::int32 lowp_int32;



 typedef detail::int64 lowp_int64;



 typedef detail::int8 lowp_int8_t;



 typedef detail::int16 lowp_int16_t;



 typedef detail::int32 lowp_int32_t;



 typedef detail::int64 lowp_int64_t;



 typedef detail::int8 lowp_i8;



 typedef detail::int16 lowp_i16;



 typedef detail::int32 lowp_i32;



 typedef detail::int64 lowp_i64;



 typedef detail::int8 mediump_int8;



 typedef detail::int16 mediump_int16;



 typedef detail::int32 mediump_int32;



 typedef detail::int64 mediump_int64;



 typedef detail::int8 mediump_int8_t;



 typedef detail::int16 mediump_int16_t;



 typedef detail::int32 mediump_int32_t;



 typedef detail::int64 mediump_int64_t;



 typedef detail::int8 mediump_i8;



 typedef detail::int16 mediump_i16;



 typedef detail::int32 mediump_i32;



 typedef detail::int64 mediump_i64;



 typedef detail::int8 highp_int8;



 typedef detail::int16 highp_int16;



 typedef detail::int32 highp_int32;



 typedef detail::int64 highp_int64;



 typedef detail::int8 highp_int8_t;



 typedef detail::int16 highp_int16_t;



 typedef detail::int32 highp_int32_t;



 typedef detail::int64 highp_int64_t;



 typedef detail::int8 highp_i8;



 typedef detail::int16 highp_i16;



 typedef detail::int32 highp_i32;



 typedef detail::int64 highp_i64;



 using std::int8_t;
 using std::int16_t;
 using std::int32_t;
 using std::int64_t;
# 224 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/type_precision.hpp"
 typedef detail::int8 i8;



 typedef detail::int16 i16;



 typedef detail::int32 i32;



 typedef detail::int64 i64;






 typedef detail::uint8 lowp_uint8;



 typedef detail::uint16 lowp_uint16;



 typedef detail::uint32 lowp_uint32;



 typedef detail::uint64 lowp_uint64;



 typedef detail::uint8 lowp_uint8_t;



 typedef detail::uint16 lowp_uint16_t;



 typedef detail::uint32 lowp_uint32_t;



 typedef detail::uint64 lowp_uint64_t;



 typedef detail::uint8 lowp_u8;



 typedef detail::uint16 lowp_u16;



 typedef detail::uint32 lowp_u32;



 typedef detail::uint64 lowp_u64;



 typedef detail::uint8 mediump_uint8;



 typedef detail::uint16 mediump_uint16;



 typedef detail::uint32 mediump_uint32;



 typedef detail::uint64 mediump_uint64;



 typedef detail::uint8 mediump_uint8_t;



 typedef detail::uint16 mediump_uint16_t;



 typedef detail::uint32 mediump_uint32_t;



 typedef detail::uint64 mediump_uint64_t;



 typedef detail::uint8 mediump_u8;



 typedef detail::uint16 mediump_u16;



 typedef detail::uint32 mediump_u32;



 typedef detail::uint64 mediump_u64;



 typedef detail::uint8 highp_uint8;



 typedef detail::uint16 highp_uint16;



 typedef detail::uint32 highp_uint32;



 typedef detail::uint64 highp_uint64;



 typedef detail::uint8 highp_uint8_t;



 typedef detail::uint16 highp_uint16_t;



 typedef detail::uint32 highp_uint32_t;



 typedef detail::uint64 highp_uint64_t;



 typedef detail::uint8 highp_u8;



 typedef detail::uint16 highp_u16;



 typedef detail::uint32 highp_u32;



 typedef detail::uint64 highp_u64;


 using std::uint8_t;
 using std::uint16_t;
 using std::uint32_t;
 using std::uint64_t;
# 410 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/type_precision.hpp"
 typedef detail::uint8 u8;



 typedef detail::uint16 u16;



 typedef detail::uint32 u32;



 typedef detail::uint64 u64;
# 433 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/type_precision.hpp"
 typedef float float32;



 typedef double float64;



 typedef float32 lowp_float32;



 typedef float64 lowp_float64;



 typedef float32 lowp_float32_t;



 typedef float64 lowp_float64_t;



 typedef float32 lowp_f32;



 typedef float64 lowp_f64;



 typedef float32 lowp_float32;



 typedef float64 lowp_float64;



 typedef float32 lowp_float32_t;



 typedef float64 lowp_float64_t;



 typedef float32 lowp_f32;



 typedef float64 lowp_f64;




 typedef float32 lowp_float32;



 typedef float64 lowp_float64;



 typedef float32 lowp_float32_t;



 typedef float64 lowp_float64_t;



 typedef float32 lowp_f32;



 typedef float64 lowp_f64;




 typedef float32 mediump_float32;



 typedef float64 mediump_float64;



 typedef float32 mediump_float32_t;



 typedef float64 mediump_float64_t;



 typedef float32 mediump_f32;



 typedef float64 mediump_f64;




 typedef float32 highp_float32;



 typedef float64 highp_float64;



 typedef float32 highp_float32_t;



 typedef float64 highp_float64_t;



 typedef float32 highp_f32;



 typedef float64 highp_f64;
# 601 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/type_precision.hpp"
 typedef highp_float32_t float32_t;



 typedef highp_float64_t float64_t;



 typedef highp_float32_t f32;



 typedef highp_float64_t f64;





 typedef vec<1, float, lowp> lowp_fvec1;



 typedef vec<2, float, lowp> lowp_fvec2;



 typedef vec<3, float, lowp> lowp_fvec3;



 typedef vec<4, float, lowp> lowp_fvec4;




 typedef vec<1, float, mediump> mediump_fvec1;



 typedef vec<2, float, mediump> mediump_fvec2;



 typedef vec<3, float, mediump> mediump_fvec3;



 typedef vec<4, float, mediump> mediump_fvec4;




 typedef vec<1, float, highp> highp_fvec1;



 typedef vec<2, float, highp> highp_fvec2;



 typedef vec<3, float, highp> highp_fvec3;



 typedef vec<4, float, highp> highp_fvec4;




 typedef vec<1, f32, lowp> lowp_f32vec1;



 typedef vec<2, f32, lowp> lowp_f32vec2;



 typedef vec<3, f32, lowp> lowp_f32vec3;



 typedef vec<4, f32, lowp> lowp_f32vec4;



 typedef vec<1, f32, mediump> mediump_f32vec1;



 typedef vec<2, f32, mediump> mediump_f32vec2;



 typedef vec<3, f32, mediump> mediump_f32vec3;



 typedef vec<4, f32, mediump> mediump_f32vec4;



 typedef vec<1, f32, highp> highp_f32vec1;



 typedef vec<2, f32, highp> highp_f32vec2;



 typedef vec<3, f32, highp> highp_f32vec3;



 typedef vec<4, f32, highp> highp_f32vec4;




 typedef vec<1, f64, lowp> lowp_f64vec1;



 typedef vec<2, f64, lowp> lowp_f64vec2;



 typedef vec<3, f64, lowp> lowp_f64vec3;



 typedef vec<4, f64, lowp> lowp_f64vec4;



 typedef vec<1, f64, mediump> mediump_f64vec1;



 typedef vec<2, f64, mediump> mediump_f64vec2;



 typedef vec<3, f64, mediump> mediump_f64vec3;



 typedef vec<4, f64, mediump> mediump_f64vec4;



 typedef vec<1, f64, highp> highp_f64vec1;



 typedef vec<2, f64, highp> highp_f64vec2;



 typedef vec<3, f64, highp> highp_f64vec3;



 typedef vec<4, f64, highp> highp_f64vec4;
# 776 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/type_precision.hpp"
 typedef mat<2, 2, f32, lowp> lowp_fmat2x2;



 typedef mat<2, 3, f32, lowp> lowp_fmat2x3;



 typedef mat<2, 4, f32, lowp> lowp_fmat2x4;



 typedef mat<3, 2, f32, lowp> lowp_fmat3x2;



 typedef mat<3, 3, f32, lowp> lowp_fmat3x3;



 typedef mat<3, 4, f32, lowp> lowp_fmat3x4;



 typedef mat<4, 2, f32, lowp> lowp_fmat4x2;



 typedef mat<4, 3, f32, lowp> lowp_fmat4x3;



 typedef mat<4, 4, f32, lowp> lowp_fmat4x4;







 typedef lowp_fmat2x2 lowp_fmat2;



 typedef lowp_fmat3x3 lowp_fmat3;



 typedef lowp_fmat4x4 lowp_fmat4;
# 833 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/type_precision.hpp"
 typedef mat<2, 2, f32, mediump> mediump_fmat2x2;



 typedef mat<2, 3, f32, mediump> mediump_fmat2x3;



 typedef mat<2, 4, f32, mediump> mediump_fmat2x4;



 typedef mat<3, 2, f32, mediump> mediump_fmat3x2;



 typedef mat<3, 3, f32, mediump> mediump_fmat3x3;



 typedef mat<3, 4, f32, mediump> mediump_fmat3x4;



 typedef mat<4, 2, f32, mediump> mediump_fmat4x2;



 typedef mat<4, 3, f32, mediump> mediump_fmat4x3;



 typedef mat<4, 4, f32, mediump> mediump_fmat4x4;







 typedef mediump_fmat2x2 mediump_fmat2;



 typedef mediump_fmat3x3 mediump_fmat3;



 typedef mediump_fmat4x4 mediump_fmat4;
# 890 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/type_precision.hpp"
 typedef mat<2, 2, f32, highp> highp_fmat2x2;



 typedef mat<2, 3, f32, highp> highp_fmat2x3;



 typedef mat<2, 4, f32, highp> highp_fmat2x4;



 typedef mat<3, 2, f32, highp> highp_fmat3x2;



 typedef mat<3, 3, f32, highp> highp_fmat3x3;



 typedef mat<3, 4, f32, highp> highp_fmat3x4;



 typedef mat<4, 2, f32, highp> highp_fmat4x2;



 typedef mat<4, 3, f32, highp> highp_fmat4x3;



 typedef mat<4, 4, f32, highp> highp_fmat4x4;







 typedef highp_fmat2x2 highp_fmat2;



 typedef highp_fmat3x3 highp_fmat3;



 typedef highp_fmat4x4 highp_fmat4;
# 947 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/type_precision.hpp"
 typedef mat<2, 2, f32, lowp> lowp_f32mat2x2;



 typedef mat<2, 3, f32, lowp> lowp_f32mat2x3;



 typedef mat<2, 4, f32, lowp> lowp_f32mat2x4;



 typedef mat<3, 2, f32, lowp> lowp_f32mat3x2;



 typedef mat<3, 3, f32, lowp> lowp_f32mat3x3;



 typedef mat<3, 4, f32, lowp> lowp_f32mat3x4;



 typedef mat<4, 2, f32, lowp> lowp_f32mat4x2;



 typedef mat<4, 3, f32, lowp> lowp_f32mat4x3;



 typedef mat<4, 4, f32, lowp> lowp_f32mat4x4;







 typedef lowp_f32mat2x2 lowp_f32mat2;



 typedef lowp_f32mat3x3 lowp_f32mat3;



 typedef lowp_f32mat4x4 lowp_f32mat4;
# 1004 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/type_precision.hpp"
 typedef mat<2, 2, f32, mediump> mediump_f32mat2x2;



 typedef mat<2, 3, f32, mediump> mediump_f32mat2x3;



 typedef mat<2, 4, f32, mediump> mediump_f32mat2x4;



 typedef mat<3, 2, f32, mediump> mediump_f32mat3x2;



 typedef mat<3, 3, f32, mediump> mediump_f32mat3x3;



 typedef mat<3, 4, f32, mediump> mediump_f32mat3x4;



 typedef mat<4, 2, f32, mediump> mediump_f32mat4x2;



 typedef mat<4, 3, f32, mediump> mediump_f32mat4x3;



 typedef mat<4, 4, f32, mediump> mediump_f32mat4x4;







 typedef mediump_f32mat2x2 mediump_f32mat2;



 typedef mediump_f32mat3x3 mediump_f32mat3;



 typedef mediump_f32mat4x4 mediump_f32mat4;
# 1061 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/type_precision.hpp"
 typedef mat<2, 2, f32, highp> highp_f32mat2x2;



 typedef mat<2, 3, f32, highp> highp_f32mat2x3;



 typedef mat<2, 4, f32, highp> highp_f32mat2x4;



 typedef mat<3, 2, f32, highp> highp_f32mat3x2;



 typedef mat<3, 3, f32, highp> highp_f32mat3x3;



 typedef mat<3, 4, f32, highp> highp_f32mat3x4;



 typedef mat<4, 2, f32, highp> highp_f32mat4x2;



 typedef mat<4, 3, f32, highp> highp_f32mat4x3;



 typedef mat<4, 4, f32, highp> highp_f32mat4x4;







 typedef highp_f32mat2x2 highp_f32mat2;



 typedef highp_f32mat3x3 highp_f32mat3;



 typedef highp_f32mat4x4 highp_f32mat4;
# 1118 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/type_precision.hpp"
 typedef mat<2, 2, f64, lowp> lowp_f64mat2x2;



 typedef mat<2, 3, f64, lowp> lowp_f64mat2x3;



 typedef mat<2, 4, f64, lowp> lowp_f64mat2x4;



 typedef mat<3, 2, f64, lowp> lowp_f64mat3x2;



 typedef mat<3, 3, f64, lowp> lowp_f64mat3x3;



 typedef mat<3, 4, f64, lowp> lowp_f64mat3x4;



 typedef mat<4, 2, f64, lowp> lowp_f64mat4x2;



 typedef mat<4, 3, f64, lowp> lowp_f64mat4x3;



 typedef mat<4, 4, f64, lowp> lowp_f64mat4x4;







 typedef lowp_f64mat2x2 lowp_f64mat2;



 typedef lowp_f64mat3x3 lowp_f64mat3;



 typedef lowp_f64mat4x4 lowp_f64mat4;
# 1175 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/type_precision.hpp"
 typedef mat<2, 2, f64, mediump> mediump_f64mat2x2;



 typedef mat<2, 3, f64, mediump> mediump_f64mat2x3;



 typedef mat<2, 4, f64, mediump> mediump_f64mat2x4;



 typedef mat<3, 2, f64, mediump> mediump_f64mat3x2;



 typedef mat<3, 3, f64, mediump> mediump_f64mat3x3;



 typedef mat<3, 4, f64, mediump> mediump_f64mat3x4;



 typedef mat<4, 2, f64, mediump> mediump_f64mat4x2;



 typedef mat<4, 3, f64, mediump> mediump_f64mat4x3;



 typedef mat<4, 4, f64, mediump> mediump_f64mat4x4;







 typedef mediump_f64mat2x2 mediump_f64mat2;



 typedef mediump_f64mat3x3 mediump_f64mat3;



 typedef mediump_f64mat4x4 mediump_f64mat4;







 typedef mat<2, 2, f64, highp> highp_f64mat2x2;



 typedef mat<2, 3, f64, highp> highp_f64mat2x3;



 typedef mat<2, 4, f64, highp> highp_f64mat2x4;



 typedef mat<3, 2, f64, highp> highp_f64mat3x2;



 typedef mat<3, 3, f64, highp> highp_f64mat3x3;



 typedef mat<3, 4, f64, highp> highp_f64mat3x4;



 typedef mat<4, 2, f64, highp> highp_f64mat4x2;



 typedef mat<4, 3, f64, highp> highp_f64mat4x3;



 typedef mat<4, 4, f64, highp> highp_f64mat4x4;







 typedef highp_f64mat2x2 highp_f64mat2;



 typedef highp_f64mat3x3 highp_f64mat3;



 typedef highp_f64mat4x4 highp_f64mat4;







 typedef vec<1, int, lowp> lowp_ivec1;



 typedef vec<2, int, lowp> lowp_ivec2;



 typedef vec<3, int, lowp> lowp_ivec3;



 typedef vec<4, int, lowp> lowp_ivec4;




 typedef vec<1, int, mediump> mediump_ivec1;



 typedef vec<2, int, mediump> mediump_ivec2;



 typedef vec<3, int, mediump> mediump_ivec3;



 typedef vec<4, int, mediump> mediump_ivec4;




 typedef vec<1, int, highp> highp_ivec1;



 typedef vec<2, int, highp> highp_ivec2;



 typedef vec<3, int, highp> highp_ivec3;



 typedef vec<4, int, highp> highp_ivec4;




 typedef vec<1, i8, lowp> lowp_i8vec1;



 typedef vec<2, i8, lowp> lowp_i8vec2;



 typedef vec<3, i8, lowp> lowp_i8vec3;



 typedef vec<4, i8, lowp> lowp_i8vec4;




 typedef vec<1, i8, mediump> mediump_i8vec1;



 typedef vec<2, i8, mediump> mediump_i8vec2;



 typedef vec<3, i8, mediump> mediump_i8vec3;



 typedef vec<4, i8, mediump> mediump_i8vec4;




 typedef vec<1, i8, highp> highp_i8vec1;



 typedef vec<2, i8, highp> highp_i8vec2;



 typedef vec<3, i8, highp> highp_i8vec3;



 typedef vec<4, i8, highp> highp_i8vec4;




 typedef vec<1, i16, lowp> lowp_i16vec1;



 typedef vec<2, i16, lowp> lowp_i16vec2;



 typedef vec<3, i16, lowp> lowp_i16vec3;



 typedef vec<4, i16, lowp> lowp_i16vec4;




 typedef vec<1, i16, mediump> mediump_i16vec1;



 typedef vec<2, i16, mediump> mediump_i16vec2;



 typedef vec<3, i16, mediump> mediump_i16vec3;



 typedef vec<4, i16, mediump> mediump_i16vec4;




 typedef vec<1, i16, highp> highp_i16vec1;



 typedef vec<2, i16, highp> highp_i16vec2;



 typedef vec<3, i16, highp> highp_i16vec3;



 typedef vec<4, i16, highp> highp_i16vec4;




 typedef vec<1, i32, lowp> lowp_i32vec1;



 typedef vec<2, i32, lowp> lowp_i32vec2;



 typedef vec<3, i32, lowp> lowp_i32vec3;



 typedef vec<4, i32, lowp> lowp_i32vec4;




 typedef vec<1, i32, mediump> mediump_i32vec1;



 typedef vec<2, i32, mediump> mediump_i32vec2;



 typedef vec<3, i32, mediump> mediump_i32vec3;



 typedef vec<4, i32, mediump> mediump_i32vec4;




 typedef vec<1, i32, highp> highp_i32vec1;



 typedef vec<2, i32, highp> highp_i32vec2;



 typedef vec<3, i32, highp> highp_i32vec3;



 typedef vec<4, i32, highp> highp_i32vec4;




 typedef vec<1, i64, lowp> lowp_i64vec1;



 typedef vec<2, i64, lowp> lowp_i64vec2;



 typedef vec<3, i64, lowp> lowp_i64vec3;



 typedef vec<4, i64, lowp> lowp_i64vec4;




 typedef vec<1, i64, mediump> mediump_i64vec1;



 typedef vec<2, i64, mediump> mediump_i64vec2;



 typedef vec<3, i64, mediump> mediump_i64vec3;



 typedef vec<4, i64, mediump> mediump_i64vec4;




 typedef vec<1, i64, highp> highp_i64vec1;



 typedef vec<2, i64, highp> highp_i64vec2;



 typedef vec<3, i64, highp> highp_i64vec3;



 typedef vec<4, i64, highp> highp_i64vec4;







 typedef vec<1, uint, lowp> lowp_uvec1;



 typedef vec<2, uint, lowp> lowp_uvec2;



 typedef vec<3, uint, lowp> lowp_uvec3;



 typedef vec<4, uint, lowp> lowp_uvec4;




 typedef vec<1, uint, mediump> mediump_uvec1;



 typedef vec<2, uint, mediump> mediump_uvec2;



 typedef vec<3, uint, mediump> mediump_uvec3;



 typedef vec<4, uint, mediump> mediump_uvec4;




 typedef vec<1, uint, highp> highp_uvec1;



 typedef vec<2, uint, highp> highp_uvec2;



 typedef vec<3, uint, highp> highp_uvec3;



 typedef vec<4, uint, highp> highp_uvec4;




 typedef vec<1, u8, lowp> lowp_u8vec1;



 typedef vec<2, u8, lowp> lowp_u8vec2;



 typedef vec<3, u8, lowp> lowp_u8vec3;



 typedef vec<4, u8, lowp> lowp_u8vec4;




 typedef vec<1, u8, mediump> mediump_u8vec1;



 typedef vec<2, u8, mediump> mediump_u8vec2;



 typedef vec<3, u8, mediump> mediump_u8vec3;



 typedef vec<4, u8, mediump> mediump_u8vec4;




 typedef vec<1, u8, highp> highp_u8vec1;



 typedef vec<2, u8, highp> highp_u8vec2;



 typedef vec<3, u8, highp> highp_u8vec3;



 typedef vec<4, u8, highp> highp_u8vec4;




 typedef vec<1, u16, lowp> lowp_u16vec1;



 typedef vec<2, u16, lowp> lowp_u16vec2;



 typedef vec<3, u16, lowp> lowp_u16vec3;



 typedef vec<4, u16, lowp> lowp_u16vec4;




 typedef vec<1, u16, mediump> mediump_u16vec1;



 typedef vec<2, u16, mediump> mediump_u16vec2;



 typedef vec<3, u16, mediump> mediump_u16vec3;



 typedef vec<4, u16, mediump> mediump_u16vec4;




 typedef vec<1, u16, highp> highp_u16vec1;



 typedef vec<2, u16, highp> highp_u16vec2;



 typedef vec<3, u16, highp> highp_u16vec3;



 typedef vec<4, u16, highp> highp_u16vec4;




 typedef vec<1, u32, lowp> lowp_u32vec1;



 typedef vec<2, u32, lowp> lowp_u32vec2;



 typedef vec<3, u32, lowp> lowp_u32vec3;



 typedef vec<4, u32, lowp> lowp_u32vec4;




 typedef vec<1, u32, mediump> mediump_u32vec1;



 typedef vec<2, u32, mediump> mediump_u32vec2;



 typedef vec<3, u32, mediump> mediump_u32vec3;



 typedef vec<4, u32, mediump> mediump_u32vec4;




 typedef vec<1, u32, highp> highp_u32vec1;



 typedef vec<2, u32, highp> highp_u32vec2;



 typedef vec<3, u32, highp> highp_u32vec3;



 typedef vec<4, u32, highp> highp_u32vec4;




 typedef vec<1, u64, lowp> lowp_u64vec1;



 typedef vec<2, u64, lowp> lowp_u64vec2;



 typedef vec<3, u64, lowp> lowp_u64vec3;



 typedef vec<4, u64, lowp> lowp_u64vec4;




 typedef vec<1, u64, mediump> mediump_u64vec1;



 typedef vec<2, u64, mediump> mediump_u64vec2;



 typedef vec<3, u64, mediump> mediump_u64vec3;



 typedef vec<4, u64, mediump> mediump_u64vec4;




 typedef vec<1, u64, highp> highp_u64vec1;



 typedef vec<2, u64, highp> highp_u64vec2;



 typedef vec<3, u64, highp> highp_u64vec3;



 typedef vec<4, u64, highp> highp_u64vec4;







 typedef float32 float32_t;



 typedef float32 f32;





  typedef float64 float64_t;



  typedef float64 f64;




 typedef vec<1, float, defaultp> fvec1;



 typedef vec<2, float, defaultp> fvec2;



 typedef vec<3, float, defaultp> fvec3;



 typedef vec<4, float, defaultp> fvec4;




 typedef vec<1, f32, defaultp> f32vec1;



 typedef vec<2, f32, defaultp> f32vec2;



 typedef vec<3, f32, defaultp> f32vec3;



 typedef vec<4, f32, defaultp> f32vec4;




  typedef vec<1, f64, defaultp> f64vec1;



  typedef vec<2, f64, defaultp> f64vec2;



  typedef vec<3, f64, defaultp> f64vec3;



  typedef vec<4, f64, defaultp> f64vec4;
# 1881 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/type_precision.hpp"
 typedef mat<2, 2, f32, defaultp> fmat2;



 typedef mat<3, 3, f32, defaultp> fmat3;



 typedef mat<4, 4, f32, defaultp> fmat4;
# 1898 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/type_precision.hpp"
 typedef mat<2, 2, f32, defaultp> fmat2x2;



 typedef mat<2, 3, f32, defaultp> fmat2x3;



 typedef mat<2, 4, f32, defaultp> fmat2x4;



 typedef mat<3, 2, f32, defaultp> fmat3x2;



 typedef mat<3, 3, f32, defaultp> fmat3x3;



 typedef mat<3, 4, f32, defaultp> fmat3x4;



 typedef mat<4, 2, f32, defaultp> fmat4x2;



 typedef mat<4, 3, f32, defaultp> fmat4x3;



 typedef mat<4, 4, f32, defaultp> fmat4x4;
# 1939 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/type_precision.hpp"
 typedef mat<2, 2, f32, defaultp> f32mat2;



 typedef mat<3, 3, f32, defaultp> f32mat3;



 typedef mat<4, 4, f32, defaultp> f32mat4;
# 1956 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/type_precision.hpp"
 typedef mat<2, 2, f32, defaultp> f32mat2x2;



 typedef mat<2, 3, f32, defaultp> f32mat2x3;



 typedef mat<2, 4, f32, defaultp> f32mat2x4;



 typedef mat<3, 2, f32, defaultp> f32mat3x2;



 typedef mat<3, 3, f32, defaultp> f32mat3x3;



 typedef mat<3, 4, f32, defaultp> f32mat3x4;



 typedef mat<4, 2, f32, defaultp> f32mat4x2;



 typedef mat<4, 3, f32, defaultp> f32mat4x3;



 typedef mat<4, 4, f32, defaultp> f32mat4x4;
# 1999 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/type_precision.hpp"
 typedef mat<2, 2, f64, defaultp> f64mat2;



 typedef mat<3, 3, f64, defaultp> f64mat3;



 typedef mat<4, 4, f64, defaultp> f64mat4;
# 2016 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/type_precision.hpp"
 typedef mat<2, 2, f64, defaultp> f64mat2x2;



 typedef mat<2, 3, f64, defaultp> f64mat2x3;



 typedef mat<2, 4, f64, defaultp> f64mat2x4;



 typedef mat<3, 2, f64, defaultp> f64mat3x2;



 typedef mat<3, 3, f64, defaultp> f64mat3x3;



 typedef mat<3, 4, f64, defaultp> f64mat3x4;



 typedef mat<4, 2, f64, defaultp> f64mat4x2;



 typedef mat<4, 3, f64, defaultp> f64mat4x3;



 typedef mat<4, 4, f64, defaultp> f64mat4x4;
# 2057 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/type_precision.hpp"
 typedef qua<f32, defaultp> f32quat;



 typedef qua<f32, lowp> lowp_f32quat;



 typedef qua<f64, lowp> lowp_f64quat;



 typedef qua<f32, mediump> mediump_f32quat;





 typedef qua<f64, mediump> mediump_f64quat;



 typedef qua<f32, highp> highp_f32quat;



 typedef qua<f64, highp> highp_f64quat;



 typedef qua<f64, defaultp> f64quat;




}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/type_precision.inl" 1


namespace glm
{

}
# 2095 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/type_precision.hpp" 2
# 24 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/bitfield.hpp" 2






namespace glm
{






 template<typename genIUType>
 [[nodiscard]] genIUType mask(genIUType Bits);
# 48 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/bitfield.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> mask(vec<L, T, Q> const& v);




 template<typename genIUType>
 [[nodiscard]] genIUType bitfieldRotateRight(genIUType In, int Shift);
# 64 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/bitfield.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> bitfieldRotateRight(vec<L, T, Q> const& In, int Shift);




 template<typename genIUType>
 [[nodiscard]] genIUType bitfieldRotateLeft(genIUType In, int Shift);
# 80 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/bitfield.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> bitfieldRotateLeft(vec<L, T, Q> const& In, int Shift);




 template<typename genIUType>
 [[nodiscard]] genIUType bitfieldFillOne(genIUType Value, int FirstBit, int BitCount);
# 96 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/bitfield.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> bitfieldFillOne(vec<L, T, Q> const& Value, int FirstBit, int BitCount);




 template<typename genIUType>
 [[nodiscard]] genIUType bitfieldFillZero(genIUType Value, int FirstBit, int BitCount);
# 112 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/bitfield.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> bitfieldFillZero(vec<L, T, Q> const& Value, int FirstBit, int BitCount);






 [[nodiscard]] int16 bitfieldInterleave(int8 x, int8 y);






 [[nodiscard]] uint16 bitfieldInterleave(uint8 x, uint8 y);






 [[nodiscard]] uint16 bitfieldInterleave(u8vec2 const& v);




 [[nodiscard]] glm::u8vec2 bitfieldDeinterleave(glm::uint16 x);






 [[nodiscard]] int32 bitfieldInterleave(int16 x, int16 y);






 [[nodiscard]] uint32 bitfieldInterleave(uint16 x, uint16 y);






 [[nodiscard]] uint32 bitfieldInterleave(u16vec2 const& v);




 [[nodiscard]] glm::u16vec2 bitfieldDeinterleave(glm::uint32 x);






 [[nodiscard]] int64 bitfieldInterleave(int32 x, int32 y);






 [[nodiscard]] uint64 bitfieldInterleave(uint32 x, uint32 y);






 [[nodiscard]] uint64 bitfieldInterleave(u32vec2 const& v);




 [[nodiscard]] glm::u32vec2 bitfieldDeinterleave(glm::uint64 x);






 [[nodiscard]] int32 bitfieldInterleave(int8 x, int8 y, int8 z);






 [[nodiscard]] uint32 bitfieldInterleave(uint8 x, uint8 y, uint8 z);






 [[nodiscard]] int64 bitfieldInterleave(int16 x, int16 y, int16 z);






 [[nodiscard]] uint64 bitfieldInterleave(uint16 x, uint16 y, uint16 z);






 [[nodiscard]] int64 bitfieldInterleave(int32 x, int32 y, int32 z);






 [[nodiscard]] uint64 bitfieldInterleave(uint32 x, uint32 y, uint32 z);






 [[nodiscard]] int32 bitfieldInterleave(int8 x, int8 y, int8 z, int8 w);






 [[nodiscard]] uint32 bitfieldInterleave(uint8 x, uint8 y, uint8 z, uint8 w);






 [[nodiscard]] int64 bitfieldInterleave(int16 x, int16 y, int16 z, int16 w);






 [[nodiscard]] uint64 bitfieldInterleave(uint16 x, uint16 y, uint16 z, uint16 w);


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/bitfield.inl" 1


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/simd/integer.h" 1



       
# 4 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/bitfield.inl" 2

namespace glm{
namespace detail
{
 template<typename PARAM, typename RET>
 [[nodiscard]] RET bitfieldInterleave(PARAM x, PARAM y);

 template<typename PARAM, typename RET>
 [[nodiscard]] RET bitfieldInterleave(PARAM x, PARAM y, PARAM z);

 template<typename PARAM, typename RET>
 [[nodiscard]] RET bitfieldInterleave(PARAM x, PARAM y, PARAM z, PARAM w);

 template<>
 inline glm::uint16 bitfieldInterleave(glm::uint8 x, glm::uint8 y)
 {
  glm::uint16 REG1(x);
  glm::uint16 REG2(y);

  REG1 = ((REG1 << 4) | REG1) & static_cast<glm::uint16>(0x0F0F);
  REG2 = ((REG2 << 4) | REG2) & static_cast<glm::uint16>(0x0F0F);

  REG1 = ((REG1 << 2) | REG1) & static_cast<glm::uint16>(0x3333);
  REG2 = ((REG2 << 2) | REG2) & static_cast<glm::uint16>(0x3333);

  REG1 = ((REG1 << 1) | REG1) & static_cast<glm::uint16>(0x5555);
  REG2 = ((REG2 << 1) | REG2) & static_cast<glm::uint16>(0x5555);

  return REG1 | static_cast<glm::uint16>(REG2 << 1);
 }

 template<>
 inline glm::uint32 bitfieldInterleave(glm::uint16 x, glm::uint16 y)
 {
  glm::uint32 REG1(x);
  glm::uint32 REG2(y);

  REG1 = ((REG1 << 8) | REG1) & static_cast<glm::uint32>(0x00FF00FF);
  REG2 = ((REG2 << 8) | REG2) & static_cast<glm::uint32>(0x00FF00FF);

  REG1 = ((REG1 << 4) | REG1) & static_cast<glm::uint32>(0x0F0F0F0F);
  REG2 = ((REG2 << 4) | REG2) & static_cast<glm::uint32>(0x0F0F0F0F);

  REG1 = ((REG1 << 2) | REG1) & static_cast<glm::uint32>(0x33333333);
  REG2 = ((REG2 << 2) | REG2) & static_cast<glm::uint32>(0x33333333);

  REG1 = ((REG1 << 1) | REG1) & static_cast<glm::uint32>(0x55555555);
  REG2 = ((REG2 << 1) | REG2) & static_cast<glm::uint32>(0x55555555);

  return REG1 | (REG2 << 1);
 }

 template<>
 inline glm::uint64 bitfieldInterleave(glm::uint32 x, glm::uint32 y)
 {
  glm::uint64 REG1(x);
  glm::uint64 REG2(y);

  REG1 = ((REG1 << 16) | REG1) & static_cast<glm::uint64>(0x0000FFFF0000FFFFull);
  REG2 = ((REG2 << 16) | REG2) & static_cast<glm::uint64>(0x0000FFFF0000FFFFull);

  REG1 = ((REG1 << 8) | REG1) & static_cast<glm::uint64>(0x00FF00FF00FF00FFull);
  REG2 = ((REG2 << 8) | REG2) & static_cast<glm::uint64>(0x00FF00FF00FF00FFull);

  REG1 = ((REG1 << 4) | REG1) & static_cast<glm::uint64>(0x0F0F0F0F0F0F0F0Full);
  REG2 = ((REG2 << 4) | REG2) & static_cast<glm::uint64>(0x0F0F0F0F0F0F0F0Full);

  REG1 = ((REG1 << 2) | REG1) & static_cast<glm::uint64>(0x3333333333333333ull);
  REG2 = ((REG2 << 2) | REG2) & static_cast<glm::uint64>(0x3333333333333333ull);

  REG1 = ((REG1 << 1) | REG1) & static_cast<glm::uint64>(0x5555555555555555ull);
  REG2 = ((REG2 << 1) | REG2) & static_cast<glm::uint64>(0x5555555555555555ull);

  return REG1 | (REG2 << 1);
 }

 template<>
 inline glm::uint32 bitfieldInterleave(glm::uint8 x, glm::uint8 y, glm::uint8 z)
 {
  glm::uint32 REG1(x);
  glm::uint32 REG2(y);
  glm::uint32 REG3(z);

  REG1 = ((REG1 << 16) | REG1) & static_cast<glm::uint32>(0xFF0000FFu);
  REG2 = ((REG2 << 16) | REG2) & static_cast<glm::uint32>(0xFF0000FFu);
  REG3 = ((REG3 << 16) | REG3) & static_cast<glm::uint32>(0xFF0000FFu);

  REG1 = ((REG1 << 8) | REG1) & static_cast<glm::uint32>(0x0F00F00Fu);
  REG2 = ((REG2 << 8) | REG2) & static_cast<glm::uint32>(0x0F00F00Fu);
  REG3 = ((REG3 << 8) | REG3) & static_cast<glm::uint32>(0x0F00F00Fu);

  REG1 = ((REG1 << 4) | REG1) & static_cast<glm::uint32>(0xC30C30C3u);
  REG2 = ((REG2 << 4) | REG2) & static_cast<glm::uint32>(0xC30C30C3u);
  REG3 = ((REG3 << 4) | REG3) & static_cast<glm::uint32>(0xC30C30C3u);

  REG1 = ((REG1 << 2) | REG1) & static_cast<glm::uint32>(0x49249249u);
  REG2 = ((REG2 << 2) | REG2) & static_cast<glm::uint32>(0x49249249u);
  REG3 = ((REG3 << 2) | REG3) & static_cast<glm::uint32>(0x49249249u);

  return REG1 | (REG2 << 1) | (REG3 << 2);
 }

 template<>
 inline glm::uint64 bitfieldInterleave(glm::uint16 x, glm::uint16 y, glm::uint16 z)
 {
  glm::uint64 REG1(x);
  glm::uint64 REG2(y);
  glm::uint64 REG3(z);

  REG1 = ((REG1 << 32) | REG1) & static_cast<glm::uint64>(0xFFFF00000000FFFFull);
  REG2 = ((REG2 << 32) | REG2) & static_cast<glm::uint64>(0xFFFF00000000FFFFull);
  REG3 = ((REG3 << 32) | REG3) & static_cast<glm::uint64>(0xFFFF00000000FFFFull);

  REG1 = ((REG1 << 16) | REG1) & static_cast<glm::uint64>(0x00FF0000FF0000FFull);
  REG2 = ((REG2 << 16) | REG2) & static_cast<glm::uint64>(0x00FF0000FF0000FFull);
  REG3 = ((REG3 << 16) | REG3) & static_cast<glm::uint64>(0x00FF0000FF0000FFull);

  REG1 = ((REG1 << 8) | REG1) & static_cast<glm::uint64>(0xF00F00F00F00F00Full);
  REG2 = ((REG2 << 8) | REG2) & static_cast<glm::uint64>(0xF00F00F00F00F00Full);
  REG3 = ((REG3 << 8) | REG3) & static_cast<glm::uint64>(0xF00F00F00F00F00Full);

  REG1 = ((REG1 << 4) | REG1) & static_cast<glm::uint64>(0x30C30C30C30C30C3ull);
  REG2 = ((REG2 << 4) | REG2) & static_cast<glm::uint64>(0x30C30C30C30C30C3ull);
  REG3 = ((REG3 << 4) | REG3) & static_cast<glm::uint64>(0x30C30C30C30C30C3ull);

  REG1 = ((REG1 << 2) | REG1) & static_cast<glm::uint64>(0x9249249249249249ull);
  REG2 = ((REG2 << 2) | REG2) & static_cast<glm::uint64>(0x9249249249249249ull);
  REG3 = ((REG3 << 2) | REG3) & static_cast<glm::uint64>(0x9249249249249249ull);

  return REG1 | (REG2 << 1) | (REG3 << 2);
 }

 template<>
 inline glm::uint64 bitfieldInterleave(glm::uint32 x, glm::uint32 y, glm::uint32 z)
 {
  glm::uint64 REG1(x);
  glm::uint64 REG2(y);
  glm::uint64 REG3(z);

  REG1 = ((REG1 << 32) | REG1) & static_cast<glm::uint64>(0xFFFF00000000FFFFull);
  REG2 = ((REG2 << 32) | REG2) & static_cast<glm::uint64>(0xFFFF00000000FFFFull);
  REG3 = ((REG3 << 32) | REG3) & static_cast<glm::uint64>(0xFFFF00000000FFFFull);

  REG1 = ((REG1 << 16) | REG1) & static_cast<glm::uint64>(0x00FF0000FF0000FFull);
  REG2 = ((REG2 << 16) | REG2) & static_cast<glm::uint64>(0x00FF0000FF0000FFull);
  REG3 = ((REG3 << 16) | REG3) & static_cast<glm::uint64>(0x00FF0000FF0000FFull);

  REG1 = ((REG1 << 8) | REG1) & static_cast<glm::uint64>(0xF00F00F00F00F00Full);
  REG2 = ((REG2 << 8) | REG2) & static_cast<glm::uint64>(0xF00F00F00F00F00Full);
  REG3 = ((REG3 << 8) | REG3) & static_cast<glm::uint64>(0xF00F00F00F00F00Full);

  REG1 = ((REG1 << 4) | REG1) & static_cast<glm::uint64>(0x30C30C30C30C30C3ull);
  REG2 = ((REG2 << 4) | REG2) & static_cast<glm::uint64>(0x30C30C30C30C30C3ull);
  REG3 = ((REG3 << 4) | REG3) & static_cast<glm::uint64>(0x30C30C30C30C30C3ull);

  REG1 = ((REG1 << 2) | REG1) & static_cast<glm::uint64>(0x9249249249249249ull);
  REG2 = ((REG2 << 2) | REG2) & static_cast<glm::uint64>(0x9249249249249249ull);
  REG3 = ((REG3 << 2) | REG3) & static_cast<glm::uint64>(0x9249249249249249ull);

  return REG1 | (REG2 << 1) | (REG3 << 2);
 }

 template<>
 inline glm::uint32 bitfieldInterleave(glm::uint8 x, glm::uint8 y, glm::uint8 z, glm::uint8 w)
 {
  glm::uint32 REG1(x);
  glm::uint32 REG2(y);
  glm::uint32 REG3(z);
  glm::uint32 REG4(w);

  REG1 = ((REG1 << 12) | REG1) & static_cast<glm::uint32>(0x000F000Fu);
  REG2 = ((REG2 << 12) | REG2) & static_cast<glm::uint32>(0x000F000Fu);
  REG3 = ((REG3 << 12) | REG3) & static_cast<glm::uint32>(0x000F000Fu);
  REG4 = ((REG4 << 12) | REG4) & static_cast<glm::uint32>(0x000F000Fu);

  REG1 = ((REG1 << 6) | REG1) & static_cast<glm::uint32>(0x03030303u);
  REG2 = ((REG2 << 6) | REG2) & static_cast<glm::uint32>(0x03030303u);
  REG3 = ((REG3 << 6) | REG3) & static_cast<glm::uint32>(0x03030303u);
  REG4 = ((REG4 << 6) | REG4) & static_cast<glm::uint32>(0x03030303u);

  REG1 = ((REG1 << 3) | REG1) & static_cast<glm::uint32>(0x11111111u);
  REG2 = ((REG2 << 3) | REG2) & static_cast<glm::uint32>(0x11111111u);
  REG3 = ((REG3 << 3) | REG3) & static_cast<glm::uint32>(0x11111111u);
  REG4 = ((REG4 << 3) | REG4) & static_cast<glm::uint32>(0x11111111u);

  return REG1 | (REG2 << 1) | (REG3 << 2) | (REG4 << 3);
 }

 template<>
 inline glm::uint64 bitfieldInterleave(glm::uint16 x, glm::uint16 y, glm::uint16 z, glm::uint16 w)
 {
  glm::uint64 REG1(x);
  glm::uint64 REG2(y);
  glm::uint64 REG3(z);
  glm::uint64 REG4(w);

  REG1 = ((REG1 << 24) | REG1) & static_cast<glm::uint64>(0x000000FF000000FFull);
  REG2 = ((REG2 << 24) | REG2) & static_cast<glm::uint64>(0x000000FF000000FFull);
  REG3 = ((REG3 << 24) | REG3) & static_cast<glm::uint64>(0x000000FF000000FFull);
  REG4 = ((REG4 << 24) | REG4) & static_cast<glm::uint64>(0x000000FF000000FFull);

  REG1 = ((REG1 << 12) | REG1) & static_cast<glm::uint64>(0x000F000F000F000Full);
  REG2 = ((REG2 << 12) | REG2) & static_cast<glm::uint64>(0x000F000F000F000Full);
  REG3 = ((REG3 << 12) | REG3) & static_cast<glm::uint64>(0x000F000F000F000Full);
  REG4 = ((REG4 << 12) | REG4) & static_cast<glm::uint64>(0x000F000F000F000Full);

  REG1 = ((REG1 << 6) | REG1) & static_cast<glm::uint64>(0x0303030303030303ull);
  REG2 = ((REG2 << 6) | REG2) & static_cast<glm::uint64>(0x0303030303030303ull);
  REG3 = ((REG3 << 6) | REG3) & static_cast<glm::uint64>(0x0303030303030303ull);
  REG4 = ((REG4 << 6) | REG4) & static_cast<glm::uint64>(0x0303030303030303ull);

  REG1 = ((REG1 << 3) | REG1) & static_cast<glm::uint64>(0x1111111111111111ull);
  REG2 = ((REG2 << 3) | REG2) & static_cast<glm::uint64>(0x1111111111111111ull);
  REG3 = ((REG3 << 3) | REG3) & static_cast<glm::uint64>(0x1111111111111111ull);
  REG4 = ((REG4 << 3) | REG4) & static_cast<glm::uint64>(0x1111111111111111ull);

  return REG1 | (REG2 << 1) | (REG3 << 2) | (REG4 << 3);
 }
}






 template<typename genIUType>
 inline genIUType mask(genIUType Bits)
 {
  static_assert(std::numeric_limits<genIUType>::is_integer, "'mask' accepts only integer values");

  return Bits >= sizeof(genIUType) * 8 ? ~static_cast<genIUType>(0) : (static_cast<genIUType>(1) << Bits) - static_cast<genIUType>(1);
 }





 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> mask(vec<L, T, Q> const& v)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'mask' accepts only integer values");

  return detail::functor1<vec, L, T, T, Q>::call(mask, v);
 }

 template<typename genIType>
 inline genIType bitfieldRotateRight(genIType In, int Shift)
 {
  static_assert(std::numeric_limits<genIType>::is_integer, "'bitfieldRotateRight' accepts only integer values");

  int const BitSize = static_cast<genIType>(sizeof(genIType) * 8);
  return (In << static_cast<genIType>(Shift)) | (In >> static_cast<genIType>(BitSize - Shift));
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> bitfieldRotateRight(vec<L, T, Q> const& In, int Shift)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'bitfieldRotateRight' accepts only integer values");

  int const BitSize = static_cast<int>(sizeof(T) * 8);
  return (In << static_cast<T>(Shift)) | (In >> static_cast<T>(BitSize - Shift));
 }

 template<typename genIType>
 inline genIType bitfieldRotateLeft(genIType In, int Shift)
 {
  static_assert(std::numeric_limits<genIType>::is_integer, "'bitfieldRotateLeft' accepts only integer values");

  int const BitSize = static_cast<genIType>(sizeof(genIType) * 8);
  return (In >> static_cast<genIType>(Shift)) | (In << static_cast<genIType>(BitSize - Shift));
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> bitfieldRotateLeft(vec<L, T, Q> const& In, int Shift)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'bitfieldRotateLeft' accepts only integer values");

  int const BitSize = static_cast<int>(sizeof(T) * 8);
  return (In >> static_cast<T>(Shift)) | (In << static_cast<T>(BitSize - Shift));
 }

 template<typename genIUType>
 inline genIUType bitfieldFillOne(genIUType Value, int FirstBit, int BitCount)
 {
  return Value | static_cast<genIUType>(mask(BitCount) << FirstBit);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> bitfieldFillOne(vec<L, T, Q> const& Value, int FirstBit, int BitCount)
 {
  return Value | static_cast<T>(mask(BitCount) << FirstBit);
 }

 template<typename genIUType>
 inline genIUType bitfieldFillZero(genIUType Value, int FirstBit, int BitCount)
 {
  return Value & static_cast<genIUType>(~(mask(BitCount) << FirstBit));
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> bitfieldFillZero(vec<L, T, Q> const& Value, int FirstBit, int BitCount)
 {
  return Value & static_cast<T>(~(mask(BitCount) << FirstBit));
 }

 inline int16 bitfieldInterleave(int8 x, int8 y)
 {
  union sign8
  {
   int8 i;
   uint8 u;
  } sign_x, sign_y;

  union sign16
  {
   int16 i;
   uint16 u;
  } result;

  sign_x.i = x;
  sign_y.i = y;
  result.u = bitfieldInterleave(sign_x.u, sign_y.u);

  return result.i;
 }

 inline uint16 bitfieldInterleave(uint8 x, uint8 y)
 {
  return detail::bitfieldInterleave<uint8, uint16>(x, y);
 }

 inline uint16 bitfieldInterleave(u8vec2 const& v)
 {
  return detail::bitfieldInterleave<uint8, uint16>(v.x, v.y);
 }

 inline u8vec2 bitfieldDeinterleave(glm::uint16 x)
 {
  uint16 REG1(x);
  uint16 REG2(x >>= 1);

  REG1 = REG1 & static_cast<uint16>(0x5555);
  REG2 = REG2 & static_cast<uint16>(0x5555);

  REG1 = ((REG1 >> 1) | REG1) & static_cast<uint16>(0x3333);
  REG2 = ((REG2 >> 1) | REG2) & static_cast<uint16>(0x3333);

  REG1 = ((REG1 >> 2) | REG1) & static_cast<uint16>(0x0F0F);
  REG2 = ((REG2 >> 2) | REG2) & static_cast<uint16>(0x0F0F);

  REG1 = ((REG1 >> 4) | REG1) & static_cast<uint16>(0x00FF);
  REG2 = ((REG2 >> 4) | REG2) & static_cast<uint16>(0x00FF);

  REG1 = ((REG1 >> 8) | REG1) & static_cast<uint16>(0xFFFF);
  REG2 = ((REG2 >> 8) | REG2) & static_cast<uint16>(0xFFFF);

  return glm::u8vec2(REG1, REG2);
 }

 inline int32 bitfieldInterleave(int16 x, int16 y)
 {
  union sign16
  {
   int16 i;
   uint16 u;
  } sign_x, sign_y;

  union sign32
  {
   int32 i;
   uint32 u;
  } result;

  sign_x.i = x;
  sign_y.i = y;
  result.u = bitfieldInterleave(sign_x.u, sign_y.u);

  return result.i;
 }

 inline uint32 bitfieldInterleave(uint16 x, uint16 y)
 {
  return detail::bitfieldInterleave<uint16, uint32>(x, y);
 }

 inline glm::uint32 bitfieldInterleave(u16vec2 const& v)
 {
  return detail::bitfieldInterleave<uint16, uint32>(v.x, v.y);
 }

 inline glm::u16vec2 bitfieldDeinterleave(glm::uint32 x)
 {
  glm::uint32 REG1(x);
  glm::uint32 REG2(x >>= 1);

  REG1 = REG1 & static_cast<glm::uint32>(0x55555555);
  REG2 = REG2 & static_cast<glm::uint32>(0x55555555);

  REG1 = ((REG1 >> 1) | REG1) & static_cast<glm::uint32>(0x33333333);
  REG2 = ((REG2 >> 1) | REG2) & static_cast<glm::uint32>(0x33333333);

  REG1 = ((REG1 >> 2) | REG1) & static_cast<glm::uint32>(0x0F0F0F0F);
  REG2 = ((REG2 >> 2) | REG2) & static_cast<glm::uint32>(0x0F0F0F0F);

  REG1 = ((REG1 >> 4) | REG1) & static_cast<glm::uint32>(0x00FF00FF);
  REG2 = ((REG2 >> 4) | REG2) & static_cast<glm::uint32>(0x00FF00FF);

  REG1 = ((REG1 >> 8) | REG1) & static_cast<glm::uint32>(0x0000FFFF);
  REG2 = ((REG2 >> 8) | REG2) & static_cast<glm::uint32>(0x0000FFFF);

  return glm::u16vec2(REG1, REG2);
 }

 inline int64 bitfieldInterleave(int32 x, int32 y)
 {
  union sign32
  {
   int32 i;
   uint32 u;
  } sign_x, sign_y;

  union sign64
  {
   int64 i;
   uint64 u;
  } result;

  sign_x.i = x;
  sign_y.i = y;
  result.u = bitfieldInterleave(sign_x.u, sign_y.u);

  return result.i;
 }

 inline uint64 bitfieldInterleave(uint32 x, uint32 y)
 {
  return detail::bitfieldInterleave<uint32, uint64>(x, y);
 }

 inline glm::uint64 bitfieldInterleave(u32vec2 const& v)
 {
  return detail::bitfieldInterleave<uint32, uint64>(v.x, v.y);
 }

 inline glm::u32vec2 bitfieldDeinterleave(glm::uint64 x)
 {
  glm::uint64 REG1(x);
  glm::uint64 REG2(x >>= 1);

  REG1 = REG1 & static_cast<glm::uint64>(0x5555555555555555ull);
  REG2 = REG2 & static_cast<glm::uint64>(0x5555555555555555ull);

  REG1 = ((REG1 >> 1) | REG1) & static_cast<glm::uint64>(0x3333333333333333ull);
  REG2 = ((REG2 >> 1) | REG2) & static_cast<glm::uint64>(0x3333333333333333ull);

  REG1 = ((REG1 >> 2) | REG1) & static_cast<glm::uint64>(0x0F0F0F0F0F0F0F0Full);
  REG2 = ((REG2 >> 2) | REG2) & static_cast<glm::uint64>(0x0F0F0F0F0F0F0F0Full);

  REG1 = ((REG1 >> 4) | REG1) & static_cast<glm::uint64>(0x00FF00FF00FF00FFull);
  REG2 = ((REG2 >> 4) | REG2) & static_cast<glm::uint64>(0x00FF00FF00FF00FFull);

  REG1 = ((REG1 >> 8) | REG1) & static_cast<glm::uint64>(0x0000FFFF0000FFFFull);
  REG2 = ((REG2 >> 8) | REG2) & static_cast<glm::uint64>(0x0000FFFF0000FFFFull);

  REG1 = ((REG1 >> 16) | REG1) & static_cast<glm::uint64>(0x00000000FFFFFFFFull);
  REG2 = ((REG2 >> 16) | REG2) & static_cast<glm::uint64>(0x00000000FFFFFFFFull);

  return glm::u32vec2(REG1, REG2);
 }

 inline int32 bitfieldInterleave(int8 x, int8 y, int8 z)
 {
  union sign8
  {
   int8 i;
   uint8 u;
  } sign_x, sign_y, sign_z;

  union sign32
  {
   int32 i;
   uint32 u;
  } result;

  sign_x.i = x;
  sign_y.i = y;
  sign_z.i = z;
  result.u = bitfieldInterleave(sign_x.u, sign_y.u, sign_z.u);

  return result.i;
 }

 inline uint32 bitfieldInterleave(uint8 x, uint8 y, uint8 z)
 {
  return detail::bitfieldInterleave<uint8, uint32>(x, y, z);
 }

 inline uint32 bitfieldInterleave(u8vec3 const& v)
 {
  return detail::bitfieldInterleave<uint8, uint32>(v.x, v.y, v.z);
 }

 inline int64 bitfieldInterleave(int16 x, int16 y, int16 z)
 {
  union sign16
  {
   int16 i;
   uint16 u;
  } sign_x, sign_y, sign_z;

  union sign64
  {
   int64 i;
   uint64 u;
  } result;

  sign_x.i = x;
  sign_y.i = y;
  sign_z.i = z;
  result.u = bitfieldInterleave(sign_x.u, sign_y.u, sign_z.u);

  return result.i;
 }

 inline uint64 bitfieldInterleave(uint16 x, uint16 y, uint16 z)
 {
  return detail::bitfieldInterleave<uint32, uint64>(x, y, z);
 }

 inline uint64 bitfieldInterleave(u16vec3 const& v)
 {
  return detail::bitfieldInterleave<uint32, uint64>(v.x, v.y, v.z);
 }

 inline int64 bitfieldInterleave(int32 x, int32 y, int32 z)
 {
  union sign16
  {
   int32 i;
   uint32 u;
  } sign_x, sign_y, sign_z;

  union sign64
  {
   int64 i;
   uint64 u;
  } result;

  sign_x.i = x;
  sign_y.i = y;
  sign_z.i = z;
  result.u = bitfieldInterleave(sign_x.u, sign_y.u, sign_z.u);

  return result.i;
 }

 inline uint64 bitfieldInterleave(uint32 x, uint32 y, uint32 z)
 {
  return detail::bitfieldInterleave<uint32, uint64>(x, y, z);
 }

 inline uint64 bitfieldInterleave(u32vec3 const& v)
 {
  return detail::bitfieldInterleave<uint32, uint64>(v.x, v.y, v.z);
 }

 inline int32 bitfieldInterleave(int8 x, int8 y, int8 z, int8 w)
 {
  union sign8
  {
   int8 i;
   uint8 u;
  } sign_x, sign_y, sign_z, sign_w;

  union sign32
  {
   int32 i;
   uint32 u;
  } result;

  sign_x.i = x;
  sign_y.i = y;
  sign_z.i = z;
  sign_w.i = w;
  result.u = bitfieldInterleave(sign_x.u, sign_y.u, sign_z.u, sign_w.u);

  return result.i;
 }

 inline uint32 bitfieldInterleave(uint8 x, uint8 y, uint8 z, uint8 w)
 {
  return detail::bitfieldInterleave<uint8, uint32>(x, y, z, w);
 }

 inline uint32 bitfieldInterleave(u8vec4 const& v)
 {
  return detail::bitfieldInterleave<uint8, uint32>(v.x, v.y, v.z, v.w);
 }

 inline int64 bitfieldInterleave(int16 x, int16 y, int16 z, int16 w)
 {
  union sign16
  {
   int16 i;
   uint16 u;
  } sign_x, sign_y, sign_z, sign_w;

  union sign64
  {
   int64 i;
   uint64 u;
  } result;

  sign_x.i = x;
  sign_y.i = y;
  sign_z.i = z;
  sign_w.i = w;
  result.u = bitfieldInterleave(sign_x.u, sign_y.u, sign_z.u, sign_w.u);

  return result.i;
 }

 inline uint64 bitfieldInterleave(uint16 x, uint16 y, uint16 z, uint16 w)
 {
  return detail::bitfieldInterleave<uint16, uint64>(x, y, z, w);
 }

 inline uint64 bitfieldInterleave(u16vec4 const& v)
 {
  return detail::bitfieldInterleave<uint16, uint64>(v.x, v.y, v.z, v.w);
 }
}
# 267 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/bitfield.hpp" 2
# 174 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/color_space.hpp" 1
# 14 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/color_space.hpp"
       


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/setup.hpp" 1
# 18 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/color_space.hpp" 2
# 28 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/color_space.hpp"
namespace glm
{





 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> convertLinearToSRGB(vec<L, T, Q> const& ColorLinear);



 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> convertLinearToSRGB(vec<L, T, Q> const& ColorLinear, T Gamma);



 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> convertSRGBToLinear(vec<L, T, Q> const& ColorSRGB);



 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> convertSRGBToLinear(vec<L, T, Q> const& ColorSRGB, T Gamma);


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/color_space.inl" 1


namespace glm{
namespace detail
{
 template<length_t L, typename T, qualifier Q>
 struct compute_rgbToSrgb
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& ColorRGB, T GammaCorrection)
  {
   vec<L, T, Q> const ClampedColor(clamp(ColorRGB, static_cast<T>(0), static_cast<T>(1)));

   return mix(
    pow(ClampedColor, vec<L, T, Q>(GammaCorrection)) * static_cast<T>(1.055) - static_cast<T>(0.055),
    ClampedColor * static_cast<T>(12.92),
    lessThan(ClampedColor, vec<L, T, Q>(static_cast<T>(0.0031308))));
  }
 };

 template<typename T, qualifier Q>
 struct compute_rgbToSrgb<4, T, Q>
 {
  inline static vec<4, T, Q> call(vec<4, T, Q> const& ColorRGB, T GammaCorrection)
  {
   return vec<4, T, Q>(compute_rgbToSrgb<3, T, Q>::call(vec<3, T, Q>(ColorRGB), GammaCorrection), ColorRGB.w);
  }
 };

 template<length_t L, typename T, qualifier Q>
 struct compute_srgbToRgb
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& ColorSRGB, T Gamma)
  {
   return mix(
    pow((ColorSRGB + static_cast<T>(0.055)) * static_cast<T>(0.94786729857819905213270142180095), vec<L, T, Q>(Gamma)),
    ColorSRGB * static_cast<T>(0.07739938080495356037151702786378),
    lessThanEqual(ColorSRGB, vec<L, T, Q>(static_cast<T>(0.04045))));
  }
 };

 template<typename T, qualifier Q>
 struct compute_srgbToRgb<4, T, Q>
 {
  inline static vec<4, T, Q> call(vec<4, T, Q> const& ColorSRGB, T Gamma)
  {
   return vec<4, T, Q>(compute_srgbToRgb<3, T, Q>::call(vec<3, T, Q>(ColorSRGB), Gamma), ColorSRGB.w);
  }
 };
}

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> convertLinearToSRGB(vec<L, T, Q> const& ColorLinear)
 {
  return detail::compute_rgbToSrgb<L, T, Q>::call(ColorLinear, static_cast<T>(0.41666));
 }


 template<>
 inline vec<3, float, lowp> convertLinearToSRGB(vec<3, float, lowp> const& ColorLinear)
 {
  vec<3, float, lowp> S1 = sqrt(ColorLinear);
  vec<3, float, lowp> S2 = sqrt(S1);
  vec<3, float, lowp> S3 = sqrt(S2);
  return 0.662002687f * S1 + 0.684122060f * S2 - 0.323583601f * S3 - 0.0225411470f * ColorLinear;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> convertLinearToSRGB(vec<L, T, Q> const& ColorLinear, T Gamma)
 {
  return detail::compute_rgbToSrgb<L, T, Q>::call(ColorLinear, static_cast<T>(1) / Gamma);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> convertSRGBToLinear(vec<L, T, Q> const& ColorSRGB)
 {
  return detail::compute_srgbToRgb<L, T, Q>::call(ColorSRGB, static_cast<T>(2.4));
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> convertSRGBToLinear(vec<L, T, Q> const& ColorSRGB, T Gamma)
 {
  return detail::compute_srgbToRgb<L, T, Q>::call(ColorSRGB, Gamma);
 }
}
# 57 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/color_space.hpp" 2
# 175 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/integer.hpp" 1
# 14 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/integer.hpp"
       


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/setup.hpp" 1
# 18 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/integer.hpp" 2
# 30 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/integer.hpp"
namespace glm
{





 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> log2(vec<L, T, Q> const& v);


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/integer.inl" 1


namespace glm{
namespace detail
{
 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_log2<L, T, Q, false, Aligned>
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& v)
  {


   return vec<L, T, Q>(detail::compute_findMSB_vec<L, T, Q, sizeof(T) * 8>::call(v));
  }
 };
# 32 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/integer.inl"
}
}
# 44 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/integer.hpp" 2
# 178 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/matrix_access.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/matrix_access.hpp"
       


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/setup.hpp" 1
# 17 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/matrix_access.hpp" 2





namespace glm
{





 template<typename genType>
 [[nodiscard]] typename genType::row_type row(
  genType const& m,
  length_t index);



 template<typename genType>
 [[nodiscard]] genType row(
  genType const& m,
  length_t index,
  typename genType::row_type const& x);



 template<typename genType>
 [[nodiscard]] typename genType::col_type column(
  genType const& m,
  length_t index);



 template<typename genType>
 [[nodiscard]] genType column(
  genType const& m,
  length_t index,
  typename genType::col_type const& x);


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/matrix_access.inl" 1


namespace glm
{
 template<typename genType>
 inline genType row
 (
  genType const& m,
  length_t index,
  typename genType::row_type const& x
 )
 {
  
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/matrix_access.inl" 3
 ((void)0)
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/matrix_access.inl"
                                            ;

  genType Result = m;
  for(length_t i = 0; i < m.length(); ++i)
   Result[i][index] = x[i];
  return Result;
 }

 template<typename genType>
 inline typename genType::row_type row
 (
  genType const& m,
  length_t index
 )
 {
  
# 28 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/matrix_access.inl" 3
 ((void)0)
# 28 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/matrix_access.inl"
                                            ;

  typename genType::row_type Result(0);
  for(length_t i = 0; i < m.length(); ++i)
   Result[i] = m[i][index];
  return Result;
 }

 template<typename genType>
 inline genType column
 (
  genType const& m,
  length_t index,
  typename genType::col_type const& x
 )
 {
  
# 44 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/matrix_access.inl" 3
 ((void)0)
# 44 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/matrix_access.inl"
                                         ;

  genType Result = m;
  Result[index] = x;
  return Result;
 }

 template<typename genType>
 inline typename genType::col_type column
 (
  genType const& m,
  length_t index
 )
 {
  
# 58 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/matrix_access.inl" 3
 ((void)0)
# 58 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/matrix_access.inl"
                                         ;

  return m[index];
 }
}
# 61 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/matrix_access.hpp" 2
# 179 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/matrix_integer.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/matrix_integer.hpp"
       
# 30 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/matrix_integer.hpp"
namespace glm
{





 typedef mat<2, 2, int, highp> highp_imat2;



 typedef mat<3, 3, int, highp> highp_imat3;



 typedef mat<4, 4, int, highp> highp_imat4;



 typedef mat<2, 2, int, highp> highp_imat2x2;



 typedef mat<2, 3, int, highp> highp_imat2x3;



 typedef mat<2, 4, int, highp> highp_imat2x4;



 typedef mat<3, 2, int, highp> highp_imat3x2;



 typedef mat<3, 3, int, highp> highp_imat3x3;



 typedef mat<3, 4, int, highp> highp_imat3x4;



 typedef mat<4, 2, int, highp> highp_imat4x2;



 typedef mat<4, 3, int, highp> highp_imat4x3;



 typedef mat<4, 4, int, highp> highp_imat4x4;




 typedef mat<2, 2, int, mediump> mediump_imat2;



 typedef mat<3, 3, int, mediump> mediump_imat3;



 typedef mat<4, 4, int, mediump> mediump_imat4;




 typedef mat<2, 2, int, mediump> mediump_imat2x2;



 typedef mat<2, 3, int, mediump> mediump_imat2x3;



 typedef mat<2, 4, int, mediump> mediump_imat2x4;



 typedef mat<3, 2, int, mediump> mediump_imat3x2;



 typedef mat<3, 3, int, mediump> mediump_imat3x3;



 typedef mat<3, 4, int, mediump> mediump_imat3x4;



 typedef mat<4, 2, int, mediump> mediump_imat4x2;



 typedef mat<4, 3, int, mediump> mediump_imat4x3;



 typedef mat<4, 4, int, mediump> mediump_imat4x4;




 typedef mat<2, 2, int, lowp> lowp_imat2;



 typedef mat<3, 3, int, lowp> lowp_imat3;



 typedef mat<4, 4, int, lowp> lowp_imat4;




 typedef mat<2, 2, int, lowp> lowp_imat2x2;



 typedef mat<2, 3, int, lowp> lowp_imat2x3;



 typedef mat<2, 4, int, lowp> lowp_imat2x4;



 typedef mat<3, 2, int, lowp> lowp_imat3x2;



 typedef mat<3, 3, int, lowp> lowp_imat3x3;



 typedef mat<3, 4, int, lowp> lowp_imat3x4;



 typedef mat<4, 2, int, lowp> lowp_imat4x2;



 typedef mat<4, 3, int, lowp> lowp_imat4x3;



 typedef mat<4, 4, int, lowp> lowp_imat4x4;




 typedef mat<2, 2, uint, highp> highp_umat2;



 typedef mat<3, 3, uint, highp> highp_umat3;



 typedef mat<4, 4, uint, highp> highp_umat4;



 typedef mat<2, 2, uint, highp> highp_umat2x2;



 typedef mat<2, 3, uint, highp> highp_umat2x3;



 typedef mat<2, 4, uint, highp> highp_umat2x4;



 typedef mat<3, 2, uint, highp> highp_umat3x2;



 typedef mat<3, 3, uint, highp> highp_umat3x3;



 typedef mat<3, 4, uint, highp> highp_umat3x4;



 typedef mat<4, 2, uint, highp> highp_umat4x2;



 typedef mat<4, 3, uint, highp> highp_umat4x3;



 typedef mat<4, 4, uint, highp> highp_umat4x4;




 typedef mat<2, 2, uint, mediump> mediump_umat2;



 typedef mat<3, 3, uint, mediump> mediump_umat3;



 typedef mat<4, 4, uint, mediump> mediump_umat4;




 typedef mat<2, 2, uint, mediump> mediump_umat2x2;



 typedef mat<2, 3, uint, mediump> mediump_umat2x3;



 typedef mat<2, 4, uint, mediump> mediump_umat2x4;



 typedef mat<3, 2, uint, mediump> mediump_umat3x2;



 typedef mat<3, 3, uint, mediump> mediump_umat3x3;



 typedef mat<3, 4, uint, mediump> mediump_umat3x4;



 typedef mat<4, 2, uint, mediump> mediump_umat4x2;



 typedef mat<4, 3, uint, mediump> mediump_umat4x3;



 typedef mat<4, 4, uint, mediump> mediump_umat4x4;




 typedef mat<2, 2, uint, lowp> lowp_umat2;



 typedef mat<3, 3, uint, lowp> lowp_umat3;



 typedef mat<4, 4, uint, lowp> lowp_umat4;




 typedef mat<2, 2, uint, lowp> lowp_umat2x2;



 typedef mat<2, 3, uint, lowp> lowp_umat2x3;



 typedef mat<2, 4, uint, lowp> lowp_umat2x4;



 typedef mat<3, 2, uint, lowp> lowp_umat3x2;



 typedef mat<3, 3, uint, lowp> lowp_umat3x3;



 typedef mat<3, 4, uint, lowp> lowp_umat3x4;



 typedef mat<4, 2, uint, lowp> lowp_umat4x2;



 typedef mat<4, 3, uint, lowp> lowp_umat4x3;



 typedef mat<4, 4, uint, lowp> lowp_umat4x4;





 typedef mat<2, 2, int, defaultp> imat2;



 typedef mat<3, 3, int, defaultp> imat3;



 typedef mat<4, 4, int, defaultp> imat4;



 typedef mat<2, 2, int, defaultp> imat2x2;



 typedef mat<2, 3, int, defaultp> imat2x3;



 typedef mat<2, 4, int, defaultp> imat2x4;



 typedef mat<3, 2, int, defaultp> imat3x2;



 typedef mat<3, 3, int, defaultp> imat3x3;



 typedef mat<3, 4, int, defaultp> imat3x4;



 typedef mat<4, 2, int, defaultp> imat4x2;



 typedef mat<4, 3, int, defaultp> imat4x3;



 typedef mat<4, 4, int, defaultp> imat4x4;





 typedef mat<2, 2, uint, defaultp> umat2;



 typedef mat<3, 3, uint, defaultp> umat3;



 typedef mat<4, 4, uint, defaultp> umat4;



 typedef mat<2, 2, uint, defaultp> umat2x2;



 typedef mat<2, 3, uint, defaultp> umat2x3;



 typedef mat<2, 4, uint, defaultp> umat2x4;



 typedef mat<3, 2, uint, defaultp> umat3x2;



 typedef mat<3, 3, uint, defaultp> umat3x3;



 typedef mat<3, 4, uint, defaultp> umat3x4;



 typedef mat<4, 2, uint, defaultp> umat4x2;



 typedef mat<4, 3, uint, defaultp> umat4x3;



 typedef mat<4, 4, uint, defaultp> umat4x4;


}
# 180 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/matrix_inverse.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/matrix_inverse.hpp"
       


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/setup.hpp" 1
# 17 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/matrix_inverse.hpp" 2
# 26 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/matrix_inverse.hpp"
namespace glm
{
# 36 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/matrix_inverse.hpp"
 template<typename genType>
 [[nodiscard]] genType affineInverse(genType const& m);






 template<typename genType>
 [[nodiscard]] genType inverseTranspose(genType const& m);


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/matrix_inverse.inl" 1


namespace glm
{
 template<typename T, qualifier Q>
 inline mat<3, 3, T, Q> affineInverse(mat<3, 3, T, Q> const& m)
 {
  mat<2, 2, T, Q> const Inv(inverse(mat<2, 2, T, Q>(m)));

  return mat<3, 3, T, Q>(
   vec<3, T, Q>(Inv[0], static_cast<T>(0)),
   vec<3, T, Q>(Inv[1], static_cast<T>(0)),
   vec<3, T, Q>(-Inv * vec<2, T, Q>(m[2]), static_cast<T>(1)));
 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> affineInverse(mat<4, 4, T, Q> const& m)
 {
  mat<3, 3, T, Q> const Inv(inverse(mat<3, 3, T, Q>(m)));

  return mat<4, 4, T, Q>(
   vec<4, T, Q>(Inv[0], static_cast<T>(0)),
   vec<4, T, Q>(Inv[1], static_cast<T>(0)),
   vec<4, T, Q>(Inv[2], static_cast<T>(0)),
   vec<4, T, Q>(-Inv * vec<3, T, Q>(m[3]), static_cast<T>(1)));
 }

 template<typename T, qualifier Q>
 inline mat<2, 2, T, Q> inverseTranspose(mat<2, 2, T, Q> const& m)
 {
  T Determinant = m[0][0] * m[1][1] - m[1][0] * m[0][1];

  mat<2, 2, T, Q> Inverse(
   + m[1][1] / Determinant,
   - m[0][1] / Determinant,
   - m[1][0] / Determinant,
   + m[0][0] / Determinant);

  return Inverse;
 }

 template<typename T, qualifier Q>
 inline mat<3, 3, T, Q> inverseTranspose(mat<3, 3, T, Q> const& m)
 {
  T Determinant =
   + m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1])
   - m[0][1] * (m[1][0] * m[2][2] - m[1][2] * m[2][0])
   + m[0][2] * (m[1][0] * m[2][1] - m[1][1] * m[2][0]);

  mat<3, 3, T, Q> Inverse;
  Inverse[0][0] = + (m[1][1] * m[2][2] - m[2][1] * m[1][2]);
  Inverse[0][1] = - (m[1][0] * m[2][2] - m[2][0] * m[1][2]);
  Inverse[0][2] = + (m[1][0] * m[2][1] - m[2][0] * m[1][1]);
  Inverse[1][0] = - (m[0][1] * m[2][2] - m[2][1] * m[0][2]);
  Inverse[1][1] = + (m[0][0] * m[2][2] - m[2][0] * m[0][2]);
  Inverse[1][2] = - (m[0][0] * m[2][1] - m[2][0] * m[0][1]);
  Inverse[2][0] = + (m[0][1] * m[1][2] - m[1][1] * m[0][2]);
  Inverse[2][1] = - (m[0][0] * m[1][2] - m[1][0] * m[0][2]);
  Inverse[2][2] = + (m[0][0] * m[1][1] - m[1][0] * m[0][1]);
  Inverse /= Determinant;

  return Inverse;
 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> inverseTranspose(mat<4, 4, T, Q> const& m)
 {
  T SubFactor00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
  T SubFactor01 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
  T SubFactor02 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
  T SubFactor03 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
  T SubFactor04 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
  T SubFactor05 = m[2][0] * m[3][1] - m[3][0] * m[2][1];
  T SubFactor06 = m[1][2] * m[3][3] - m[3][2] * m[1][3];
  T SubFactor07 = m[1][1] * m[3][3] - m[3][1] * m[1][3];
  T SubFactor08 = m[1][1] * m[3][2] - m[3][1] * m[1][2];
  T SubFactor09 = m[1][0] * m[3][3] - m[3][0] * m[1][3];
  T SubFactor10 = m[1][0] * m[3][2] - m[3][0] * m[1][2];
  T SubFactor11 = m[1][0] * m[3][1] - m[3][0] * m[1][1];
  T SubFactor12 = m[1][2] * m[2][3] - m[2][2] * m[1][3];
  T SubFactor13 = m[1][1] * m[2][3] - m[2][1] * m[1][3];
  T SubFactor14 = m[1][1] * m[2][2] - m[2][1] * m[1][2];
  T SubFactor15 = m[1][0] * m[2][3] - m[2][0] * m[1][3];
  T SubFactor16 = m[1][0] * m[2][2] - m[2][0] * m[1][2];
  T SubFactor17 = m[1][0] * m[2][1] - m[2][0] * m[1][1];

  mat<4, 4, T, Q> Inverse;
  Inverse[0][0] = + (m[1][1] * SubFactor00 - m[1][2] * SubFactor01 + m[1][3] * SubFactor02);
  Inverse[0][1] = - (m[1][0] * SubFactor00 - m[1][2] * SubFactor03 + m[1][3] * SubFactor04);
  Inverse[0][2] = + (m[1][0] * SubFactor01 - m[1][1] * SubFactor03 + m[1][3] * SubFactor05);
  Inverse[0][3] = - (m[1][0] * SubFactor02 - m[1][1] * SubFactor04 + m[1][2] * SubFactor05);

  Inverse[1][0] = - (m[0][1] * SubFactor00 - m[0][2] * SubFactor01 + m[0][3] * SubFactor02);
  Inverse[1][1] = + (m[0][0] * SubFactor00 - m[0][2] * SubFactor03 + m[0][3] * SubFactor04);
  Inverse[1][2] = - (m[0][0] * SubFactor01 - m[0][1] * SubFactor03 + m[0][3] * SubFactor05);
  Inverse[1][3] = + (m[0][0] * SubFactor02 - m[0][1] * SubFactor04 + m[0][2] * SubFactor05);

  Inverse[2][0] = + (m[0][1] * SubFactor06 - m[0][2] * SubFactor07 + m[0][3] * SubFactor08);
  Inverse[2][1] = - (m[0][0] * SubFactor06 - m[0][2] * SubFactor09 + m[0][3] * SubFactor10);
  Inverse[2][2] = + (m[0][0] * SubFactor07 - m[0][1] * SubFactor09 + m[0][3] * SubFactor11);
  Inverse[2][3] = - (m[0][0] * SubFactor08 - m[0][1] * SubFactor10 + m[0][2] * SubFactor11);

  Inverse[3][0] = - (m[0][1] * SubFactor12 - m[0][2] * SubFactor13 + m[0][3] * SubFactor14);
  Inverse[3][1] = + (m[0][0] * SubFactor12 - m[0][2] * SubFactor15 + m[0][3] * SubFactor16);
  Inverse[3][2] = - (m[0][0] * SubFactor13 - m[0][1] * SubFactor15 + m[0][3] * SubFactor17);
  Inverse[3][3] = + (m[0][0] * SubFactor14 - m[0][1] * SubFactor16 + m[0][2] * SubFactor17);

  T Determinant =
   + m[0][0] * Inverse[0][0]
   + m[0][1] * Inverse[0][1]
   + m[0][2] * Inverse[0][2]
   + m[0][3] * Inverse[0][3];

  Inverse /= Determinant;

  return Inverse;
 }
}
# 51 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/matrix_inverse.hpp" 2
# 181 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/noise.hpp" 1
# 17 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/noise.hpp"
       


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/setup.hpp" 1
# 21 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/noise.hpp" 2

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/_noise.hpp" 1
       



namespace glm{
namespace detail
{
 template<typename T>
 inline T mod289(T const& x)
 {
  return x - floor(x * (static_cast<T>(1.0) / static_cast<T>(289.0))) * static_cast<T>(289.0);
 }

 template<typename T>
 inline T permute(T const& x)
 {
  return mod289(((x * static_cast<T>(34)) + static_cast<T>(1)) * x);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> permute(vec<2, T, Q> const& x)
 {
  return mod289(((x * static_cast<T>(34)) + static_cast<T>(1)) * x);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> permute(vec<3, T, Q> const& x)
 {
  return mod289(((x * static_cast<T>(34)) + static_cast<T>(1)) * x);
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> permute(vec<4, T, Q> const& x)
 {
  return mod289(((x * static_cast<T>(34)) + static_cast<T>(1)) * x);
 }

 template<typename T>
 inline T taylorInvSqrt(T const& r)
 {
  return static_cast<T>(1.79284291400159) - static_cast<T>(0.85373472095314) * r;
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> taylorInvSqrt(vec<2, T, Q> const& r)
 {
  return static_cast<T>(1.79284291400159) - static_cast<T>(0.85373472095314) * r;
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> taylorInvSqrt(vec<3, T, Q> const& r)
 {
  return static_cast<T>(1.79284291400159) - static_cast<T>(0.85373472095314) * r;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> taylorInvSqrt(vec<4, T, Q> const& r)
 {
  return static_cast<T>(1.79284291400159) - static_cast<T>(0.85373472095314) * r;
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> fade(vec<2, T, Q> const& t)
 {
  return (t * t * t) * (t * (t * static_cast<T>(6) - static_cast<T>(15)) + static_cast<T>(10));
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> fade(vec<3, T, Q> const& t)
 {
  return (t * t * t) * (t * (t * static_cast<T>(6) - static_cast<T>(15)) + static_cast<T>(10));
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> fade(vec<4, T, Q> const& t)
 {
  return (t * t * t) * (t * (t * static_cast<T>(6) - static_cast<T>(15)) + static_cast<T>(10));
 }
}
}
# 23 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/noise.hpp" 2
# 34 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/noise.hpp"
namespace glm
{





 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] T perlin(
  vec<L, T, Q> const& p);



 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] T perlin(
  vec<L, T, Q> const& p,
  vec<L, T, Q> const& rep);



 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] T simplex(
  vec<L, T, Q> const& p);


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/noise.inl" 1







namespace glm{
namespace detail
{
 template<typename T, qualifier Q>
 inline vec<4, T, Q> grad4(T const& j, vec<4, T, Q> const& ip)
 {
  vec<3, T, Q> pXYZ = floor(fract(vec<3, T, Q>(j) * vec<3, T, Q>(ip)) * T(7)) * ip[2] - T(1);
  T pW = static_cast<T>(1.5) - dot(abs(pXYZ), vec<3, T, Q>(1));
  vec<4, T, Q> s = vec<4, T, Q>(lessThan(vec<4, T, Q>(pXYZ, pW), vec<4, T, Q>(0.0)));
  pXYZ = pXYZ + (vec<3, T, Q>(s) * T(2) - T(1)) * s.w;
  return vec<4, T, Q>(pXYZ, pW);
 }
}


 template<typename T, qualifier Q>
 inline T perlin(vec<2, T, Q> const& Position)
 {
  vec<4, T, Q> Pi = glm::floor(vec<4, T, Q>(Position.x, Position.y, Position.x, Position.y)) + vec<4, T, Q>(0.0, 0.0, 1.0, 1.0);
  vec<4, T, Q> Pf = glm::fract(vec<4, T, Q>(Position.x, Position.y, Position.x, Position.y)) - vec<4, T, Q>(0.0, 0.0, 1.0, 1.0);
  Pi = mod(Pi, vec<4, T, Q>(289));
  vec<4, T, Q> ix(Pi.x, Pi.z, Pi.x, Pi.z);
  vec<4, T, Q> iy(Pi.y, Pi.y, Pi.w, Pi.w);
  vec<4, T, Q> fx(Pf.x, Pf.z, Pf.x, Pf.z);
  vec<4, T, Q> fy(Pf.y, Pf.y, Pf.w, Pf.w);

  vec<4, T, Q> i = detail::permute(detail::permute(ix) + iy);

  vec<4, T, Q> gx = static_cast<T>(2) * glm::fract(i / T(41)) - T(1);
  vec<4, T, Q> gy = glm::abs(gx) - T(0.5);
  vec<4, T, Q> tx = glm::floor(gx + T(0.5));
  gx = gx - tx;

  vec<2, T, Q> g00(gx.x, gy.x);
  vec<2, T, Q> g10(gx.y, gy.y);
  vec<2, T, Q> g01(gx.z, gy.z);
  vec<2, T, Q> g11(gx.w, gy.w);

  vec<4, T, Q> norm = detail::taylorInvSqrt(vec<4, T, Q>(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));
  g00 *= norm.x;
  g01 *= norm.y;
  g10 *= norm.z;
  g11 *= norm.w;

  T n00 = dot(g00, vec<2, T, Q>(fx.x, fy.x));
  T n10 = dot(g10, vec<2, T, Q>(fx.y, fy.y));
  T n01 = dot(g01, vec<2, T, Q>(fx.z, fy.z));
  T n11 = dot(g11, vec<2, T, Q>(fx.w, fy.w));

  vec<2, T, Q> fade_xy = detail::fade(vec<2, T, Q>(Pf.x, Pf.y));
  vec<2, T, Q> n_x = mix(vec<2, T, Q>(n00, n01), vec<2, T, Q>(n10, n11), fade_xy.x);
  T n_xy = mix(n_x.x, n_x.y, fade_xy.y);
  return T(2.3) * n_xy;
 }


 template<typename T, qualifier Q>
 inline T perlin(vec<3, T, Q> const& Position)
 {
  vec<3, T, Q> Pi0 = floor(Position);
  vec<3, T, Q> Pi1 = Pi0 + T(1);
  Pi0 = detail::mod289(Pi0);
  Pi1 = detail::mod289(Pi1);
  vec<3, T, Q> Pf0 = fract(Position);
  vec<3, T, Q> Pf1 = Pf0 - T(1);
  vec<4, T, Q> ix(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
  vec<4, T, Q> iy = vec<4, T, Q>(vec<2, T, Q>(Pi0.y), vec<2, T, Q>(Pi1.y));
  vec<4, T, Q> iz0(Pi0.z);
  vec<4, T, Q> iz1(Pi1.z);

  vec<4, T, Q> ixy = detail::permute(detail::permute(ix) + iy);
  vec<4, T, Q> ixy0 = detail::permute(ixy + iz0);
  vec<4, T, Q> ixy1 = detail::permute(ixy + iz1);

  vec<4, T, Q> gx0 = ixy0 * T(1.0 / 7.0);
  vec<4, T, Q> gy0 = fract(floor(gx0) * T(1.0 / 7.0)) - T(0.5);
  gx0 = fract(gx0);
  vec<4, T, Q> gz0 = vec<4, T, Q>(0.5) - abs(gx0) - abs(gy0);
  vec<4, T, Q> sz0 = step(gz0, vec<4, T, Q>(0.0));
  gx0 -= sz0 * (step(T(0), gx0) - T(0.5));
  gy0 -= sz0 * (step(T(0), gy0) - T(0.5));

  vec<4, T, Q> gx1 = ixy1 * T(1.0 / 7.0);
  vec<4, T, Q> gy1 = fract(floor(gx1) * T(1.0 / 7.0)) - T(0.5);
  gx1 = fract(gx1);
  vec<4, T, Q> gz1 = vec<4, T, Q>(0.5) - abs(gx1) - abs(gy1);
  vec<4, T, Q> sz1 = step(gz1, vec<4, T, Q>(0.0));
  gx1 -= sz1 * (step(T(0), gx1) - T(0.5));
  gy1 -= sz1 * (step(T(0), gy1) - T(0.5));

  vec<3, T, Q> g000(gx0.x, gy0.x, gz0.x);
  vec<3, T, Q> g100(gx0.y, gy0.y, gz0.y);
  vec<3, T, Q> g010(gx0.z, gy0.z, gz0.z);
  vec<3, T, Q> g110(gx0.w, gy0.w, gz0.w);
  vec<3, T, Q> g001(gx1.x, gy1.x, gz1.x);
  vec<3, T, Q> g101(gx1.y, gy1.y, gz1.y);
  vec<3, T, Q> g011(gx1.z, gy1.z, gz1.z);
  vec<3, T, Q> g111(gx1.w, gy1.w, gz1.w);

  vec<4, T, Q> norm0 = detail::taylorInvSqrt(vec<4, T, Q>(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
  g000 *= norm0.x;
  g010 *= norm0.y;
  g100 *= norm0.z;
  g110 *= norm0.w;
  vec<4, T, Q> norm1 = detail::taylorInvSqrt(vec<4, T, Q>(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
  g001 *= norm1.x;
  g011 *= norm1.y;
  g101 *= norm1.z;
  g111 *= norm1.w;

  T n000 = dot(g000, Pf0);
  T n100 = dot(g100, vec<3, T, Q>(Pf1.x, Pf0.y, Pf0.z));
  T n010 = dot(g010, vec<3, T, Q>(Pf0.x, Pf1.y, Pf0.z));
  T n110 = dot(g110, vec<3, T, Q>(Pf1.x, Pf1.y, Pf0.z));
  T n001 = dot(g001, vec<3, T, Q>(Pf0.x, Pf0.y, Pf1.z));
  T n101 = dot(g101, vec<3, T, Q>(Pf1.x, Pf0.y, Pf1.z));
  T n011 = dot(g011, vec<3, T, Q>(Pf0.x, Pf1.y, Pf1.z));
  T n111 = dot(g111, Pf1);

  vec<3, T, Q> fade_xyz = detail::fade(Pf0);
  vec<4, T, Q> n_z = mix(vec<4, T, Q>(n000, n100, n010, n110), vec<4, T, Q>(n001, n101, n011, n111), fade_xyz.z);
  vec<2, T, Q> n_yz = mix(vec<2, T, Q>(n_z.x, n_z.y), vec<2, T, Q>(n_z.z, n_z.w), fade_xyz.y);
  T n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
  return T(2.2) * n_xyz;
 }
# 208 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/noise.inl"
 template<typename T, qualifier Q>
 inline T perlin(vec<4, T, Q> const& Position)
 {
  vec<4, T, Q> Pi0 = floor(Position);
  vec<4, T, Q> Pi1 = Pi0 + T(1);
  Pi0 = mod(Pi0, vec<4, T, Q>(289));
  Pi1 = mod(Pi1, vec<4, T, Q>(289));
  vec<4, T, Q> Pf0 = fract(Position);
  vec<4, T, Q> Pf1 = Pf0 - T(1);
  vec<4, T, Q> ix(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
  vec<4, T, Q> iy(Pi0.y, Pi0.y, Pi1.y, Pi1.y);
  vec<4, T, Q> iz0(Pi0.z);
  vec<4, T, Q> iz1(Pi1.z);
  vec<4, T, Q> iw0(Pi0.w);
  vec<4, T, Q> iw1(Pi1.w);

  vec<4, T, Q> ixy = detail::permute(detail::permute(ix) + iy);
  vec<4, T, Q> ixy0 = detail::permute(ixy + iz0);
  vec<4, T, Q> ixy1 = detail::permute(ixy + iz1);
  vec<4, T, Q> ixy00 = detail::permute(ixy0 + iw0);
  vec<4, T, Q> ixy01 = detail::permute(ixy0 + iw1);
  vec<4, T, Q> ixy10 = detail::permute(ixy1 + iw0);
  vec<4, T, Q> ixy11 = detail::permute(ixy1 + iw1);

  vec<4, T, Q> gx00 = ixy00 / T(7);
  vec<4, T, Q> gy00 = floor(gx00) / T(7);
  vec<4, T, Q> gz00 = floor(gy00) / T(6);
  gx00 = fract(gx00) - T(0.5);
  gy00 = fract(gy00) - T(0.5);
  gz00 = fract(gz00) - T(0.5);
  vec<4, T, Q> gw00 = vec<4, T, Q>(0.75) - abs(gx00) - abs(gy00) - abs(gz00);
  vec<4, T, Q> sw00 = step(gw00, vec<4, T, Q>(0.0));
  gx00 -= sw00 * (step(T(0), gx00) - T(0.5));
  gy00 -= sw00 * (step(T(0), gy00) - T(0.5));

  vec<4, T, Q> gx01 = ixy01 / T(7);
  vec<4, T, Q> gy01 = floor(gx01) / T(7);
  vec<4, T, Q> gz01 = floor(gy01) / T(6);
  gx01 = fract(gx01) - T(0.5);
  gy01 = fract(gy01) - T(0.5);
  gz01 = fract(gz01) - T(0.5);
  vec<4, T, Q> gw01 = vec<4, T, Q>(0.75) - abs(gx01) - abs(gy01) - abs(gz01);
  vec<4, T, Q> sw01 = step(gw01, vec<4, T, Q>(0.0));
  gx01 -= sw01 * (step(T(0), gx01) - T(0.5));
  gy01 -= sw01 * (step(T(0), gy01) - T(0.5));

  vec<4, T, Q> gx10 = ixy10 / T(7);
  vec<4, T, Q> gy10 = floor(gx10) / T(7);
  vec<4, T, Q> gz10 = floor(gy10) / T(6);
  gx10 = fract(gx10) - T(0.5);
  gy10 = fract(gy10) - T(0.5);
  gz10 = fract(gz10) - T(0.5);
  vec<4, T, Q> gw10 = vec<4, T, Q>(0.75) - abs(gx10) - abs(gy10) - abs(gz10);
  vec<4, T, Q> sw10 = step(gw10, vec<4, T, Q>(0));
  gx10 -= sw10 * (step(T(0), gx10) - T(0.5));
  gy10 -= sw10 * (step(T(0), gy10) - T(0.5));

  vec<4, T, Q> gx11 = ixy11 / T(7);
  vec<4, T, Q> gy11 = floor(gx11) / T(7);
  vec<4, T, Q> gz11 = floor(gy11) / T(6);
  gx11 = fract(gx11) - T(0.5);
  gy11 = fract(gy11) - T(0.5);
  gz11 = fract(gz11) - T(0.5);
  vec<4, T, Q> gw11 = vec<4, T, Q>(0.75) - abs(gx11) - abs(gy11) - abs(gz11);
  vec<4, T, Q> sw11 = step(gw11, vec<4, T, Q>(0.0));
  gx11 -= sw11 * (step(T(0), gx11) - T(0.5));
  gy11 -= sw11 * (step(T(0), gy11) - T(0.5));

  vec<4, T, Q> g0000(gx00.x, gy00.x, gz00.x, gw00.x);
  vec<4, T, Q> g1000(gx00.y, gy00.y, gz00.y, gw00.y);
  vec<4, T, Q> g0100(gx00.z, gy00.z, gz00.z, gw00.z);
  vec<4, T, Q> g1100(gx00.w, gy00.w, gz00.w, gw00.w);
  vec<4, T, Q> g0010(gx10.x, gy10.x, gz10.x, gw10.x);
  vec<4, T, Q> g1010(gx10.y, gy10.y, gz10.y, gw10.y);
  vec<4, T, Q> g0110(gx10.z, gy10.z, gz10.z, gw10.z);
  vec<4, T, Q> g1110(gx10.w, gy10.w, gz10.w, gw10.w);
  vec<4, T, Q> g0001(gx01.x, gy01.x, gz01.x, gw01.x);
  vec<4, T, Q> g1001(gx01.y, gy01.y, gz01.y, gw01.y);
  vec<4, T, Q> g0101(gx01.z, gy01.z, gz01.z, gw01.z);
  vec<4, T, Q> g1101(gx01.w, gy01.w, gz01.w, gw01.w);
  vec<4, T, Q> g0011(gx11.x, gy11.x, gz11.x, gw11.x);
  vec<4, T, Q> g1011(gx11.y, gy11.y, gz11.y, gw11.y);
  vec<4, T, Q> g0111(gx11.z, gy11.z, gz11.z, gw11.z);
  vec<4, T, Q> g1111(gx11.w, gy11.w, gz11.w, gw11.w);

  vec<4, T, Q> norm00 = detail::taylorInvSqrt(vec<4, T, Q>(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));
  g0000 *= norm00.x;
  g0100 *= norm00.y;
  g1000 *= norm00.z;
  g1100 *= norm00.w;

  vec<4, T, Q> norm01 = detail::taylorInvSqrt(vec<4, T, Q>(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));
  g0001 *= norm01.x;
  g0101 *= norm01.y;
  g1001 *= norm01.z;
  g1101 *= norm01.w;

  vec<4, T, Q> norm10 = detail::taylorInvSqrt(vec<4, T, Q>(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));
  g0010 *= norm10.x;
  g0110 *= norm10.y;
  g1010 *= norm10.z;
  g1110 *= norm10.w;

  vec<4, T, Q> norm11 = detail::taylorInvSqrt(vec<4, T, Q>(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));
  g0011 *= norm11.x;
  g0111 *= norm11.y;
  g1011 *= norm11.z;
  g1111 *= norm11.w;

  T n0000 = dot(g0000, Pf0);
  T n1000 = dot(g1000, vec<4, T, Q>(Pf1.x, Pf0.y, Pf0.z, Pf0.w));
  T n0100 = dot(g0100, vec<4, T, Q>(Pf0.x, Pf1.y, Pf0.z, Pf0.w));
  T n1100 = dot(g1100, vec<4, T, Q>(Pf1.x, Pf1.y, Pf0.z, Pf0.w));
  T n0010 = dot(g0010, vec<4, T, Q>(Pf0.x, Pf0.y, Pf1.z, Pf0.w));
  T n1010 = dot(g1010, vec<4, T, Q>(Pf1.x, Pf0.y, Pf1.z, Pf0.w));
  T n0110 = dot(g0110, vec<4, T, Q>(Pf0.x, Pf1.y, Pf1.z, Pf0.w));
  T n1110 = dot(g1110, vec<4, T, Q>(Pf1.x, Pf1.y, Pf1.z, Pf0.w));
  T n0001 = dot(g0001, vec<4, T, Q>(Pf0.x, Pf0.y, Pf0.z, Pf1.w));
  T n1001 = dot(g1001, vec<4, T, Q>(Pf1.x, Pf0.y, Pf0.z, Pf1.w));
  T n0101 = dot(g0101, vec<4, T, Q>(Pf0.x, Pf1.y, Pf0.z, Pf1.w));
  T n1101 = dot(g1101, vec<4, T, Q>(Pf1.x, Pf1.y, Pf0.z, Pf1.w));
  T n0011 = dot(g0011, vec<4, T, Q>(Pf0.x, Pf0.y, Pf1.z, Pf1.w));
  T n1011 = dot(g1011, vec<4, T, Q>(Pf1.x, Pf0.y, Pf1.z, Pf1.w));
  T n0111 = dot(g0111, vec<4, T, Q>(Pf0.x, Pf1.y, Pf1.z, Pf1.w));
  T n1111 = dot(g1111, Pf1);

  vec<4, T, Q> fade_xyzw = detail::fade(Pf0);
  vec<4, T, Q> n_0w = mix(vec<4, T, Q>(n0000, n1000, n0100, n1100), vec<4, T, Q>(n0001, n1001, n0101, n1101), fade_xyzw.w);
  vec<4, T, Q> n_1w = mix(vec<4, T, Q>(n0010, n1010, n0110, n1110), vec<4, T, Q>(n0011, n1011, n0111, n1111), fade_xyzw.w);
  vec<4, T, Q> n_zw = mix(n_0w, n_1w, fade_xyzw.z);
  vec<2, T, Q> n_yzw = mix(vec<2, T, Q>(n_zw.x, n_zw.y), vec<2, T, Q>(n_zw.z, n_zw.w), fade_xyzw.y);
  T n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);
  return T(2.2) * n_xyzw;
 }


 template<typename T, qualifier Q>
 inline T perlin(vec<2, T, Q> const& Position, vec<2, T, Q> const& rep)
 {
  vec<4, T, Q> Pi = floor(vec<4, T, Q>(Position.x, Position.y, Position.x, Position.y)) + vec<4, T, Q>(0.0, 0.0, 1.0, 1.0);
  vec<4, T, Q> Pf = fract(vec<4, T, Q>(Position.x, Position.y, Position.x, Position.y)) - vec<4, T, Q>(0.0, 0.0, 1.0, 1.0);
  Pi = mod(Pi, vec<4, T, Q>(rep.x, rep.y, rep.x, rep.y));
  Pi = mod(Pi, vec<4, T, Q>(289));
  vec<4, T, Q> ix(Pi.x, Pi.z, Pi.x, Pi.z);
  vec<4, T, Q> iy(Pi.y, Pi.y, Pi.w, Pi.w);
  vec<4, T, Q> fx(Pf.x, Pf.z, Pf.x, Pf.z);
  vec<4, T, Q> fy(Pf.y, Pf.y, Pf.w, Pf.w);

  vec<4, T, Q> i = detail::permute(detail::permute(ix) + iy);

  vec<4, T, Q> gx = static_cast<T>(2) * fract(i / T(41)) - T(1);
  vec<4, T, Q> gy = abs(gx) - T(0.5);
  vec<4, T, Q> tx = floor(gx + T(0.5));
  gx = gx - tx;

  vec<2, T, Q> g00(gx.x, gy.x);
  vec<2, T, Q> g10(gx.y, gy.y);
  vec<2, T, Q> g01(gx.z, gy.z);
  vec<2, T, Q> g11(gx.w, gy.w);

  vec<4, T, Q> norm = detail::taylorInvSqrt(vec<4, T, Q>(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));
  g00 *= norm.x;
  g01 *= norm.y;
  g10 *= norm.z;
  g11 *= norm.w;

  T n00 = dot(g00, vec<2, T, Q>(fx.x, fy.x));
  T n10 = dot(g10, vec<2, T, Q>(fx.y, fy.y));
  T n01 = dot(g01, vec<2, T, Q>(fx.z, fy.z));
  T n11 = dot(g11, vec<2, T, Q>(fx.w, fy.w));

  vec<2, T, Q> fade_xy = detail::fade(vec<2, T, Q>(Pf.x, Pf.y));
  vec<2, T, Q> n_x = mix(vec<2, T, Q>(n00, n01), vec<2, T, Q>(n10, n11), fade_xy.x);
  T n_xy = mix(n_x.x, n_x.y, fade_xy.y);
  return T(2.3) * n_xy;
 }


 template<typename T, qualifier Q>
 inline T perlin(vec<3, T, Q> const& Position, vec<3, T, Q> const& rep)
 {
  vec<3, T, Q> Pi0 = mod(floor(Position), rep);
  vec<3, T, Q> Pi1 = mod(Pi0 + vec<3, T, Q>(T(1)), rep);
  Pi0 = mod(Pi0, vec<3, T, Q>(289));
  Pi1 = mod(Pi1, vec<3, T, Q>(289));
  vec<3, T, Q> Pf0 = fract(Position);
  vec<3, T, Q> Pf1 = Pf0 - vec<3, T, Q>(T(1));
  vec<4, T, Q> ix = vec<4, T, Q>(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
  vec<4, T, Q> iy = vec<4, T, Q>(Pi0.y, Pi0.y, Pi1.y, Pi1.y);
  vec<4, T, Q> iz0(Pi0.z);
  vec<4, T, Q> iz1(Pi1.z);

  vec<4, T, Q> ixy = detail::permute(detail::permute(ix) + iy);
  vec<4, T, Q> ixy0 = detail::permute(ixy + iz0);
  vec<4, T, Q> ixy1 = detail::permute(ixy + iz1);

  vec<4, T, Q> gx0 = ixy0 / T(7);
  vec<4, T, Q> gy0 = fract(floor(gx0) / T(7)) - T(0.5);
  gx0 = fract(gx0);
  vec<4, T, Q> gz0 = vec<4, T, Q>(0.5) - abs(gx0) - abs(gy0);
  vec<4, T, Q> sz0 = step(gz0, vec<4, T, Q>(0));
  gx0 -= sz0 * (step(T(0), gx0) - T(0.5));
  gy0 -= sz0 * (step(T(0), gy0) - T(0.5));

  vec<4, T, Q> gx1 = ixy1 / T(7);
  vec<4, T, Q> gy1 = fract(floor(gx1) / T(7)) - T(0.5);
  gx1 = fract(gx1);
  vec<4, T, Q> gz1 = vec<4, T, Q>(0.5) - abs(gx1) - abs(gy1);
  vec<4, T, Q> sz1 = step(gz1, vec<4, T, Q>(T(0)));
  gx1 -= sz1 * (step(T(0), gx1) - T(0.5));
  gy1 -= sz1 * (step(T(0), gy1) - T(0.5));

  vec<3, T, Q> g000 = vec<3, T, Q>(gx0.x, gy0.x, gz0.x);
  vec<3, T, Q> g100 = vec<3, T, Q>(gx0.y, gy0.y, gz0.y);
  vec<3, T, Q> g010 = vec<3, T, Q>(gx0.z, gy0.z, gz0.z);
  vec<3, T, Q> g110 = vec<3, T, Q>(gx0.w, gy0.w, gz0.w);
  vec<3, T, Q> g001 = vec<3, T, Q>(gx1.x, gy1.x, gz1.x);
  vec<3, T, Q> g101 = vec<3, T, Q>(gx1.y, gy1.y, gz1.y);
  vec<3, T, Q> g011 = vec<3, T, Q>(gx1.z, gy1.z, gz1.z);
  vec<3, T, Q> g111 = vec<3, T, Q>(gx1.w, gy1.w, gz1.w);

  vec<4, T, Q> norm0 = detail::taylorInvSqrt(vec<4, T, Q>(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
  g000 *= norm0.x;
  g010 *= norm0.y;
  g100 *= norm0.z;
  g110 *= norm0.w;
  vec<4, T, Q> norm1 = detail::taylorInvSqrt(vec<4, T, Q>(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
  g001 *= norm1.x;
  g011 *= norm1.y;
  g101 *= norm1.z;
  g111 *= norm1.w;

  T n000 = dot(g000, Pf0);
  T n100 = dot(g100, vec<3, T, Q>(Pf1.x, Pf0.y, Pf0.z));
  T n010 = dot(g010, vec<3, T, Q>(Pf0.x, Pf1.y, Pf0.z));
  T n110 = dot(g110, vec<3, T, Q>(Pf1.x, Pf1.y, Pf0.z));
  T n001 = dot(g001, vec<3, T, Q>(Pf0.x, Pf0.y, Pf1.z));
  T n101 = dot(g101, vec<3, T, Q>(Pf1.x, Pf0.y, Pf1.z));
  T n011 = dot(g011, vec<3, T, Q>(Pf0.x, Pf1.y, Pf1.z));
  T n111 = dot(g111, Pf1);

  vec<3, T, Q> fade_xyz = detail::fade(Pf0);
  vec<4, T, Q> n_z = mix(vec<4, T, Q>(n000, n100, n010, n110), vec<4, T, Q>(n001, n101, n011, n111), fade_xyz.z);
  vec<2, T, Q> n_yz = mix(vec<2, T, Q>(n_z.x, n_z.y), vec<2, T, Q>(n_z.z, n_z.w), fade_xyz.y);
  T n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
  return T(2.2) * n_xyz;
 }


 template<typename T, qualifier Q>
 inline T perlin(vec<4, T, Q> const& Position, vec<4, T, Q> const& rep)
 {
  vec<4, T, Q> Pi0 = mod(floor(Position), rep);
  vec<4, T, Q> Pi1 = mod(Pi0 + T(1), rep);
  vec<4, T, Q> Pf0 = fract(Position);
  vec<4, T, Q> Pf1 = Pf0 - T(1);
  vec<4, T, Q> ix = vec<4, T, Q>(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
  vec<4, T, Q> iy = vec<4, T, Q>(Pi0.y, Pi0.y, Pi1.y, Pi1.y);
  vec<4, T, Q> iz0(Pi0.z);
  vec<4, T, Q> iz1(Pi1.z);
  vec<4, T, Q> iw0(Pi0.w);
  vec<4, T, Q> iw1(Pi1.w);

  vec<4, T, Q> ixy = detail::permute(detail::permute(ix) + iy);
  vec<4, T, Q> ixy0 = detail::permute(ixy + iz0);
  vec<4, T, Q> ixy1 = detail::permute(ixy + iz1);
  vec<4, T, Q> ixy00 = detail::permute(ixy0 + iw0);
  vec<4, T, Q> ixy01 = detail::permute(ixy0 + iw1);
  vec<4, T, Q> ixy10 = detail::permute(ixy1 + iw0);
  vec<4, T, Q> ixy11 = detail::permute(ixy1 + iw1);

  vec<4, T, Q> gx00 = ixy00 / T(7);
  vec<4, T, Q> gy00 = floor(gx00) / T(7);
  vec<4, T, Q> gz00 = floor(gy00) / T(6);
  gx00 = fract(gx00) - T(0.5);
  gy00 = fract(gy00) - T(0.5);
  gz00 = fract(gz00) - T(0.5);
  vec<4, T, Q> gw00 = vec<4, T, Q>(0.75) - abs(gx00) - abs(gy00) - abs(gz00);
  vec<4, T, Q> sw00 = step(gw00, vec<4, T, Q>(0));
  gx00 -= sw00 * (step(T(0), gx00) - T(0.5));
  gy00 -= sw00 * (step(T(0), gy00) - T(0.5));

  vec<4, T, Q> gx01 = ixy01 / T(7);
  vec<4, T, Q> gy01 = floor(gx01) / T(7);
  vec<4, T, Q> gz01 = floor(gy01) / T(6);
  gx01 = fract(gx01) - T(0.5);
  gy01 = fract(gy01) - T(0.5);
  gz01 = fract(gz01) - T(0.5);
  vec<4, T, Q> gw01 = vec<4, T, Q>(0.75) - abs(gx01) - abs(gy01) - abs(gz01);
  vec<4, T, Q> sw01 = step(gw01, vec<4, T, Q>(0.0));
  gx01 -= sw01 * (step(T(0), gx01) - T(0.5));
  gy01 -= sw01 * (step(T(0), gy01) - T(0.5));

  vec<4, T, Q> gx10 = ixy10 / T(7);
  vec<4, T, Q> gy10 = floor(gx10) / T(7);
  vec<4, T, Q> gz10 = floor(gy10) / T(6);
  gx10 = fract(gx10) - T(0.5);
  gy10 = fract(gy10) - T(0.5);
  gz10 = fract(gz10) - T(0.5);
  vec<4, T, Q> gw10 = vec<4, T, Q>(0.75) - abs(gx10) - abs(gy10) - abs(gz10);
  vec<4, T, Q> sw10 = step(gw10, vec<4, T, Q>(0.0));
  gx10 -= sw10 * (step(T(0), gx10) - T(0.5));
  gy10 -= sw10 * (step(T(0), gy10) - T(0.5));

  vec<4, T, Q> gx11 = ixy11 / T(7);
  vec<4, T, Q> gy11 = floor(gx11) / T(7);
  vec<4, T, Q> gz11 = floor(gy11) / T(6);
  gx11 = fract(gx11) - T(0.5);
  gy11 = fract(gy11) - T(0.5);
  gz11 = fract(gz11) - T(0.5);
  vec<4, T, Q> gw11 = vec<4, T, Q>(0.75) - abs(gx11) - abs(gy11) - abs(gz11);
  vec<4, T, Q> sw11 = step(gw11, vec<4, T, Q>(T(0)));
  gx11 -= sw11 * (step(T(0), gx11) - T(0.5));
  gy11 -= sw11 * (step(T(0), gy11) - T(0.5));

  vec<4, T, Q> g0000(gx00.x, gy00.x, gz00.x, gw00.x);
  vec<4, T, Q> g1000(gx00.y, gy00.y, gz00.y, gw00.y);
  vec<4, T, Q> g0100(gx00.z, gy00.z, gz00.z, gw00.z);
  vec<4, T, Q> g1100(gx00.w, gy00.w, gz00.w, gw00.w);
  vec<4, T, Q> g0010(gx10.x, gy10.x, gz10.x, gw10.x);
  vec<4, T, Q> g1010(gx10.y, gy10.y, gz10.y, gw10.y);
  vec<4, T, Q> g0110(gx10.z, gy10.z, gz10.z, gw10.z);
  vec<4, T, Q> g1110(gx10.w, gy10.w, gz10.w, gw10.w);
  vec<4, T, Q> g0001(gx01.x, gy01.x, gz01.x, gw01.x);
  vec<4, T, Q> g1001(gx01.y, gy01.y, gz01.y, gw01.y);
  vec<4, T, Q> g0101(gx01.z, gy01.z, gz01.z, gw01.z);
  vec<4, T, Q> g1101(gx01.w, gy01.w, gz01.w, gw01.w);
  vec<4, T, Q> g0011(gx11.x, gy11.x, gz11.x, gw11.x);
  vec<4, T, Q> g1011(gx11.y, gy11.y, gz11.y, gw11.y);
  vec<4, T, Q> g0111(gx11.z, gy11.z, gz11.z, gw11.z);
  vec<4, T, Q> g1111(gx11.w, gy11.w, gz11.w, gw11.w);

  vec<4, T, Q> norm00 = detail::taylorInvSqrt(vec<4, T, Q>(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));
  g0000 *= norm00.x;
  g0100 *= norm00.y;
  g1000 *= norm00.z;
  g1100 *= norm00.w;

  vec<4, T, Q> norm01 = detail::taylorInvSqrt(vec<4, T, Q>(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));
  g0001 *= norm01.x;
  g0101 *= norm01.y;
  g1001 *= norm01.z;
  g1101 *= norm01.w;

  vec<4, T, Q> norm10 = detail::taylorInvSqrt(vec<4, T, Q>(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));
  g0010 *= norm10.x;
  g0110 *= norm10.y;
  g1010 *= norm10.z;
  g1110 *= norm10.w;

  vec<4, T, Q> norm11 = detail::taylorInvSqrt(vec<4, T, Q>(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));
  g0011 *= norm11.x;
  g0111 *= norm11.y;
  g1011 *= norm11.z;
  g1111 *= norm11.w;

  T n0000 = dot(g0000, Pf0);
  T n1000 = dot(g1000, vec<4, T, Q>(Pf1.x, Pf0.y, Pf0.z, Pf0.w));
  T n0100 = dot(g0100, vec<4, T, Q>(Pf0.x, Pf1.y, Pf0.z, Pf0.w));
  T n1100 = dot(g1100, vec<4, T, Q>(Pf1.x, Pf1.y, Pf0.z, Pf0.w));
  T n0010 = dot(g0010, vec<4, T, Q>(Pf0.x, Pf0.y, Pf1.z, Pf0.w));
  T n1010 = dot(g1010, vec<4, T, Q>(Pf1.x, Pf0.y, Pf1.z, Pf0.w));
  T n0110 = dot(g0110, vec<4, T, Q>(Pf0.x, Pf1.y, Pf1.z, Pf0.w));
  T n1110 = dot(g1110, vec<4, T, Q>(Pf1.x, Pf1.y, Pf1.z, Pf0.w));
  T n0001 = dot(g0001, vec<4, T, Q>(Pf0.x, Pf0.y, Pf0.z, Pf1.w));
  T n1001 = dot(g1001, vec<4, T, Q>(Pf1.x, Pf0.y, Pf0.z, Pf1.w));
  T n0101 = dot(g0101, vec<4, T, Q>(Pf0.x, Pf1.y, Pf0.z, Pf1.w));
  T n1101 = dot(g1101, vec<4, T, Q>(Pf1.x, Pf1.y, Pf0.z, Pf1.w));
  T n0011 = dot(g0011, vec<4, T, Q>(Pf0.x, Pf0.y, Pf1.z, Pf1.w));
  T n1011 = dot(g1011, vec<4, T, Q>(Pf1.x, Pf0.y, Pf1.z, Pf1.w));
  T n0111 = dot(g0111, vec<4, T, Q>(Pf0.x, Pf1.y, Pf1.z, Pf1.w));
  T n1111 = dot(g1111, Pf1);

  vec<4, T, Q> fade_xyzw = detail::fade(Pf0);
  vec<4, T, Q> n_0w = mix(vec<4, T, Q>(n0000, n1000, n0100, n1100), vec<4, T, Q>(n0001, n1001, n0101, n1101), fade_xyzw.w);
  vec<4, T, Q> n_1w = mix(vec<4, T, Q>(n0010, n1010, n0110, n1110), vec<4, T, Q>(n0011, n1011, n0111, n1111), fade_xyzw.w);
  vec<4, T, Q> n_zw = mix(n_0w, n_1w, fade_xyzw.z);
  vec<2, T, Q> n_yzw = mix(vec<2, T, Q>(n_zw.x, n_zw.y), vec<2, T, Q>(n_zw.z, n_zw.w), fade_xyzw.y);
  T n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);
  return T(2.2) * n_xyzw;
 }

 template<typename T, qualifier Q>
 inline T simplex(glm::vec<2, T, Q> const& v)
 {
  vec<4, T, Q> const C = vec<4, T, Q>(
   T( 0.211324865405187),
   T( 0.366025403784439),
   T(-0.577350269189626),
   T( 0.024390243902439));


  vec<2, T, Q> i = floor(v + dot(v, vec<2, T, Q>(C[1])));
  vec<2, T, Q> x0 = v - i + dot(i, vec<2, T, Q>(C[0]));




  vec<2, T, Q> i1 = (x0.x > x0.y) ? vec<2, T, Q>(1, 0) : vec<2, T, Q>(0, 1);



  vec<4, T, Q> x12 = vec<4, T, Q>(x0.x, x0.y, x0.x, x0.y) + vec<4, T, Q>(C.x, C.x, C.z, C.z);
  x12 = vec<4, T, Q>(vec<2, T, Q>(x12) - i1, x12.z, x12.w);


  i = mod(i, vec<2, T, Q>(289));
  vec<3, T, Q> p = detail::permute(
   detail::permute(i.y + vec<3, T, Q>(T(0), i1.y, T(1)))
   + i.x + vec<3, T, Q>(T(0), i1.x, T(1)));

  vec<3, T, Q> m = max(vec<3, T, Q>(0.5) - vec<3, T, Q>(
   dot(x0, x0),
   dot(vec<2, T, Q>(x12.x, x12.y), vec<2, T, Q>(x12.x, x12.y)),
   dot(vec<2, T, Q>(x12.z, x12.w), vec<2, T, Q>(x12.z, x12.w))), vec<3, T, Q>(0));
  m = m * m ;
  m = m * m ;




  vec<3, T, Q> x = static_cast<T>(2) * fract(p * C.w) - T(1);
  vec<3, T, Q> h = abs(x) - T(0.5);
  vec<3, T, Q> ox = floor(x + T(0.5));
  vec<3, T, Q> a0 = x - ox;



  m *= static_cast<T>(1.79284291400159) - T(0.85373472095314) * (a0 * a0 + h * h);


  vec<3, T, Q> g;
  g.x = a0.x * x0.x + h.x * x0.y;

  g.y = a0.y * x12.x + h.y * x12.y;
  g.z = a0.z * x12.z + h.z * x12.w;
  return T(130) * dot(m, g);
 }

 template<typename T, qualifier Q>
 inline T simplex(vec<3, T, Q> const& v)
 {
  vec<2, T, Q> const C(1.0 / 6.0, 1.0 / 3.0);
  vec<4, T, Q> const D(0.0, 0.5, 1.0, 2.0);


  vec<3, T, Q> i(floor(v + dot(v, vec<3, T, Q>(C.y))));
  vec<3, T, Q> x0(v - i + dot(i, vec<3, T, Q>(C.x)));


  vec<3, T, Q> g(step(vec<3, T, Q>(x0.y, x0.z, x0.x), x0));
  vec<3, T, Q> l(T(1) - g);
  vec<3, T, Q> i1(min(g, vec<3, T, Q>(l.z, l.x, l.y)));
  vec<3, T, Q> i2(max(g, vec<3, T, Q>(l.z, l.x, l.y)));





  vec<3, T, Q> x1(x0 - i1 + C.x);
  vec<3, T, Q> x2(x0 - i2 + C.y);
  vec<3, T, Q> x3(x0 - D.y);


  i = detail::mod289(i);
  vec<4, T, Q> p(detail::permute(detail::permute(detail::permute(
   i.z + vec<4, T, Q>(T(0), i1.z, i2.z, T(1))) +
   i.y + vec<4, T, Q>(T(0), i1.y, i2.y, T(1))) +
   i.x + vec<4, T, Q>(T(0), i1.x, i2.x, T(1))));



  T n_ = static_cast<T>(0.142857142857);
  vec<3, T, Q> ns(n_ * vec<3, T, Q>(D.w, D.y, D.z) - vec<3, T, Q>(D.x, D.z, D.x));

  vec<4, T, Q> j(p - T(49) * floor(p * ns.z * ns.z));

  vec<4, T, Q> x_(floor(j * ns.z));
  vec<4, T, Q> y_(floor(j - T(7) * x_));

  vec<4, T, Q> x(x_ * ns.x + ns.y);
  vec<4, T, Q> y(y_ * ns.x + ns.y);
  vec<4, T, Q> h(T(1) - abs(x) - abs(y));

  vec<4, T, Q> b0(x.x, x.y, y.x, y.y);
  vec<4, T, Q> b1(x.z, x.w, y.z, y.w);



  vec<4, T, Q> s0(floor(b0) * T(2) + T(1));
  vec<4, T, Q> s1(floor(b1) * T(2) + T(1));
  vec<4, T, Q> sh(-step(h, vec<4, T, Q>(0.0)));

  vec<4, T, Q> a0 = vec<4, T, Q>(b0.x, b0.z, b0.y, b0.w) + vec<4, T, Q>(s0.x, s0.z, s0.y, s0.w) * vec<4, T, Q>(sh.x, sh.x, sh.y, sh.y);
  vec<4, T, Q> a1 = vec<4, T, Q>(b1.x, b1.z, b1.y, b1.w) + vec<4, T, Q>(s1.x, s1.z, s1.y, s1.w) * vec<4, T, Q>(sh.z, sh.z, sh.w, sh.w);

  vec<3, T, Q> p0(a0.x, a0.y, h.x);
  vec<3, T, Q> p1(a0.z, a0.w, h.y);
  vec<3, T, Q> p2(a1.x, a1.y, h.z);
  vec<3, T, Q> p3(a1.z, a1.w, h.w);


  vec<4, T, Q> norm = detail::taylorInvSqrt(vec<4, T, Q>(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;


  vec<4, T, Q> m = max(T(0.6) - vec<4, T, Q>(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), vec<4, T, Q>(0));
  m = m * m;
  return T(42) * dot(m * m, vec<4, T, Q>(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));
 }

 template<typename T, qualifier Q>
 inline T simplex(vec<4, T, Q> const& v)
 {
  vec<4, T, Q> const C(
   0.138196601125011,
   0.276393202250021,
   0.414589803375032,
   -0.447213595499958);


  T const F4 = static_cast<T>(0.309016994374947451);


  vec<4, T, Q> i = floor(v + dot(v, vec<4, T, Q>(F4)));
  vec<4, T, Q> x0 = v - i + dot(i, vec<4, T, Q>(C.x));




  vec<4, T, Q> i0;
  vec<3, T, Q> isX = step(vec<3, T, Q>(x0.y, x0.z, x0.w), vec<3, T, Q>(x0.x));
  vec<3, T, Q> isYZ = step(vec<3, T, Q>(x0.z, x0.w, x0.w), vec<3, T, Q>(x0.y, x0.y, x0.z));



  i0 = vec<4, T, Q>(isX.x + isX.y + isX.z, T(1) - isX);

  i0.y += isYZ.x + isYZ.y;

  i0.z += static_cast<T>(1) - isYZ.x;
  i0.w += static_cast<T>(1) - isYZ.y;
  i0.z += isYZ.z;
  i0.w += static_cast<T>(1) - isYZ.z;


  vec<4, T, Q> i3 = clamp(i0, T(0), T(1));
  vec<4, T, Q> i2 = clamp(i0 - T(1), T(0), T(1));
  vec<4, T, Q> i1 = clamp(i0 - T(2), T(0), T(1));






  vec<4, T, Q> x1 = x0 - i1 + C.x;
  vec<4, T, Q> x2 = x0 - i2 + C.y;
  vec<4, T, Q> x3 = x0 - i3 + C.z;
  vec<4, T, Q> x4 = x0 + C.w;


  i = mod(i, vec<4, T, Q>(289));
  T j0 = detail::permute(detail::permute(detail::permute(detail::permute(i.w) + i.z) + i.y) + i.x);
  vec<4, T, Q> j1 = detail::permute(detail::permute(detail::permute(detail::permute(
   i.w + vec<4, T, Q>(i1.w, i2.w, i3.w, T(1))) +
   i.z + vec<4, T, Q>(i1.z, i2.z, i3.z, T(1))) +
   i.y + vec<4, T, Q>(i1.y, i2.y, i3.y, T(1))) +
   i.x + vec<4, T, Q>(i1.x, i2.x, i3.x, T(1)));



  vec<4, T, Q> ip = vec<4, T, Q>(T(1) / T(294), T(1) / T(49), T(1) / T(7), T(0));

  vec<4, T, Q> p0 = detail::grad4(j0, ip);
  vec<4, T, Q> p1 = detail::grad4(j1.x, ip);
  vec<4, T, Q> p2 = detail::grad4(j1.y, ip);
  vec<4, T, Q> p3 = detail::grad4(j1.z, ip);
  vec<4, T, Q> p4 = detail::grad4(j1.w, ip);


  vec<4, T, Q> norm = detail::taylorInvSqrt(vec<4, T, Q>(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;
  p4 *= detail::taylorInvSqrt(dot(p4, p4));


  vec<3, T, Q> m0 = max(T(0.6) - vec<3, T, Q>(dot(x0, x0), dot(x1, x1), dot(x2, x2)), vec<3, T, Q>(0));
  vec<2, T, Q> m1 = max(T(0.6) - vec<2, T, Q>(dot(x3, x3), dot(x4, x4) ), vec<2, T, Q>(0));
  m0 = m0 * m0;
  m1 = m1 * m1;
  return T(49) *
   (dot(m0 * m0, vec<3, T, Q>(dot(p0, x0), dot(p1, x1), dot(p2, x2))) +
   dot(m1 * m1, vec<2, T, Q>(dot(p3, x3), dot(p4, x4))));
 }
}
# 62 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/noise.hpp" 2
# 183 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.hpp" 1
# 14 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.hpp"
       
# 24 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.hpp"
namespace glm
{
# 40 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.hpp"
 [[nodiscard]] uint8 packUnorm1x8(float v);
# 52 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.hpp"
 [[nodiscard]] float unpackUnorm1x8(uint8 p);
# 68 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.hpp"
 [[nodiscard]] uint16 packUnorm2x8(vec2 const& v);
# 84 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.hpp"
 [[nodiscard]] vec2 unpackUnorm2x8(uint16 p);
# 97 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.hpp"
 [[nodiscard]] uint8 packSnorm1x8(float s);
# 110 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.hpp"
 [[nodiscard]] float unpackSnorm1x8(uint8 p);
# 126 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.hpp"
 [[nodiscard]] uint16 packSnorm2x8(vec2 const& v);
# 142 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.hpp"
 [[nodiscard]] vec2 unpackSnorm2x8(uint16 p);
# 155 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.hpp"
 [[nodiscard]] uint16 packUnorm1x16(float v);
# 168 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.hpp"
 [[nodiscard]] float unpackUnorm1x16(uint16 p);
# 184 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.hpp"
 [[nodiscard]] uint64 packUnorm4x16(vec4 const& v);
# 200 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.hpp"
 [[nodiscard]] vec4 unpackUnorm4x16(uint64 p);
# 213 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.hpp"
 [[nodiscard]] uint16 packSnorm1x16(float v);
# 226 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.hpp"
 [[nodiscard]] float unpackSnorm1x16(uint16 p);
# 242 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.hpp"
 [[nodiscard]] uint64 packSnorm4x16(vec4 const& v);
# 258 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.hpp"
 [[nodiscard]] vec4 unpackSnorm4x16(uint64 p);
# 269 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.hpp"
 [[nodiscard]] uint16 packHalf1x16(float v);
# 280 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.hpp"
 [[nodiscard]] float unpackHalf1x16(uint16 v);
# 293 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.hpp"
 [[nodiscard]] uint64 packHalf4x16(vec4 const& v);
# 306 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.hpp"
 [[nodiscard]] vec4 unpackHalf4x16(uint64 p);
# 319 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.hpp"
 [[nodiscard]] uint32 packI3x10_1x2(ivec4 const& v);
# 330 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.hpp"
 [[nodiscard]] ivec4 unpackI3x10_1x2(uint32 p);
# 343 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.hpp"
 [[nodiscard]] uint32 packU3x10_1x2(uvec4 const& v);
# 354 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.hpp"
 [[nodiscard]] uvec4 unpackU3x10_1x2(uint32 p);
# 372 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.hpp"
 [[nodiscard]] uint32 packSnorm3x10_1x2(vec4 const& v);
# 389 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.hpp"
 [[nodiscard]] vec4 unpackSnorm3x10_1x2(uint32 p);
# 407 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.hpp"
 [[nodiscard]] uint32 packUnorm3x10_1x2(vec4 const& v);
# 424 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.hpp"
 [[nodiscard]] vec4 unpackUnorm3x10_1x2(uint32 p);
# 435 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.hpp"
 [[nodiscard]] uint32 packF2x11_1x10(vec3 const& v);
# 445 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.hpp"
 [[nodiscard]] vec3 unpackF2x11_1x10(uint32 p);
# 459 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.hpp"
 [[nodiscard]] uint32 packF3x9_E1x5(vec3 const& v);
# 471 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.hpp"
 [[nodiscard]] vec3 unpackF3x9_E1x5(uint32 p);
# 481 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<4, T, Q> packRGBM(vec<3, T, Q> const& rgb);
# 491 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<3, T, Q> unpackRGBM(vec<4, T, Q> const& rgbm);
# 502 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.hpp"
 template<length_t L, qualifier Q>
 [[nodiscard]] vec<L, uint16, Q> packHalf(vec<L, float, Q> const& v);
# 512 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.hpp"
 template<length_t L, qualifier Q>
 [[nodiscard]] vec<L, float, Q> unpackHalf(vec<L, uint16, Q> const& p);





 template<typename uintType, length_t L, typename floatType, qualifier Q>
 [[nodiscard]] vec<L, uintType, Q> packUnorm(vec<L, floatType, Q> const& v);





 template<typename floatType, length_t L, typename uintType, qualifier Q>
 [[nodiscard]] vec<L, floatType, Q> unpackUnorm(vec<L, uintType, Q> const& v);





 template<typename intType, length_t L, typename floatType, qualifier Q>
 [[nodiscard]] vec<L, intType, Q> packSnorm(vec<L, floatType, Q> const& v);





 template<typename floatType, length_t L, typename intType, qualifier Q>
 [[nodiscard]] vec<L, floatType, Q> unpackSnorm(vec<L, intType, Q> const& v);





 [[nodiscard]] uint8 packUnorm2x4(vec2 const& v);





 [[nodiscard]] vec2 unpackUnorm2x4(uint8 p);





 [[nodiscard]] uint16 packUnorm4x4(vec4 const& v);





 [[nodiscard]] vec4 unpackUnorm4x4(uint16 p);





 [[nodiscard]] uint16 packUnorm1x5_1x6_1x5(vec3 const& v);





 [[nodiscard]] vec3 unpackUnorm1x5_1x6_1x5(uint16 p);





 [[nodiscard]] uint16 packUnorm3x5_1x1(vec4 const& v);





 [[nodiscard]] vec4 unpackUnorm3x5_1x1(uint16 p);





 [[nodiscard]] uint8 packUnorm2x3_1x2(vec3 const& v);





 [[nodiscard]] vec3 unpackUnorm2x3_1x2(uint8 p);







 [[nodiscard]] int16 packInt2x8(i8vec2 const& v);





 [[nodiscard]] i8vec2 unpackInt2x8(int16 p);





 [[nodiscard]] uint16 packUint2x8(u8vec2 const& v);





 [[nodiscard]] u8vec2 unpackUint2x8(uint16 p);





 [[nodiscard]] int32 packInt4x8(i8vec4 const& v);





 [[nodiscard]] i8vec4 unpackInt4x8(int32 p);





 [[nodiscard]] uint32 packUint4x8(u8vec4 const& v);





 [[nodiscard]] u8vec4 unpackUint4x8(uint32 p);





 [[nodiscard]] int packInt2x16(i16vec2 const& v);





 [[nodiscard]] i16vec2 unpackInt2x16(int p);





 [[nodiscard]] int64 packInt4x16(i16vec4 const& v);





 [[nodiscard]] i16vec4 unpackInt4x16(int64 p);





 [[nodiscard]] uint packUint2x16(u16vec2 const& v);





 [[nodiscard]] u16vec2 unpackUint2x16(uint p);





 [[nodiscard]] uint64 packUint4x16(u16vec4 const& v);





 [[nodiscard]] u16vec4 unpackUint4x16(uint64 p);





 [[nodiscard]] int64 packInt2x32(i32vec2 const& v);





 [[nodiscard]] i32vec2 unpackInt2x32(int64 p);





 [[nodiscard]] uint64 packUint2x32(u32vec2 const& v);





 [[nodiscard]] u32vec2 unpackUint2x32(uint64 p);


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.inl" 1
# 10 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.inl"
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cstring" 1 3
# 39 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cstring" 3
       
# 40 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cstring" 3


# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 1 3
# 47 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 3
       
# 48 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 3
# 43 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cstring" 2 3
# 1 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/string.h" 1 3
# 21 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/string.h" 3

# 21 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/string.h" 3
extern "C" {
# 45 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/string.h" 3
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _memccpy(void *_Dst,const void *_Src,int _Val,size_t _MaxCount);
  void *__attribute__((__cdecl__)) memchr(const void *_Buf ,int _Val,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _memicmp(const void *_Buf1,const void *_Buf2,size_t _Size);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _memicmp_l(const void *_Buf1,const void *_Buf2,size_t _Size,_locale_t _Locale);
  int __attribute__((__cdecl__)) memcmp(const void *_Buf1,const void *_Buf2,size_t _Size);
  void * __attribute__((__cdecl__)) memcpy(void * __restrict__ _Dst,const void * __restrict__ _Src,size_t _Size) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) memcpy_s (void *_dest,size_t _numberOfElements,const void *_src,size_t _count);
  void * __attribute__((__cdecl__)) mempcpy (void *_Dst, const void *_Src, size_t _Size);
  void * __attribute__((__cdecl__)) memset(void *_Dst,int _Val,size_t _Size);

  void * __attribute__((__cdecl__)) memccpy(void *_Dst,const void *_Src,int _Val,size_t _Size) ;
  int __attribute__((__cdecl__)) memicmp(const void *_Buf1,const void *_Buf2,size_t _Size) ;


  char * __attribute__((__cdecl__)) _strset(char *_Str,int _Val) ;
  char * __attribute__((__cdecl__)) _strset_l(char *_Str,int _Val,_locale_t _Locale) ;
  char * __attribute__((__cdecl__)) strcpy(char * __restrict__ _Dest,const char * __restrict__ _Source);
  char * __attribute__((__cdecl__)) strcat(char * __restrict__ _Dest,const char * __restrict__ _Source);
  int __attribute__((__cdecl__)) strcmp(const char *_Str1,const char *_Str2);
  size_t __attribute__((__cdecl__)) strlen(const char *_Str);
  size_t __attribute__((__cdecl__)) strnlen(const char *_Str,size_t _MaxCount);
  void *__attribute__((__cdecl__)) memmove(void *_Dst,const void *_Src,size_t _Size) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strdup(const char *_Src);
  char *__attribute__((__cdecl__)) strchr(const char *_Str,int _Val);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _stricmp(const char *_Str1,const char *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strcmpi(const char *_Str1,const char *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _stricmp_l(const char *_Str1,const char *_Str2,_locale_t _Locale);
  int __attribute__((__cdecl__)) strcoll(const char *_Str1,const char *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strcoll_l(const char *_Str1,const char *_Str2,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _stricoll(const char *_Str1,const char *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _stricoll_l(const char *_Str1,const char *_Str2,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strncoll (const char *_Str1,const char *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strncoll_l(const char *_Str1,const char *_Str2,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strnicoll (const char *_Str1,const char *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strnicoll_l(const char *_Str1,const char *_Str2,size_t _MaxCount,_locale_t _Locale);
  size_t __attribute__((__cdecl__)) strcspn(const char *_Str,const char *_Control);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strerror(const char *_ErrMsg) ;
  char *__attribute__((__cdecl__)) strerror(int) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strlwr(char *_String) ;
  char *strlwr_l(char *_String,_locale_t _Locale) ;
  char *__attribute__((__cdecl__)) strncat(char * __restrict__ _Dest,const char * __restrict__ _Source,size_t _Count) ;
  int __attribute__((__cdecl__)) strncmp(const char *_Str1,const char *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strnicmp(const char *_Str1,const char *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strnicmp_l(const char *_Str1,const char *_Str2,size_t _MaxCount,_locale_t _Locale);
  char *strncpy(char * __restrict__ _Dest,const char * __restrict__ _Source,size_t _Count) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strnset(char *_Str,int _Val,size_t _MaxCount) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strnset_l(char *str,int c,size_t count,_locale_t _Locale) ;
  char *__attribute__((__cdecl__)) strpbrk(const char *_Str,const char *_Control);
  char *__attribute__((__cdecl__)) strrchr(const char *_Str,int _Ch);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strrev(char *_Str);
  size_t __attribute__((__cdecl__)) strspn(const char *_Str,const char *_Control);
  char *__attribute__((__cdecl__)) strstr(const char *_Str,const char *_SubStr);
  char *__attribute__((__cdecl__)) strtok(char * __restrict__ _Str,const char * __restrict__ _Delim) ;
       

  char *strtok_r(char * __restrict__ _Str, const char * __restrict__ _Delim, char ** __restrict__ __last);
       
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strupr(char *_String) ;
  __attribute__ ((__dllimport__)) char *_strupr_l(char *_String,_locale_t _Locale) ;
  size_t __attribute__((__cdecl__)) strxfrm(char * __restrict__ _Dst,const char * __restrict__ _Src,size_t _MaxCount);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _strxfrm_l(char * __restrict__ _Dst,const char * __restrict__ _Src,size_t _MaxCount,_locale_t _Locale);


  char *__attribute__((__cdecl__)) strdup(const char *_Src) ;
  int __attribute__((__cdecl__)) strcmpi(const char *_Str1,const char *_Str2) ;
  int __attribute__((__cdecl__)) stricmp(const char *_Str1,const char *_Str2) ;
  char *__attribute__((__cdecl__)) strlwr(char *_Str) ;
  int __attribute__((__cdecl__)) strnicmp(const char *_Str1,const char *_Str,size_t _MaxCount) ;
  int __attribute__((__cdecl__)) strncasecmp (const char *, const char *, size_t);
  int __attribute__((__cdecl__)) strcasecmp (const char *, const char *);

  inline int __attribute__((__cdecl__)) strncasecmp (const char *__sz1, const char *__sz2, size_t __sizeMaxCompare) { return _strnicmp (__sz1, __sz2, __sizeMaxCompare); }
  inline int __attribute__((__cdecl__)) strcasecmp (const char *__sz1, const char *__sz2) { return _stricmp (__sz1, __sz2); }




  char *__attribute__((__cdecl__)) strnset(char *_Str,int _Val,size_t _MaxCount) ;
  char *__attribute__((__cdecl__)) strrev(char *_Str) ;
  char *__attribute__((__cdecl__)) strset(char *_Str,int _Val) ;
  char *__attribute__((__cdecl__)) strupr(char *_Str) ;





  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcsdup(const wchar_t *_Str);
  wchar_t *__attribute__((__cdecl__)) wcscat(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source) ;
  wchar_t *__attribute__((__cdecl__)) wcschr(const wchar_t *_Str,wchar_t _Ch);
  int __attribute__((__cdecl__)) wcscmp(const wchar_t *_Str1,const wchar_t *_Str2);
  wchar_t *__attribute__((__cdecl__)) wcscpy(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source) ;
  size_t __attribute__((__cdecl__)) wcscspn(const wchar_t *_Str,const wchar_t *_Control);
  size_t __attribute__((__cdecl__)) wcslen(const wchar_t *_Str);
  size_t __attribute__((__cdecl__)) wcsnlen(const wchar_t *_Src,size_t _MaxCount);
  wchar_t *wcsncat(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _Count) ;
  int __attribute__((__cdecl__)) wcsncmp(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount);
  wchar_t *wcsncpy(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _Count) ;
  wchar_t *__attribute__((__cdecl__)) _wcsncpy_l(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _Count,_locale_t _Locale) ;
  wchar_t *__attribute__((__cdecl__)) wcspbrk(const wchar_t *_Str,const wchar_t *_Control);
  wchar_t *__attribute__((__cdecl__)) wcsrchr(const wchar_t *_Str,wchar_t _Ch);
  size_t __attribute__((__cdecl__)) wcsspn(const wchar_t *_Str,const wchar_t *_Control);
  wchar_t *__attribute__((__cdecl__)) wcsstr(const wchar_t *_Str,const wchar_t *_SubStr);



  wchar_t *__attribute__((__cdecl__)) wcstok(wchar_t * __restrict__ _Str,const wchar_t * __restrict__ _Delim) ;

  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcserror(int _ErrNum) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) __wcserror(const wchar_t *_Str) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsicmp(const wchar_t *_Str1,const wchar_t *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsicmp_l(const wchar_t *_Str1,const wchar_t *_Str2,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsnicmp(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsnicmp_l(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcsnset(wchar_t *_Str,wchar_t _Val,size_t _MaxCount) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcsrev(wchar_t *_Str);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcsset(wchar_t *_Str,wchar_t _Val) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcslwr(wchar_t *_String) ;
  __attribute__ ((__dllimport__)) wchar_t *_wcslwr_l(wchar_t *_String,_locale_t _Locale) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcsupr(wchar_t *_String) ;
  __attribute__ ((__dllimport__)) wchar_t *_wcsupr_l(wchar_t *_String,_locale_t _Locale) ;
  size_t __attribute__((__cdecl__)) wcsxfrm(wchar_t * __restrict__ _Dst,const wchar_t * __restrict__ _Src,size_t _MaxCount);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _wcsxfrm_l(wchar_t * __restrict__ _Dst,const wchar_t * __restrict__ _Src,size_t _MaxCount,_locale_t _Locale);
  int __attribute__((__cdecl__)) wcscoll(const wchar_t *_Str1,const wchar_t *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcscoll_l(const wchar_t *_Str1,const wchar_t *_Str2,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsicoll(const wchar_t *_Str1,const wchar_t *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsicoll_l(const wchar_t *_Str1,const wchar_t *_Str2,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsncoll(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsncoll_l(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsnicoll(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsnicoll_l(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount,_locale_t _Locale);


  wchar_t *__attribute__((__cdecl__)) wcsdup(const wchar_t *_Str) ;

  int __attribute__((__cdecl__)) wcsicmp(const wchar_t *_Str1,const wchar_t *_Str2) ;
  int __attribute__((__cdecl__)) wcsnicmp(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount) ;
  wchar_t *__attribute__((__cdecl__)) wcsnset(wchar_t *_Str,wchar_t _Val,size_t _MaxCount) ;
  wchar_t *__attribute__((__cdecl__)) wcsrev(wchar_t *_Str) ;
  wchar_t *__attribute__((__cdecl__)) wcsset(wchar_t *_Str,wchar_t _Val) ;
  wchar_t *__attribute__((__cdecl__)) wcslwr(wchar_t *_Str) ;
  wchar_t *__attribute__((__cdecl__)) wcsupr(wchar_t *_Str) ;
  int __attribute__((__cdecl__)) wcsicoll(const wchar_t *_Str1,const wchar_t *_Str2) ;




}


# 1 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/sec_api/string_s.h" 1 3
# 9 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/sec_api/string_s.h" 3
# 1 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/string.h" 1 3
# 10 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/sec_api/string_s.h" 2 3
# 21 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/sec_api/string_s.h" 3
extern "C" {


  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strset_s(char *_Dst,size_t _DstSize,int _Value);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _strset_s(char (&_Dst)[__size], int _Value) { return _strset_s(_Dst,__size,_Value); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strerror_s(char *_Buf,size_t _SizeInBytes,const char *_ErrMsg);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _strerror_s(char (&_Buf)[__size], const char * _ErrMsg) { return _strerror_s(_Buf,__size,_ErrMsg); } }
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) strerror_s(char *_Buf,size_t _SizeInBytes,int _ErrNum);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) strerror_s(char (&_Buf)[__size], int _ErrNum) { return strerror_s(_Buf,__size,_ErrNum); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strlwr_s(char *_Str,size_t _Size);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _strlwr_s(char (&_Str)[__size]) { return _strlwr_s(_Str,__size); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strlwr_s_l(char *_Str,size_t _Size,_locale_t _Locale);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _strlwr_s_l(char (&_Str)[__size], _locale_t _Locale) { return _strlwr_s_l(_Str,__size,_Locale); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strnset_s(char *_Str,size_t _Size,int _Val,size_t _MaxCount);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _strnset_s(char (&_Str)[__size], int _Val, size_t _MaxCount) { return _strnset_s(_Str,__size,_Val,_MaxCount); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strupr_s(char *_Str,size_t _Size);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _strupr_s(char (&_Str)[__size]) { return _strupr_s(_Str,__size); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strupr_s_l(char *_Str,size_t _Size,_locale_t _Locale);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _strupr_s_l(char (&_Str)[__size], _locale_t _Locale) { return _strupr_s_l(_Str,__size,_Locale); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) strncat_s(char *_Dst,size_t _DstSizeInChars,const char *_Src,size_t _MaxCount);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) strncat_s(char (&_Dst)[__size], const char * _Src, size_t _MaxCount) { return strncat_s(_Dst,__size,_Src,_MaxCount); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strncat_s_l(char *_Dst,size_t _DstSizeInChars,const char *_Src,size_t _MaxCount,_locale_t _Locale);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _strncat_s_l(char (&_Dst)[__size], const char * _Src, size_t _MaxCount, _locale_t _Locale) { return _strncat_s_l(_Dst,__size,_Src,_MaxCount,_Locale); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) strcpy_s(char *_Dst, rsize_t _SizeInBytes, const char *_Src);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) strcpy_s(char (&_Dest)[__size], const char * _Source) { return strcpy_s(_Dest,__size,_Source); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) strncpy_s(char *_Dst, size_t _DstSizeInChars, const char *_Src, size_t _MaxCount);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) strncpy_s(char (&_Dest)[__size], const char * _Source, size_t _MaxCount) { return strncpy_s(_Dest,__size,_Source,_MaxCount); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strncpy_s_l(char *_Dst, size_t _DstSizeInChars, const char *_Src, size_t _MaxCount, _locale_t _Locale);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _strncpy_s_l(char (&_Dest)[__size], const char * _Source, size_t _MaxCount, _locale_t _Locale) { return _strncpy_s_l(_Dest,__size,_Source,_MaxCount,_Locale); } }
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) strtok_s(char *_Str,const char *_Delim,char **_Context);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strtok_s_l(char *_Str,const char *_Delim,char **_Context,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) strcat_s(char *_Dst, rsize_t _SizeInBytes, const char * _Src);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) strcat_s(char (&_Dest)[__size], const char * _Source) { return strcat_s(_Dest,__size,_Source); } }

  inline __attribute__((__always_inline__)) size_t __attribute__((__cdecl__)) strnlen_s(const char * _src, size_t _count) {
    return _src ? strnlen(_src, _count) : 0;
  }

  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) memmove_s(void *_dest,size_t _numberOfElements,const void *_src,size_t _count);


  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) wcstok_s(wchar_t *_Str,const wchar_t *_Delim,wchar_t **_Context);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcserror_s(wchar_t *_Buf,size_t _SizeInWords,int _ErrNum);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _wcserror_s(wchar_t (&buffer)[__size], int error) { return _wcserror_s(buffer,__size,error); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) __wcserror_s(wchar_t *_Buffer,size_t _SizeInWords,const wchar_t *_ErrMsg);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsnset_s(wchar_t *_Dst,size_t _DstSizeInWords,wchar_t _Val,size_t _MaxCount);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsset_s(wchar_t *_Str,size_t _SizeInWords,wchar_t _Val);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcslwr_s(wchar_t *_Str,size_t _SizeInWords);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _wcslwr_s(wchar_t (&_Str)[__size]) { return _wcslwr_s(_Str,__size); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcslwr_s_l(wchar_t *_Str,size_t _SizeInWords,_locale_t _Locale);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _wcslwr_s_l(wchar_t (&_Str)[__size], _locale_t _Locale) { return _wcslwr_s_l(_Str,__size,_Locale); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsupr_s(wchar_t *_Str,size_t _Size);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _wcsupr_s(wchar_t (&_Str)[__size]) { return _wcsupr_s(_Str,__size); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsupr_s_l(wchar_t *_Str,size_t _Size,_locale_t _Locale);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _wcsupr_s_l(wchar_t (&_Str)[__size], _locale_t _Locale) { return _wcsupr_s_l(_Str,__size,_Locale); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcscpy_s(wchar_t *_Dst, rsize_t _SizeInWords, const wchar_t *_Src);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) wcscpy_s(wchar_t (&_Dest)[__size], const wchar_t * _Source) { return wcscpy_s(_Dest,__size,_Source); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcscat_s(wchar_t * _Dst, rsize_t _SizeInWords, const wchar_t *_Src);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) wcscat_s(wchar_t (&_Dest)[__size], const wchar_t * _Source) { return wcscat_s(_Dest,__size,_Source); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcsncat_s(wchar_t *_Dst,size_t _DstSizeInChars,const wchar_t *_Src,size_t _MaxCount);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) wcsncat_s(wchar_t (&_Dst)[__size], const wchar_t * _Src, size_t _MaxCount) { return wcsncat_s(_Dst,__size,_Src,_MaxCount); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsncat_s_l(wchar_t *_Dst,size_t _DstSizeInChars,const wchar_t *_Src,size_t _MaxCount,_locale_t _Locale);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _wcsncat_s_l(wchar_t (&_Dst)[__size], const wchar_t * _Src, size_t _MaxCount, _locale_t _Locale) { return _wcsncat_s_l(_Dst,__size,_Src,_MaxCount,_Locale); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcsncpy_s(wchar_t *_Dst, size_t _DstSizeInChars, const wchar_t *_Src, size_t _MaxCount);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) wcsncpy_s(wchar_t (&_Dest)[__size], const wchar_t * _Source, size_t _MaxCount) { return wcsncpy_s(_Dest,__size,_Source,_MaxCount); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsncpy_s_l(wchar_t *_Dst, size_t _DstSizeInChars, const wchar_t *_Src, size_t _MaxCount, _locale_t _Locale);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _wcsncpy_s_l(wchar_t (&_Dest)[__size], const wchar_t * _Source, size_t _MaxCount, _locale_t _Locale) { return _wcsncpy_s_l(_Dest,__size,_Source,_MaxCount,_Locale); } }
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcstok_s_l(wchar_t *_Str,const wchar_t *_Delim,wchar_t **_Context,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsset_s_l(wchar_t *_Str,size_t _SizeInChars,wchar_t _Val,_locale_t _Locale);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _wcsset_s_l(wchar_t (&_Str)[__size], wchar_t _Val, _locale_t _Locale) { return _wcsset_s_l(_Str,__size,_Val,_Locale); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsnset_s_l(wchar_t *_Str,size_t _SizeInChars,wchar_t _Val, size_t _Count,_locale_t _Locale);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _wcsnset_s_l(wchar_t (&_Str)[__size], wchar_t _Val, size_t _Count, _locale_t _Locale) { return _wcsnset_s_l(_Str,__size,_Val,_Count,_Locale); } }

  inline __attribute__((__always_inline__)) size_t __attribute__((__cdecl__)) wcsnlen_s(const wchar_t * _src, size_t _count) {
    return _src ? wcsnlen(_src, _count) : 0;
  }



}
# 195 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/string.h" 2 3
# 44 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cstring" 2 3
# 72 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cstring" 3
extern "C++"
{
namespace std
{


  using ::memchr;
  using ::memcmp;
  using ::memcpy;
  using ::memmove;
  using ::memset;
  using ::strcat;
  using ::strcmp;
  using ::strcoll;
  using ::strcpy;
  using ::strcspn;
  using ::strerror;
  using ::strlen;
  using ::strncat;
  using ::strncmp;
  using ::strncpy;
  using ::strspn;

  using ::strtok;

  using ::strxfrm;
  using ::strchr;
  using ::strpbrk;
  using ::strrchr;
  using ::strstr;


  inline void*
  memchr(void* __s, int __c, size_t __n)
  { return __builtin_memchr(__s, __c, __n); }

  inline char*
  strchr(char* __s, int __n)
  { return __builtin_strchr(__s, __n); }

  inline char*
  strpbrk(char* __s1, const char* __s2)
  { return __builtin_strpbrk(__s1, __s2); }

  inline char*
  strrchr(char* __s, int __n)
  { return __builtin_strrchr(__s, __n); }

  inline char*
  strstr(char* __s1, const char* __s2)
  { return __builtin_strstr(__s1, __s2); }



}
}
# 11 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.inl" 2



# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.inl"
namespace glm{
namespace detail
{
 inline glm::uint16 float2half(glm::uint32 f)
 {
# 28 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.inl"
  return
   ((f >> 16) & 0x8000) |
   ((((f & 0x7f800000) - 0x38000000) >> 13) & 0x7c00) |
   ((f >> 13) & 0x03ff);
 }

 inline glm::uint32 float2packed11(glm::uint32 f)
 {
# 47 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.inl"
  return
   ((((f & 0x7f800000) - 0x38000000) >> 17) & 0x07c0) |
   ((f >> 17) & 0x003f);
 }

 inline glm::uint32 packed11ToFloat(glm::uint32 p)
 {
# 65 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.inl"
  return
   ((((p & 0x07c0) << 17) + 0x38000000) & 0x7f800000) |
   ((p & 0x003f) << 17);
 }

 inline glm::uint32 float2packed10(glm::uint32 f)
 {
# 86 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.inl"
  return
   ((((f & 0x7f800000) - 0x38000000) >> 18) & 0x03E0) |
   ((f >> 18) & 0x001f);
 }

 inline glm::uint32 packed10ToFloat(glm::uint32 p)
 {
# 107 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.inl"
  return
   ((((p & 0x03E0) << 18) + 0x38000000) & 0x7f800000) |
   ((p & 0x001f) << 18);
 }

 inline glm::uint half2float(glm::uint h)
 {
  return ((h & 0x8000) << 16) | ((( h & 0x7c00) + 0x1C000) << 13) | ((h & 0x03FF) << 13);
 }

 inline glm::uint floatTo11bit(float x)
 {
  if(x == 0.0f)
   return 0u;
  else if(glm::isnan(x))
   return ~0u;
  else if(glm::isinf(x))
   return 0x1Fu << 6u;

  uint Pack = 0u;
  memcpy(&Pack, &x, sizeof(Pack));
  return float2packed11(Pack);
 }

 inline float packed11bitToFloat(glm::uint x)
 {
  if(x == 0)
   return 0.0f;
  else if(x == ((1 << 11) - 1))
   return ~0;
  else if(x == (0x1f << 6))
   return ~0;

  uint Result = packed11ToFloat(x);

  float Temp = 0;
  memcpy(&Temp, &Result, sizeof(Temp));
  return Temp;
 }

 inline glm::uint floatTo10bit(float x)
 {
  if(x == 0.0f)
   return 0u;
  else if(glm::isnan(x))
   return ~0u;
  else if(glm::isinf(x))
   return 0x1Fu << 5u;

  uint Pack = 0;
  memcpy(&Pack, &x, sizeof(Pack));
  return float2packed10(Pack);
 }

 inline float packed10bitToFloat(glm::uint x)
 {
  if(x == 0)
   return 0.0f;
  else if(x == ((1 << 10) - 1))
   return ~0;
  else if(x == (0x1f << 5))
   return ~0;

  uint Result = packed10ToFloat(x);

  float Temp = 0;
  memcpy(&Temp, &Result, sizeof(Temp));
  return Temp;
 }
# 189 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.inl"
 union u3u3u2
 {
  struct Data
  {
   uint x : 3;
   uint y : 3;
   uint z : 2;
  } data;
  uint8 pack;
 };

 union u4u4
 {
  struct Data
  {
   uint x : 4;
   uint y : 4;
  } data;
  uint8 pack;
 };

 union u4u4u4u4
 {
  struct Data
  {
   uint x : 4;
   uint y : 4;
   uint z : 4;
   uint w : 4;
  } data;
  uint16 pack;
 };

 union u5u6u5
 {
  struct Data
  {
   uint x : 5;
   uint y : 6;
   uint z : 5;
  } data;
  uint16 pack;
 };

 union u5u5u5u1
 {
  struct Data
  {
   uint x : 5;
   uint y : 5;
   uint z : 5;
   uint w : 1;
  } data;
  uint16 pack;
 };







 union u10u10u10u2
 {
  struct Data
  {
   uint x : 10;
   uint y : 10;
   uint z : 10;
   uint w : 2;
  } data;
  uint32 pack;
 };

 union i10i10i10i2
 {
  struct Data
  {
   int x : 10;
   int y : 10;
   int z : 10;
   int w : 2;
  } data;
  uint32 pack;
 };

 union u9u9u9e5
 {
  struct Data
  {
   uint x : 9;
   uint y : 9;
   uint z : 9;
   uint w : 5;
  } data;
  uint32 pack;
 };

 template<length_t L, qualifier Q>
 struct compute_half
 {};

 template<qualifier Q>
 struct compute_half<1, Q>
 {
  inline static vec<1, uint16, Q> pack(vec<1, float, Q> const& v)
  {
   int16 const Unpack(detail::toFloat16(v.x));
   u16vec1 Packed;
   memcpy(&Packed, &Unpack, sizeof(Packed));
   return Packed;
  }

  inline static vec<1, float, Q> unpack(vec<1, uint16, Q> const& v)
  {
   i16vec1 Unpack;
   memcpy(&Unpack, &v, sizeof(Unpack));
   return vec<1, float, Q>(detail::toFloat32(v.x));
  }
 };

 template<qualifier Q>
 struct compute_half<2, Q>
 {
  inline static vec<2, uint16, Q> pack(vec<2, float, Q> const& v)
  {
   vec<2, int16, Q> const Unpack(detail::toFloat16(v.x), detail::toFloat16(v.y));
   u16vec2 Packed;
   memcpy(&Packed, &Unpack, sizeof(Packed));
   return Packed;
  }

  inline static vec<2, float, Q> unpack(vec<2, uint16, Q> const& v)
  {
   i16vec2 Unpack;
   memcpy(&Unpack, &v, sizeof(Unpack));
   return vec<2, float, Q>(detail::toFloat32(v.x), detail::toFloat32(v.y));
  }
 };

 template<qualifier Q>
 struct compute_half<3, Q>
 {
  inline static vec<3, uint16, Q> pack(vec<3, float, Q> const& v)
  {
   vec<3, int16, Q> const Unpack(detail::toFloat16(v.x), detail::toFloat16(v.y), detail::toFloat16(v.z));
   u16vec3 Packed;
   memcpy(&Packed, &Unpack, sizeof(Packed));
   return Packed;
  }

  inline static vec<3, float, Q> unpack(vec<3, uint16, Q> const& v)
  {
   i16vec3 Unpack;
   memcpy(&Unpack, &v, sizeof(Unpack));
   return vec<3, float, Q>(detail::toFloat32(v.x), detail::toFloat32(v.y), detail::toFloat32(v.z));
  }
 };

 template<qualifier Q>
 struct compute_half<4, Q>
 {
  inline static vec<4, uint16, Q> pack(vec<4, float, Q> const& v)
  {
   vec<4, int16, Q> const Unpack(detail::toFloat16(v.x), detail::toFloat16(v.y), detail::toFloat16(v.z), detail::toFloat16(v.w));
   u16vec4 Packed;
   memcpy(&Packed, &Unpack, sizeof(Packed));
   return Packed;
  }

  inline static vec<4, float, Q> unpack(vec<4, uint16, Q> const& v)
  {
   i16vec4 Unpack;
   memcpy(&Unpack, &v, sizeof(Unpack));
   return vec<4, float, Q>(detail::toFloat32(Unpack.x), detail::toFloat32(Unpack.y), detail::toFloat32(Unpack.z), detail::toFloat32(Unpack.w));
  }
 };
}

 inline uint8 packUnorm1x8(float v)
 {
  return static_cast<uint8>(round(clamp(v, 0.0f, 1.0f) * 255.0f));
 }

 inline float unpackUnorm1x8(uint8 p)
 {
  float const Unpack(p);
  return Unpack * static_cast<float>(0.0039215686274509803921568627451);
 }

 inline uint16 packUnorm2x8(vec2 const& v)
 {
  u8vec2 const Topack(round(clamp(v, 0.0f, 1.0f) * 255.0f));

  uint16 Unpack = 0;
  memcpy(&Unpack, &Topack, sizeof(Unpack));
  return Unpack;
 }

 inline vec2 unpackUnorm2x8(uint16 p)
 {
  u8vec2 Unpack;
  memcpy(&Unpack, &p, sizeof(Unpack));
  return vec2(Unpack) * float(0.0039215686274509803921568627451);
 }

 inline uint8 packSnorm1x8(float v)
 {
  int8 const Topack(static_cast<int8>(round(clamp(v ,-1.0f, 1.0f) * 127.0f)));
  uint8 Packed = 0;
  memcpy(&Packed, &Topack, sizeof(Packed));
  return Packed;
 }

 inline float unpackSnorm1x8(uint8 p)
 {
  int8 Unpack = 0;
  memcpy(&Unpack, &p, sizeof(Unpack));
  return clamp(
   static_cast<float>(Unpack) * 0.00787401574803149606299212598425f,
   -1.0f, 1.0f);
 }

 inline uint16 packSnorm2x8(vec2 const& v)
 {
  i8vec2 const Topack(round(clamp(v, -1.0f, 1.0f) * 127.0f));
  uint16 Packed = 0;
  memcpy(&Packed, &Topack, sizeof(Packed));
  return Packed;
 }

 inline vec2 unpackSnorm2x8(uint16 p)
 {
  i8vec2 Unpack;
  memcpy(&Unpack, &p, sizeof(Unpack));
  return clamp(
   vec2(Unpack) * 0.00787401574803149606299212598425f,
   -1.0f, 1.0f);
 }

 inline uint16 packUnorm1x16(float s)
 {
  return static_cast<uint16>(round(clamp(s, 0.0f, 1.0f) * 65535.0f));
 }

 inline float unpackUnorm1x16(uint16 p)
 {
  float const Unpack(p);
  return Unpack * 1.5259021896696421759365224689097e-5f;
 }

 inline uint64 packUnorm4x16(vec4 const& v)
 {
  u16vec4 const Topack(round(clamp(v , 0.0f, 1.0f) * 65535.0f));
  uint64 Packed = 0;
  memcpy(&Packed, &Topack, sizeof(Packed));
  return Packed;
 }

 inline vec4 unpackUnorm4x16(uint64 p)
 {
  u16vec4 Unpack;
  memcpy(&Unpack, &p, sizeof(Unpack));
  return vec4(Unpack) * 1.5259021896696421759365224689097e-5f;
 }

 inline uint16 packSnorm1x16(float v)
 {
  int16 const Topack = static_cast<int16>(round(clamp(v ,-1.0f, 1.0f) * 32767.0f));
  uint16 Packed = 0;
  memcpy(&Packed, &Topack, sizeof(Packed));
  return Packed;
 }

 inline float unpackSnorm1x16(uint16 p)
 {
  int16 Unpack = 0;
  memcpy(&Unpack, &p, sizeof(Unpack));
  return clamp(
   static_cast<float>(Unpack) * 3.0518509475997192297128208258309e-5f,
   -1.0f, 1.0f);
 }

 inline uint64 packSnorm4x16(vec4 const& v)
 {
  i16vec4 const Topack(round(clamp(v ,-1.0f, 1.0f) * 32767.0f));
  uint64 Packed = 0;
  memcpy(&Packed, &Topack, sizeof(Packed));
  return Packed;
 }

 inline vec4 unpackSnorm4x16(uint64 p)
 {
  i16vec4 Unpack;
  memcpy(&Unpack, &p, sizeof(Unpack));
  return clamp(
   vec4(Unpack) * 3.0518509475997192297128208258309e-5f,
   -1.0f, 1.0f);
 }

 inline uint16 packHalf1x16(float v)
 {
  int16 const Topack(detail::toFloat16(v));
  uint16 Packed = 0;
  memcpy(&Packed, &Topack, sizeof(Packed));
  return Packed;
 }

 inline float unpackHalf1x16(uint16 v)
 {
  int16 Unpack = 0;
  memcpy(&Unpack, &v, sizeof(Unpack));
  return detail::toFloat32(Unpack);
 }

 inline uint64 packHalf4x16(glm::vec4 const& v)
 {
  i16vec4 const Unpack(
   detail::toFloat16(v.x),
   detail::toFloat16(v.y),
   detail::toFloat16(v.z),
   detail::toFloat16(v.w));
  uint64 Packed = 0;
  memcpy(&Packed, &Unpack, sizeof(Packed));
  return Packed;
 }

 inline glm::vec4 unpackHalf4x16(uint64 v)
 {
  i16vec4 Unpack;
  memcpy(&Unpack, &v, sizeof(Unpack));
  return vec4(
   detail::toFloat32(Unpack.x),
   detail::toFloat32(Unpack.y),
   detail::toFloat32(Unpack.z),
   detail::toFloat32(Unpack.w));
 }

 inline uint32 packI3x10_1x2(ivec4 const& v)
 {
  detail::i10i10i10i2 Result;
  Result.data.x = v.x;
  Result.data.y = v.y;
  Result.data.z = v.z;
  Result.data.w = v.w;
  return Result.pack;
 }

 inline ivec4 unpackI3x10_1x2(uint32 v)
 {
  detail::i10i10i10i2 Unpack;
  Unpack.pack = v;
  return ivec4(
   Unpack.data.x,
   Unpack.data.y,
   Unpack.data.z,
   Unpack.data.w);
 }

 inline uint32 packU3x10_1x2(uvec4 const& v)
 {
  detail::u10u10u10u2 Result;
  Result.data.x = v.x;
  Result.data.y = v.y;
  Result.data.z = v.z;
  Result.data.w = v.w;
  return Result.pack;
 }

 inline uvec4 unpackU3x10_1x2(uint32 v)
 {
  detail::u10u10u10u2 Unpack;
  Unpack.pack = v;
  return uvec4(
   Unpack.data.x,
   Unpack.data.y,
   Unpack.data.z,
   Unpack.data.w);
 }

 inline uint32 packSnorm3x10_1x2(vec4 const& v)
 {
  ivec4 const Pack(round(clamp(v,-1.0f, 1.0f) * vec4(511.f, 511.f, 511.f, 1.f)));

  detail::i10i10i10i2 Result;
  Result.data.x = Pack.x;
  Result.data.y = Pack.y;
  Result.data.z = Pack.z;
  Result.data.w = Pack.w;
  return Result.pack;
 }

 inline vec4 unpackSnorm3x10_1x2(uint32 v)
 {
  detail::i10i10i10i2 Unpack;
  Unpack.pack = v;

  vec4 const Result(Unpack.data.x, Unpack.data.y, Unpack.data.z, Unpack.data.w);

  return clamp(Result * vec4(1.f / 511.f, 1.f / 511.f, 1.f / 511.f, 1.f), -1.0f, 1.0f);
 }

 inline uint32 packUnorm3x10_1x2(vec4 const& v)
 {
  uvec4 const Unpack(round(clamp(v, 0.0f, 1.0f) * vec4(1023.f, 1023.f, 1023.f, 3.f)));

  detail::u10u10u10u2 Result;
  Result.data.x = Unpack.x;
  Result.data.y = Unpack.y;
  Result.data.z = Unpack.z;
  Result.data.w = Unpack.w;
  return Result.pack;
 }

 inline vec4 unpackUnorm3x10_1x2(uint32 v)
 {
  vec4 const ScaleFactors(1.0f / 1023.f, 1.0f / 1023.f, 1.0f / 1023.f, 1.0f / 3.f);

  detail::u10u10u10u2 Unpack;
  Unpack.pack = v;
  return vec4(Unpack.data.x, Unpack.data.y, Unpack.data.z, Unpack.data.w) * ScaleFactors;
 }

 inline uint32 packF2x11_1x10(vec3 const& v)
 {
  return
   ((detail::floatTo11bit(v.x) & ((1 << 11) - 1)) << 0) |
   ((detail::floatTo11bit(v.y) & ((1 << 11) - 1)) << 11) |
   ((detail::floatTo10bit(v.z) & ((1 << 10) - 1)) << 22);
 }

 inline vec3 unpackF2x11_1x10(uint32 v)
 {
  return vec3(
   detail::packed11bitToFloat(v >> 0),
   detail::packed11bitToFloat(v >> 11),
   detail::packed10bitToFloat(v >> 22));
 }

 inline uint32 packF3x9_E1x5(vec3 const& v)
 {
  float const SharedExpMax = (pow(2.0f, 9.0f - 1.0f) / pow(2.0f, 9.0f)) * pow(2.0f, 31.f - 15.f);
  vec3 const Color = clamp(v, 0.0f, SharedExpMax);
  float const MaxColor = max(Color.x, max(Color.y, Color.z));

  float const ExpSharedP = max(-15.f - 1.f, floor(log2(MaxColor))) + 1.0f + 15.f;
  float const MaxShared = floor(MaxColor / pow(2.0f, (ExpSharedP - 15.f - 9.f)) + 0.5f);
  float const ExpShared = equal(MaxShared, pow(2.0f, 9.0f), epsilon<float>()) ? ExpSharedP + 1.0f : ExpSharedP;

  uvec3 const ColorComp(floor(Color / pow(2.f, (ExpShared - 15.f - 9.f)) + 0.5f));

  detail::u9u9u9e5 Unpack;
  Unpack.data.x = ColorComp.x;
  Unpack.data.y = ColorComp.y;
  Unpack.data.z = ColorComp.z;
  Unpack.data.w = uint(ExpShared);
  return Unpack.pack;
 }

 inline vec3 unpackF3x9_E1x5(uint32 v)
 {
  detail::u9u9u9e5 Unpack;
  Unpack.pack = v;

  return vec3(Unpack.data.x, Unpack.data.y, Unpack.data.z) * pow(2.0f, static_cast<float>(Unpack.data.w) - 15.f - 9.f);
 }


 template<typename T, qualifier Q>
 inline vec<4, T, Q> packRGBM(vec<3, T, Q> const& rgb)
 {
  vec<3, T, Q> const Color(rgb * static_cast<T>(1.0 / 6.0));
  T Alpha = clamp(max(max(Color.x, Color.y), max(Color.z, static_cast<T>(1e-6))), static_cast<T>(0), static_cast<T>(1));
  Alpha = ceil(Alpha * static_cast<T>(255.0)) / static_cast<T>(255.0);
  return vec<4, T, Q>(Color / Alpha, Alpha);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> unpackRGBM(vec<4, T, Q> const& rgbm)
 {
  return vec<3, T, Q>(rgbm.x, rgbm.y, rgbm.z) * rgbm.w * static_cast<T>(6);
 }

 template<length_t L, qualifier Q>
 inline vec<L, uint16, Q> packHalf(vec<L, float, Q> const& v)
 {
  return detail::compute_half<L, Q>::pack(v);
 }

 template<length_t L, qualifier Q>
 inline vec<L, float, Q> unpackHalf(vec<L, uint16, Q> const& v)
 {
  return detail::compute_half<L, Q>::unpack(v);
 }

 template<typename uintType, length_t L, typename floatType, qualifier Q>
 inline vec<L, uintType, Q> packUnorm(vec<L, floatType, Q> const& v)
 {
  static_assert(std::numeric_limits<uintType>::is_integer, "uintType must be an integer type");
  static_assert(std::numeric_limits<floatType>::is_iec559, "floatType must be a floating point type");

  return vec<L, uintType, Q>(round(clamp(v, static_cast<floatType>(0), static_cast<floatType>(1)) * static_cast<floatType>(std::numeric_limits<uintType>::max())));
 }

 template<typename floatType, length_t L, typename uintType, qualifier Q>
 inline vec<L, floatType, Q> unpackUnorm(vec<L, uintType, Q> const& v)
 {
  static_assert(std::numeric_limits<uintType>::is_integer, "uintType must be an integer type");
  static_assert(std::numeric_limits<floatType>::is_iec559, "floatType must be a floating point type");

  return vec<L, floatType, Q>(v) * (static_cast<floatType>(1) / static_cast<floatType>(std::numeric_limits<uintType>::max()));
 }

 template<typename intType, length_t L, typename floatType, qualifier Q>
 inline vec<L, intType, Q> packSnorm(vec<L, floatType, Q> const& v)
 {
  static_assert(std::numeric_limits<intType>::is_integer, "uintType must be an integer type");
  static_assert(std::numeric_limits<floatType>::is_iec559, "floatType must be a floating point type");

  return vec<L, intType, Q>(round(clamp(v , static_cast<floatType>(-1), static_cast<floatType>(1)) * static_cast<floatType>(std::numeric_limits<intType>::max())));
 }

 template<typename floatType, length_t L, typename intType, qualifier Q>
 inline vec<L, floatType, Q> unpackSnorm(vec<L, intType, Q> const& v)
 {
  static_assert(std::numeric_limits<intType>::is_integer, "uintType must be an integer type");
  static_assert(std::numeric_limits<floatType>::is_iec559, "floatType must be a floating point type");

  return clamp(vec<L, floatType, Q>(v) * (static_cast<floatType>(1) / static_cast<floatType>(std::numeric_limits<intType>::max())), static_cast<floatType>(-1), static_cast<floatType>(1));
 }

 inline uint8 packUnorm2x4(vec2 const& v)
 {
  u32vec2 const Unpack(round(clamp(v, 0.0f, 1.0f) * 15.0f));
  detail::u4u4 Result;
  Result.data.x = Unpack.x;
  Result.data.y = Unpack.y;
  return Result.pack;
 }

 inline vec2 unpackUnorm2x4(uint8 v)
 {
  float const ScaleFactor(1.f / 15.f);
  detail::u4u4 Unpack;
  Unpack.pack = v;
  return vec2(Unpack.data.x, Unpack.data.y) * ScaleFactor;
 }

 inline uint16 packUnorm4x4(vec4 const& v)
 {
  u32vec4 const Unpack(round(clamp(v, 0.0f, 1.0f) * 15.0f));
  detail::u4u4u4u4 Result;
  Result.data.x = Unpack.x;
  Result.data.y = Unpack.y;
  Result.data.z = Unpack.z;
  Result.data.w = Unpack.w;
  return Result.pack;
 }

 inline vec4 unpackUnorm4x4(uint16 v)
 {
  float const ScaleFactor(1.f / 15.f);
  detail::u4u4u4u4 Unpack;
  Unpack.pack = v;
  return vec4(Unpack.data.x, Unpack.data.y, Unpack.data.z, Unpack.data.w) * ScaleFactor;
 }

 inline uint16 packUnorm1x5_1x6_1x5(vec3 const& v)
 {
  u32vec3 const Unpack(round(clamp(v, 0.0f, 1.0f) * vec3(31.f, 63.f, 31.f)));
  detail::u5u6u5 Result;
  Result.data.x = Unpack.x;
  Result.data.y = Unpack.y;
  Result.data.z = Unpack.z;
  return Result.pack;
 }

 inline vec3 unpackUnorm1x5_1x6_1x5(uint16 v)
 {
  vec3 const ScaleFactor(1.f / 31.f, 1.f / 63.f, 1.f / 31.f);
  detail::u5u6u5 Unpack;
  Unpack.pack = v;
  return vec3(Unpack.data.x, Unpack.data.y, Unpack.data.z) * ScaleFactor;
 }

 inline uint16 packUnorm3x5_1x1(vec4 const& v)
 {
  u32vec4 const Unpack(round(clamp(v, 0.0f, 1.0f) * vec4(31.f, 31.f, 31.f, 1.f)));
  detail::u5u5u5u1 Result;
  Result.data.x = Unpack.x;
  Result.data.y = Unpack.y;
  Result.data.z = Unpack.z;
  Result.data.w = Unpack.w;
  return Result.pack;
 }

 inline vec4 unpackUnorm3x5_1x1(uint16 v)
 {
  vec4 const ScaleFactor(1.f / 31.f, 1.f / 31.f, 1.f / 31.f, 1.f);
  detail::u5u5u5u1 Unpack;
  Unpack.pack = v;
  return vec4(Unpack.data.x, Unpack.data.y, Unpack.data.z, Unpack.data.w) * ScaleFactor;
 }

 inline uint8 packUnorm2x3_1x2(vec3 const& v)
 {
  u32vec3 const Unpack(round(clamp(v, 0.0f, 1.0f) * vec3(7.f, 7.f, 3.f)));
  detail::u3u3u2 Result;
  Result.data.x = Unpack.x;
  Result.data.y = Unpack.y;
  Result.data.z = Unpack.z;
  return Result.pack;
 }

 inline vec3 unpackUnorm2x3_1x2(uint8 v)
 {
  vec3 const ScaleFactor(1.f / 7.f, 1.f / 7.f, 1.f / 3.f);
  detail::u3u3u2 Unpack;
  Unpack.pack = v;
  return vec3(Unpack.data.x, Unpack.data.y, Unpack.data.z) * ScaleFactor;
 }

 inline int16 packInt2x8(i8vec2 const& v)
 {
  int16 Pack = 0;
  memcpy(&Pack, &v, sizeof(Pack));
  return Pack;
 }

 inline i8vec2 unpackInt2x8(int16 p)
 {
  i8vec2 Unpack;
  memcpy(&Unpack, &p, sizeof(Unpack));
  return Unpack;
 }

 inline uint16 packUint2x8(u8vec2 const& v)
 {
  uint16 Pack = 0;
  memcpy(&Pack, &v, sizeof(Pack));
  return Pack;
 }

 inline u8vec2 unpackUint2x8(uint16 p)
 {
  u8vec2 Unpack;
  memcpy(&Unpack, &p, sizeof(Unpack));
  return Unpack;
 }

 inline int32 packInt4x8(i8vec4 const& v)
 {
  int32 Pack = 0;
  memcpy(&Pack, &v, sizeof(Pack));
  return Pack;
 }

 inline i8vec4 unpackInt4x8(int32 p)
 {
  i8vec4 Unpack;
  memcpy(&Unpack, &p, sizeof(Unpack));
  return Unpack;
 }

 inline uint32 packUint4x8(u8vec4 const& v)
 {
  uint32 Pack = 0;
  memcpy(&Pack, &v, sizeof(Pack));
  return Pack;
 }

 inline u8vec4 unpackUint4x8(uint32 p)
 {
  u8vec4 Unpack;
  memcpy(&Unpack, &p, sizeof(Unpack));
  return Unpack;
 }

 inline int packInt2x16(i16vec2 const& v)
 {
  int Pack = 0;
  memcpy(&Pack, &v, sizeof(Pack));
  return Pack;
 }

 inline i16vec2 unpackInt2x16(int p)
 {
  i16vec2 Unpack;
  memcpy(&Unpack, &p, sizeof(Unpack));
  return Unpack;
 }

 inline int64 packInt4x16(i16vec4 const& v)
 {
  int64 Pack = 0;
  memcpy(&Pack, &v, sizeof(Pack));
  return Pack;
 }

 inline i16vec4 unpackInt4x16(int64 p)
 {
  i16vec4 Unpack;
  memcpy(&Unpack, &p, sizeof(Unpack));
  return Unpack;
 }

 inline uint packUint2x16(u16vec2 const& v)
 {
  uint Pack = 0;
  memcpy(&Pack, &v, sizeof(Pack));
  return Pack;
 }

 inline u16vec2 unpackUint2x16(uint p)
 {
  u16vec2 Unpack;
  memcpy(&Unpack, &p, sizeof(Unpack));
  return Unpack;
 }

 inline uint64 packUint4x16(u16vec4 const& v)
 {
  uint64 Pack = 0;
  memcpy(&Pack, &v, sizeof(Pack));
  return Pack;
 }

 inline u16vec4 unpackUint4x16(uint64 p)
 {
  u16vec4 Unpack;
  memcpy(&Unpack, &p, sizeof(Unpack));
  return Unpack;
 }

 inline int64 packInt2x32(i32vec2 const& v)
 {
  int64 Pack = 0;
  memcpy(&Pack, &v, sizeof(Pack));
  return Pack;
 }

 inline i32vec2 unpackInt2x32(int64 p)
 {
  i32vec2 Unpack;
  memcpy(&Unpack, &p, sizeof(Unpack));
  return Unpack;
 }

 inline uint64 packUint2x32(u32vec2 const& v)
 {
  uint64 Pack = 0;
  memcpy(&Pack, &v, sizeof(Pack));
  return Pack;
 }

 inline u32vec2 unpackUint2x32(uint64 p)
 {
  u32vec2 Unpack;
  memcpy(&Unpack, &p, sizeof(Unpack));
  return Unpack;
 }
}
# 729 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/packing.hpp" 2
# 184 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/random.hpp" 1
# 14 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/random.hpp"
       
# 25 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/random.hpp"
namespace glm
{
# 36 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/random.hpp"
 template<typename genType>
 [[nodiscard]] genType linearRand(genType Min, genType Max);
# 46 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/random.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> linearRand(vec<L, T, Q> const& Min, vec<L, T, Q> const& Max);




 template<typename genType>
 [[nodiscard]] genType gaussRand(genType Mean, genType Deviation);




 template<typename T>
 [[nodiscard]] vec<2, T, defaultp> circularRand(T Radius);




 template<typename T>
 [[nodiscard]] vec<3, T, defaultp> sphericalRand(T Radius);




 template<typename T>
 [[nodiscard]] vec<2, T, defaultp> diskRand(T Radius);




 template<typename T>
 [[nodiscard]] vec<3, T, defaultp> ballRand(T Radius);


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/random.inl" 1




# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cstdlib" 1 3
# 39 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cstdlib" 3
       
# 40 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cstdlib" 3
# 6 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/random.inl" 2
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/ctime" 1 3
# 39 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/ctime" 3
       
# 40 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/ctime" 3


# 1 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/time.h" 1 3
# 25 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/time.h" 3
# 1 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/sys/timeb.h" 1 3
# 15 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/sys/timeb.h" 3
#pragma pack(push,_CRT_PACKING)



# 18 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/sys/timeb.h" 3
extern "C" {
# 53 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/sys/timeb.h" 3
  struct __timeb32 {
    __time32_t time;
    unsigned short millitm;
    short timezone;
    short dstflag;
  };


  struct timeb {
    time_t time;
    unsigned short millitm;
    short timezone;
    short dstflag;
  };


  struct __timeb64 {
    __time64_t time;
    unsigned short millitm;
    short timezone;
    short dstflag;
  };



  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _ftime64(struct __timeb64 *_Time);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _ftime32(struct __timeb32 *_Time);
# 89 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/sys/timeb.h" 3
struct _timespec32 {
  __time32_t tv_sec;
  long tv_nsec;
};

struct _timespec64 {
  __time64_t tv_sec;
  long tv_nsec;
};



struct timespec {
  time_t tv_sec;
  long tv_nsec;
};

struct itimerspec {
  struct timespec it_interval;
  struct timespec it_value;
};



  void __attribute__((__cdecl__)) ftime (struct timeb *);




  inline void __attribute__((__cdecl__)) ftime(struct timeb *_Tmb) {
    _ftime64((struct __timeb64 *)_Tmb);
  }
# 130 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/sys/timeb.h" 3
}


#pragma pack(pop)

# 1 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/sec_api/sys/timeb_s.h" 1 3
# 10 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/sec_api/sys/timeb_s.h" 3
# 1 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/sys/timeb.h" 1 3
# 11 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/sec_api/sys/timeb_s.h" 2 3


extern "C" {


  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ftime32_s(struct __timeb32 *_Time);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ftime64_s(struct __timeb64 *_Time);
# 26 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/sec_api/sys/timeb_s.h" 3
}
# 136 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/sys/timeb.h" 2 3
# 26 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/time.h" 2 3

#pragma pack(push,_CRT_PACKING)


extern "C" {
# 63 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/time.h" 3
  typedef long clock_t;
# 100 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/time.h" 3
  struct tm {
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
  };
# 129 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/time.h" 3
  extern __attribute__ ((__dllimport__)) int _daylight;
  extern __attribute__ ((__dllimport__)) long _dstbias;
  extern __attribute__ ((__dllimport__)) long _timezone;
  extern __attribute__ ((__dllimport__)) char * _tzname[2];
# 145 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/time.h" 3
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _get_daylight(int *_Daylight);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _get_dstbias(long *_Daylight_savings_bias);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _get_timezone(long *_Timezone);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _get_tzname(size_t *_ReturnValue,char *_Buffer,size_t _SizeInBytes,int _Index);
  char *__attribute__((__cdecl__)) asctime(const struct tm *_Tm) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) asctime_s (char *_Buf,size_t _SizeInWords,const struct tm *_Tm);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ctime32(const __time32_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _ctime32_s (char *_Buf,size_t _SizeInBytes,const __time32_t *_Time);
  clock_t __attribute__((__cdecl__)) clock(void);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _difftime32(__time32_t _Time1,__time32_t _Time2);
  __attribute__ ((__dllimport__)) struct tm *__attribute__((__cdecl__)) _gmtime32(const __time32_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _gmtime32_s (struct tm *_Tm,const __time32_t *_Time);
  __attribute__ ((__dllimport__)) struct tm *__attribute__((__cdecl__)) _localtime32(const __time32_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _localtime32_s (struct tm *_Tm,const __time32_t *_Time);
  size_t __attribute__((__cdecl__)) strftime(char * __restrict__ _Buf,size_t _SizeInBytes,const char * __restrict__ _Format,const struct tm * __restrict__ _Tm) __attribute__((__format__ (ms_strftime, 3, 0)));
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _strftime_l(char * __restrict__ _Buf,size_t _Max_size,const char * __restrict__ _Format,const struct tm * __restrict__ _Tm,_locale_t _Locale);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strdate(char *_Buffer) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _strdate_s (char *_Buf,size_t _SizeInBytes);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _strdate_s(char (&_Str)[__size]) { return _strdate_s(_Str,__size); } }
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strtime(char *_Buffer) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _strtime_s (char *_Buf ,size_t _SizeInBytes);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _strtime_s(char (&_Str)[__size]) { return _strtime_s(_Str,__size); } }
  __attribute__ ((__dllimport__)) __time32_t __attribute__((__cdecl__)) _time32(__time32_t *_Time);



  __attribute__ ((__dllimport__)) __time32_t __attribute__((__cdecl__)) _mktime32(struct tm *_Tm);
  __attribute__ ((__dllimport__)) __time32_t __attribute__((__cdecl__)) _mkgmtime32(struct tm *_Tm);


  void __attribute__((__cdecl__)) tzset(void) ;



  __attribute__ ((__dllimport__))

  void __attribute__((__cdecl__)) _tzset(void);


  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _difftime64(__time64_t _Time1,__time64_t _Time2);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ctime64(const __time64_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _ctime64_s (char *_Buf,size_t _SizeInBytes,const __time64_t *_Time);
  __attribute__ ((__dllimport__)) struct tm *__attribute__((__cdecl__)) _gmtime64(const __time64_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _gmtime64_s (struct tm *_Tm,const __time64_t *_Time);
  __attribute__ ((__dllimport__)) struct tm *__attribute__((__cdecl__)) _localtime64(const __time64_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _localtime64_s (struct tm *_Tm,const __time64_t *_Time);
  __attribute__ ((__dllimport__)) __time64_t __attribute__((__cdecl__)) _mktime64(struct tm *_Tm);
  __attribute__ ((__dllimport__)) __time64_t __attribute__((__cdecl__)) _mkgmtime64(struct tm *_Tm);
  __attribute__ ((__dllimport__)) __time64_t __attribute__((__cdecl__)) _time64(__time64_t *_Time);



  unsigned __attribute__((__cdecl__)) _getsystime(struct tm *_Tm);
  unsigned __attribute__((__cdecl__)) _setsystime(struct tm *_Tm,unsigned _MilliSec);


  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wasctime(const struct tm *_Tm);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wasctime_s (wchar_t *_Buf,size_t _SizeInWords,const struct tm *_Tm);
  wchar_t *__attribute__((__cdecl__)) _wctime32(const __time32_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wctime32_s (wchar_t *_Buf,size_t _SizeInWords,const __time32_t *_Time);
  size_t __attribute__((__cdecl__)) wcsftime(wchar_t * __restrict__ _Buf,size_t _SizeInWords,const wchar_t * __restrict__ _Format,const struct tm * __restrict__ _Tm);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _wcsftime_l(wchar_t * __restrict__ _Buf,size_t _SizeInWords,const wchar_t * __restrict__ _Format,const struct tm * __restrict__ _Tm,_locale_t _Locale);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wstrdate(wchar_t *_Buffer) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wstrdate_s (wchar_t *_Buf,size_t _SizeInWords);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wstrtime(wchar_t *_Buffer) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wstrtime_s (wchar_t *_Buf,size_t _SizeInWords);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wctime64(const __time64_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wctime64_s (wchar_t *_Buf,size_t _SizeInWords,const __time64_t *_Time);




  wchar_t *__attribute__((__cdecl__)) _wctime(const time_t *_Time) __asm__("_wctime64");
# 226 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/time.h" 3
  errno_t __attribute__((__cdecl__)) _wctime_s (wchar_t *_Buffer,size_t _SizeInWords,const time_t *_Time) __asm__("_wctime64_s");
# 252 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/time.h" 3
time_t __attribute__((__cdecl__)) time(time_t *_Time) __asm__("_time64");



double __attribute__((__cdecl__)) difftime(time_t _Time1,time_t _Time2) __asm__("_difftime64");
struct tm *__attribute__((__cdecl__)) localtime(const time_t *_Time) __asm__("_localtime64");
errno_t __attribute__((__cdecl__)) localtime_s(struct tm *_Tm,const time_t *_Time) __asm__("_localtime64_s");
struct tm *__attribute__((__cdecl__)) gmtime(const time_t *_Time) __asm__("_gmtime64");
errno_t __attribute__((__cdecl__)) gmtime_s(struct tm *_Tm, const time_t *_Time) __asm__("_gmtime64_s");
char *__attribute__((__cdecl__)) ctime(const time_t *_Time) __asm__("_ctime64");
errno_t __attribute__((__cdecl__)) ctime_s(char *_Buf,size_t _SizeInBytes,const time_t *_Time) __asm__("_ctime64_s");
time_t __attribute__((__cdecl__)) mktime(struct tm *_Tm) __asm__("_mktime64");
time_t __attribute__((__cdecl__)) _mkgmtime(struct tm *_Tm) __asm__("_mkgmtime64");
# 281 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/time.h" 3
  __attribute__ ((__dllimport__)) extern int daylight ;
  __attribute__ ((__dllimport__)) extern long timezone ;
  __attribute__ ((__dllimport__)) extern char *tzname[2] ;
  void __attribute__((__cdecl__)) tzset(void) ;


# 1 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/_timeval.h" 1 3
# 10 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/_timeval.h" 3
struct timeval
{
 long tv_sec;
 long tv_usec;
};
# 288 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/time.h" 2 3



struct timezone {
  int tz_minuteswest;
  int tz_dsttime;
};

  extern int __attribute__((__cdecl__)) mingw_gettimeofday (struct timeval *p, struct timezone *z);


#pragma pack(pop)
# 321 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/time.h" 3
}
# 330 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/time.h" 3
# 1 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/pthread_time.h" 1 3
# 49 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/pthread_time.h" 3
typedef int clockid_t;
# 78 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/pthread_time.h" 3
extern "C" {



       





 int __attribute__((__cdecl__)) nanosleep(const struct timespec *request, struct timespec *remain);

 int __attribute__((__cdecl__)) clock_nanosleep(clockid_t clock_id, int flags, const struct timespec *request, struct timespec *remain);
 int __attribute__((__cdecl__)) clock_getres(clockid_t clock_id, struct timespec *res);
 int __attribute__((__cdecl__)) clock_gettime(clockid_t clock_id, struct timespec *tp);
 int __attribute__((__cdecl__)) clock_settime(clockid_t clock_id, const struct timespec *tp);

       


}
# 331 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/time.h" 2 3
# 43 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/ctime" 2 3
# 58 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/ctime" 3
namespace std
{
  using ::clock_t;
  using ::time_t;
  using ::tm;

  using ::clock;
  using ::difftime;
  using ::mktime;
  using ::time;
  using ::asctime;
  using ::ctime;
  using ::gmtime;
  using ::localtime;
  using ::strftime;
}
# 7 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/random.inl" 2
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cassert" 1 3
# 41 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cassert" 3
       
# 42 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cassert" 3


# 1 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/assert.h" 1 3
# 45 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cassert" 2 3
# 8 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/random.inl" 2
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 1 3
# 39 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 3
       
# 40 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cmath" 3
# 9 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/random.inl" 2


# 10 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/random.inl"
namespace glm{
namespace detail
{
 template <length_t L, typename T, qualifier Q>
 struct compute_rand
 {
  inline static vec<L, T, Q> call();
 };

 template <qualifier P>
 struct compute_rand<1, uint8, P>
 {
  inline static vec<1, uint8, P> call()
  {
   return vec<1, uint8, P>(
    static_cast<uint8>(std::rand() % std::numeric_limits<uint8>::max()));
  }
 };

 template <qualifier P>
 struct compute_rand<2, uint8, P>
 {
  inline static vec<2, uint8, P> call()
  {
   return vec<2, uint8, P>(
    std::rand() % std::numeric_limits<uint8>::max(),
    std::rand() % std::numeric_limits<uint8>::max());
  }
 };

 template <qualifier P>
 struct compute_rand<3, uint8, P>
 {
  inline static vec<3, uint8, P> call()
  {
   return vec<3, uint8, P>(
    std::rand() % std::numeric_limits<uint8>::max(),
    std::rand() % std::numeric_limits<uint8>::max(),
    std::rand() % std::numeric_limits<uint8>::max());
  }
 };

 template <qualifier P>
 struct compute_rand<4, uint8, P>
 {
  inline static vec<4, uint8, P> call()
  {
   return vec<4, uint8, P>(
    std::rand() % std::numeric_limits<uint8>::max(),
    std::rand() % std::numeric_limits<uint8>::max(),
    std::rand() % std::numeric_limits<uint8>::max(),
    std::rand() % std::numeric_limits<uint8>::max());
  }
 };

 template <length_t L, qualifier Q>
 struct compute_rand<L, uint16, Q>
 {
  inline static vec<L, uint16, Q> call()
  {
   return
    (vec<L, uint16, Q>(compute_rand<L, uint8, Q>::call()) << static_cast<uint16>(8)) |
    (vec<L, uint16, Q>(compute_rand<L, uint8, Q>::call()) << static_cast<uint16>(0));
  }
 };

 template <length_t L, qualifier Q>
 struct compute_rand<L, uint32, Q>
 {
  inline static vec<L, uint32, Q> call()
  {
   return
    (vec<L, uint32, Q>(compute_rand<L, uint16, Q>::call()) << static_cast<uint32>(16)) |
    (vec<L, uint32, Q>(compute_rand<L, uint16, Q>::call()) << static_cast<uint32>(0));
  }
 };

 template <length_t L, qualifier Q>
 struct compute_rand<L, uint64, Q>
 {
  inline static vec<L, uint64, Q> call()
  {
   return
    (vec<L, uint64, Q>(compute_rand<L, uint32, Q>::call()) << static_cast<uint64>(32)) |
    (vec<L, uint64, Q>(compute_rand<L, uint32, Q>::call()) << static_cast<uint64>(0));
  }
 };

 template <length_t L, typename T, qualifier Q>
 struct compute_linearRand
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& Min, vec<L, T, Q> const& Max);
 };

 template<length_t L, qualifier Q>
 struct compute_linearRand<L, int8, Q>
 {
  inline static vec<L, int8, Q> call(vec<L, int8, Q> const& Min, vec<L, int8, Q> const& Max)
  {
   return (vec<L, int8, Q>(compute_rand<L, uint8, Q>::call() % vec<L, uint8, Q>(Max + static_cast<int8>(1) - Min))) + Min;
  }
 };

 template<length_t L, qualifier Q>
 struct compute_linearRand<L, uint8, Q>
 {
  inline static vec<L, uint8, Q> call(vec<L, uint8, Q> const& Min, vec<L, uint8, Q> const& Max)
  {
   return (compute_rand<L, uint8, Q>::call() % (Max + static_cast<uint8>(1) - Min)) + Min;
  }
 };

 template<length_t L, qualifier Q>
 struct compute_linearRand<L, int16, Q>
 {
  inline static vec<L, int16, Q> call(vec<L, int16, Q> const& Min, vec<L, int16, Q> const& Max)
  {
   return (vec<L, int16, Q>(compute_rand<L, uint16, Q>::call() % vec<L, uint16, Q>(Max + static_cast<int16>(1) - Min))) + Min;
  }
 };

 template<length_t L, qualifier Q>
 struct compute_linearRand<L, uint16, Q>
 {
  inline static vec<L, uint16, Q> call(vec<L, uint16, Q> const& Min, vec<L, uint16, Q> const& Max)
  {
   return (compute_rand<L, uint16, Q>::call() % (Max + static_cast<uint16>(1) - Min)) + Min;
  }
 };

 template<length_t L, qualifier Q>
 struct compute_linearRand<L, int32, Q>
 {
  inline static vec<L, int32, Q> call(vec<L, int32, Q> const& Min, vec<L, int32, Q> const& Max)
  {
   return (vec<L, int32, Q>(compute_rand<L, uint32, Q>::call() % vec<L, uint32, Q>(Max + static_cast<int32>(1) - Min))) + Min;
  }
 };

 template<length_t L, qualifier Q>
 struct compute_linearRand<L, uint32, Q>
 {
  inline static vec<L, uint32, Q> call(vec<L, uint32, Q> const& Min, vec<L, uint32, Q> const& Max)
  {
   return (compute_rand<L, uint32, Q>::call() % (Max + static_cast<uint32>(1) - Min)) + Min;
  }
 };

 template<length_t L, qualifier Q>
 struct compute_linearRand<L, int64, Q>
 {
  inline static vec<L, int64, Q> call(vec<L, int64, Q> const& Min, vec<L, int64, Q> const& Max)
  {
   return (vec<L, int64, Q>(compute_rand<L, uint64, Q>::call() % vec<L, uint64, Q>(Max + static_cast<int64>(1) - Min))) + Min;
  }
 };

 template<length_t L, qualifier Q>
 struct compute_linearRand<L, uint64, Q>
 {
  inline static vec<L, uint64, Q> call(vec<L, uint64, Q> const& Min, vec<L, uint64, Q> const& Max)
  {
   return (compute_rand<L, uint64, Q>::call() % (Max + static_cast<uint64>(1) - Min)) + Min;
  }
 };

 template<length_t L, qualifier Q>
 struct compute_linearRand<L, float, Q>
 {
  inline static vec<L, float, Q> call(vec<L, float, Q> const& Min, vec<L, float, Q> const& Max)
  {
   return vec<L, float, Q>(compute_rand<L, uint32, Q>::call()) / static_cast<float>(std::numeric_limits<uint32>::max()) * (Max - Min) + Min;
  }
 };

 template<length_t L, qualifier Q>
 struct compute_linearRand<L, double, Q>
 {
  inline static vec<L, double, Q> call(vec<L, double, Q> const& Min, vec<L, double, Q> const& Max)
  {
   return vec<L, double, Q>(compute_rand<L, uint64, Q>::call()) / static_cast<double>(std::numeric_limits<uint64>::max()) * (Max - Min) + Min;
  }
 };

 template<length_t L, qualifier Q>
 struct compute_linearRand<L, long double, Q>
 {
  inline static vec<L, long double, Q> call(vec<L, long double, Q> const& Min, vec<L, long double, Q> const& Max)
  {
   return vec<L, long double, Q>(compute_rand<L, uint64, Q>::call()) / static_cast<long double>(std::numeric_limits<uint64>::max()) * (Max - Min) + Min;
  }
 };
}

 template<typename genType>
 inline genType linearRand(genType Min, genType Max)
 {
  return detail::compute_linearRand<1, genType, highp>::call(
   vec<1, genType, highp>(Min),
   vec<1, genType, highp>(Max)).x;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> linearRand(vec<L, T, Q> const& Min, vec<L, T, Q> const& Max)
 {
  return detail::compute_linearRand<L, T, Q>::call(Min, Max);
 }

 template<typename genType>
 inline genType gaussRand(genType Mean, genType Deviation)
 {
  genType w, x1, x2;

  do
  {
   x1 = linearRand(genType(-1), genType(1));
   x2 = linearRand(genType(-1), genType(1));

   w = x1 * x1 + x2 * x2;
  } while(w > genType(1));

  return static_cast<genType>(x2 * Deviation * Deviation * sqrt((genType(-2) * log(w)) / w) + Mean);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> gaussRand(vec<L, T, Q> const& Mean, vec<L, T, Q> const& Deviation)
 {
  return detail::functor2<vec, L, T, Q>::call(gaussRand, Mean, Deviation);
 }

 template<typename T>
 inline vec<2, T, defaultp> diskRand(T Radius)
 {
  
# 243 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/random.inl" 3
 ((void)0)
# 243 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/random.inl"
                                   ;

  vec<2, T, defaultp> Result(T(0));
  T LenRadius(T(0));

  do
  {
   Result = linearRand(
    vec<2, T, defaultp>(-Radius),
    vec<2, T, defaultp>(Radius));
   LenRadius = length(Result);
  }
  while(LenRadius > Radius);

  return Result;
 }

 template<typename T>
 inline vec<3, T, defaultp> ballRand(T Radius)
 {
  
# 263 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/random.inl" 3
 ((void)0)
# 263 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/random.inl"
                                   ;

  vec<3, T, defaultp> Result(T(0));
  T LenRadius(T(0));

  do
  {
   Result = linearRand(
    vec<3, T, defaultp>(-Radius),
    vec<3, T, defaultp>(Radius));
   LenRadius = length(Result);
  }
  while(LenRadius > Radius);

  return Result;
 }

 template<typename T>
 inline vec<2, T, defaultp> circularRand(T Radius)
 {
  
# 283 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/random.inl" 3
 ((void)0)
# 283 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/random.inl"
                                   ;

  T a = linearRand(T(0), static_cast<T>(6.283185307179586476925286766559));
  return vec<2, T, defaultp>(glm::cos(a), glm::sin(a)) * Radius;
 }

 template<typename T>
 inline vec<3, T, defaultp> sphericalRand(T Radius)
 {
  
# 292 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/random.inl" 3
 ((void)0)
# 292 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/random.inl"
                                   ;

  T theta = linearRand(T(0), T(6.283185307179586476925286766559f));
  T phi = std::acos(linearRand(T(-1.0f), T(1.0f)));

  T x = std::sin(phi) * std::cos(theta);
  T y = std::sin(phi) * std::sin(theta);
  T z = std::cos(phi);

  return vec<3, T, defaultp>(x, y, z) * Radius;
 }
}
# 83 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/random.hpp" 2
# 186 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/reciprocal.hpp" 1
# 13 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/reciprocal.hpp"
       


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/setup.hpp" 1
# 17 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/reciprocal.hpp" 2
# 187 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/round.hpp" 1
# 14 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/round.hpp"
       


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/setup.hpp" 1
# 18 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/round.hpp" 2
# 28 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/round.hpp"
namespace glm
{







 template<typename genIUType>
 [[nodiscard]] genIUType ceilPowerOfTwo(genIUType v);
# 48 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/round.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> ceilPowerOfTwo(vec<L, T, Q> const& v);





 template<typename genIUType>
 [[nodiscard]] genIUType floorPowerOfTwo(genIUType v);
# 66 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/round.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> floorPowerOfTwo(vec<L, T, Q> const& v);




 template<typename genIUType>
 [[nodiscard]] genIUType roundPowerOfTwo(genIUType v);
# 82 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/round.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> roundPowerOfTwo(vec<L, T, Q> const& v);
# 93 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/round.hpp"
 template<typename genType>
 [[nodiscard]] genType ceilMultiple(genType v, genType Multiple);
# 106 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/round.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> ceilMultiple(vec<L, T, Q> const& v, vec<L, T, Q> const& Multiple);
# 117 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/round.hpp"
 template<typename genType>
 [[nodiscard]] genType floorMultiple(genType v, genType Multiple);
# 130 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/round.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> floorMultiple(vec<L, T, Q> const& v, vec<L, T, Q> const& Multiple);
# 141 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/round.hpp"
 template<typename genType>
 [[nodiscard]] genType roundMultiple(genType v, genType Multiple);
# 154 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/round.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> roundMultiple(vec<L, T, Q> const& v, vec<L, T, Q> const& Multiple);


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/round.inl" 1





namespace glm{
namespace detail
{
 template<bool is_float, bool is_signed>
 struct compute_roundMultiple {};

 template<>
 struct compute_roundMultiple<true, true>
 {
  template<typename genType>
  inline static genType call(genType Source, genType Multiple)
  {
   if (Source >= genType(0))
    return Source - std::fmod(Source, Multiple);
   else
   {
    genType Tmp = Source + genType(1);
    return Tmp - std::fmod(Tmp, Multiple) - Multiple;
   }
  }
 };

 template<>
 struct compute_roundMultiple<false, false>
 {
  template<typename genType>
  inline static genType call(genType Source, genType Multiple)
  {
   if (Source >= genType(0))
    return Source - Source % Multiple;
   else
   {
    genType Tmp = Source + genType(1);
    return Tmp - Tmp % Multiple - Multiple;
   }
  }
 };

 template<>
 struct compute_roundMultiple<false, true>
 {
  template<typename genType>
  inline static genType call(genType Source, genType Multiple)
  {
   if (Source >= genType(0))
    return Source - Source % Multiple;
   else
   {
    genType Tmp = Source + genType(1);
    return Tmp - Tmp % Multiple - Multiple;
   }
  }
 };
}




 template<typename genType>
 inline genType ceilPowerOfTwo(genType value)
 {
  return detail::compute_ceilPowerOfTwo<1, genType, defaultp, std::numeric_limits<genType>::is_signed>::call(vec<1, genType, defaultp>(value)).x;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> ceilPowerOfTwo(vec<L, T, Q> const& v)
 {
  return detail::compute_ceilPowerOfTwo<L, T, Q, std::numeric_limits<T>::is_signed>::call(v);
 }




 template<typename genType>
 inline genType floorPowerOfTwo(genType value)
 {
  return isPowerOfTwo(value) ? value : static_cast<genType>(1) << findMSB(value);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> floorPowerOfTwo(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(floorPowerOfTwo, v);
 }




 template<typename genIUType>
 inline genIUType roundPowerOfTwo(genIUType value)
 {
  if(isPowerOfTwo(value))
   return value;

  genIUType const prev = static_cast<genIUType>(1) << findMSB(value);
  genIUType const next = prev << static_cast<genIUType>(1);
  return (next - value) < (value - prev) ? next : prev;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> roundPowerOfTwo(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(roundPowerOfTwo, v);
 }




 template<typename genType>
 inline genType ceilMultiple(genType Source, genType Multiple)
 {
  return detail::compute_ceilMultiple<std::numeric_limits<genType>::is_iec559, std::numeric_limits<genType>::is_signed>::call(Source, Multiple);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> ceilMultiple(vec<L, T, Q> const& Source, vec<L, T, Q> const& Multiple)
 {
  return detail::functor2<vec, L, T, Q>::call(ceilMultiple, Source, Multiple);
 }




 template<typename genType>
 inline genType floorMultiple(genType Source, genType Multiple)
 {
  return detail::compute_floorMultiple<std::numeric_limits<genType>::is_iec559, std::numeric_limits<genType>::is_signed>::call(Source, Multiple);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> floorMultiple(vec<L, T, Q> const& Source, vec<L, T, Q> const& Multiple)
 {
  return detail::functor2<vec, L, T, Q>::call(floorMultiple, Source, Multiple);
 }




 template<typename genType>
 inline genType roundMultiple(genType Source, genType Multiple)
 {
  return detail::compute_roundMultiple<std::numeric_limits<genType>::is_iec559, std::numeric_limits<genType>::is_signed>::call(Source, Multiple);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> roundMultiple(vec<L, T, Q> const& Source, vec<L, T, Q> const& Multiple)
 {
  return detail::functor2<vec, L, T, Q>::call(roundMultiple, Source, Multiple);
 }
}
# 161 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/round.hpp" 2
# 188 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/type_ptr.hpp" 1
# 34 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/type_ptr.hpp"
       
# 51 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/type_ptr.hpp"
# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cstring" 1 3
# 39 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cstring" 3
       
# 40 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cstring" 3


# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 1 3
# 47 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 3
       
# 48 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 3
# 43 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cstring" 2 3
# 52 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/type_ptr.hpp" 2





namespace glm
{





 template<typename genType>
 [[nodiscard]] typename genType::value_type const * value_ptr(genType const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<1, T, Q> make_vec1(vec<1, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<1, T, Q> make_vec1(vec<2, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<1, T, Q> make_vec1(vec<3, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<1, T, Q> make_vec1(vec<4, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<2, T, Q> make_vec2(vec<1, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<2, T, Q> make_vec2(vec<2, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<2, T, Q> make_vec2(vec<3, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<2, T, Q> make_vec2(vec<4, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<3, T, Q> make_vec3(vec<1, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<3, T, Q> make_vec3(vec<2, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<3, T, Q> make_vec3(vec<3, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<3, T, Q> make_vec3(vec<4, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<4, T, Q> make_vec4(vec<1, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<4, T, Q> make_vec4(vec<2, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<4, T, Q> make_vec4(vec<3, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<4, T, Q> make_vec4(vec<4, T, Q> const& v);



 template<typename T>
 [[nodiscard]] vec<2, T, defaultp> make_vec2(T const * const ptr);



 template<typename T>
 [[nodiscard]] vec<3, T, defaultp> make_vec3(T const * const ptr);



 template<typename T>
 [[nodiscard]] vec<4, T, defaultp> make_vec4(T const * const ptr);



 template<typename T>
 [[nodiscard]] mat<2, 2, T, defaultp> make_mat2x2(T const * const ptr);



 template<typename T>
 [[nodiscard]] mat<2, 3, T, defaultp> make_mat2x3(T const * const ptr);



 template<typename T>
 [[nodiscard]] mat<2, 4, T, defaultp> make_mat2x4(T const * const ptr);



 template<typename T>
 [[nodiscard]] mat<3, 2, T, defaultp> make_mat3x2(T const * const ptr);



 template<typename T>
 [[nodiscard]] mat<3, 3, T, defaultp> make_mat3x3(T const * const ptr);



 template<typename T>
 [[nodiscard]] mat<3, 4, T, defaultp> make_mat3x4(T const * const ptr);



 template<typename T>
 [[nodiscard]] mat<4, 2, T, defaultp> make_mat4x2(T const * const ptr);



 template<typename T>
 [[nodiscard]] mat<4, 3, T, defaultp> make_mat4x3(T const * const ptr);



 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> make_mat4x4(T const * const ptr);



 template<typename T>
 [[nodiscard]] mat<2, 2, T, defaultp> make_mat2(T const * const ptr);



 template<typename T>
 [[nodiscard]] mat<3, 3, T, defaultp> make_mat3(T const * const ptr);



 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> make_mat4(T const * const ptr);



 template<typename T>
 [[nodiscard]] qua<T, defaultp> make_quat(T const * const ptr);


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/type_ptr.inl" 1


# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cstring" 1 3
# 39 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cstring" 3
       
# 40 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cstring" 3


# 1 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 1 3
# 47 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 3
       
# 48 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/bits/version.h" 3
# 43 "D:/Enviroments/mingw64_msvcrt/include/c++/14.2.0/cstring" 2 3
# 4 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/type_ptr.inl" 2

namespace glm
{



 template<typename T, qualifier Q>
 inline T const* value_ptr(vec<2, T, Q> const& v)
 {
  return &(v.x);
 }

 template<typename T, qualifier Q>
 inline T* value_ptr(vec<2, T, Q>& v)
 {
  return &(v.x);
 }

 template<typename T, qualifier Q>
 inline T const * value_ptr(vec<3, T, Q> const& v)
 {
  return &(v.x);
 }

 template<typename T, qualifier Q>
 inline T* value_ptr(vec<3, T, Q>& v)
 {
  return &(v.x);
 }

 template<typename T, qualifier Q>
 inline T const* value_ptr(vec<4, T, Q> const& v)
 {
  return &(v.x);
 }

 template<typename T, qualifier Q>
 inline T* value_ptr(vec<4, T, Q>& v)
 {
  return &(v.x);
 }

 template<typename T, qualifier Q>
 inline T const* value_ptr(mat<2, 2, T, Q> const& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T* value_ptr(mat<2, 2, T, Q>& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T const* value_ptr(mat<3, 3, T, Q> const& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T* value_ptr(mat<3, 3, T, Q>& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T const* value_ptr(mat<4, 4, T, Q> const& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T* value_ptr(mat<4, 4, T, Q>& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T const* value_ptr(mat<2, 3, T, Q> const& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T* value_ptr(mat<2, 3, T, Q>& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T const* value_ptr(mat<3, 2, T, Q> const& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T* value_ptr(mat<3, 2, T, Q>& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T const* value_ptr(mat<2, 4, T, Q> const& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T* value_ptr(mat<2, 4, T, Q>& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T const* value_ptr(mat<4, 2, T, Q> const& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T* value_ptr(mat<4, 2, T, Q>& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T const* value_ptr(mat<3, 4, T, Q> const& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T* value_ptr(mat<3, 4, T, Q>& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T const* value_ptr(mat<4, 3, T, Q> const& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T * value_ptr(mat<4, 3, T, Q>& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T const * value_ptr(qua<T, Q> const& q)
 {
  return &(q[0]);
 }

 template<typename T, qualifier Q>
 inline T* value_ptr(qua<T, Q>& q)
 {
  return &(q[0]);
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<1, T, Q> make_vec1(vec<1, T, Q> const& v)
 {
  return v;
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<1, T, Q> make_vec1(vec<2, T, Q> const& v)
 {
  return vec<1, T, Q>(v);
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<1, T, Q> make_vec1(vec<3, T, Q> const& v)
 {
  return vec<1, T, Q>(v);
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<1, T, Q> make_vec1(vec<4, T, Q> const& v)
 {
  return vec<1, T, Q>(v);
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<2, T, Q> make_vec2(vec<1, T, Q> const& v)
 {
  return vec<2, T, Q>(v.x, static_cast<T>(0));
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<2, T, Q> make_vec2(vec<2, T, Q> const& v)
 {
  return v;
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<2, T, Q> make_vec2(vec<3, T, Q> const& v)
 {
  return vec<2, T, Q>(v);
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<2, T, Q> make_vec2(vec<4, T, Q> const& v)
 {
  return vec<2, T, Q>(v);
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<3, T, Q> make_vec3(vec<1, T, Q> const& v)
 {
  return vec<3, T, Q>(v.x, static_cast<T>(0), static_cast<T>(0));
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<3, T, Q> make_vec3(vec<2, T, Q> const& v)
 {
  return vec<3, T, Q>(v.x, v.y, static_cast<T>(0));
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<3, T, Q> make_vec3(vec<3, T, Q> const& v)
 {
  return v;
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<3, T, Q> make_vec3(vec<4, T, Q> const& v)
 {
  return vec<3, T, Q>(v);
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<4, T, Q> make_vec4(vec<1, T, Q> const& v)
 {
  return vec<4, T, Q>(v.x, static_cast<T>(0), static_cast<T>(0), static_cast<T>(1));
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<4, T, Q> make_vec4(vec<2, T, Q> const& v)
 {
  return vec<4, T, Q>(v.x, v.y, static_cast<T>(0), static_cast<T>(1));
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<4, T, Q> make_vec4(vec<3, T, Q> const& v)
 {
  return vec<4, T, Q>(v.x, v.y, v.z, static_cast<T>(1));
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<4, T, Q> make_vec4(vec<4, T, Q> const& v)
 {
  return v;
 }

 template<typename T>
 inline vec<2, T, defaultp> make_vec2(T const *const ptr)
 {
  vec<2, T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(vec<2, T, defaultp>));
  return Result;
 }

 template<typename T>
 inline vec<3, T, defaultp> make_vec3(T const *const ptr)
 {
  vec<3, T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(vec<3, T, defaultp>));
  return Result;
 }

 template<typename T>
 inline vec<4, T, defaultp> make_vec4(T const *const ptr)
 {
  vec<4, T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(vec<4, T, defaultp>));
  return Result;
 }

 template<typename T>
 inline mat<2, 2, T, defaultp> make_mat2x2(T const *const ptr)
 {
  mat<2, 2, T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(mat<2, 2, T, defaultp>));
  return Result;
 }

 template<typename T>
 inline mat<2, 3, T, defaultp> make_mat2x3(T const *const ptr)
 {
  mat<2, 3, T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(mat<2, 3, T, defaultp>));
  return Result;
 }

 template<typename T>
 inline mat<2, 4, T, defaultp> make_mat2x4(T const *const ptr)
 {
  mat<2, 4, T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(mat<2, 4, T, defaultp>));
  return Result;
 }

 template<typename T>
 inline mat<3, 2, T, defaultp> make_mat3x2(T const *const ptr)
 {
  mat<3, 2, T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(mat<3, 2, T, defaultp>));
  return Result;
 }

 template<typename T>
 inline mat<3, 3, T, defaultp> make_mat3x3(T const *const ptr)
 {
  mat<3, 3, T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(mat<3, 3, T, defaultp>));
  return Result;
 }

 template<typename T>
 inline mat<3, 4, T, defaultp> make_mat3x4(T const *const ptr)
 {
  mat<3, 4, T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(mat<3, 4, T, defaultp>));
  return Result;
 }

 template<typename T>
 inline mat<4, 2, T, defaultp> make_mat4x2(T const *const ptr)
 {
  mat<4, 2, T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(mat<4, 2, T, defaultp>));
  return Result;
 }

 template<typename T>
 inline mat<4, 3, T, defaultp> make_mat4x3(T const *const ptr)
 {
  mat<4, 3, T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(mat<4, 3, T, defaultp>));
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> make_mat4x4(T const *const ptr)
 {
  mat<4, 4, T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(mat<4, 4, T, defaultp>));
  return Result;
 }

 template<typename T>
 inline mat<2, 2, T, defaultp> make_mat2(T const *const ptr)
 {
  return make_mat2x2(ptr);
 }

 template<typename T>
 inline mat<3, 3, T, defaultp> make_mat3(T const *const ptr)
 {
  return make_mat3x3(ptr);
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> make_mat4(T const *const ptr)
 {
  return make_mat4x4(ptr);
 }

 template<typename T>
 inline qua<T, defaultp> make_quat(T const *const ptr)
 {
  qua<T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(qua<T, defaultp>));
  return Result;
 }


}
# 231 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/type_ptr.hpp" 2
# 190 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/ulp.hpp" 1
# 15 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/ulp.hpp"
       


# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/detail/setup.hpp" 1
# 19 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/ulp.hpp" 2
# 27 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/ulp.hpp"
namespace glm
{
# 37 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/ulp.hpp"
 template<typename genType>
 [[nodiscard]] genType next_float(genType x);






 template<typename genType>
 [[nodiscard]] genType prev_float(genType x);






 template<typename genType>
 [[nodiscard]] genType next_float(genType x, int ULPs);






 template<typename genType>
 [[nodiscard]] genType prev_float(genType x, int ULPs);




 [[nodiscard]] int float_distance(float x, float y);




 [[nodiscard]] int64 float_distance(double x, double y);
# 81 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/ulp.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> next_float(vec<L, T, Q> const& x);
# 91 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/ulp.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> next_float(vec<L, T, Q> const& x, int ULPs);
# 101 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/ulp.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> next_float(vec<L, T, Q> const& x, vec<L, int, Q> const& ULPs);
# 111 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/ulp.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> prev_float(vec<L, T, Q> const& x);
# 121 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/ulp.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> prev_float(vec<L, T, Q> const& x, int ULPs);
# 131 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/ulp.hpp"
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> prev_float(vec<L, T, Q> const& x, vec<L, int, Q> const& ULPs);







 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, int, Q> float_distance(vec<L, float, Q> const& x, vec<L, float, Q> const& y);







 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, int64, Q> float_distance(vec<L, double, Q> const& x, vec<L, double, Q> const& y);


}

# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/ulp.inl" 1




namespace glm
{
 template<>
 inline float next_float(float x)
 {

  return std::nextafter(x, std::numeric_limits<float>::max());







 }

 template<>
 inline double next_float(double x)
 {

  return std::nextafter(x, std::numeric_limits<double>::max());







 }

 template<typename T>
 inline T next_float(T x, int ULPs)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'next_float' only accept floating-point input");
  
# 39 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/ulp.inl" 3
 ((void)0)
# 39 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/ulp.inl"
                  ;

  T temp = x;
  for (int i = 0; i < ULPs; ++i)
   temp = next_float(temp);
  return temp;
 }

 inline float prev_float(float x)
 {

  return std::nextafter(x, std::numeric_limits<float>::min());







 }

 inline double prev_float(double x)
 {

  return std::nextafter(x, std::numeric_limits<double>::min());







 }

 template<typename T>
 inline T prev_float(T x, int ULPs)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'prev_float' only accept floating-point input");
  
# 77 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/ulp.inl" 3
 ((void)0)
# 77 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/ulp.inl"
                  ;

  T temp = x;
  for (int i = 0; i < ULPs; ++i)
   temp = prev_float(temp);
  return temp;
 }

 inline int float_distance(float x, float y)
 {
  detail::float_t<float> const a(x);
  detail::float_t<float> const b(y);

  return abs(a.i - b.i);
 }

 inline int64 float_distance(double x, double y)
 {
  detail::float_t<double> const a(x);
  detail::float_t<double> const b(y);

  return abs(a.i - b.i);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> next_float(vec<L, T, Q> const& x)
 {
  vec<L, T, Q> Result;
  for (length_t i = 0, n = Result.length(); i < n; ++i)
   Result[i] = next_float(x[i]);
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> next_float(vec<L, T, Q> const& x, int ULPs)
 {
  vec<L, T, Q> Result;
  for (length_t i = 0, n = Result.length(); i < n; ++i)
   Result[i] = next_float(x[i], ULPs);
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> next_float(vec<L, T, Q> const& x, vec<L, int, Q> const& ULPs)
 {
  vec<L, T, Q> Result;
  for (length_t i = 0, n = Result.length(); i < n; ++i)
   Result[i] = next_float(x[i], ULPs[i]);
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> prev_float(vec<L, T, Q> const& x)
 {
  vec<L, T, Q> Result;
  for (length_t i = 0, n = Result.length(); i < n; ++i)
   Result[i] = prev_float(x[i]);
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> prev_float(vec<L, T, Q> const& x, int ULPs)
 {
  vec<L, T, Q> Result;
  for (length_t i = 0, n = Result.length(); i < n; ++i)
   Result[i] = prev_float(x[i], ULPs);
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> prev_float(vec<L, T, Q> const& x, vec<L, int, Q> const& ULPs)
 {
  vec<L, T, Q> Result;
  for (length_t i = 0, n = Result.length(); i < n; ++i)
   Result[i] = prev_float(x[i], ULPs[i]);
  return Result;
 }

 template<length_t L, qualifier Q>
 inline vec<L, int, Q> float_distance(vec<L, float, Q> const& x, vec<L, float, Q> const& y)
 {
  vec<L, int, Q> Result;
  for (length_t i = 0, n = Result.length(); i < n; ++i)
   Result[i] = float_distance(x[i], y[i]);
  return Result;
 }

 template<length_t L, qualifier Q>
 inline vec<L, int64, Q> float_distance(vec<L, double, Q> const& x, vec<L, double, Q> const& y)
 {
  vec<L, int64, Q> Result;
  for (length_t i = 0, n = Result.length(); i < n; ++i)
   Result[i] = float_distance(x[i], y[i]);
  return Result;
 }
}
# 156 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/gtc/ulp.hpp" 2
# 191 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/ext.hpp" 2
# 139 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/glm/glm.hpp" 2
# 5 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/Creepy/Input.hpp" 2

struct GLFWwindow;

namespace Creepy{
    enum class MouseButton : uint32_t{
        LEFT = 0, RIGHT, MIDDLE
    };

    class Mouse{
        public:
            static bool IsMousePress(MouseButton button);
            static bool IsMouseHold(MouseButton button);
            static glm::vec2 GetMousePosition();
            static bool IsMouseInWindow();

        private:
            static void RegisterMouseEvent(GLFWwindow* window);

            static void PreProcessEveryFrame();

            friend class VulkanEngine;
    };

    enum class KeyCode : uint32_t{
        NONE = 0,
        KEY_SPACE = 32,
        KEY_APOSTROPHE = 39,
        KEY_COMMA = 44,
        KEY_MINUS = 45,
        KEY_PERIOD = 46,
        KEY_SLASH = 47,
        KEY_0 = 48,
        KEY_1 = 49,
        KEY_2 = 50,
        KEY_3 = 51,
        KEY_4 = 52,
        KEY_5 = 53,
        KEY_6 = 54,
        KEY_7 = 55,
        KEY_8 = 56,
        KEY_9 = 57,
        KEY_SEMICOLON = 59,
        KEY_EQUAL = 61,
        KEY_A = 65,
        KEY_B = 66,
        KEY_C = 67,
        KEY_D = 68,
        KEY_E = 69,
        KEY_F = 70,
        KEY_G = 71,
        KEY_H = 72,
        KEY_I = 73,
        KEY_J = 74,
        KEY_K = 75,
        KEY_L = 76,
        KEY_M = 77,
        KEY_N = 78,
        KEY_O = 79,
        KEY_P = 80,
        KEY_Q = 81,
        KEY_R = 82,
        KEY_S = 83,
        KEY_T = 84,
        KEY_U = 85,
        KEY_V = 86,
        KEY_W = 87,
        KEY_X = 88,
        KEY_Y = 89,
        KEY_Z = 90,
        KEY_LEFT_BRACKET = 91,
        KEY_BACKSLASH = 92,
        KEY_RIGHT_BRACKET = 93,
        KEY_GRAVE_ACCENT = 96,
        KEY_WORLD_1 = 161,
        KEY_WORLD_2 = 162,

        KEY_ESCAPE = 256,
        KEY_ENTER = 257,
        KEY_TAB = 258,
        KEY_BACKSPACE = 259,
        KEY_INSERT = 260,
        KEY_DELETE = 261,
        KEY_RIGHT = 262,
        KEY_LEFT = 263,
        KEY_DOWN = 264,
        KEY_UP = 265,
        KEY_PAGE_UP = 266,
        KEY_PAGE_DOWN = 267,
        KEY_HOME = 268,
        KEY_END = 269,
        KEY_CAPS_LOCK = 280,
        KEY_SCROLL_LOCK = 281,
        KEY_NUM_LOCK = 282,
        KEY_PRINT_SCREEN = 283,
        KEY_PAUSE = 284,
        KEY_F1 = 290,
        KEY_F2 = 291,
        KEY_F3 = 292,
        KEY_F4 = 293,
        KEY_F5 = 294,
        KEY_F6 = 295,
        KEY_F7 = 296,
        KEY_F8 = 297,
        KEY_F9 = 298,
        KEY_F10 = 299,
        KEY_F11 = 300,
        KEY_F12 = 301,
        KEY_F13 = 302,
        KEY_F14 = 303,
        KEY_F15 = 304,
        KEY_F16 = 305,
        KEY_F17 = 306,
        KEY_F18 = 307,
        KEY_F19 = 308,
        KEY_F20 = 309,
        KEY_F21 = 310,
        KEY_F22 = 311,
        KEY_F23 = 312,
        KEY_F24 = 313,
        KEY_F25 = 314,
        KEY_KP_0 = 320,
        KEY_KP_1 = 321,
        KEY_KP_2 = 322,
        KEY_KP_3 = 323,
        KEY_KP_4 = 324,
        KEY_KP_5 = 325,
        KEY_KP_6 = 326,
        KEY_KP_7 = 327,
        KEY_KP_8 = 328,
        KEY_KP_9 = 329,
        KEY_KP_DECIMAL = 330,
        KEY_KP_DIVIDE = 331,
        KEY_KP_MULTIPLY = 332,
        KEY_KP_SUBTRACT = 333,
        KEY_KP_ADD = 334,
        KEY_KP_ENTER = 335,
        KEY_KP_EQUAL = 336,
        KEY_LEFT_SHIFT = 340,
        KEY_LEFT_CONTROL = 341,
        KEY_LEFT_ALT = 342,
        KEY_LEFT_SUPER = 343,
        KEY_RIGHT_SHIFT = 344,
        KEY_RIGHT_CONTROL = 345,
        KEY_RIGHT_ALT = 346,
        KEY_RIGHT_SUPER = 347,
        KEY_MENU = 348,
    };

    class KeyBoard{
        public:
            static bool IsKeyPress(KeyCode keyCode);
            static bool IsKeyHold(KeyCode keyCode);
            static bool IsKeyRepeat(KeyCode keyCode);
            static char GetChar();

        private:
            static void RegisterKeyEvent(GLFWwindow* window);

            static void PreProcessEveryFrame();

            friend class VulkanEngine;
    };
}
# 4 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/src/Creepy/Input.cpp" 2
# 1 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h" 1
# 33 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
extern "C" {
# 103 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
# 1 "D:/Enviroments/mingw64_msvcrt/lib/gcc/x86_64-w64-mingw32/14.2.0/include/stddef.h" 1 3 4
# 1 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/stddef.h" 1 3 4
# 2 "D:/Enviroments/mingw64_msvcrt/lib/gcc/x86_64-w64-mingw32/14.2.0/include/stddef.h" 2 3 4
# 104 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h" 2
# 241 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
# 1 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 1 3
# 15 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
# 1 "D:/Enviroments/mingw64_msvcrt/lib/gcc/x86_64-w64-mingw32/14.2.0/include/stddef.h" 1 3 4
# 1 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/stddef.h" 1 3 4
# 2 "D:/Enviroments/mingw64_msvcrt/lib/gcc/x86_64-w64-mingw32/14.2.0/include/stddef.h" 2 3 4
# 16 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 2 3




# 19 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
extern "C" {


typedef unsigned int GLenum;
typedef unsigned char GLboolean;
typedef unsigned int GLbitfield;
typedef signed char GLbyte;
typedef short GLshort;
typedef int GLint;
typedef int GLsizei;
typedef unsigned char GLubyte;
typedef unsigned short GLushort;
typedef unsigned int GLuint;
typedef float GLfloat;
typedef float GLclampf;
typedef double GLdouble;
typedef double GLclampd;
typedef void GLvoid;
# 684 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
__attribute__((dllimport)) 
# 684 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 684 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glAccum(GLenum op,GLfloat value);
__attribute__((dllimport)) 
# 685 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 685 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glAlphaFunc(GLenum func,GLclampf ref);
__attribute__((dllimport)) 
# 686 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         GLboolean __attribute__((__stdcall__)) 
# 686 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                            glAreTexturesResident(GLsizei n,const GLuint *textures,GLboolean *residences);
__attribute__((dllimport)) 
# 687 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 687 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glArrayElement(GLint i);
__attribute__((dllimport)) 
# 688 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 688 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glBegin(GLenum mode);
__attribute__((dllimport)) 
# 689 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 689 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glBindTexture(GLenum target,GLuint texture);
__attribute__((dllimport)) 
# 690 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 690 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glBitmap(GLsizei width,GLsizei height,GLfloat xorig,GLfloat yorig,GLfloat xmove,GLfloat ymove,const GLubyte *bitmap);
__attribute__((dllimport)) 
# 691 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 691 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glBlendFunc(GLenum sfactor,GLenum dfactor);
__attribute__((dllimport)) 
# 692 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 692 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glCallList(GLuint list);
__attribute__((dllimport)) 
# 693 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 693 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glCallLists(GLsizei n,GLenum type,const GLvoid *lists);
__attribute__((dllimport)) 
# 694 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 694 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glClear(GLbitfield mask);
__attribute__((dllimport)) 
# 695 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 695 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glClearAccum(GLfloat red,GLfloat green,GLfloat blue,GLfloat alpha);
__attribute__((dllimport)) 
# 696 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 696 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glClearColor(GLclampf red,GLclampf green,GLclampf blue,GLclampf alpha);
__attribute__((dllimport)) 
# 697 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 697 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glClearDepth(GLclampd depth);
__attribute__((dllimport)) 
# 698 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 698 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glClearIndex(GLfloat c);
__attribute__((dllimport)) 
# 699 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 699 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glClearStencil(GLint s);
__attribute__((dllimport)) 
# 700 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 700 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glClipPlane(GLenum plane,const GLdouble *equation);
__attribute__((dllimport)) 
# 701 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 701 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glColor3b(GLbyte red,GLbyte green,GLbyte blue);
__attribute__((dllimport)) 
# 702 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 702 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glColor3bv(const GLbyte *v);
__attribute__((dllimport)) 
# 703 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 703 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glColor3d(GLdouble red,GLdouble green,GLdouble blue);
__attribute__((dllimport)) 
# 704 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 704 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glColor3dv(const GLdouble *v);
__attribute__((dllimport)) 
# 705 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 705 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glColor3f(GLfloat red,GLfloat green,GLfloat blue);
__attribute__((dllimport)) 
# 706 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 706 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glColor3fv(const GLfloat *v);
__attribute__((dllimport)) 
# 707 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 707 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glColor3i(GLint red,GLint green,GLint blue);
__attribute__((dllimport)) 
# 708 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 708 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glColor3iv(const GLint *v);
__attribute__((dllimport)) 
# 709 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 709 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glColor3s(GLshort red,GLshort green,GLshort blue);
__attribute__((dllimport)) 
# 710 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 710 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glColor3sv(const GLshort *v);
__attribute__((dllimport)) 
# 711 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 711 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glColor3ub(GLubyte red,GLubyte green,GLubyte blue);
__attribute__((dllimport)) 
# 712 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 712 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glColor3ubv(const GLubyte *v);
__attribute__((dllimport)) 
# 713 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 713 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glColor3ui(GLuint red,GLuint green,GLuint blue);
__attribute__((dllimport)) 
# 714 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 714 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glColor3uiv(const GLuint *v);
__attribute__((dllimport)) 
# 715 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 715 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glColor3us(GLushort red,GLushort green,GLushort blue);
__attribute__((dllimport)) 
# 716 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 716 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glColor3usv(const GLushort *v);
__attribute__((dllimport)) 
# 717 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 717 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glColor4b(GLbyte red,GLbyte green,GLbyte blue,GLbyte alpha);
__attribute__((dllimport)) 
# 718 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 718 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glColor4bv(const GLbyte *v);
__attribute__((dllimport)) 
# 719 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 719 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glColor4d(GLdouble red,GLdouble green,GLdouble blue,GLdouble alpha);
__attribute__((dllimport)) 
# 720 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 720 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glColor4dv(const GLdouble *v);
__attribute__((dllimport)) 
# 721 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 721 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glColor4f(GLfloat red,GLfloat green,GLfloat blue,GLfloat alpha);
__attribute__((dllimport)) 
# 722 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 722 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glColor4fv(const GLfloat *v);
__attribute__((dllimport)) 
# 723 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 723 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glColor4i(GLint red,GLint green,GLint blue,GLint alpha);
__attribute__((dllimport)) 
# 724 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 724 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glColor4iv(const GLint *v);
__attribute__((dllimport)) 
# 725 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 725 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glColor4s(GLshort red,GLshort green,GLshort blue,GLshort alpha);
__attribute__((dllimport)) 
# 726 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 726 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glColor4sv(const GLshort *v);
__attribute__((dllimport)) 
# 727 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 727 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glColor4ub(GLubyte red,GLubyte green,GLubyte blue,GLubyte alpha);
__attribute__((dllimport)) 
# 728 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 728 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glColor4ubv(const GLubyte *v);
__attribute__((dllimport)) 
# 729 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 729 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glColor4ui(GLuint red,GLuint green,GLuint blue,GLuint alpha);
__attribute__((dllimport)) 
# 730 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 730 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glColor4uiv(const GLuint *v);
__attribute__((dllimport)) 
# 731 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 731 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glColor4us(GLushort red,GLushort green,GLushort blue,GLushort alpha);
__attribute__((dllimport)) 
# 732 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 732 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glColor4usv(const GLushort *v);
__attribute__((dllimport)) 
# 733 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 733 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glColorMask(GLboolean red,GLboolean green,GLboolean blue,GLboolean alpha);
__attribute__((dllimport)) 
# 734 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 734 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glColorMaterial(GLenum face,GLenum mode);
__attribute__((dllimport)) 
# 735 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 735 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glColorPointer(GLint size,GLenum type,GLsizei stride,const GLvoid *pointer);
__attribute__((dllimport)) 
# 736 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 736 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glCopyPixels(GLint x,GLint y,GLsizei width,GLsizei height,GLenum type);
__attribute__((dllimport)) 
# 737 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 737 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glCopyTexImage1D(GLenum target,GLint level,GLenum internalFormat,GLint x,GLint y,GLsizei width,GLint border);
__attribute__((dllimport)) 
# 738 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 738 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glCopyTexImage2D(GLenum target,GLint level,GLenum internalFormat,GLint x,GLint y,GLsizei width,GLsizei height,GLint border);
__attribute__((dllimport)) 
# 739 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 739 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glCopyTexSubImage1D(GLenum target,GLint level,GLint xoffset,GLint x,GLint y,GLsizei width);
__attribute__((dllimport)) 
# 740 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 740 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glCopyTexSubImage2D(GLenum target,GLint level,GLint xoffset,GLint yoffset,GLint x,GLint y,GLsizei width,GLsizei height);
__attribute__((dllimport)) 
# 741 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 741 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glCullFace(GLenum mode);
__attribute__((dllimport)) 
# 742 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 742 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glDeleteLists(GLuint list,GLsizei range);
__attribute__((dllimport)) 
# 743 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 743 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glDeleteTextures(GLsizei n,const GLuint *textures);
__attribute__((dllimport)) 
# 744 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 744 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glDepthFunc(GLenum func);
__attribute__((dllimport)) 
# 745 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 745 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glDepthMask(GLboolean flag);
__attribute__((dllimport)) 
# 746 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 746 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glDepthRange (GLclampd zNear,GLclampd zFar);
__attribute__((dllimport)) 
# 747 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 747 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glDisable(GLenum cap);
__attribute__((dllimport)) 
# 748 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 748 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glDisableClientState(GLenum array);
__attribute__((dllimport)) 
# 749 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 749 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glDrawArrays(GLenum mode,GLint first,GLsizei count);
__attribute__((dllimport)) 
# 750 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 750 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glDrawBuffer(GLenum mode);
__attribute__((dllimport)) 
# 751 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 751 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glDrawElements(GLenum mode,GLsizei count,GLenum type,const GLvoid *indices);
__attribute__((dllimport)) 
# 752 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 752 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glDrawPixels(GLsizei width,GLsizei height,GLenum format,GLenum type,const GLvoid *pixels);
__attribute__((dllimport)) 
# 753 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 753 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glEdgeFlag(GLboolean flag);
__attribute__((dllimport)) 
# 754 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 754 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glEdgeFlagPointer(GLsizei stride,const GLvoid *pointer);
__attribute__((dllimport)) 
# 755 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 755 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glEdgeFlagv(const GLboolean *flag);
__attribute__((dllimport)) 
# 756 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 756 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glEnable(GLenum cap);
__attribute__((dllimport)) 
# 757 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 757 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glEnableClientState(GLenum array);
__attribute__((dllimport)) 
# 758 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 758 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glEnd(void);
__attribute__((dllimport)) 
# 759 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 759 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glEndList(void);
__attribute__((dllimport)) 
# 760 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 760 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glEvalCoord1d(GLdouble u);
__attribute__((dllimport)) 
# 761 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 761 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glEvalCoord1dv(const GLdouble *u);
__attribute__((dllimport)) 
# 762 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 762 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glEvalCoord1f(GLfloat u);
__attribute__((dllimport)) 
# 763 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 763 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glEvalCoord1fv(const GLfloat *u);
__attribute__((dllimport)) 
# 764 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 764 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glEvalCoord2d(GLdouble u,GLdouble v);
__attribute__((dllimport)) 
# 765 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 765 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glEvalCoord2dv(const GLdouble *u);
__attribute__((dllimport)) 
# 766 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 766 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glEvalCoord2f(GLfloat u,GLfloat v);
__attribute__((dllimport)) 
# 767 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 767 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glEvalCoord2fv(const GLfloat *u);
__attribute__((dllimport)) 
# 768 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 768 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glEvalMesh1(GLenum mode,GLint i1,GLint i2);
__attribute__((dllimport)) 
# 769 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 769 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glEvalMesh2(GLenum mode,GLint i1,GLint i2,GLint j1,GLint j2);
__attribute__((dllimport)) 
# 770 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 770 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glEvalPoint1(GLint i);
__attribute__((dllimport)) 
# 771 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 771 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glEvalPoint2(GLint i,GLint j);
__attribute__((dllimport)) 
# 772 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 772 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glFeedbackBuffer(GLsizei size,GLenum type,GLfloat *buffer);
__attribute__((dllimport)) 
# 773 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 773 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glFinish(void);
__attribute__((dllimport)) 
# 774 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 774 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glFlush(void);
__attribute__((dllimport)) 
# 775 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 775 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glFogf(GLenum pname,GLfloat param);
__attribute__((dllimport)) 
# 776 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 776 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glFogfv(GLenum pname,const GLfloat *params);
__attribute__((dllimport)) 
# 777 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 777 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glFogi(GLenum pname,GLint param);
__attribute__((dllimport)) 
# 778 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 778 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glFogiv(GLenum pname,const GLint *params);
__attribute__((dllimport)) 
# 779 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 779 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glFrontFace(GLenum mode);
__attribute__((dllimport)) 
# 780 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 780 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glFrustum(GLdouble left,GLdouble right,GLdouble bottom,GLdouble top,GLdouble zNear,GLdouble zFar);
__attribute__((dllimport)) 
# 781 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         GLuint __attribute__((__stdcall__)) 
# 781 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                         glGenLists(GLsizei range);
__attribute__((dllimport)) 
# 782 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 782 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glGenTextures(GLsizei n,GLuint *textures);
__attribute__((dllimport)) 
# 783 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 783 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glGetBooleanv(GLenum pname,GLboolean *params);
__attribute__((dllimport)) 
# 784 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 784 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glGetClipPlane(GLenum plane,GLdouble *equation);
__attribute__((dllimport)) 
# 785 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 785 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glGetDoublev(GLenum pname,GLdouble *params);
__attribute__((dllimport)) 
# 786 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         GLenum __attribute__((__stdcall__)) 
# 786 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                         glGetError(void);
__attribute__((dllimport)) 
# 787 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 787 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glGetFloatv(GLenum pname,GLfloat *params);
__attribute__((dllimport)) 
# 788 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 788 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glGetIntegerv(GLenum pname,GLint *params);
__attribute__((dllimport)) 
# 789 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 789 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glGetLightfv(GLenum light,GLenum pname,GLfloat *params);
__attribute__((dllimport)) 
# 790 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 790 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glGetLightiv(GLenum light,GLenum pname,GLint *params);
__attribute__((dllimport)) 
# 791 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 791 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glGetMapdv(GLenum target,GLenum query,GLdouble *v);
__attribute__((dllimport)) 
# 792 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 792 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glGetMapfv(GLenum target,GLenum query,GLfloat *v);
__attribute__((dllimport)) 
# 793 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 793 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glGetMapiv(GLenum target,GLenum query,GLint *v);
__attribute__((dllimport)) 
# 794 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 794 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glGetMaterialfv(GLenum face,GLenum pname,GLfloat *params);
__attribute__((dllimport)) 
# 795 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 795 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glGetMaterialiv(GLenum face,GLenum pname,GLint *params);
__attribute__((dllimport)) 
# 796 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 796 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glGetPixelMapfv(GLenum map,GLfloat *values);
__attribute__((dllimport)) 
# 797 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 797 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glGetPixelMapuiv(GLenum map,GLuint *values);
__attribute__((dllimport)) 
# 798 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 798 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glGetPixelMapusv(GLenum map,GLushort *values);
__attribute__((dllimport)) 
# 799 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 799 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glGetPointerv(GLenum pname,GLvoid **params);
__attribute__((dllimport)) 
# 800 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 800 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glGetPolygonStipple(GLubyte *mask);
__attribute__((dllimport)) 
# 801 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         const GLubyte *__attribute__((__stdcall__)) 
# 801 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                                 glGetString(GLenum name);
__attribute__((dllimport)) 
# 802 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 802 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glGetTexEnvfv(GLenum target,GLenum pname,GLfloat *params);
__attribute__((dllimport)) 
# 803 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 803 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glGetTexEnviv(GLenum target,GLenum pname,GLint *params);
__attribute__((dllimport)) 
# 804 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 804 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glGetTexGendv(GLenum coord,GLenum pname,GLdouble *params);
__attribute__((dllimport)) 
# 805 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 805 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glGetTexGenfv(GLenum coord,GLenum pname,GLfloat *params);
__attribute__((dllimport)) 
# 806 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 806 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glGetTexGeniv(GLenum coord,GLenum pname,GLint *params);
__attribute__((dllimport)) 
# 807 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 807 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glGetTexImage(GLenum target,GLint level,GLenum format,GLenum type,GLvoid *pixels);
__attribute__((dllimport)) 
# 808 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 808 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glGetTexLevelParameterfv(GLenum target,GLint level,GLenum pname,GLfloat *params);
__attribute__((dllimport)) 
# 809 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 809 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glGetTexLevelParameteriv(GLenum target,GLint level,GLenum pname,GLint *params);
__attribute__((dllimport)) 
# 810 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 810 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glGetTexParameterfv(GLenum target,GLenum pname,GLfloat *params);
__attribute__((dllimport)) 
# 811 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 811 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glGetTexParameteriv(GLenum target,GLenum pname,GLint *params);
__attribute__((dllimport)) 
# 812 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 812 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glHint(GLenum target,GLenum mode);
__attribute__((dllimport)) 
# 813 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 813 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glIndexMask(GLuint mask);
__attribute__((dllimport)) 
# 814 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 814 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glIndexPointer(GLenum type,GLsizei stride,const GLvoid *pointer);
__attribute__((dllimport)) 
# 815 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 815 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glIndexd(GLdouble c);
__attribute__((dllimport)) 
# 816 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 816 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glIndexdv(const GLdouble *c);
__attribute__((dllimport)) 
# 817 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 817 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glIndexf(GLfloat c);
__attribute__((dllimport)) 
# 818 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 818 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glIndexfv(const GLfloat *c);
__attribute__((dllimport)) 
# 819 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 819 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glIndexi(GLint c);
__attribute__((dllimport)) 
# 820 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 820 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glIndexiv(const GLint *c);
__attribute__((dllimport)) 
# 821 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 821 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glIndexs(GLshort c);
__attribute__((dllimport)) 
# 822 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 822 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glIndexsv(const GLshort *c);
__attribute__((dllimport)) 
# 823 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 823 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glIndexub(GLubyte c);
__attribute__((dllimport)) 
# 824 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 824 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glIndexubv(const GLubyte *c);
__attribute__((dllimport)) 
# 825 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 825 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glInitNames(void);
__attribute__((dllimport)) 
# 826 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 826 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glInterleavedArrays(GLenum format,GLsizei stride,const GLvoid *pointer);
__attribute__((dllimport)) 
# 827 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         GLboolean __attribute__((__stdcall__)) 
# 827 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                            glIsEnabled(GLenum cap);
__attribute__((dllimport)) 
# 828 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         GLboolean __attribute__((__stdcall__)) 
# 828 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                            glIsList(GLuint list);
__attribute__((dllimport)) 
# 829 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         GLboolean __attribute__((__stdcall__)) 
# 829 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                            glIsTexture(GLuint texture);
__attribute__((dllimport)) 
# 830 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 830 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glLightModelf(GLenum pname,GLfloat param);
__attribute__((dllimport)) 
# 831 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 831 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glLightModelfv(GLenum pname,const GLfloat *params);
__attribute__((dllimport)) 
# 832 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 832 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glLightModeli(GLenum pname,GLint param);
__attribute__((dllimport)) 
# 833 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 833 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glLightModeliv(GLenum pname,const GLint *params);
__attribute__((dllimport)) 
# 834 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 834 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glLightf(GLenum light,GLenum pname,GLfloat param);
__attribute__((dllimport)) 
# 835 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 835 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glLightfv(GLenum light,GLenum pname,const GLfloat *params);
__attribute__((dllimport)) 
# 836 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 836 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glLighti(GLenum light,GLenum pname,GLint param);
__attribute__((dllimport)) 
# 837 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 837 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glLightiv(GLenum light,GLenum pname,const GLint *params);
__attribute__((dllimport)) 
# 838 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 838 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glLineStipple(GLint factor,GLushort pattern);
__attribute__((dllimport)) 
# 839 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 839 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glLineWidth(GLfloat width);
__attribute__((dllimport)) 
# 840 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 840 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glListBase(GLuint base);
__attribute__((dllimport)) 
# 841 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 841 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glLoadIdentity(void);
__attribute__((dllimport)) 
# 842 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 842 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glLoadMatrixd(const GLdouble *m);
__attribute__((dllimport)) 
# 843 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 843 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glLoadMatrixf(const GLfloat *m);
__attribute__((dllimport)) 
# 844 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 844 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glLoadName(GLuint name);
__attribute__((dllimport)) 
# 845 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 845 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glLogicOp(GLenum opcode);
__attribute__((dllimport)) 
# 846 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 846 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glMap1d(GLenum target,GLdouble u1,GLdouble u2,GLint stride,GLint order,const GLdouble *points);
__attribute__((dllimport)) 
# 847 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 847 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glMap1f(GLenum target,GLfloat u1,GLfloat u2,GLint stride,GLint order,const GLfloat *points);
__attribute__((dllimport)) 
# 848 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 848 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glMap2d(GLenum target,GLdouble u1,GLdouble u2,GLint ustride,GLint uorder,GLdouble v1,GLdouble v2,GLint vstride,GLint vorder,const GLdouble *points);
__attribute__((dllimport)) 
# 849 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 849 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glMap2f(GLenum target,GLfloat u1,GLfloat u2,GLint ustride,GLint uorder,GLfloat v1,GLfloat v2,GLint vstride,GLint vorder,const GLfloat *points);
__attribute__((dllimport)) 
# 850 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 850 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glMapGrid1d(GLint un,GLdouble u1,GLdouble u2);
__attribute__((dllimport)) 
# 851 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 851 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glMapGrid1f(GLint un,GLfloat u1,GLfloat u2);
__attribute__((dllimport)) 
# 852 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 852 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glMapGrid2d(GLint un,GLdouble u1,GLdouble u2,GLint vn,GLdouble v1,GLdouble v2);
__attribute__((dllimport)) 
# 853 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 853 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glMapGrid2f(GLint un,GLfloat u1,GLfloat u2,GLint vn,GLfloat v1,GLfloat v2);
__attribute__((dllimport)) 
# 854 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 854 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glMaterialf(GLenum face,GLenum pname,GLfloat param);
__attribute__((dllimport)) 
# 855 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 855 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glMaterialfv(GLenum face,GLenum pname,const GLfloat *params);
__attribute__((dllimport)) 
# 856 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 856 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glMateriali(GLenum face,GLenum pname,GLint param);
__attribute__((dllimport)) 
# 857 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 857 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glMaterialiv(GLenum face,GLenum pname,const GLint *params);
__attribute__((dllimport)) 
# 858 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 858 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glMatrixMode(GLenum mode);
__attribute__((dllimport)) 
# 859 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 859 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glMultMatrixd(const GLdouble *m);
__attribute__((dllimport)) 
# 860 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 860 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glMultMatrixf(const GLfloat *m);
__attribute__((dllimport)) 
# 861 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 861 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glNewList(GLuint list,GLenum mode);
__attribute__((dllimport)) 
# 862 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 862 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glNormal3b (GLbyte nx,GLbyte ny,GLbyte nz);
__attribute__((dllimport)) 
# 863 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 863 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glNormal3bv(const GLbyte *v);
__attribute__((dllimport)) 
# 864 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 864 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glNormal3d(GLdouble nx,GLdouble ny,GLdouble nz);
__attribute__((dllimport)) 
# 865 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 865 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glNormal3dv(const GLdouble *v);
__attribute__((dllimport)) 
# 866 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 866 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glNormal3f(GLfloat nx,GLfloat ny,GLfloat nz);
__attribute__((dllimport)) 
# 867 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 867 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glNormal3fv(const GLfloat *v);
__attribute__((dllimport)) 
# 868 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 868 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glNormal3i(GLint nx,GLint ny,GLint nz);
__attribute__((dllimport)) 
# 869 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 869 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glNormal3iv(const GLint *v);
__attribute__((dllimport)) 
# 870 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 870 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glNormal3s(GLshort nx,GLshort ny,GLshort nz);
__attribute__((dllimport)) 
# 871 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 871 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glNormal3sv(const GLshort *v);
__attribute__((dllimport)) 
# 872 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 872 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glNormalPointer(GLenum type,GLsizei stride,const GLvoid *pointer);
__attribute__((dllimport)) 
# 873 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 873 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glOrtho(GLdouble left,GLdouble right,GLdouble bottom,GLdouble top,GLdouble zNear,GLdouble zFar);
__attribute__((dllimport)) 
# 874 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 874 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glPassThrough(GLfloat token);
__attribute__((dllimport)) 
# 875 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 875 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glPixelMapfv(GLenum map,GLsizei mapsize,const GLfloat *values);
__attribute__((dllimport)) 
# 876 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 876 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glPixelMapuiv(GLenum map,GLsizei mapsize,const GLuint *values);
__attribute__((dllimport)) 
# 877 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 877 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glPixelMapusv(GLenum map,GLsizei mapsize,const GLushort *values);
__attribute__((dllimport)) 
# 878 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 878 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glPixelStoref(GLenum pname,GLfloat param);
__attribute__((dllimport)) 
# 879 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 879 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glPixelStorei(GLenum pname,GLint param);
__attribute__((dllimport)) 
# 880 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 880 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glPixelTransferf(GLenum pname,GLfloat param);
__attribute__((dllimport)) 
# 881 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 881 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glPixelTransferi(GLenum pname,GLint param);
__attribute__((dllimport)) 
# 882 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 882 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glPixelZoom(GLfloat xfactor,GLfloat yfactor);
__attribute__((dllimport)) 
# 883 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 883 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glPointSize(GLfloat size);
__attribute__((dllimport)) 
# 884 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 884 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glPolygonMode(GLenum face,GLenum mode);
__attribute__((dllimport)) 
# 885 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 885 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glPolygonOffset(GLfloat factor,GLfloat units);
__attribute__((dllimport)) 
# 886 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 886 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glPolygonStipple(const GLubyte *mask);
__attribute__((dllimport)) 
# 887 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 887 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glPopAttrib(void);
__attribute__((dllimport)) 
# 888 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 888 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glPopClientAttrib(void);
__attribute__((dllimport)) 
# 889 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 889 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glPopMatrix(void);
__attribute__((dllimport)) 
# 890 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 890 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glPopName(void);
__attribute__((dllimport)) 
# 891 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 891 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glPrioritizeTextures(GLsizei n,const GLuint *textures,const GLclampf *priorities);
__attribute__((dllimport)) 
# 892 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 892 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glPushAttrib(GLbitfield mask);
__attribute__((dllimport)) 
# 893 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 893 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glPushClientAttrib(GLbitfield mask);
__attribute__((dllimport)) 
# 894 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 894 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glPushMatrix(void);
__attribute__((dllimport)) 
# 895 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 895 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glPushName(GLuint name);
__attribute__((dllimport)) 
# 896 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 896 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glRasterPos2d(GLdouble x,GLdouble y);
__attribute__((dllimport)) 
# 897 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 897 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glRasterPos2dv(const GLdouble *v);
__attribute__((dllimport)) 
# 898 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 898 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glRasterPos2f(GLfloat x,GLfloat y);
__attribute__((dllimport)) 
# 899 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 899 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glRasterPos2fv(const GLfloat *v);
__attribute__((dllimport)) 
# 900 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 900 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glRasterPos2i(GLint x,GLint y);
__attribute__((dllimport)) 
# 901 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 901 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glRasterPos2iv(const GLint *v);
__attribute__((dllimport)) 
# 902 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 902 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glRasterPos2s(GLshort x,GLshort y);
__attribute__((dllimport)) 
# 903 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 903 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glRasterPos2sv(const GLshort *v);
__attribute__((dllimport)) 
# 904 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 904 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glRasterPos3d(GLdouble x,GLdouble y,GLdouble z);
__attribute__((dllimport)) 
# 905 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 905 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glRasterPos3dv(const GLdouble *v);
__attribute__((dllimport)) 
# 906 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 906 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glRasterPos3f(GLfloat x,GLfloat y,GLfloat z);
__attribute__((dllimport)) 
# 907 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 907 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glRasterPos3fv(const GLfloat *v);
__attribute__((dllimport)) 
# 908 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 908 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glRasterPos3i(GLint x,GLint y,GLint z);
__attribute__((dllimport)) 
# 909 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 909 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glRasterPos3iv(const GLint *v);
__attribute__((dllimport)) 
# 910 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 910 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glRasterPos3s(GLshort x,GLshort y,GLshort z);
__attribute__((dllimport)) 
# 911 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 911 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glRasterPos3sv(const GLshort *v);
__attribute__((dllimport)) 
# 912 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 912 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glRasterPos4d(GLdouble x,GLdouble y,GLdouble z,GLdouble w);
__attribute__((dllimport)) 
# 913 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 913 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glRasterPos4dv(const GLdouble *v);
__attribute__((dllimport)) 
# 914 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 914 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glRasterPos4f(GLfloat x,GLfloat y,GLfloat z,GLfloat w);
__attribute__((dllimport)) 
# 915 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 915 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glRasterPos4fv(const GLfloat *v);
__attribute__((dllimport)) 
# 916 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 916 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glRasterPos4i(GLint x,GLint y,GLint z,GLint w);
__attribute__((dllimport)) 
# 917 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 917 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glRasterPos4iv(const GLint *v);
__attribute__((dllimport)) 
# 918 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 918 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glRasterPos4s(GLshort x,GLshort y,GLshort z,GLshort w);
__attribute__((dllimport)) 
# 919 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 919 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glRasterPos4sv(const GLshort *v);
__attribute__((dllimport)) 
# 920 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 920 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glReadBuffer(GLenum mode);
__attribute__((dllimport)) 
# 921 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 921 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glReadPixels(GLint x,GLint y,GLsizei width,GLsizei height,GLenum format,GLenum type,GLvoid *pixels);
__attribute__((dllimport)) 
# 922 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 922 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glRectd(GLdouble x1,GLdouble y1,GLdouble x2,GLdouble y2);
__attribute__((dllimport)) 
# 923 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 923 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glRectdv(const GLdouble *v1,const GLdouble *v2);
__attribute__((dllimport)) 
# 924 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 924 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glRectf(GLfloat x1,GLfloat y1,GLfloat x2,GLfloat y2);
__attribute__((dllimport)) 
# 925 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 925 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glRectfv(const GLfloat *v1,const GLfloat *v2);
__attribute__((dllimport)) 
# 926 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 926 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glRecti(GLint x1,GLint y1,GLint x2,GLint y2);
__attribute__((dllimport)) 
# 927 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 927 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glRectiv(const GLint *v1,const GLint *v2);
__attribute__((dllimport)) 
# 928 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 928 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glRects(GLshort x1,GLshort y1,GLshort x2,GLshort y2);
__attribute__((dllimport)) 
# 929 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 929 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glRectsv(const GLshort *v1,const GLshort *v2);
__attribute__((dllimport)) 
# 930 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         GLint __attribute__((__stdcall__)) 
# 930 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                        glRenderMode(GLenum mode);
__attribute__((dllimport)) 
# 931 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 931 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glRotated(GLdouble angle,GLdouble x,GLdouble y,GLdouble z);
__attribute__((dllimport)) 
# 932 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 932 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glRotatef(GLfloat angle,GLfloat x,GLfloat y,GLfloat z);
__attribute__((dllimport)) 
# 933 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 933 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glScaled(GLdouble x,GLdouble y,GLdouble z);
__attribute__((dllimport)) 
# 934 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 934 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glScalef(GLfloat x,GLfloat y,GLfloat z);
__attribute__((dllimport)) 
# 935 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 935 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glScissor(GLint x,GLint y,GLsizei width,GLsizei height);
__attribute__((dllimport)) 
# 936 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 936 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glSelectBuffer(GLsizei size,GLuint *buffer);
__attribute__((dllimport)) 
# 937 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 937 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glShadeModel(GLenum mode);
__attribute__((dllimport)) 
# 938 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 938 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glStencilFunc(GLenum func,GLint ref,GLuint mask);
__attribute__((dllimport)) 
# 939 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 939 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glStencilMask(GLuint mask);
__attribute__((dllimport)) 
# 940 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 940 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glStencilOp(GLenum fail,GLenum zfail,GLenum zpass);
__attribute__((dllimport)) 
# 941 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 941 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexCoord1d(GLdouble s);
__attribute__((dllimport)) 
# 942 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 942 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexCoord1dv(const GLdouble *v);
__attribute__((dllimport)) 
# 943 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 943 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexCoord1f(GLfloat s);
__attribute__((dllimport)) 
# 944 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 944 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexCoord1fv(const GLfloat *v);
__attribute__((dllimport)) 
# 945 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 945 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexCoord1i(GLint s);
__attribute__((dllimport)) 
# 946 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 946 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexCoord1iv(const GLint *v);
__attribute__((dllimport)) 
# 947 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 947 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexCoord1s(GLshort s);
__attribute__((dllimport)) 
# 948 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 948 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexCoord1sv(const GLshort *v);
__attribute__((dllimport)) 
# 949 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 949 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexCoord2d(GLdouble s,GLdouble t);
__attribute__((dllimport)) 
# 950 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 950 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexCoord2dv(const GLdouble *v);
__attribute__((dllimport)) 
# 951 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 951 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexCoord2f(GLfloat s,GLfloat t);
__attribute__((dllimport)) 
# 952 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 952 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexCoord2fv(const GLfloat *v);
__attribute__((dllimport)) 
# 953 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 953 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexCoord2i(GLint s,GLint t);
__attribute__((dllimport)) 
# 954 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 954 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexCoord2iv(const GLint *v);
__attribute__((dllimport)) 
# 955 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 955 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexCoord2s(GLshort s,GLshort t);
__attribute__((dllimport)) 
# 956 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 956 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexCoord2sv(const GLshort *v);
__attribute__((dllimport)) 
# 957 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 957 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexCoord3d(GLdouble s,GLdouble t,GLdouble r);
__attribute__((dllimport)) 
# 958 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 958 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexCoord3dv(const GLdouble *v);
__attribute__((dllimport)) 
# 959 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 959 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexCoord3f(GLfloat s,GLfloat t,GLfloat r);
__attribute__((dllimport)) 
# 960 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 960 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexCoord3fv(const GLfloat *v);
__attribute__((dllimport)) 
# 961 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 961 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexCoord3i(GLint s,GLint t,GLint r);
__attribute__((dllimport)) 
# 962 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 962 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexCoord3iv(const GLint *v);
__attribute__((dllimport)) 
# 963 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 963 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexCoord3s(GLshort s,GLshort t,GLshort r);
__attribute__((dllimport)) 
# 964 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 964 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexCoord3sv(const GLshort *v);
__attribute__((dllimport)) 
# 965 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 965 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexCoord4d(GLdouble s,GLdouble t,GLdouble r,GLdouble q);
__attribute__((dllimport)) 
# 966 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 966 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexCoord4dv(const GLdouble *v);
__attribute__((dllimport)) 
# 967 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 967 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexCoord4f(GLfloat s,GLfloat t,GLfloat r,GLfloat q);
__attribute__((dllimport)) 
# 968 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 968 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexCoord4fv(const GLfloat *v);
__attribute__((dllimport)) 
# 969 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 969 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexCoord4i(GLint s,GLint t,GLint r,GLint q);
__attribute__((dllimport)) 
# 970 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 970 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexCoord4iv(const GLint *v);
__attribute__((dllimport)) 
# 971 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 971 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexCoord4s(GLshort s,GLshort t,GLshort r,GLshort q);
__attribute__((dllimport)) 
# 972 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 972 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexCoord4sv(const GLshort *v);
__attribute__((dllimport)) 
# 973 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 973 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexCoordPointer(GLint size,GLenum type,GLsizei stride,const GLvoid *pointer);
__attribute__((dllimport)) 
# 974 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 974 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexEnvf(GLenum target,GLenum pname,GLfloat param);
__attribute__((dllimport)) 
# 975 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 975 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexEnvfv(GLenum target,GLenum pname,const GLfloat *params);
__attribute__((dllimport)) 
# 976 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 976 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexEnvi(GLenum target,GLenum pname,GLint param);
__attribute__((dllimport)) 
# 977 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 977 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexEnviv(GLenum target,GLenum pname,const GLint *params);
__attribute__((dllimport)) 
# 978 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 978 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexGend(GLenum coord,GLenum pname,GLdouble param);
__attribute__((dllimport)) 
# 979 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 979 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexGendv(GLenum coord,GLenum pname,const GLdouble *params);
__attribute__((dllimport)) 
# 980 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 980 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexGenf(GLenum coord,GLenum pname,GLfloat param);
__attribute__((dllimport)) 
# 981 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 981 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexGenfv(GLenum coord,GLenum pname,const GLfloat *params);
__attribute__((dllimport)) 
# 982 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 982 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexGeni(GLenum coord,GLenum pname,GLint param);
__attribute__((dllimport)) 
# 983 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 983 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexGeniv(GLenum coord,GLenum pname,const GLint *params);
__attribute__((dllimport)) 
# 984 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 984 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexImage1D(GLenum target,GLint level,GLint internalformat,GLsizei width,GLint border,GLenum format,GLenum type,const GLvoid *pixels);
__attribute__((dllimport)) 
# 985 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 985 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexImage2D(GLenum target,GLint level,GLint internalformat,GLsizei width,GLsizei height,GLint border,GLenum format,GLenum type,const GLvoid *pixels);
__attribute__((dllimport)) 
# 986 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 986 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexParameterf(GLenum target,GLenum pname,GLfloat param);
__attribute__((dllimport)) 
# 987 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 987 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexParameterfv(GLenum target,GLenum pname,const GLfloat *params);
__attribute__((dllimport)) 
# 988 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 988 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexParameteri(GLenum target,GLenum pname,GLint param);
__attribute__((dllimport)) 
# 989 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 989 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexParameteriv(GLenum target,GLenum pname,const GLint *params);
__attribute__((dllimport)) 
# 990 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 990 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexSubImage1D(GLenum target,GLint level,GLint xoffset,GLsizei width,GLenum format,GLenum type,const GLvoid *pixels);
__attribute__((dllimport)) 
# 991 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 991 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTexSubImage2D(GLenum target,GLint level,GLint xoffset,GLint yoffset,GLsizei width,GLsizei height,GLenum format,GLenum type,const GLvoid *pixels);
__attribute__((dllimport)) 
# 992 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 992 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTranslated(GLdouble x,GLdouble y,GLdouble z);
__attribute__((dllimport)) 
# 993 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 993 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glTranslatef(GLfloat x,GLfloat y,GLfloat z);
__attribute__((dllimport)) 
# 994 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 994 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glVertex2d(GLdouble x,GLdouble y);
__attribute__((dllimport)) 
# 995 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 995 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glVertex2dv(const GLdouble *v);
__attribute__((dllimport)) 
# 996 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 996 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glVertex2f(GLfloat x,GLfloat y);
__attribute__((dllimport)) 
# 997 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 997 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glVertex2fv(const GLfloat *v);
__attribute__((dllimport)) 
# 998 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 998 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glVertex2i(GLint x,GLint y);
__attribute__((dllimport)) 
# 999 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 999 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glVertex2iv(const GLint *v);
__attribute__((dllimport)) 
# 1000 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 1000 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glVertex2s(GLshort x,GLshort y);
__attribute__((dllimport)) 
# 1001 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 1001 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glVertex2sv(const GLshort *v);
__attribute__((dllimport)) 
# 1002 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 1002 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glVertex3d(GLdouble x,GLdouble y,GLdouble z);
__attribute__((dllimport)) 
# 1003 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 1003 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glVertex3dv(const GLdouble *v);
__attribute__((dllimport)) 
# 1004 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 1004 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glVertex3f(GLfloat x,GLfloat y,GLfloat z);
__attribute__((dllimport)) 
# 1005 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 1005 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glVertex3fv(const GLfloat *v);
__attribute__((dllimport)) 
# 1006 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 1006 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glVertex3i(GLint x,GLint y,GLint z);
__attribute__((dllimport)) 
# 1007 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 1007 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glVertex3iv(const GLint *v);
__attribute__((dllimport)) 
# 1008 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 1008 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glVertex3s(GLshort x,GLshort y,GLshort z);
__attribute__((dllimport)) 
# 1009 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 1009 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glVertex3sv(const GLshort *v);
__attribute__((dllimport)) 
# 1010 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 1010 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glVertex4d(GLdouble x,GLdouble y,GLdouble z,GLdouble w);
__attribute__((dllimport)) 
# 1011 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 1011 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glVertex4dv(const GLdouble *v);
__attribute__((dllimport)) 
# 1012 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 1012 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glVertex4f(GLfloat x,GLfloat y,GLfloat z,GLfloat w);
__attribute__((dllimport)) 
# 1013 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 1013 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glVertex4fv(const GLfloat *v);
__attribute__((dllimport)) 
# 1014 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 1014 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glVertex4i(GLint x,GLint y,GLint z,GLint w);
__attribute__((dllimport)) 
# 1015 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 1015 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glVertex4iv(const GLint *v);
__attribute__((dllimport)) 
# 1016 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 1016 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glVertex4s(GLshort x,GLshort y,GLshort z,GLshort w);
__attribute__((dllimport)) 
# 1017 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 1017 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glVertex4sv(const GLshort *v);
__attribute__((dllimport)) 
# 1018 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 1018 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glVertexPointer(GLint size,GLenum type,GLsizei stride,const GLvoid *pointer);
__attribute__((dllimport)) 
# 1019 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
         void __attribute__((__stdcall__)) 
# 1019 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                       glViewport(GLint x,GLint y,GLsizei width,GLsizei height);

typedef void (__attribute__((__stdcall__)) 
# 1021 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                      *PFNGLARRAYELEMENTEXTPROC)(GLint i);
typedef void (__attribute__((__stdcall__)) 
# 1022 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                      *PFNGLDRAWARRAYSEXTPROC)(GLenum mode,GLint first,GLsizei count);
typedef void (__attribute__((__stdcall__)) 
# 1023 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                      *PFNGLVERTEXPOINTEREXTPROC)(GLint size,GLenum type,GLsizei stride,GLsizei count,const GLvoid *pointer);
typedef void (__attribute__((__stdcall__)) 
# 1024 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                      *PFNGLNORMALPOINTEREXTPROC)(GLenum type,GLsizei stride,GLsizei count,const GLvoid *pointer);
typedef void (__attribute__((__stdcall__)) 
# 1025 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                      *PFNGLCOLORPOINTEREXTPROC)(GLint size,GLenum type,GLsizei stride,GLsizei count,const GLvoid *pointer);
typedef void (__attribute__((__stdcall__)) 
# 1026 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                      *PFNGLINDEXPOINTEREXTPROC)(GLenum type,GLsizei stride,GLsizei count,const GLvoid *pointer);
typedef void (__attribute__((__stdcall__)) 
# 1027 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                      *PFNGLTEXCOORDPOINTEREXTPROC)(GLint size,GLenum type,GLsizei stride,GLsizei count,const GLvoid *pointer);
typedef void (__attribute__((__stdcall__)) 
# 1028 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                      *PFNGLEDGEFLAGPOINTEREXTPROC)(GLsizei stride,GLsizei count,const GLboolean *pointer);
typedef void (__attribute__((__stdcall__)) 
# 1029 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                      *PFNGLGETPOINTERVEXTPROC)(GLenum pname,GLvoid **params);
typedef void (__attribute__((__stdcall__)) 
# 1030 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                      *PFNGLARRAYELEMENTARRAYEXTPROC)(GLenum mode,GLsizei count,const GLvoid *pi);
typedef void (__attribute__((__stdcall__)) 
# 1031 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                      *PFNGLDRAWRANGEELEMENTSWINPROC)(GLenum mode,GLuint start,GLuint end,GLsizei count,GLenum type,const GLvoid *indices);
typedef void (__attribute__((__stdcall__)) 
# 1032 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                      *PFNGLADDSWAPHINTRECTWINPROC)(GLint x,GLint y,GLsizei width,GLsizei height);
typedef void (__attribute__((__stdcall__)) 
# 1033 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                      *PFNGLCOLORTABLEEXTPROC)(GLenum target,GLenum internalFormat,GLsizei width,GLenum format,GLenum type,const GLvoid *data);
typedef void (__attribute__((__stdcall__)) 
# 1034 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                      *PFNGLCOLORSUBTABLEEXTPROC)(GLenum target,GLsizei start,GLsizei count,GLenum format,GLenum type,const GLvoid *data);
typedef void (__attribute__((__stdcall__)) 
# 1035 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                      *PFNGLGETCOLORTABLEEXTPROC)(GLenum target,GLenum format,GLenum type,GLvoid *data);
typedef void (__attribute__((__stdcall__)) 
# 1036 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                      *PFNGLGETCOLORTABLEPARAMETERIVEXTPROC)(GLenum target,GLenum pname,GLint *params);
typedef void (__attribute__((__stdcall__)) 
# 1037 "D:/Enviroments/mingw64_msvcrt/x86_64-w64-mingw32/include/GL/gl.h" 3
                      *PFNGLGETCOLORTABLEPARAMETERFVEXTPROC)(GLenum target,GLenum pname,GLfloat *params);


}
# 242 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h" 2
# 1365 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"

# 1365 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
typedef void (*GLFWglproc)(void);
# 1379 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
typedef void (*GLFWvkproc)(void);
# 1391 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
typedef struct GLFWmonitor GLFWmonitor;
# 1403 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
typedef struct GLFWwindow GLFWwindow;
# 1415 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
typedef struct GLFWcursor GLFWcursor;
# 1468 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
typedef void* (* GLFWallocatefun)(size_t size, void* user);
# 1524 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
typedef void* (* GLFWreallocatefun)(void* block, size_t size, void* user);
# 1566 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
typedef void (* GLFWdeallocatefun)(void* block, void* user);
# 1590 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
typedef void (* GLFWerrorfun)(int error_code, const char* description);
# 1613 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
typedef void (* GLFWwindowposfun)(GLFWwindow* window, int xpos, int ypos);
# 1635 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
typedef void (* GLFWwindowsizefun)(GLFWwindow* window, int width, int height);
# 1655 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
typedef void (* GLFWwindowclosefun)(GLFWwindow* window);
# 1675 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
typedef void (* GLFWwindowrefreshfun)(GLFWwindow* window);
# 1696 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
typedef void (* GLFWwindowfocusfun)(GLFWwindow* window, int focused);
# 1717 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
typedef void (* GLFWwindowiconifyfun)(GLFWwindow* window, int iconified);
# 1738 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
typedef void (* GLFWwindowmaximizefun)(GLFWwindow* window, int maximized);
# 1759 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
typedef void (* GLFWframebuffersizefun)(GLFWwindow* window, int width, int height);
# 1780 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
typedef void (* GLFWwindowcontentscalefun)(GLFWwindow* window, float xscale, float yscale);
# 1806 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
typedef void (* GLFWmousebuttonfun)(GLFWwindow* window, int button, int action, int mods);
# 1829 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
typedef void (* GLFWcursorposfun)(GLFWwindow* window, double xpos, double ypos);
# 1850 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
typedef void (* GLFWcursorenterfun)(GLFWwindow* window, int entered);
# 1871 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
typedef void (* GLFWscrollfun)(GLFWwindow* window, double xoffset, double yoffset);
# 1897 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
typedef void (* GLFWkeyfun)(GLFWwindow* window, int key, int scancode, int action, int mods);
# 1918 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
typedef void (* GLFWcharfun)(GLFWwindow* window, unsigned int codepoint);
# 1945 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
typedef void (* GLFWcharmodsfun)(GLFWwindow* window, unsigned int codepoint, int mods);
# 1969 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
typedef void (* GLFWdropfun)(GLFWwindow* window, int path_count, const char* paths[]);
# 1990 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
typedef void (* GLFWmonitorfun)(GLFWmonitor* monitor, int event);
# 2011 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
typedef void (* GLFWjoystickfun)(int jid, int event);
# 2026 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
typedef struct GLFWvidmode
{


    int width;


    int height;


    int redBits;


    int greenBits;


    int blueBits;


    int refreshRate;
} GLFWvidmode;
# 2060 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
typedef struct GLFWgammaramp
{


    unsigned short* red;


    unsigned short* green;


    unsigned short* blue;


    unsigned int size;
} GLFWgammaramp;
# 2089 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
typedef struct GLFWimage
{


    int width;


    int height;


    unsigned char* pixels;
} GLFWimage;
# 2113 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
typedef struct GLFWgamepadstate
{



    unsigned char buttons[15];



    float axes[6];
} GLFWgamepadstate;
# 2137 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
typedef struct GLFWallocator
{



    GLFWallocatefun allocate;



    GLFWreallocatefun reallocate;



    GLFWdeallocatefun deallocate;



    void* user;
} GLFWallocator;
# 2220 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 int glfwInit(void);
# 2254 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwTerminate(void);
# 2286 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwInitHint(int hint, int value);
# 2317 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwInitAllocator(const GLFWallocator* allocator);
# 2392 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwGetVersion(int* major, int* minor, int* rev);
# 2426 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 const char* glfwGetVersionString(void);
# 2457 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 int glfwGetError(const char** description);
# 2503 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 GLFWerrorfun glfwSetErrorCallback(GLFWerrorfun callback);
# 2524 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 int glfwGetPlatform(void);
# 2548 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 int glfwPlatformSupported(int platform);
# 2577 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 GLFWmonitor** glfwGetMonitors(int* count);
# 2601 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 GLFWmonitor* glfwGetPrimaryMonitor(void);
# 2626 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwGetMonitorPos(GLFWmonitor* monitor, int* xpos, int* ypos);
# 2657 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwGetMonitorWorkarea(GLFWmonitor* monitor, int* xpos, int* ypos, int* width, int* height);
# 2692 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwGetMonitorPhysicalSize(GLFWmonitor* monitor, int* widthMM, int* heightMM);
# 2727 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwGetMonitorContentScale(GLFWmonitor* monitor, float* xscale, float* yscale);
# 2753 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 const char* glfwGetMonitorName(GLFWmonitor* monitor);
# 2779 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwSetMonitorUserPointer(GLFWmonitor* monitor, void* pointer);
# 2803 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void* glfwGetMonitorUserPointer(GLFWmonitor* monitor);
# 2833 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 GLFWmonitorfun glfwSetMonitorCallback(GLFWmonitorfun callback);
# 2867 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 const GLFWvidmode* glfwGetVideoModes(GLFWmonitor* monitor, int* count);
# 2895 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 const GLFWvidmode* glfwGetVideoMode(GLFWmonitor* monitor);
# 2928 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwSetGamma(GLFWmonitor* monitor, float gamma);
# 2958 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 const GLFWgammaramp* glfwGetGammaRamp(GLFWmonitor* monitor);
# 2999 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwSetGammaRamp(GLFWmonitor* monitor, const GLFWgammaramp* ramp);
# 3018 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwDefaultWindowHints(void);
# 3053 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwWindowHint(int hint, int value);
# 3091 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwWindowHintString(int hint, const char* value);
# 3235 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 GLFWwindow* glfwCreateWindow(int width, int height, const char* title, GLFWmonitor* monitor, GLFWwindow* share);
# 3264 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwDestroyWindow(GLFWwindow* window);
# 3284 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 int glfwWindowShouldClose(GLFWwindow* window);
# 3306 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwSetWindowShouldClose(GLFWwindow* window, int value);
# 3338 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 const char* glfwGetWindowTitle(GLFWwindow* window);
# 3364 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwSetWindowTitle(GLFWwindow* window, const char* title);
# 3413 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwSetWindowIcon(GLFWwindow* window, int count, const GLFWimage* images);
# 3445 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwGetWindowPos(GLFWwindow* window, int* xpos, int* ypos);
# 3480 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwSetWindowPos(GLFWwindow* window, int xpos, int ypos);
# 3510 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwGetWindowSize(GLFWwindow* window, int* width, int* height);
# 3553 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwSetWindowSizeLimits(GLFWwindow* window, int minwidth, int minheight, int maxwidth, int maxheight);
# 3596 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwSetWindowAspectRatio(GLFWwindow* window, int numer, int denom);
# 3634 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwSetWindowSize(GLFWwindow* window, int width, int height);
# 3663 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwGetFramebufferSize(GLFWwindow* window, int* width, int* height);
# 3700 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwGetWindowFrameSize(GLFWwindow* window, int* left, int* top, int* right, int* bottom);
# 3733 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwGetWindowContentScale(GLFWwindow* window, float* xscale, float* yscale);
# 3760 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 float glfwGetWindowOpacity(GLFWwindow* window);
# 3792 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwSetWindowOpacity(GLFWwindow* window, float opacity);
# 3824 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwIconifyWindow(GLFWwindow* window);
# 3851 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwRestoreWindow(GLFWwindow* window);
# 3876 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwMaximizeWindow(GLFWwindow* window);
# 3908 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwShowWindow(GLFWwindow* window);
# 3930 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwHideWindow(GLFWwindow* window);
# 3969 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwFocusWindow(GLFWwindow* window);
# 3996 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwRequestWindowAttention(GLFWwindow* window);
# 4018 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 GLFWmonitor* glfwGetWindowMonitor(GLFWwindow* window);
# 4074 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwSetWindowMonitor(GLFWwindow* window, GLFWmonitor* monitor, int xpos, int ypos, int width, int height, int refreshRate);
# 4111 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 int glfwGetWindowAttrib(GLFWwindow* window, int attrib);
# 4153 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwSetWindowAttrib(GLFWwindow* window, int attrib, int value);
# 4176 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwSetWindowUserPointer(GLFWwindow* window, void* pointer);
# 4197 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void* glfwGetWindowUserPointer(GLFWwindow* window);
# 4232 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 GLFWwindowposfun glfwSetWindowPosCallback(GLFWwindow* window, GLFWwindowposfun callback);
# 4264 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 GLFWwindowsizefun glfwSetWindowSizeCallback(GLFWwindow* window, GLFWwindowsizefun callback);
# 4304 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 GLFWwindowclosefun glfwSetWindowCloseCallback(GLFWwindow* window, GLFWwindowclosefun callback);
# 4340 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 GLFWwindowrefreshfun glfwSetWindowRefreshCallback(GLFWwindow* window, GLFWwindowrefreshfun callback);
# 4375 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 GLFWwindowfocusfun glfwSetWindowFocusCallback(GLFWwindow* window, GLFWwindowfocusfun callback);
# 4405 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 GLFWwindowiconifyfun glfwSetWindowIconifyCallback(GLFWwindow* window, GLFWwindowiconifyfun callback);
# 4435 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 GLFWwindowmaximizefun glfwSetWindowMaximizeCallback(GLFWwindow* window, GLFWwindowmaximizefun callback);
# 4465 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 GLFWframebuffersizefun glfwSetFramebufferSizeCallback(GLFWwindow* window, GLFWframebuffersizefun callback);
# 4496 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 GLFWwindowcontentscalefun glfwSetWindowContentScaleCallback(GLFWwindow* window, GLFWwindowcontentscalefun callback);
# 4534 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwPollEvents(void);
# 4579 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwWaitEvents(void);
# 4628 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwWaitEventsTimeout(double timeout);
# 4648 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwPostEmptyEvent(void);
# 4673 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 int glfwGetInputMode(GLFWwindow* window, int mode);
# 4738 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwSetInputMode(GLFWwindow* window, int mode, int value);
# 4767 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 int glfwRawMouseMotionSupported(void);
# 4835 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 const char* glfwGetKeyName(int key, int scancode);
# 4862 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 int glfwGetKeyScancode(int key);
# 4901 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 int glfwGetKey(GLFWwindow* window, int key);
# 4930 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 int glfwGetMouseButton(GLFWwindow* window, int button);
# 4968 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwGetCursorPos(GLFWwindow* window, double* xpos, double* ypos);
# 5008 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwSetCursorPos(GLFWwindow* window, double xpos, double ypos);
# 5046 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 GLFWcursor* glfwCreateCursor(const GLFWimage* image, int xhot, int yhot);
# 5094 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 GLFWcursor* glfwCreateStandardCursor(int shape);
# 5121 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwDestroyCursor(GLFWcursor* cursor);
# 5148 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwSetCursor(GLFWwindow* window, GLFWcursor* cursor);
# 5198 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 GLFWkeyfun glfwSetKeyCallback(GLFWwindow* window, GLFWkeyfun callback);
# 5241 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 GLFWcharfun glfwSetCharCallback(GLFWwindow* window, GLFWcharfun callback);
# 5283 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 GLFWcharmodsfun glfwSetCharModsCallback(GLFWwindow* window, GLFWcharmodsfun callback);
# 5320 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 GLFWmousebuttonfun glfwSetMouseButtonCallback(GLFWwindow* window, GLFWmousebuttonfun callback);
# 5352 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 GLFWcursorposfun glfwSetCursorPosCallback(GLFWwindow* window, GLFWcursorposfun callback);
# 5383 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 GLFWcursorenterfun glfwSetCursorEnterCallback(GLFWwindow* window, GLFWcursorenterfun callback);
# 5417 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 GLFWscrollfun glfwSetScrollCallback(GLFWwindow* window, GLFWscrollfun callback);
# 5452 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 GLFWdropfun glfwSetDropCallback(GLFWwindow* window, GLFWdropfun callback);
# 5476 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 int glfwJoystickPresent(int jid);
# 5509 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 const float* glfwGetJoystickAxes(int jid, int* count);
# 5550 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 const unsigned char* glfwGetJoystickButtons(int jid, int* count);
# 5607 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 const unsigned char* glfwGetJoystickHats(int jid, int* count);
# 5638 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 const char* glfwGetJoystickName(int jid);
# 5679 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 const char* glfwGetJoystickGUID(int jid);
# 5705 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwSetJoystickUserPointer(int jid, void* pointer);
# 5729 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void* glfwGetJoystickUserPointer(int jid);
# 5757 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 int glfwJoystickIsGamepad(int jid);
# 5793 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 GLFWjoystickfun glfwSetJoystickCallback(GLFWjoystickfun callback);
# 5827 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 int glfwUpdateGamepadMappings(const char* string);
# 5859 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 const char* glfwGetGamepadName(int jid);
# 5897 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 int glfwGetGamepadState(int jid, GLFWgamepadstate* state);
# 5927 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwSetClipboardString(GLFWwindow* window, const char* string);
# 5962 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 const char* glfwGetClipboardString(GLFWwindow* window);
# 5992 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 double glfwGetTime(void);
# 6022 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwSetTime(double time);
# 6044 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 uint64_t glfwGetTimerValue(void);
# 6064 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 uint64_t glfwGetTimerFrequency(void);
# 6109 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwMakeContextCurrent(GLFWwindow* window);
# 6130 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 GLFWwindow* glfwGetCurrentContext(void);
# 6164 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwSwapBuffers(GLFWwindow* window);
# 6210 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 void glfwSwapInterval(int interval);
# 6248 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 int glfwExtensionSupported(const char* extension);
# 6290 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 GLFWglproc glfwGetProcAddress(const char* procname);
# 6316 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 int glfwVulkanSupported(void);
# 6360 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
 const char** glfwGetRequiredInstanceExtensions(uint32_t* count);
# 6543 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/include/GLFW/glfw3.h"
}
# 5 "D:/Code/VSCode/C++/Vulkan/SelfLearn1/src/Creepy/Input.cpp" 2

namespace Creepy{
    struct MouseData{
        glm::vec2 Position{}, OldPosition{}, Scroll{};
        bool IsInWindow{}, WasInWindow{};
        std::unordered_set<MouseButton> PressedButtons;
        std::unordered_set<MouseButton> ReleasedButtons;
        std::unordered_set<MouseButton> HoldButtons;
    };

    MouseData s_mouseData{};

    struct KeyBoardData{
        uint32_t UnicodeChar{};
        KeyCode RepeatKey{};
        KeyCode CurrentKey{};
        std::unordered_set<KeyCode> PressedKeys;
        std::unordered_set<KeyCode> ReleasedKeys;
        std::unordered_set<KeyCode> HoldKeys;
    };

    KeyBoardData s_keyBoardData{};

    void Mouse::RegisterMouseEvent(GLFWwindow* window) {
        glfwSetCursorPosCallback(window, [](GLFWwindow* window, double xPos, double yPos){
            s_mouseData.Position.x = xPos;
            s_mouseData.Position.y = yPos;
        });

        glfwSetCursorEnterCallback(window, [](GLFWwindow* window, int entered){
            s_mouseData.IsInWindow = static_cast<bool>(entered);
        });

        glfwSetScrollCallback(window, [](GLFWwindow* window, double xOffset, double yOffset){
            s_mouseData.Scroll.x = xOffset;
            s_mouseData.Scroll.y = yOffset;
        });

        glfwSetMouseButtonCallback(window, [](GLFWwindow* window, int button, int action, int mods){
            if(action == 1){
                s_mouseData.PressedButtons.insert(static_cast<MouseButton>(button));
                s_mouseData.HoldButtons.insert(static_cast<MouseButton>(button));

            }else if(action == 0){
                s_mouseData.ReleasedButtons.insert(static_cast<MouseButton>(button));
                s_mouseData.HoldButtons.erase(static_cast<MouseButton>(button));
            }
        });
    }

    void Mouse::PreProcessEveryFrame() {
        s_mouseData.OldPosition.x = s_mouseData.Position.x;
        s_mouseData.OldPosition.y = s_mouseData.Position.y;

        s_mouseData.WasInWindow = s_mouseData.IsInWindow;
        s_mouseData.PressedButtons.clear();
        s_mouseData.ReleasedButtons.clear();
        s_mouseData.Scroll.x = 0.0f;
        s_mouseData.Scroll.y = 0.0f;
    }

    bool Mouse::IsMousePress(MouseButton button) {
        return s_mouseData.PressedButtons.contains(button);
    }

    bool Mouse::IsMouseHold(MouseButton button) {
        return s_mouseData.HoldButtons.contains(button);
    }

    glm::vec2 Mouse::GetMousePosition() {
        return s_mouseData.Position;
    }

    bool Mouse::IsMouseInWindow() {
        return s_mouseData.IsInWindow;
    }

    void KeyBoard::RegisterKeyEvent(GLFWwindow* window) {
        glfwSetKeyCallback(window, [](GLFWwindow* window, int key, int scanCode, int action, int mods){
            if(action == 1){
                s_keyBoardData.PressedKeys.insert(static_cast<KeyCode>(key));
                s_keyBoardData.HoldKeys.insert(static_cast<KeyCode>(key));
                s_keyBoardData.CurrentKey = static_cast<KeyCode>(key);
            }
            else if(action == 2){
                s_keyBoardData.RepeatKey = static_cast<KeyCode>(key);
            }
            else if(action == 0){
                s_keyBoardData.ReleasedKeys.insert(static_cast<KeyCode>(key));
                s_keyBoardData.HoldKeys.erase(static_cast<KeyCode>(key));
            }
        });

        glfwSetCharCallback(window, [](GLFWwindow* window, uint32_t codePoint){
            s_keyBoardData.UnicodeChar = codePoint;
        });
    }

    void KeyBoard::PreProcessEveryFrame() {
        s_keyBoardData.RepeatKey = KeyCode::NONE;
        s_keyBoardData.CurrentKey = KeyCode::NONE;
        s_keyBoardData.UnicodeChar = 0u;
        s_keyBoardData.PressedKeys.clear();
        s_keyBoardData.ReleasedKeys.clear();
    }

    bool KeyBoard::IsKeyPress(KeyCode keyCode) {
        return s_keyBoardData.PressedKeys.contains(keyCode);
    }

    bool KeyBoard::IsKeyHold(KeyCode keyCode) {
        return s_keyBoardData.HoldKeys.contains(keyCode);
    }

    bool KeyBoard::IsKeyRepeat(KeyCode keyCode) {
        return s_keyBoardData.RepeatKey == keyCode;
    }

    char KeyBoard::GetChar() {
        auto character = std::to_underlying(s_keyBoardData.CurrentKey);

        if(character > 128){
            return 0;
        }
        return static_cast<char>(character);
    }
};
